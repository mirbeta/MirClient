//******************************************************************************
//*                                                                            *
//*                         AsphyreSphinx绘图修改                              *
//*                         作者：盼盼 QQ117594672                             *
//*                                                                            *
//******************************************************************************
unit FState;

interface

uses
  Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,
  uGameEngine, uCommon, DWinCtl, StdCtrls, PXL.Canvas, PXL.Textures, PXL.Providers,
  AsphyreTextureFonts, PXL.Types, Grobal2, ClFunc, HUtil32, cliUtil, Grids,
  MapUnit, SoundUtil, WIL, IniFiles, MaketSystem, EDcode, GList, HashList, spin;

var
  BOTTOMBOARD800: Integer = 371;
  BOTTOMBOARD1024: Integer = 371;
const
  VIEWCHATLINE = 9;
  MAXSTATEPAGE = 4;
  LISTLINEHEIGHT = 13;
  MAKETLINEHEIGHT = 19;
  MAXMENU = 10;
  FRIENDMAXMENU = 13;

  sNextLevel = '<下级技能修炼等级:%d|C=$FF00>\';
  sNextLevel2 = '<下级技能修炼内功等级:%d|C=$FF00>\';
  sFullLevel = '<已达到最高技能修炼等级|C=$FF00>\';

  AdjustAbilHints: array[0..8] of string = (
    '攻击力',
    '魔法(魔法师)',
    '道术(道士)',
    '防御',
    '魔法防御',
    '生命值',
    '魔法值',
    '准确',
    '敏捷');

type
  TSpotDlgMode = (dmSell, dmRepair, dmStorage, dmMaketSell, dmItemDlg, dmBindItem, dmUnBindItem, dmExchangeBook);
  TMenuDlgMode = (dmBuy, dmMakeDrug, dmDetailMenu, dmGetSave);

  TClickPoint = record
    rc: TRect;
    rstr: string;
    sidx: string;
  end;
  pTClickPoint = ^TClickPoint;

  TDiceInfo = record
    nDicePoint: Integer;
    nPlayPoint: Integer;
    nX: Integer;
    nY: Integer;
    n67C: Integer;
    n680: Integer;
    dwPlayTick: LongWord;
  end;
  pTDiceInfo = ^TDiceInfo;

  TFrmDlg = class(TForm)
    DStateWin: TDWindow;
    DBackground: TDWindow;
    DItemBag: TDWindow;
    DBottom: TDWindow;
    DMyState: TDButton;
    DMyBag: TDButton;
    DMyMagic: TDButton;
    DOption: TDButton;
    DGold: TDButton;
    DRefineItem: TDButton;
    DCloseBag: TDButton;
    DCloseState: TDButton;
    DLogin: TDWindow;
    DLoginNew: TDButton;
    DLoginOk: TDButton;
    DNewAccount: TDWindow;
    DNewAccountOk: TDButton;
    DLoginClose: TDButton;
    DNewAccountClose: TDButton;
    DSelectChr: TDWindow;
    DscSelect1: TDButton;
    DscSelect2: TDButton;
    DscStart: TDButton;
    DscNewChr: TDButton;
    DscEraseChr: TDButton;
    DscCredits: TDButton;
    DscExit: TDButton;
    DCreateChr: TDWindow;
    DccWarrior: TDButton;
    DccWizzard: TDButton;
    DccMonk: TDButton;
    DccReserved: TDButton;
    DccMale: TDButton;
    DccFemale: TDButton;
    DccLeftHair: TDButton;
    DccRightHair: TDButton;
    DccOk: TDButton;
    DccClose: TDButton;
    DItemGrid: TDGrid;
    DLoginChgPw: TDButton;
    DMsgDlg: TDWindow;
    DMsgDlgOk: TDButton;
    DMsgDlgYes: TDButton;
    DMsgDlgCancel: TDButton;
    DMsgDlgNo: TDButton;
    DSWNecklace: TDButton;
    DSWLight: TDButton;
    DSWArmRingR: TDButton;
    DSWArmRingL: TDButton;
    DSWRingR: TDButton;
    DSWRingL: TDButton;
    DSWWeapon: TDButton;
    DSWDress: TDButton;
    DSWHelmet: TDButton;
    DSWBujuk: TDButton;
    DSWBelt: TDButton;
    DSWBoots: TDButton;
    DSWCharm: TDButton;

    DBelt1: TDButton;
    DBelt2: TDButton;
    DBelt3: TDButton;
    DBelt4: TDButton;
    DBelt5: TDButton;
    DBelt6: TDButton;
    DChgPw: TDWindow;
    DChgpwOk: TDButton;
    DChgpwCancel: TDButton;
    DMerchantDlg: TDWindow;
    DMerchantDlgClose: TDButton;
    DMenuDlg: TDWindow;
    DMenuPrev: TDButton;
    DMenuNext: TDButton;
    DMenuBuy: TDButton;
    DMenuClose: TDButton;
    DSellDlg: TDWindow;
    DSellDlgOk: TDButton;
    DSellDlgClose: TDButton;
    DSellDlgSpot: TDButton;
    DStMag1: TDButton;
    DStMag2: TDButton;
    DStMag3: TDButton;
    DStMag4: TDButton;
    DStMag5: TDButton;
    DHStMag1: TDButton;
    DHStMag2: TDButton;
    DHStMag3: TDButton;
    DHStMag4: TDButton;
    DHStMag5: TDButton;
    DKeySelDlg: TDWindow;
    DKsIcon: TDButton;
    DKsF1: TDButton;
    DKsF2: TDButton;
    DKsF3: TDButton;
    DKsF4: TDButton;
    DKsNone: TDButton;
    DKsOk: TDButton;
    DBotGroup: TDButton;
    DBotTrade: TDButton;
    DBotMiniMap: TDButton;
    DBotFriend: TDButton;
    DGroupDlg: TDWindow;
    DGrpAllowGroup: TDButton;
    DGrpDlgClose: TDButton;
    DGrpCreate: TDButton;
    DGrpAddMem: TDButton;
    DGrpDelMem: TDButton;
    DBotLogout: TDButton;
    DBotExit: TDButton;
    DBotGuild: TDButton;
    DStPageUp: TDButton;
    DStPageDown: TDButton;
    DDealRemoteDlg: TDWindow;
    DDealDlg: TDWindow;
    DDRGrid: TDGrid;
    DDGrid: TDGrid;
    DDealOk: TDButton;
    DDealClose: TDButton;
    DDGold: TDButton;
    DDRGold: TDButton;
    DSelServerDlg: TDWindow;
    DSSrvClose: TDButton;
    DSServer1: TDButton;
    DSServer2: TDButton;
    DUserState1: TDWindow;
    DCloseUS1: TDButton;
    DWeaponUS1: TDButton;
    DHelmetUS1: TDButton;
    DNecklaceUS1: TDButton;
    DDressUS1: TDButton;
    DLightUS1: TDButton;
    DArmringRUS1: TDButton;
    DRingRUS1: TDButton;
    DArmringLUS1: TDButton;
    DRingLUS1: TDButton;

    DBujukUS1: TDButton;
    DBeltUS1: TDButton;
    DBootsUS1: TDButton;
    DCharmUS1: TDButton;

    DSServer3: TDButton;
    DSServer4: TDButton;
    DGuildDlg: TDWindow;
    DGDHome: TDButton;
    DGDList: TDButton;
    DGDChat: TDButton;
    DGDAddMem: TDButton;
    DGDDelMem: TDButton;
    DGDEditNotice: TDButton;
    DGDEditGrade: TDButton;
    DGDAlly: TDButton;
    DGDBreakAlly: TDButton;
    DGDWar: TDButton;
    DGDCancelWar: TDButton;
    DGDUp: TDButton;
    DGDDown: TDButton;
    DGDClose: TDButton;
    DGuildEditNotice: TDWindow;
    DGEClose: TDButton;
    DGEOk: TDButton;
    DSServer5: TDButton;
    DSServer6: TDButton;
    DNewAccountCancel: TDButton;
    DAdjustAbility: TDWindow;
    DPlusDC: TDButton;
    DPlusMC: TDButton;
    DPlusSC: TDButton;
    DPlusAC: TDButton;
    DPlusMAC: TDButton;
    DPlusHP: TDButton;
    DPlusMP: TDButton;
    DPlusHit: TDButton;
    DPlusSpeed: TDButton;
    DMinusDC: TDButton;
    DMinusMC: TDButton;
    DMinusSC: TDButton;
    DMinusAC: TDButton;
    DMinusMAC: TDButton;
    DMinusMP: TDButton;
    DMinusHP: TDButton;
    DMinusHit: TDButton;
    DMinusSpeed: TDButton;
    DAdjustAbilClose: TDButton;
    DAdjustAbilOk: TDButton;
    DBotPlusAbil: TDButton;
    DKsF5: TDButton;
    DKsF6: TDButton;
    DKsF7: TDButton;
    DKsF8: TDButton;
    DEngServer1: TDButton;
    DKsConF1: TDButton;
    DKsConF2: TDButton;
    DKsConF3: TDButton;
    DKsConF4: TDButton;
    DKsConF5: TDButton;
    DKsConF6: TDButton;
    DKsConF7: TDButton;
    DKsConF8: TDButton;
    DFriendDlg: TDWindow;
    DFrdFriend: TDButton;
    DFrdBlackList: TDButton;
    DFrdClose: TDButton;
    DFrdPgUp: TDButton;
    DFrdPgDn: TDButton;
    DFrdAdd: TDButton;
    DFrdDel: TDButton;
    DFrdMemo: TDButton;
    DFrdMaster: TDButton;
    DGameShop: TDWindow;
    DGameShopClose: TDButton;
    DButtonHP: TDButton;
    DButtonMP: TDButton;
    DButtonRecallHero: TDButton;
    DButtonHeroState: TDButton;
    DButtonHeroBag: TDButton;
    DButtonShop: TDButton;
    DBotDare: TDButton;
    DBotLevelRank: TDButton;
    DButtonShop1: TDButton;
    DButtonShop2: TDButton;
    DButtonShop3: TDButton;
    DButtonShop4: TDButton;
    DButtonShop5: TDButton;
    DButtonShop6: TDButton;
    DButtonShop7: TDButton;
    DButtonShop8: TDButton;
    DButtonShop10: TDButton;
    DButtonShop9: TDButton;
    DButtonShopEffect: TDButton;
    DGridShop1: TDGrid;
    DGridShop2: TDGrid;
    DWHeroStatus: TDWindow;
    DHeroItemBag: TDWindow;
    DHeroItemGrid: TDGrid;
    DCloseHeroBag: TDButton;
    DHStateWin: TDWindow;
    DHCloseState: TDButton;
    DHSWBujuk: TDButton;
    DHSWBelt: TDButton;
    DHSWBoots: TDButton;
    DHSWCharm: TDButton;
    DHStPageUp: TDButton;
    DHStPageDown: TDButton;
    DHSWRingL: TDButton;
    DHSWArmRingL: TDButton;
    DHSWLight: TDButton;
    DHSWNecklace: TDButton;
    DHSWHelmet: TDButton;
    DHSWDress: TDButton;
    DHSWWeapon: TDButton;
    DHSWArmRingR: TDButton;
    DHSWRingR: TDButton;
    DBHeroEnergy: TDButton;
    DBDelCharList: TDButton;
    DBGetDelCharClose: TDButton;
    DBGetBackDelChar: TDButton;
    DBHeroGlory: TDButton;
    DWRefine: TDWindow;
    DBRefineClose: TDButton;
    DBRefineItem1: TDButton;
    DBRefineItem2: TDButton;
    DBRefineItem3: TDButton;
    DBRefineOK: TDButton;
    DWGameConfig: TDWindow;
    DBGCClose: TDButton;
    DBGCActivePage1: TDButton;
    DBGCActivePage2: TDButton;
    DBGCActivePage3: TDButton;
    DBGCActivePage4: TDButton;
    DBGCActivePage5: TDButton;
    DBGCActivePage6: TDButton;
    DBVigour: TDButton;
    DWRank: TDWindow;
    DBLRHunam: TDButton;
    DBLRHero: TDButton;
    DBLRMaster: TDButton;
    DBLRClose: TDButton;
    DBLRFirst: TDButton;
    DBLRPrior: TDButton;
    DBLRNext: TDButton;
    DBLRLast: TDButton;
    DBLRMyRank: TDButton;
    DBLRAll: TDButton;
    DBLRWarr: TDButton;
    DBLRWizard: TDButton;
    DBLRTaos: TDButton;
    DxEditLoginID: TDEdit;
    DxEditPassword: TDEdit;
    DWBookBkgnd: TDWindow;
    DBBookClose: TDButton;
    DBBookPage: TDButton;
    DBBookNext: TDButton;
    DBBookPrior: TDButton;
    DWBoxBKGnd: TDWindow;
    DBRareItem1: TDButton;
    DBRareItem2: TDButton;
    DBRareItem3: TDButton;
    DBRareItem8: TDButton;
    DBRareItem9: TDButton;
    DBRareItem4: TDButton;
    DBRareItem7: TDButton;
    DBRareItem6: TDButton;
    DBRareItem5: TDButton;
    DBFlashRareBox: TDButton;
    DItemMarketDlg: TDWindow;
    DItemMarketClose: TDButton;
    DMarketMemo: TDButton;
    DItemListNext: TDButton;
    DItemListRefresh: TDButton;
    DItemListPrev: TDButton;
    DItemSellCancel: TDButton;
    DItemBuy: TDButton;
    DItemCancel: TDButton;
    DItemFind: TDButton;
    DEditItemFind: TDEdit;
    DWYBDealDlg: TDWindow;
    DGridYBDeal: TDGrid;
    DBYBDealDlgClose: TDButton;
    DEYBDealCharName: TDEdit;
    DEYBDealCount: TDEdit;
    DBYBDealOK: TDButton;
    DBYBDealCalcel: TDButton;
    DWYbDealItems: TDWindow;
    DBYbBuyItems: TDButton;
    DBYbBuyCancel: TDButton;
    DBYbCalcelSell: TDButton;
    DBYbDealItemsClose: TDButton;
    DBAotoSay: TDButton;
    DBRefuseGuild: TDButton;
    DBRefuseWhisper: TDButton;
    DBRefuseCry: TDButton;
    DBRefuseSay: TDButton;
    DStMag6: TDButton;
    DHStMag6: TDButton;
    DxEditRenewHPPercent: TDEdit;
    DxEditRenewMPPercent: TDEdit;
    DxEditRenewSpecialPercent: TDEdit;
    DxEditRenewBookPercent: TDEdit;
    DxEditExpFilter: TDEdit;
    DxEditRenewHPTime: TDEdit;
    DxEditRenewMPTime: TDEdit;
    DxEditRenewSpecialTime: TDEdit;
    DxEditRenewBookTime: TDEdit;
    DxEditPractice: TDEdit;
    DxEditRenewHPPercentHero: TDEdit;
    DxEditRenewMPPercentHero: TDEdit;
    DxEditRenewSpecialPercentHero: TDEdit;
    DxEditPerHeroSidestep: TDEdit;
    DxEditRenewHPTimeHero: TDEdit;
    DxEditRenewMPTimeHero: TDEdit;
    DxEditRenewSpecialTimeHero: TDEdit;
    DCBRenewBookNowBook: TDComboBox;
    DLBRenewBookNowBook: TDListBox;
    DCBPractice: TDComboBox;
    DLBPractice: TDListBox;
    DEHeroCallHeroPre: TDEdit;
    DEHeroSetTargetPre: TDEdit;
    DEHeroUnionHitPre: TDEdit;
    DEHeroSetAttackStatePre: TDEdit;
    DEHeroSetGuardPre: TDEdit;
    DESwitchAttackModePre: TDEdit;
    DESwitchMiniMapPre: TDEdit;
    DEHeroCallHero: TDEdit;
    DEHeroSetTarget: TDEdit;
    DEHeroUnionHit: TDEdit;
    DEHeroSetAttackState: TDEdit;
    DESwitchAttackMode: TDEdit;
    DESwitchMiniMap: TDEdit;
    DWMissions: TDWindow;
    DBMissionsClose: TDButton;
    DBMS1: TDButton;
    DBMS2: TDButton;
    DBMS3: TDButton;
    DBMS4: TDButton;
    DBMUP1: TDButton;
    DBMDown1: TDButton;
    DBMUP2: TDButton;
    DBMDown2: TDButton;
    DBMissionOpen: TDButton;
    DBMiniMap: TDButton;
    DBState: TDButton;
    DBConRandom: TDButton;
    DBConKey: TDButton;
    DSeMag1: TDButton;
    DSeMag2: TDButton;
    DSeMag3: TDButton;
    DSeMag4: TDButton;
    DListBoxSSkill: TDListBox;
    DxEditSSkillPre: TDEdit;
    DxEditSSkill: TDEdit;
    DBTrainVenation: TDButton;
    DBV1: TDButton;
    DBV2: TDButton;
    DBV3: TDButton;
    DBV4: TDButton;
    DBP1: TDButton;
    DBP2: TDButton;
    DBP3: TDButton;
    DBP4: TDButton;
    DBP5: TDButton;
    DBPH1: TDButton;
    DBPH2: TDButton;
    DBPH3: TDButton;
    DBPH4: TDButton;
    DBPH5: TDButton;
    DBHState: TDButton;
    DWBuildAcus: TDWindow;
    DWBuildAcusClose: TDButton;
    DBCharm1: TDButton;
    DBCharm3: TDButton;
    DBCharm2: TDButton;
    DBBuildAcusHelp: TDButton;
    DBAcus1: TDButton;
    DBAcus2: TDButton;
    DBAcus4: TDButton;
    DBAcus3: TDButton;
    DBAcus5: TDButton;
    DBBuildAcusMaterial: TDButton;
    DBBuildAcusStart: TDButton;
    DWCollectExp: TDWindow;
    DBCollectState: TDButton;
    DBCollectExp: TDButton;
    DBCollectIPExp: TDButton;
    DMBHitSpeed: TDMoveButton;
    DMBMagSpeed: TDMoveButton;
    DMBMoveSpeed: TDMoveButton;
    DxEditHitSpeed: TDEdit;
    DxEditMagSpeed: TDEdit;
    DxEditMoveSpeed: TDEdit;
    DHSeMag1: TDButton;
    DHSeMag2: TDButton;
    DHSeMag3: TDButton;
    DHSeMag4: TDButton;

    DBHV1: TDButton;
    DBHV2: TDButton;
    DBHV3: TDButton;
    DBHV4: TDButton;
    DBHConRandom: TDButton;
    DBHConKey: TDButton;
    DBHP1: TDButton;
    DBHP2: TDButton;
    DBHP3: TDButton;
    DBHP4: TDButton;
    DBHP5: TDButton;
    DBHPH5: TDButton;
    DBHPH4: TDButton;
    DBHPH3: TDButton;
    DBHPH2: TDButton;
    DBHPH1: TDButton;
    DBHTrainVenation: TDButton;
    DHListBoxSSkill: TDListBox;
    DxDlgEdit: TDEdit;
    DBotBelt: TDButton;
    DBeltWindow: TDWindow;
    DBeltClose: TDButton;
    DBeltSwap: TDButton;
    DBChat: TDButton;
    DEdChat: TDEdit;
    DBChatStatus: TDButton;
    DBChatWin: TDButton;
    DBChatRange: TDButton;
    DBHideChat: TDButton;
    DBAttackMode: TDButton;
    DBotStore: TDButton;
    DMBChat: TDMoveButton;
    DStorageGrid: TDGrid;
    DxEdChrName: TDEdit;
    DMBVolume: TDMoveButton;
    DxHint: TDHint;

    DWHeroStore: TDWindow;
    DGridStore: TDGrid;
    DBStoreBuy: TDButton;
    DBStoreCancel: TDButton;
    DxEditStoreName: TDEdit;
    DBStoreClose: TDButton;
    DWStoreItemPrice: TDWindow;
    DBStorePage1: TDButton;
    DBStorePage2: TDButton;
    DxEditStoreItemPrice: TDEdit;
    DBStoreItemPriceOk: TDButton;
    DBStoreItemPriceCancel: TDButton;
    DBStorePriceClose: TDButton;
    DButton1: TDButton;
    DWUserStall: TDWindow;
    DGridUserStall: TDGrid;
    DBUserStallBuy: TDButton;
    DBUserStallClose: TDButton;
    DBGameGold: TDButton;
    DComboBox_Hero: TDComboBox;
    DListBox_Hero: TDListBox;
    DBCommand: TDButton;
    DxHint1: TDHint;
    DBGCActivePage7: TDButton;
    DComboBox_Items: TDComboBox;
    DListBox_Items: TDListBox;
    DxEdit_Items: TDEdit;
    DBIUP: TDButton;
    DBIDown: TDButton;
    DMoveButton_items: TDMoveButton;
    DWHint1: TDWindow;
    DBHint1Close: TDButton;
    DBDetectBox: TDButton;
    DWTI: TDWindow;
    DBTIClose: TDButton;
    DBTIItem1: TDButton;
    DBTIItem2: TDButton;
    DBTIbtn2: TDButton;
    DBTIbtn1: TDButton;
    DBTIpag1: TDButton;
    DBTIpag2: TDButton;
    DBTIpag4: TDButton;
    DBTIpag3: TDButton;
    DWSP: TDWindow;
    DBSP: TDButton;
    DBMB1: TDButton;
    DBSPItem2: TDButton;
    DBSPItem1: TDButton;
    DBSPPage1: TDButton;
    DBSPPage2: TDButton;
    DBSPPage3: TDButton;
    DBSPPage4: TDButton;
    DBSPClose: TDButton;
    DBMB2: TDButton;
    DBMB3: TDButton;
    DBMB4: TDButton;
    DBSPenergy: TDButton;
    DBSPLuck: TDButton;
    DWChatRecordList: TDWindow;
    DBChatRecordListClose: TDButton;
    DBChatRecordPrev: TDButton;
    DBDBChatRecordScroll: TDMoveButton;
    DBChatRecordNext: TDButton;
    DBState2: TDButton;
    DSWDrum: TDButton;
    DSWHorse: TDButton;
    DStMag0: TDButton;
    CheckBox_ShowFashion: TDCheckBox;
    CheckBox_hShowFashion: TDCheckBox;
    DHSWDrum: TDButton;
    DHSWHorse: TDButton;
    DHStMag0: TDButton;
    DBHState2: TDButton;
    DDrumUS1: TDButton;
    DHorseUS1: TDButton;
    DPageUS1: TDButton;
    DStMagUS1: TDButton;
    DStMagUS2: TDButton;
    DStMagUS3: TDButton;
    DStMagUS4: TDButton;
    DStMagUS5: TDButton;
    DStMagUS6: TDButton;
    DStMagUS0: TDButton;
    DEHeroSetGuard: TDEdit;
    DRefurbishItem: TDButton;
    DBChatPrev: TDButton;
    DBChatNext: TDButton;
    DBDBChatScroll: TDMoveButton;
    procedure DButtonRecallHeroDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    //procedure DBottomInRealArea(Sender: TObject; X, Y: Integer; var IsRealArea: Boolean);
    procedure DBottomDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DMyStateDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DOptionClick();
    procedure DItemBagDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DStateWinDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure FormCreate(Sender: TObject);
    procedure DPrevStateDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DLoginNewDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DscSelect1DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DccCloseDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DItemGridGridSelect(Sender: TObject; X, Y, ACol, ARow: Integer; Shift: TShiftState);
    procedure DItemGridGridPaint(Sender: TObject; ACol, ARow: Integer; Rect: TRect; State: TGridDrawState; dsurface: TCustomCanvas);
    procedure DItemGridDblClick(Sender: TObject);
    procedure DMsgDlgOkDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DMsgDlgDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DMsgDlgKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);
    procedure DCloseBagDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBackgroundBackgroundClick(Sender: TObject);
    procedure DItemGridGridMouseMove(Sender: TObject; X, Y, ACol, ARow: Integer; Shift: TShiftState);
    procedure DBelt1DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure FormDestroy(Sender: TObject);
    procedure DBelt1DblClick(Sender: TObject);
    procedure DLoginCloseClick(Sender: TObject; X, Y: Integer);
    procedure DLoginOkClick(Sender: TObject; X, Y: Integer);
    procedure DLoginNewClick(Sender: TObject; X, Y: Integer);
    procedure DLoginChgPwClick(Sender: TObject; X, Y: Integer);
    procedure DNewAccountOkClick(Sender: TObject; X, Y: Integer);
    procedure DNewAccountCloseClick(Sender: TObject; X, Y: Integer);
    procedure DccCloseClick(Sender: TObject; X, Y: Integer);
    procedure DChgpwOkClick(Sender: TObject; X, Y: Integer);
    procedure DscSelect1Click(Sender: TObject; X, Y: Integer);
    procedure DCloseStateClick(Sender: TObject; X, Y: Integer);
    procedure DSWWeaponClick(Sender: TObject; X, Y: Integer);
    procedure DMsgDlgOkClick(Sender: TObject; X, Y: Integer);
    procedure DCloseBagClick(Sender: TObject; X, Y: Integer);
    procedure DBelt1Click(Sender: TObject; X, Y: Integer);
    procedure DMyStateClick(Sender: TObject; X, Y: Integer);
    procedure DSWWeaponMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DBelt1MouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DMerchantDlgDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DMerchantDlgCloseClick(Sender: TObject; X, Y: Integer);
    procedure DMerchantDlgClick(Sender: TObject; X, Y: Integer);
    procedure DMerchantDlgMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure DMerchantDlgMouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure DMenuCloseClick(Sender: TObject; X, Y: Integer);
    procedure DMenuDlgDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DMenuDlgClick(Sender: TObject; X, Y: Integer);
    procedure DSellDlgDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DSellDlgCloseClick(Sender: TObject; X, Y: Integer);
    procedure DSellDlgSpotClick(Sender: TObject; X, Y: Integer);
    procedure DSellDlgSpotDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DSellDlgSpotMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DSellDlgOkClick(Sender: TObject; X, Y: Integer);
    procedure DMenuBuyClick(Sender: TObject; X, Y: Integer);
    procedure DMenuPrevClick(Sender: TObject; X, Y: Integer);
    procedure DMenuNextClick(Sender: TObject; X, Y: Integer);
    procedure DGoldClick(Sender: TObject; X, Y: Integer);
    procedure DSWLightDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBackgroundMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure DStateWinMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DLoginNewClickSound(Sender: TObject; Clicksound: TClickSound);
    procedure DStMag1DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DStMag1Click(Sender: TObject; X, Y: Integer);
    procedure DKsIconDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DKsF1DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DKsOkClick(Sender: TObject; X, Y: Integer);
    procedure DKsF1Click(Sender: TObject; X, Y: Integer);
    procedure DKeySelDlgDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBotGroupDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DGrpAllowGroupDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DGrpDlgCloseClick(Sender: TObject; X, Y: Integer);
    procedure DGrpAllowGroupClick(Sender: TObject; X, Y: Integer);
    procedure DGrpCreateClick(Sender: TObject; X, Y: Integer);
    procedure DGroupDlgDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DGrpAddMemClick(Sender: TObject; X, Y: Integer);
    procedure DGrpDelMemClick(Sender: TObject; X, Y: Integer);
    procedure DBotLogoutClick(Sender: TObject; X, Y: Integer);
    procedure DBotExitClick(Sender: TObject; X, Y: Integer);
    procedure DStPageUpClick(Sender: TObject; X, Y: Integer);
    procedure DBottomMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure DDealOkClick(Sender: TObject; X, Y: Integer);
    procedure DDealCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBotTradeClick(Sender: TObject; X, Y: Integer);
    procedure DDealRemoteDlgDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DDealDlgDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DDGridGridSelect(Sender: TObject; X, Y, ACol, ARow: Integer; Shift: TShiftState);
    procedure DDGridGridPaint(Sender: TObject; ACol, ARow: Integer; Rect: TRect; State: TGridDrawState; dsurface: TCustomCanvas);
    procedure DDGridGridMouseMove(Sender: TObject; X, Y, ACol, ARow: Integer; Shift: TShiftState);
    procedure DDRGridGridPaint(Sender: TObject; ACol, ARow: Integer; Rect: TRect; State: TGridDrawState; dsurface: TCustomCanvas);
    procedure DDRGridGridMouseMove(Sender: TObject; X, Y, ACol, ARow: Integer; Shift: TShiftState);
    procedure DDGoldClick(Sender: TObject; X, Y: Integer);
    procedure DSServer1Click(Sender: TObject; X, Y: Integer);
    procedure DSSrvCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBotMiniMapClick(Sender: TObject; X, Y: Integer);
    procedure DMenuDlgMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DUserState1DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DUserState1MouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DWeaponUS1MouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DCloseUS1Click(Sender: TObject; X, Y: Integer);
    procedure DNecklaceUS1DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBotGuildClick(Sender: TObject; X, Y: Integer);
    procedure DGuildDlgDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DGDUpClick(Sender: TObject; X, Y: Integer);
    procedure DGDDownClick(Sender: TObject; X, Y: Integer);
    procedure DGDCloseClick(Sender: TObject; X, Y: Integer);
    procedure DGDHomeClick(Sender: TObject; X, Y: Integer);
    procedure DGDListClick(Sender: TObject; X, Y: Integer);
    procedure DGDAddMemClick(Sender: TObject; X, Y: Integer);
    procedure DGDDelMemClick(Sender: TObject; X, Y: Integer);
    procedure DGDEditNoticeClick(Sender: TObject; X, Y: Integer);
    procedure DGDEditGradeClick(Sender: TObject; X, Y: Integer);
    procedure DGECloseClick(Sender: TObject; X, Y: Integer);
    procedure DGEOkClick(Sender: TObject; X, Y: Integer);
    procedure DGuildEditNoticeDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DGDChatClick(Sender: TObject; X, Y: Integer);
    procedure DGoldDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DNewAccountDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DAdjustAbilCloseClick(Sender: TObject; X, Y: Integer);
    procedure DAdjustAbilityDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBotPlusAbilClick(Sender: TObject; X, Y: Integer);
    procedure DPlusDCClick(Sender: TObject; X, Y: Integer);
    procedure DMinusDCClick(Sender: TObject; X, Y: Integer);
    procedure DAdjustAbilOkClick(Sender: TObject; X, Y: Integer);
    procedure DBotPlusAbilDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DAdjustAbilityMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DUserState1MouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure DEngServer1Click(Sender: TObject; X, Y: Integer);
    procedure DGDAllyClick(Sender: TObject; X, Y: Integer);
    procedure DGDBreakAllyClick(Sender: TObject; X, Y: Integer);
    procedure DBotMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DConfigDlgDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DConfigDlgCloseDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DConfigDlgOKDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DFrdFriendDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBotFriendClick(Sender: TObject; X, Y: Integer);
    procedure DFrdCloseClick(Sender: TObject; X, Y: Integer);
    procedure DGameShopCloseClick(Sender: TObject; X, Y: Integer);
    procedure DGameShopDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DFrdAddClick(Sender: TObject; X, Y: Integer);
    procedure DFrdFriendClick(Sender: TObject; X, Y: Integer);
    procedure DFriendDlgDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DFriendDlgClick(Sender: TObject; X, Y: Integer);
    procedure DFriendDlgDblClick(Sender: TObject);
    procedure DFrdPgDnClick(Sender: TObject; X, Y: Integer);
    procedure DFrdDelClick(Sender: TObject; X, Y: Integer);
    procedure DFrdPgUpClick(Sender: TObject; X, Y: Integer);
    procedure DFrdSave();
    procedure DButtonShopClick(Sender: TObject; X, Y: Integer);
    procedure DButtonShop1Click(Sender: TObject; X, Y: Integer);
    procedure DButtonShop6Click(Sender: TObject; X, Y: Integer);
    procedure DButtonShop7Click(Sender: TObject; X, Y: Integer);
    procedure DButtonShop8Click(Sender: TObject; X, Y: Integer);
    procedure DGridShop1GridPaint(Sender: TObject; ACol, ARow: Integer; Rect: TRect; State: TGridDrawState; dsurface: TCustomCanvas);
    procedure DGridShop1GridSelect(Sender: TObject; X, Y, ACol, ARow: Integer; Shift: TShiftState);
    procedure DButtonShop9Click(Sender: TObject; X, Y: Integer);
    procedure DButtonShop10Click(Sender: TObject; X, Y: Integer);
    procedure DGridShop2GridPaint(Sender: TObject; ACol, ARow: Integer; Rect: TRect; State: TGridDrawState; dsurface: TCustomCanvas);
    procedure DGridShop2GridSelect(Sender: TObject; X, Y, ACol, ARow: Integer; Shift: TShiftState);
    procedure DButtonShopEffectDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DWHeroStatusDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DButtonRecallHeroClick(Sender: TObject; X, Y: Integer);
    procedure DHeroItemBagDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DHeroItemGridGridMouseMove(Sender: TObject; X, Y, ACol, ARow: Integer; Shift: TShiftState);
    procedure DHeroItemGridGridSelect(Sender: TObject; X, Y, ACol, ARow: Integer; Shift: TShiftState);
    procedure DHeroItemGridGridPaint(Sender: TObject; ACol, ARow: Integer; Rect: TRect; State: TGridDrawState; dsurface: TCustomCanvas);
    procedure DHeroItemGridDblClick(Sender: TObject);
    procedure DButtonHeroStateClick(Sender: TObject; X, Y: Integer);
    procedure DCloseHeroBagClick(Sender: TObject; X, Y: Integer);
    procedure DButtonHeroBagClick(Sender: TObject; X, Y: Integer);
    procedure DHeroItemBagMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DItemBagMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DHCloseStateClick(Sender: TObject; X, Y: Integer);
    procedure DHStateWinMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DHStateWinDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DHStMag1DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DHStPageUpDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DHStPageUpClick(Sender: TObject; X, Y: Integer);
    procedure DHSWArmRingRDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DHSWWeaponClick(Sender: TObject; X, Y: Integer);
    procedure DHSWWeaponMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DWHeroStatusClick(Sender: TObject; X, Y: Integer);
    procedure DBDelCharListDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBGetDelCharCloseClick(Sender: TObject; X, Y: Integer);
    procedure DscCreditsClick(Sender: TObject; X, Y: Integer);
    procedure DBDelCharListClick(Sender: TObject; X, Y: Integer);
    procedure DBGetBackDelCharClick(Sender: TObject; X, Y: Integer);
    procedure DRefineItemClick(Sender: TObject; X, Y: Integer);
    procedure DBRefineItem1DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DWRefineDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBRefineCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBRefineItem1Click(Sender: TObject; X, Y: Integer);
    procedure DWRefineMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DBRefineOKClick(Sender: TObject; X, Y: Integer);
    procedure DBRefineItem1MouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DBGCCloseClick(Sender: TObject; X, Y: Integer);
    procedure DWGameConfigDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBGCActivePage1Click(Sender: TObject; X, Y: Integer);
    procedure DBGCShowNameClick(Sender: TObject; X, Y: Integer);
    procedure DHStMag1Click(Sender: TObject; X, Y: Integer);
    procedure DBLRHunamDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBLRHunamClick(Sender: TObject; X, Y: Integer);
    procedure DBLRCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBotLevelRankClick(Sender: TObject; X, Y: Integer);
    procedure DBLRAllClick(Sender: TObject; X, Y: Integer);
    procedure DWRankDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBLRFirstClick(Sender: TObject; X, Y: Integer);
    procedure DBLRLastClick(Sender: TObject; X, Y: Integer);
    procedure DBLRMyRankClick(Sender: TObject; X, Y: Integer);
    procedure DBLRPriorClick(Sender: TObject; X, Y: Integer);
    procedure DBLRNextClick(Sender: TObject; X, Y: Integer);
    procedure DWRankClick(Sender: TObject; X, Y: Integer);
    procedure DWRankMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DWRankDblClick(Sender: TObject);
    procedure DWGameConfigClick(Sender: TObject; X, Y: Integer);
    procedure DWGameConfigMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure GameConfigEditChange(Sender: TObject);
    procedure GameConfigKeyPress(Sender: TObject; var Key: Char);
    procedure DWGameConfigKeyPress(Sender: TObject; var Key: Char);
    procedure DxEditLoginIDKeyPress(Sender: TObject; var Key: Char);
    procedure DxEditPasswordKeyPress(Sender: TObject; var Key: Char);
    procedure DWBookBkgndDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBBookCloseDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBBookCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBBookPageDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBBookPriorDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBBookNextDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBBookPriorClick(Sender: TObject; X, Y: Integer);
    procedure DBBookNextClick(Sender: TObject; X, Y: Integer);
    procedure DWBoxBKGndDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DWBoxBKGndClick(Sender: TObject; X, Y: Integer);
    procedure DBFlashRareBoxDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBRareItem1DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBFlashRareBoxMouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure DBRareItem1DblClick(Sender: TObject);
    procedure DBRareItem1MouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DWBoxBKGndMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DSServer1DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DItemMarketDlgDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DItemMarketDlgClick(Sender: TObject; X, Y: Integer);
    procedure DItemMarketDlgMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DItemListPrevClick(Sender: TObject; X, Y: Integer);
    procedure DItemListNextClick(Sender: TObject; X, Y: Integer);
    procedure DItemBuyClick(Sender: TObject; X, Y: Integer);
    procedure DItemMarketCloseClick(Sender: TObject; X, Y: Integer);
    procedure DItemMarketDlgKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);
    procedure DItemListRefreshClick(Sender: TObject; X, Y: Integer);
    procedure DItemCancelClick(Sender: TObject; X, Y: Integer);
    procedure DItemFindClick(Sender: TObject; X, Y: Integer);
    procedure DItemMarketDlgMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure DItemSellCancelClick(Sender: TObject; X, Y: Integer);
    procedure DWYBDealDlgDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBYBDealCalcelClick(Sender: TObject; X, Y: Integer);
    procedure DGridYBDealGridMouseMove(Sender: TObject; X, Y, ACol, ARow: Integer; Shift: TShiftState);
    procedure DGridYBDealGridPaint(Sender: TObject; ACol, ARow: Integer; Rect: TRect; State: TGridDrawState; dsurface: TCustomCanvas);
    procedure DGridYBDealGridSelect(Sender: TObject; X, Y, ACol, ARow: Integer; Shift: TShiftState);
    procedure DBYBDealOKClick(Sender: TObject; X, Y: Integer);
    procedure ServerSendYBSell(nCode, nCount: Integer; sMsg: string);
    procedure ServerSendYBDeal(nCode, nCount: Integer; sMsg: string);
    procedure DWYbDealItemsDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBYBDealDlgCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBYbDealItemsCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBYbCalcelSellClick(Sender: TObject; X, Y: Integer);
    procedure DWYbDealItemsMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DBYbBuyItemsClick(Sender: TObject; X, Y: Integer);
    procedure DBYbBuyCancelClick(Sender: TObject; X, Y: Integer);
    procedure DBotGroupMouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure DWHeroStatusMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DLogInDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBRefuseSayDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBRefuseSayClick(Sender: TObject; X, Y: Integer);
    procedure DBGCCloseDirectPaint(Sender: TObject;
      dsurface: TCustomCanvas);
    procedure DHStMag1MouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DBMissionsCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBMS1Click(Sender: TObject; X, Y: Integer);
    procedure DBGCActivePage1DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBMS1DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DWMissionsDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DWMissionsMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure DWMissionsClick(Sender: TObject; X, Y: Integer);
    procedure DBMissionOpenClick(Sender: TObject; X, Y: Integer);
    procedure DBMissionOpenDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBMUP1Click(Sender: TObject; X, Y: Integer);
    procedure DBMDown1Click(Sender: TObject; X, Y: Integer);
    procedure DBMUP2Click(Sender: TObject; X, Y: Integer);
    procedure DBMDown2Click(Sender: TObject; X, Y: Integer);
    procedure DStMag1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBMiniMapDirectPaint(Sender: TObject;
      dsurface: TCustomCanvas);
    procedure DBMiniMapMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DBStateDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBStateMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DBStateMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBConRandomDirectPaint(Sender: TObject;
      dsurface: TCustomCanvas);
    procedure DBConRandomClick(Sender: TObject; X, Y: Integer);
    procedure DBConKeyClick(Sender: TObject; X, Y: Integer);
    procedure DBConRandomMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBConKeyMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DSeMag1DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DSeMag1MouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DListBoxSSkillDirectPaint(Sender: TObject;
      dsurface: TCustomCanvas);
    procedure DListBoxSSkillMouseMove2(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBV1DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBV1Click(Sender: TObject; X, Y: Integer);
    procedure DBP1DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBPH1DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBP1MouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DBV1MouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DAdjustAbilOkDirectPaint(Sender: TObject;
      dsurface: TCustomCanvas);
    procedure DBP1MouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DBTrainVenationMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DBHStateDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBHStateMouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure DWBuildAcusCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBotDareClick(Sender: TObject; X, Y: Integer);
    procedure DWBuildAcusDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBBuildAcusHelpDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBBuildAcusHelpClick(Sender: TObject; X, Y: Integer);
    procedure DBAcus1DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBAcus1Click(Sender: TObject; X, Y: Integer);
    procedure DBAcus1MouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DWCollectExpDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBCollectStateDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBCollectExpDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBCollectExpMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DWCollectExpMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DBCollectStateMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DBCollectStateMouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure DMBHitSpeedMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DMBHitSpeedDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DHSeMag1DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBHV1MouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DBHP1MouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DBHP1MouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure DBHP1DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DHSeMag1MouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure DHListBoxSSkillDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBHV1Click(Sender: TObject; X, Y: Integer);
    procedure DBHTrainVenationMouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure DHStateWinMouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure DHListBoxSSkillMouseMove2(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DListBoxSSkillChangeSelect2(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure DHListBoxSSkillChangeSelect2(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);

    procedure DBeltCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBeltSwapClick(Sender: TObject; X, Y: Integer);
    procedure DBeltWindowMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DBeltSwapDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBChatDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBChatStatusDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBChatStatusClick(Sender: TObject; X, Y: Integer);
    procedure DBChatWinDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBChatWinInRealArea(Sender: TObject; X, Y: Integer; var IsRealArea: Boolean);
    procedure DBChatWinMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);

    procedure DBChatRangeClick(Sender: TObject; X, Y: Integer);
    procedure DBChatRangeDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBChatWinMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DBHideChatClick(Sender: TObject; X, Y: Integer);
    procedure DBAttackModeDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBAttackModeClick(Sender: TObject; X, Y: Integer);
    procedure DMBChatDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DMBChatMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DMBVolumeDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DMBVolumeMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DxEditLoginIDMouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure DWHeroStoreDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DGridStoreGridPaint(Sender: TObject; ACol, ARow: Integer; Rect: TRect; State: TGridDrawState; dsurface: TCustomCanvas);
    procedure DGridStoreGridMouseMove(Sender: TObject; X, Y, ACol, ARow: Integer; Shift: TShiftState);
    procedure DGridStoreGridSelect(Sender: TObject; X, Y, ACol, ARow: Integer; Shift: TShiftState);
    procedure DWStoreItemPriceDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBStorePage1DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBStorePage1Click(Sender: TObject; X, Y: Integer);
    procedure DBStoreItemPriceOkClick(Sender: TObject; X, Y: Integer);
    procedure DBStoreItemPriceCancelClick(Sender: TObject; X, Y: Integer);
    procedure DWHeroStoreMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DBStoreCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBStoreBuyClick(Sender: TObject; X, Y: Integer);
    procedure DBotStoreClick(Sender: TObject; X, Y: Integer);
    procedure DGridUserStallGridPaint(Sender: TObject; ACol, ARow: Integer; Rect: TRect; State: TGridDrawState; dsurface: TCustomCanvas);
    procedure DGridUserStallGridSelect(Sender: TObject; X, Y, ACol, ARow: Integer; Shift: TShiftState);
    procedure DBUserStallCloseClick(Sender: TObject; X, Y: Integer);
    procedure DGridUserStallGridMouseMove(Sender: TObject; X, Y, ACol, ARow: Integer; Shift: TShiftState);
    procedure DWUserStallDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBUserStallBuyClick(Sender: TObject; X, Y: Integer);
    procedure DBStoreCancelClick(Sender: TObject; X, Y: Integer);
    procedure DBotStoreDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBGameGoldMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DItemGridMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DWYBDealDlgMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DscStartDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBCommandClick(Sender: TObject; X, Y: Integer);
    procedure DxHint1ChangeSelect(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DBIUPDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DMoveButton_itemsMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DBIUPClick(Sender: TObject; X, Y: Integer);
    procedure DBIDownClick(Sender: TObject; X, Y: Integer);
    procedure DListBox_ItemsOnChangeSelect(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DxEdit_Items_Search_OnTextChanged(Sender: TObject; sText: string);
    procedure DBHint1CloseClick(Sender: TObject; X, Y: Integer);
    procedure DWHint1DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBDetectBoxDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBDetectBoxClick(Sender: TObject; X, Y: Integer);
    procedure DBDetectBoxMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DBDetectBoxDblClick(Sender: TObject);
    procedure DBTICloseClick(Sender: TObject; X, Y: Integer);
    procedure DWTIDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DWTIDirectPaint2(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBTIpag1Click(Sender: TObject; X, Y: Integer);
    procedure DBTIItem1Click(Sender: TObject; X, Y: Integer);
    procedure DBTIItem1DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBTIItem1MouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DBTIbtn1Click(Sender: TObject; X, Y: Integer);
    procedure DWTIMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DBTIbtn2Click(Sender: TObject; X, Y: Integer);

    procedure DWSPDirectPaint2(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBSPPage1Click(Sender: TObject; X, Y: Integer);
    procedure DWSPDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBSPenergyMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DBSPClick(Sender: TObject; X, Y: Integer);
    procedure DBSPItem1Click(Sender: TObject; X, Y: Integer);
    procedure DBSPItem1DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBSPItem1MouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DBSPCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBSPenergyDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBSPLuckDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DWMissionsMouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure DBChatRecordListCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBChatRecordListCloseDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DWChatRecordListDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DWChatRecordListMouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure DWChatRecordListMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DBChatRecordPrevClick(Sender: TObject; X, Y: Integer);
    procedure DBChatRecordNextClick(Sender: TObject; X, Y: Integer);
    procedure DBDBChatRecordScrollMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DBState2DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DBState2MouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure DStPageUpDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure CheckBox_ShowFashionDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure CheckBox_ShowFashionClick(Sender: TObject; X, Y: Integer);
    procedure DBHState2MouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure DStMagUS1DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure DStMagUS2MouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure DPageUS1MouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure DPageUS1DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
    procedure CheckBox_ShowFashionInRealArea(Sender: TObject; X, Y: Integer; var IsRealArea: Boolean);
    procedure DMerchantDlgInRealArea(Sender: TObject; X, Y: Integer;
      var IsRealArea: Boolean);
    procedure DRefurbishItemClick(Sender: TObject; X, Y: Integer);
    procedure DBChatPrevClick(Sender: TObject; X, Y: Integer);
    procedure DBChatPrevDirectPaint(Sender: TObject; DSurface: TCustomCanvas);
    procedure DBChatNextClick(Sender: TObject; X, Y: Integer);
    procedure DBChatNextDirectPaint(Sender: TObject; DSurface: TCustomCanvas);
    procedure DBDBChatScrollMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);

  private
    m_bHeroEnergyFlash: Boolean;
    m_dwHeroEnergyFlashTick: LongWord;
    m_dwShopEffectTick: LongWord;
    m_nShopShowMaxFrame: Integer;
    m_nShopShowEffectFrame: Integer;
    m_nShopShowCurrentFrame: Integer;
    DlgTemp: TList;
    m_nMagTop: Integer;
    m_nHMagTop: Integer;
    Memo: TMemo;
    ViewDlgEdit: Boolean;
    msglx, msgly: Integer;
    MenuTop: Integer;
    Total: Integer;
    m_nDelCharTop: Integer;
    m_nFriendsTop: Integer;
    m_nBlockTop: Integer;
    MagKeyIcon, MagKeyCurKey: Integer;
    MemoCharID: string;
    MemoCharID2: string;
    MemoDate: string;
    MagKeyMagName: string;
    MagicPage: Integer;
    IPMagicPage: Integer;
    m_nHeroMagicPage: Integer;
    m_nHeroIPMagicPage: Integer;
    m_nShopPage: Integer;
    m_nShopClass: Integer;
    BlinkTime: LongWord;
    BlinkCount: Integer;

    procedure HideAllControls;
    procedure RestoreHideControls;
    procedure DealItemReturnBag(mitem: TClientItem);
    procedure DealZeroGold;
    procedure OpenSoundOption(bkg: Boolean);
    procedure OpenFriendDlg;
  public
    m_HintStrs: THintStrings;
    m_dwRecallHeroTick: LongWord;
    m_dwUnRecallHeroTick: LongWord;
    EditTemp: TEdit;
    //m_sAutoSayMsg: string;
    m_sAutoSayMsgTick: LongWord;
    m_dwSendMessageTick: LongWord;
    //EdDlgEdit: TEdit;
    m_nLevelRankPage: Integer;
    m_nLevelRankType: Integer;
    m_nLastLevelRankPage: Integer;
    m_nLastLevelRankType: Integer;

    StatePage: Integer;
    uStatePage: Integer;
    m_nIPStatePage: Integer;
    m_nHeroStatePage: Integer;
    m_nHeroIPStatePage: Integer;
    MsgText: string;
    DialogSize: Integer;
    m_nDiceCount: Integer;
    m_boPlayDice: Boolean;
    m_Dice: array[0..9] of TDiceInfo;

    boInRect: Boolean;
    MItemSellState: byte;

    //MerchantName: string;
    //MerchantFace: Integer;
    MDlgStr: string;
    MDlgPoints: TList;
    RequireAddPoints: Boolean;
    SelectMenuStr: string;

    m_MissionList: array[1..4] of TGList;
    m_MissionPoints: TList;
    m_MissionIdxTitle: Integer;
    m_MissionIdxDesc: Integer;
    m_MissionRequireAddPoints: Boolean;
    m_MissionSelectIndexStr: string;
    m_MissionSelectMenuStr: string;

    LastestClickTime: LongWord;
    SpotDlgMode: TSpotDlgMode;
    SpotDlgStr: string;
    m_FriendsList: THStringList;
    m_BlockList: TStringList;
    m_nFriendIndex: Integer;
    m_nBlockIndex: Integer;
    m_nShopItemIndex: Integer;
    m_nShopItemIndex2: Integer;

    MenuList: TList;
    menuindex: Integer;
    MenuTopLine: Integer;
    m_DelCharList: TList;
    m_nDelCharIndex: Integer;
    m_nDelCharTopLine: Integer;

    m_nLevelRankIndex: Integer;
    m_nLevelRankMoveIndex: Integer;
    m_YbItemIndex: Integer;

    BoDetailMenu: Boolean;
    BoStorageMenu: Boolean;
    BoNoDisplayMaxDura: Boolean;
    BoMakeDrugMenu: Boolean;
    NAHelps: TStringList;
    NewAccountTitle: string;
    CurDetailItem: string;
    DlgEditText: string;
    //UserState1: TUserStateInfo;

    Guild: string;
    GuildFlag: string;
    GuildCommanderMode: Boolean;
    GuildStrs: TStringList;
    GuildStrs2: TStringList;
    GuildNotice: TStringList;
    GuildMembers: TStringList;
    GuildTopLine: Integer;
    GuildEditHint: string;
    GuildChats: TStringList;
    BoGuildChat: Boolean;

    {-----ChatRecordList-----}
    m_xChatRecordList: TStringList;
    m_nChatRecordListTop: Integer;
    m_nChatRecordListMouseIdx: Integer;
    m_nChatRecordListCurIdx: Integer;
    m_nChatRecordListRightClip: Integer;
    m_nChatRecordListRightClipMax: Integer;

    procedure PageChanged;
    procedure USPageChanged;
    procedure HeroPageChanged;
    procedure InitializeNext();
    procedure InitializeNext2();
    procedure InitializeNext3();
    procedure Initialize(FirstStep: Boolean);
    procedure OpenMyStatus;

    procedure OpenHeroStatus;
    procedure OpenUserState(UserState: TUserStateInfo);
    procedure OpenItemBag;
    procedure OpenHeroItemBag;
    procedure ViewBottomBox(Visible: Boolean);
    procedure CancelItemMoving;
    procedure DropMovingItem;
    procedure HeroDropMovingItem;
    procedure OpenAdjustAbility;
    procedure YbDealItemReturnBag();

    procedure ShowSelectServerDlg;
    function DMessageDlg(msgstr: string; DlgButtons: TMsgDlgButtons; deftext: string = ''; nt: byte = 0; len: Integer = -1): TModalResult;
    procedure QueryYbSell();
    procedure ShowMDlg(face: Integer; mname, msgstr: string);
    procedure ShowMissionDlg(param: Integer);
    procedure ShowGuildDlg;
    procedure ShowGuildEditNotice;
    procedure ShowGuildEditGrade;

    procedure ShowAssistantItemFilter;
    procedure ShowAssistantMonFilter;

    procedure ShowItemMarketDlg;
    procedure CloseItemMarketDlg;
    procedure ResetMenuDlg;
    procedure ResetDelCharMenuDlg;
    procedure ShowShopMenuDlg(mode: TMenuDlgMode);
    procedure ShowDelCharInfoDlg;
    procedure ShowShopSellDlg;
    procedure CloseDSellDlg;
    procedure CloseMDlg;
    procedure CloseMissionDlg;

    procedure ToggleShowGroupDlg;
    procedure OpenDealDlg;
    procedure CloseDealDlg;

    procedure SoldOutGoods(itemserverindex: Integer);
    procedure DelStorageItem(itemserverindex: Integer; remain: Word);
    //procedure GetMouseItemInfo(CurrMouseItem: TClientItem; var iname, line1, line2, line3, line4: string; var useable: Boolean; bIsHero: Boolean = False);
    procedure GetMouseItemInfoHint(CurrMouseItem: TClientItem; var hintstr: string; bIsHero: Boolean = False);

    procedure SetMagicKeyDlg(icon: Integer; magname: string; var curkey: Word);
    procedure AddGuildChat(Str: string);
    procedure LoadMySelfConfig();
    procedure CloseHeroWindows();
    procedure ClientCallHero();
    procedure ClientHeroState();
    procedure ClientHeroBag();
    procedure SaveGameConfig();
    procedure OpenBuildAcusWin();
    procedure LoadBeltConfig();
    procedure SaveBeltConfig();

    procedure QueryChangeHero(sName: string);

    function ShowHintWindow1(X, Y: Integer; Str: string; Color: TColor; drawUp, drawLeft, ShowItem, ItemWearing: Boolean): Integer;

    procedure InitGrobalSurface();
    procedure UnInitGrobalSurface();

    procedure OpenDBTI();
    procedure CloseDBTI();

    procedure OpenDBSP();
    procedure CloseDBSP();
    procedure BuildBottomWinSurface(Surface: TCustomCanvas; HeroSys: Boolean = True);
  end;

procedure InitMainImagesSecond();

var
  FrmDlg: TFrmDlg;
  g_pweapon: PTClientItem;
  StandardNpcDlg: Boolean; //是否标准NPC对话框

implementation

uses
  ClMain, MShare, HumanActor, Actor, MirEffect, frmWebBroser, StallSystem,uThreadEx,
  DxHint;

{$R *.DFM}

function ExtractUserName(line: string): string;
var
  uname: string;
begin
  GetValidStr3(line, line, ['(', '!', '*', '/', ')']);
  GetValidStr3(line, uname, [' ', '=', ':']);
  if uname <> '' then
    if (uname[1] = '/') or (uname[1] = '(') or (uname[1] = ' ') or (uname[1] = '[') then
      uname := '';
  Result := uname;
end;

procedure TFrmDlg.BuildBottomWinSurface(Surface: TCustomCanvas; HeroSys: Boolean);
var
  i, n, lx, ly: Integer;
  offset: Integer;
  d: TCustomLockableTexture;
  p: PLongWord;
  f: string;

  DestRect: TIntRect;
begin
  d := nil;
  g_QueryWinBottomTick := GetTickCount;
//  Surface.FillRect(g_BotSurface.ClientRect, $00000000);

  Surface.FillRectAlpha(IntRectBDS(100, SCREENHEIGHT - 250 + 130,SCREENWIDTH,SCREENHEIGHT - 250 + 130 + 80), $F8FCF8,255);

//  HeroSys := False;
  if HeroSys then begin
    d := g_opui.Images[1];
    Surface.Draw(SCREENWIDTH - d.Width, SCREENHEIGHT - d.Height , d.ClientRect, d, True);
  end else begin
    d := g_opui.Images[1];
    if d <> nil then begin
      Surface.Draw(SCREENWIDTH - d.Width, SCREENHEIGHT - d.Height , d.ClientRect, d, True);
    end;
    d := g_WMain3Images.Images[291];
    if d <> nil then begin
      DestRect := d.ClientRect;
      DestRect.Left := d.Width - 163;
      Surface.Draw(SCREENWIDTH - 163, SCREENHEIGHT - d.Height , DestRect, d, True);
    end;
  end;

  d := g_opui.Images[0];
  if d <> nil then
  Surface.Draw(0, SCREENHEIGHT - d.Height , d.ClientRect, d, True);

  d := g_opui.Images[2];
  if d <> nil then
  Surface.Draw((SCREENWIDTH - d.Width) div 2 + 11, SCREENHEIGHT - 211, d.ClientRect, d, True);

  d := g_opui.Images[10];
  if d <> nil then
  Surface.Draw(194, SCREENHEIGHT - 158, d.ClientRect, d, True);

  d := g_opui.Images[11];
  if d <> nil then begin
    n := (SCREENWIDTH - 241 - 194) div 48;
    if n > 0 then begin
      for i := 1 to n do
        Surface.Draw(194 + 48 * i, SCREENHEIGHT - 158, d.ClientRect, d, True);
    end;
  end;

  d := g_opui.Images[12];
  if d <> nil then
    Surface.Draw(SCREENWIDTH - 241, SCREENHEIGHT - 158, d.ClientRect, d, True);

  d := g_opui.Images[13];
  if d <> nil then begin
    Surface.Draw(194, SCREENHEIGHT - 158 + 48, d.ClientRect, d, True);
    Surface.Draw(194, SCREENHEIGHT - 158 + 48 * 2, d.ClientRect, d, True);
  end;

  d := g_opui.Images[14];
  if d <> nil then begin
    Surface.Draw(SCREENWIDTH - 241, SCREENHEIGHT - 158 + 48, d.ClientRect, d, True);
    Surface.Draw(SCREENWIDTH - 241, SCREENHEIGHT - 158 + 48 * 2, d.ClientRect, d, True);
  end;

  d := g_opui.Images[15];
  if d <> nil then
    Surface.Draw(194, SCREENHEIGHT - 48, d.ClientRect, d, True);

  d := g_opui.Images[16];
  if d <> nil then begin
    n := (SCREENWIDTH - 241 - 194) div 48;
    if n > 0 then begin
      for i := 1 to n do
        Surface.Draw(194 + 48 * i, SCREENHEIGHT - 48, d.ClientRect, d, True);
    end;
  end;

  d := g_opui.Images[17];
  if d <> nil then
    Surface.Draw(SCREENWIDTH - 241, SCREENHEIGHT - 48, d.ClientRect, d, True);

//  DBottom.ImageSurface := g_BotSurface;

end;

procedure TFrmDlg.FormCreate(Sender: TObject);
var
  i: Integer;
  ts: TStringList;
begin
  m_xChatRecordList := TStringList.Create;

  m_nChatRecordListTop := 0;
  m_nChatRecordListCurIdx := -1;
  m_nChatRecordListMouseIdx := -1;
  m_nChatRecordListRightClip := 0;
  m_nChatRecordListRightClipMax := 0;

  m_sAutoSayMsgTick := 0;
  m_bHeroEnergyFlash := True;
  StatePage := 0;
  m_nIPStatePage := 0;
  m_nHeroStatePage := 0;
  m_nHeroIPStatePage := 0;
  DlgTemp := TList.Create;
  DialogSize := 1;
  m_nDiceCount := 0;
  m_boPlayDice := False;
  //m_nMagCur := 0;
  m_nMagTop := 0;
  //m_nHMagCur := 0;
  m_nHMagTop := 0;
  MDlgPoints := TList.Create;
  m_MissionPoints := TList.Create;
  m_MissionIdxTitle := 0;
  m_MissionIdxDesc := 0;

  for i := Low(m_MissionList) to High(m_MissionList) do m_MissionList[i] := TGList.Create;

  SelectMenuStr := '';
  SpotDlgStr := '请输入:';
  MenuList := TList.Create;
  m_DelCharList := TList.Create;
  m_FriendsList := THStringList.Create;
  m_BlockList := TStringList.Create;
  menuindex := -1;
  m_nDelCharIndex := -1;
  m_nLevelRankIndex := -1;
  m_nLevelRankMoveIndex := -1;
  m_YbItemIndex := -1;
  m_nFriendIndex := -1;
  m_nBlockIndex := -1;
  m_nShopItemIndex := -1;
  m_nShopItemIndex2 := -1;
  MenuTopLine := 0;
  m_nDelCharTopLine := 0;
  BoDetailMenu := False;
  BoStorageMenu := False;
  BoNoDisplayMaxDura := False;
  BoMakeDrugMenu := False;
  MagicPage := 0;
  IPMagicPage := 0;
  m_nHeroMagicPage := 0;
  m_nHeroIPMagicPage := 0;
  m_nShopPage := 0;
  m_nShopClass := 0;
  NAHelps := TStringList.Create;
  BlinkTime := GetTickCount;
  BlinkCount := 0;

  g_SellDlgItem.s.Name := '';
  Guild := '';
  GuildFlag := '';
  GuildCommanderMode := False;
  GuildStrs := TStringList.Create;
  GuildStrs2 := TStringList.Create;
  GuildNotice := TStringList.Create;
  GuildMembers := TStringList.Create;
  GuildChats := TStringList.Create;

  DxHint.Items.Clear;
  DxHint.Items.Add(' 剪切 (Ctrl+X) ');
  DxHint.Items.Add(' 复制 (Ctrl+C) ');
  DxHint.Items.Add(' 粘贴 (Ctrl+V) ');
  DxHint.Items.Add(' 删除 (Delete) ');
  DxHint.Items.Add(' 全选 (Ctrl+A) ');
  DxHint.Width := 105;
  DxHint.Height := 20 * DxHint.Items.Count + 8;

  ts := TStringList.Create();
  if FileExists('.\CmdLine.txt') then begin
    ts.LoadFromFile('.\CmdLine.txt');
    DeleteFile('.\CmdLine.txt');
  end;

  DxHint1.Items.Clear;
  for i := 0 to ts.Count - 1 do
    if Trim(ts[i]) <> '' then
      DxHint1.Items.Add(Format(' %s ', [Trim(ts[i])]));

  DxHint1.Items.Add(' 黄字喊话(!) ');
  DxHint1.Items.Add(' 行会聊天(!~) ');
  DxHint1.Items.Add(' 组队聊天(!!) ');
  DxHint1.Items.Add(' 千里传音 ');

  DxHint1.Width := 128;
  DxHint1.Height := 20 * DxHint1.Items.Count + 8;
  DxHint1.Left := 176;
  DxHint1.Top := DxHint1.LocalY(SCREENHEIGHT - (SCREENHEIGHT - 600) - DxHint1.Height);
  DxHint1.FOnChangeSelect := DxHint1ChangeSelect;

  ts.free;

  DxDlgEdit.Height := 18;
  DxDlgEdit.Width := 375;
  DxDlgEdit.Left := 40;
  DxDlgEdit.Top := 80;
  DxDlgEdit.Visible := False;

  //EdChat := TEdit.Create(frmMain.Owner);
  with DEdChat do begin
    OnKeyPress := g_PlayScene.EdChatKeyPress;
    MaxLength := 255;
    Font.Size := 9;
    FRightClick := True;

    Left := 210;
    Top := 233 + 2;
    Height := 12;
    Width := (SCREENWIDTH div 2 - 207) * 2;
    FCaretColor := clBlack;
    FMiniCaret := 2;
    FontSelColor := clWhite;
    m_InputHint := 'Ctrl+↑↓浏览历史记录';
  end;

  EditTemp := TEdit.Create(frmMain.Owner);
  with EditTemp do begin
    Parent := frmMain;
    Color := clBlack;
    Font.Color := clBlack;
    Font.Size := 9;
    MaxLength := 0;
    Height := 16;
    Ctl3D := False;
    BorderStyle := bsSingle;
    Visible := False;
  end;

  Memo := TMemo.Create(frmMain.Owner);
  with Memo do begin
    Parent := frmMain;
    Color := clBlack;
    Font.Color := clWhite;
    Font.Size := 10;
    Ctl3D := False;
    BorderStyle := bsSingle; {OnKeyPress := EdDlgEditKeyPress;}
    Visible := False;
  end;
  Visible := False;
end;

procedure TFrmDlg.FormDestroy(Sender: TObject);
var
  i, ii: Integer;
  List: TGList;
begin
  m_xChatRecordList.free;
  DlgTemp.free;
  MDlgPoints.free;
  m_MissionPoints.free;

  for i := Low(m_MissionList) to High(m_MissionList) do begin
    List := m_MissionList[i];
    for ii := 0 to List.Count - 1 do
      Dispose(PTClientMission(List[ii]));
    List.free;
  end;

  MenuList.free;
  m_DelCharList.free;
  m_FriendsList.free;
  m_BlockList.free;
  NAHelps.free;
  GuildStrs.free;
  GuildStrs2.free;
  GuildNotice.free;
  GuildMembers.free;
  GuildChats.free;
end;

procedure TFrmDlg.HideAllControls;
var
  i: Integer;
  c: TControl;
begin
  DScreen.ClearHint;
  DlgTemp.Clear;
  with frmMain do
    for i := 0 to ControlCount - 1 do begin
      c := Controls[i];
      if c is TEdit then
        if (c.Visible) {and (c <> EdDlgEdit)} then begin
          DlgTemp.Add(c);
          c.Visible := False;
        end;
    end;
end;

procedure TFrmDlg.RestoreHideControls;
var
  i: Integer;
  c: TControl;
begin
  for i := 0 to DlgTemp.Count - 1 do
    TControl(DlgTemp[i]).Visible := True;
  //Memo.Visible := False;  //080722
end;

procedure TFrmDlg.InitGrobalSurface();
var
  Rect: TRect;
begin
//  g_ImgMixSurface := TCustomLockableTexture.Create;
//  g_ImgMixSurface.SetSize(300, 350);
//
//  g_ImgLargeMixSurface := TCustomLockableTexture.Create;
//  g_ImgLargeMixSurface.SetSize(800, 700);
//
//  g_MiniMapSurface := TCustomLockableTexture.Create;
//  g_MiniMapSurface.SetSize(540, 360);
//
//  g_DsMiniMapPixel := TCustomLockableTexture.Create;
//  g_DsMiniMapPixel.SetSize(200, 200);
//
//  g_HeathBar_Red := TCustomLockableTexture.Create;
//  g_HeathBar_Red.SetSize(30, 2);
//  g_HeathBar_Red.FillRect(g_HeathBar_Red.ClientRect, {$IF MIR2EX}Pal_8to16[249]{$ELSE}249{$IFEND MIR2EX});
//  Rect := g_HeathBar_Red.ClientRect;
//  Inc(Rect.Top);
//  Dec(Rect.Right);
//  g_HeathBar_Red.FillRect(Rect, {$IF MIR2EX}Pal_8to16[55]{$ELSE}55{$IFEND MIR2EX});

//  g_HeathBar_Green := TCustomLockableTexture.Create;
//  g_HeathBar_Green.SetSize(30, 2);
//  g_HeathBar_Green.FillRect(g_HeathBar_Green.ClientRect, {$IF MIR2EX}Pal_8to16[250]{$ELSE}250{$IFEND MIR2EX});
//  Rect := g_HeathBar_Green.ClientRect;
//  Inc(Rect.Top);
//  Dec(Rect.Right);
//  g_HeathBar_Green.FillRect(Rect, {$IF MIR2EX}Pal_8to16[221]{$ELSE}221{$IFEND MIR2EX});

//  g_HeathBar_Blue := TCustomLockableTexture.Create;
//  g_HeathBar_Blue.SetSize(30, 2);
//  g_HeathBar_Blue.FillRect(g_HeathBar_Blue.ClientRect, {$IF MIR2EX}Pal_8to16[155]{$ELSE}155{$IFEND MIR2EX});
//  Rect := g_HeathBar_Blue.ClientRect;
//  Inc(Rect.Top);
//  Dec(Rect.Right);
//  g_HeathBar_Blue.FillRect(Rect, {$IF MIR2EX}Pal_8to16[157]{$ELSE}157{$IFEND MIR2EX});

//  g_HeathBar_Yellow := TCustomLockableTexture.Create;
//  g_HeathBar_Yellow.SetSize(30, 2);
//  g_HeathBar_Yellow.FillRect(g_HeathBar_Yellow.ClientRect, {$IF MIR2EX}Pal_8to16[251]{$ELSE}251{$IFEND MIR2EX});
//  Rect := g_HeathBar_Yellow.ClientRect;
//  Inc(Rect.Top);
//  Dec(Rect.Right);
//  g_HeathBar_Yellow.FillRect(Rect, {$IF MIR2EX}Pal_8to16[125]{$ELSE}125{$IFEND MIR2EX});

//  g_HintSurface_Y := TCustomLockableTexture.Create;
//  g_HintSurface_Y.SetSize(550, 550);
//  g_HintSurface_Y.FillRect(g_HintSurface_Y.ClientRect, {$IF MIR2EX}Pal_8to16[161]{$ELSE}161{$IFEND MIR2EX});
  g_HintSurface_Y := PXL.Providers.TGraphicsDeviceProvider(g_GameDevice.Provider).CreateLockableTexture(g_GameDevice, False);
  g_HintSurface_Y.SetSize(550, 550);
  g_HintSurface_Y.PixelFormat := TPixelFormat.A8R8G8B8;

//  g_HintSurface_B := TCustomLockableTexture.Create;
//  g_HintSurface_B.SetSize(SCREENWIDTH - 100, SCREENHEIGHT - 5);
//  g_HintSurface_B.FillRect(g_HintSurface_B.ClientRect, {$IF MIR2EX}Pal_8to16[162]{$ELSE}162{$IFEND MIR2EX});
  g_HintSurface_B := PXL.Providers.TGraphicsDeviceProvider(g_GameDevice.Provider).CreateLockableTexture(g_GameDevice, False);
  g_HintSurface_B.SetSize(SCREENWIDTH - 100, SCREENHEIGHT - 5);
  g_HintSurface_B.PixelFormat := TPixelFormat.A8R8G8B8;


  g_HintSurface_C := PXL.Providers.TGraphicsDeviceProvider(g_GameDevice.Provider).CreateLockableTexture(g_GameDevice, False);
  g_HintSurface_C.SetSize(800, 100);
  g_HintSurface_C.PixelFormat := TPixelFormat.A8R8G8B8;
//  g_HintSurface_C.FillRect(g_HintSurface_C.ClientRect, {$IF MIR2EX}Pal_8to16[152]{$ELSE}152{$IFEND MIR2EX});
//
//  g_HintSurface_Olive := TCustomLockableTexture.Create;
//  g_HintSurface_Olive.SetSize(550, 550);
//  g_HintSurface_Olive.FillRect(g_HintSurface_Olive.ClientRect, Pal_8to16[2]);
//
//  g_HintSurface_Red := TCustomLockableTexture.Create;
//  g_HintSurface_Red.SetSize(550, 550);
//  g_HintSurface_Red.FillRect(g_HintSurface_Red.ClientRect, clOlive);
//
//  g_HintSurface_W := TCustomLockableTexture.Create;
//  g_HintSurface_W.SetSize(SCREENWIDTH, 80);
//  g_HintSurface_W.FillRect(g_HintSurface_W.ClientRect, clWhite);
//
  g_BotSurface := PXL.Providers.TGraphicsDeviceProvider(g_GameDevice.Provider).CreateLockableTexture(g_GameDevice, False);
  g_BotSurface.SetSize(SCREENWIDTH, 252);
  g_BotSurface.PixelFormat := TPixelFormat.A8R8G8B8;
//  g_BotSurface.FillRect(g_BotSurface.ClientRect, $00000000);

end;

procedure TFrmDlg.UnInitGrobalSurface();
begin
//  if Assigned(g_ImgMixSurface) then FreeAndNil(g_ImgMixSurface);
//  if Assigned(g_ImgLargeMixSurface) then FreeAndNil(g_ImgLargeMixSurface);
//  if Assigned(g_MiniMapSurface) then FreeAndNil(g_MiniMapSurface);
  if Assigned(g_DsMiniMapPixel) then FreeAndNil(g_DsMiniMapPixel);
  if Assigned(g_HeathBar_Red) then FreeAndNil(g_HeathBar_Red);
  if Assigned(g_HeathBar_Green) then FreeAndNil(g_HeathBar_Green);
  if Assigned(g_HeathBar_Blue) then FreeAndNil(g_HeathBar_Blue);
  if Assigned(g_HeathBar_Yellow) then FreeAndNil(g_HeathBar_Yellow);
  if Assigned(g_HintSurface_Y) then FreeAndNil(g_HintSurface_Y);
  if Assigned(g_HintSurface_B) then FreeAndNil(g_HintSurface_B);
  if Assigned(g_HintSurface_C) then FreeAndNil(g_HintSurface_C);
  if Assigned(g_HintSurface_Olive) then FreeAndNil(g_HintSurface_Olive);
  if Assigned(g_HintSurface_Red) then FreeAndNil(g_HintSurface_Red);
  if Assigned(g_HintSurface_W) then FreeAndNil(g_HintSurface_W);
  if Assigned(g_BotSurface) then FreeAndNil(g_BotSurface);
end;

procedure TFrmDlg.InitializeNext2();
var
  d: TCustomLockableTexture;
begin
  d := nil;
  if not g_fGetRenderBottom then
    Exit;
  if g_WinBottomType < g_WinBottomRetry - 1 then begin
    if GetTickCount - g_QueryWinBottomTick > 300 then begin
      g_QueryWinBottomTick := GetTickCount;
      Inc(g_WinBottomType);
      if (g_opui.Images[0] <> nil) and (g_opui.Images[01] <> nil) and (g_opui.Images[02] <> nil) and (g_opui.Images[03] <> nil) and
        (g_opui.Images[10] <> nil) and (g_opui.Images[11] <> nil) and (g_opui.Images[12] <> nil) and (g_opui.Images[13] <> nil) and
        (g_opui.Images[14] <> nil) and (g_opui.Images[15] <> nil) and (g_opui.Images[16] <> nil) and (g_opui.Images[17] <> nil) then begin
        g_WinBottomType := g_WinBottomRetry;
        d := g_opui.Images[0];
        DBottom.Left := 0;
        DBottom.Top := SCREENHEIGHT - d.Height;
        DBottom.Width := SCREENWIDTH;
        DBottom.Height := d.Height;
//        BuildBottomWinSurface(g_GameCanvas, False);
      end;
    end;
  end;
end;

procedure TFrmDlg.InitializeNext3();
var
  d: TCustomLockableTexture;
begin
  d := nil;
  if not g_fGetRenderBottom then
    Exit;
  if g_WinBottomType < g_WinBottomRetry - 1 then begin
    if GetTickCount - g_QueryWinBottomTick > 500 then begin
      g_QueryWinBottomTick := GetTickCount;
      Inc(g_WinBottomType);
      if (g_opui.Images[0] <> nil) and (g_opui.Images[01] <> nil) and (g_opui.Images[02] <> nil) and (g_opui.Images[03] <> nil) and
        (g_opui.Images[10] <> nil) and (g_opui.Images[11] <> nil) and (g_opui.Images[12] <> nil) and (g_opui.Images[13] <> nil) and
        (g_opui.Images[14] <> nil) and (g_opui.Images[15] <> nil) and (g_opui.Images[16] <> nil) and (g_opui.Images[17] <> nil) then begin
        g_WinBottomType := g_WinBottomRetry;
        d := g_opui.Images[0];
        DBottom.Left := 0;
        DBottom.Top := SCREENHEIGHT - d.Height;
        DBottom.Width := SCREENWIDTH;
        DBottom.Height := d.Height;
//        BuildBottomWinSurface(True);
      end;
    end;
  end;
end;

procedure TFrmDlg.InitializeNext();
var
  i: Integer;
  Rect: TRect;
  d: TCustomLockableTexture;
  pt: TPoint;
begin
  DBeltWindow.Visible := False;

  DBChat.Visible := False;
  //DBAttackMode.Visible := False;

  d := g_Wui.Images[880];
  DWTI.SetImgIndex(g_Wui, 880);
  DWTI.Left := (SCREENWIDTH - 491) div 2;
  DWTI.Top := (SCREENHEIGHT - 279) div 2;

  DWTI.OnDirectPaint2 := DWTIDirectPaint2;

  DBTIClose.SetImgIndex(g_WMain3Images, 233);
  DBTIClose.Left := 470;
  DBTIClose.Top := 3;

  DBTIpag1.SetImgIndex(g_WMain2Images, 590);
  DBTIpag1.Left := 32;
  DBTIpag1.Top := 164;
  DBTIpag2.SetImgIndex(g_WMain2Images, 590);
  DBTIpag2.Left := 32;
  DBTIpag2.Top := 164 + 23;
  DBTIpag3.SetImgIndex(g_WMain2Images, 590);
  DBTIpag3.Left := 32;
  DBTIpag3.Top := 164 + 23 * 2;
  DBTIpag4.SetImgIndex(g_WMain2Images, 590);
  DBTIpag4.Left := 32;
  DBTIpag4.Top := 164 + 23 * 3;

  DBTIbtn1.SetImgIndex(g_WMain2Images, 590);
  DBTIbtn1.Left := 325;
  DBTIbtn1.Top := 184;
  DBTIbtn1.OnbtnState := tdisable;

  DBTIbtn2.SetImgIndex(g_WMain2Images, 590);
  DBTIbtn2.Left := 325;
  DBTIbtn2.Top := 207;
  DBTIbtn2.OnbtnState := tdisable;

  DBTIItem1.SetImgIndex(g_Wui, 883);
  DBTIItem1.Left := 192;
  DBTIItem1.Top := 188;
  //DBTIItem1.FFloating := True;
  DBTIItem2.SetImgIndex(g_Wui, 883);
  DBTIItem2.Left := 255;
  DBTIItem2.Top := 188;
  //DBTIItem2.FFloating := True;

  //===================
  d := g_Wui.Images[880];
  DWSP.SetImgIndex(g_Wui, 880);
  DWSP.Left := 0;
  DWSP.Top := 0;
  DWSP.OnDirectPaint2 := DWSPDirectPaint2;

  DBSPClose.SetImgIndex(g_WMain3Images, 233);
  DBSPClose.Left := 470;
  DBSPClose.Top := 3;

  DBSPPage1.SetImgIndex(g_WMain2Images, 590);
  DBSPPage1.Left := 32;
  DBSPPage1.Top := 164;
  DBSPPage2.SetImgIndex(g_WMain2Images, 590);
  DBSPPage2.Left := 32;
  DBSPPage2.Top := 164 + 23;
  DBSPPage3.SetImgIndex(g_WMain2Images, 590);
  DBSPPage3.Left := 32;
  DBSPPage3.Top := 164 + 23 * 2;
  DBSPPage4.SetImgIndex(g_WMain2Images, 590);
  DBSPPage4.Left := 32;
  DBSPPage4.Top := 164 + 23 * 3;

  DBSP.SetImgIndex(g_Wui, 885);
  DBSP.Left := 325;
  DBSP.Top := 188;
  //DBSP.btnState := tdisable;

  DBMB1.SetImgIndex(g_WMain2Images, 590);
  DBMB1.Left := 248;
  DBMB1.Top := 187;
  //DBmb1.FFloating := True;

  DBMB2.SetImgIndex(g_WMain2Images, 590);
  DBMB2.Left := 248;
  DBMB2.Top := 212;
  //DBmb2.FFloating := True;

  DBMB3.SetImgIndex(g_WMain2Images, 590);
  DBMB3.Left := 326;
  DBMB3.Top := 187;
  //DBmb3.FFloating := True;

  DBMB4.SetImgIndex(g_WMain2Images, 590);
  DBMB4.Left := 326;
  DBMB4.Top := 212;
  //DBmb4.FFloating := True;

  DBSPItem1.SetImgIndex(g_Wui, 923);
  DBSPItem1.Left := 192;
  DBSPItem1.Top := 188;
  //DBSPItem1.FFloating := True;
  DBSPItem2.SetImgIndex(g_Wui, 925);
  DBSPItem2.Left := 255;
  DBSPItem2.Top := 188;
  //DBSPItem2.FFloating := True;

  DBSPenergy.SetImgIndex(g_Wui, 894);
  DBSPenergy.Left := 185;
  DBSPenergy.Top := 16;
  //DBSPenergy.FFloating := True;
  DBSPLuck.SetImgIndex(g_Wui, 895);
  DBSPLuck.Left := 298;
  DBSPLuck.Top := 16;
  //DBSPluck.FFloating := True;

  d := g_WMainImages.Images[464];
  DWCollectExp.Left := 10;
  DWCollectExp.Top := ((SCREENHEIGHT - 250) - DWCollectExp.Height) div 2;

  DWCollectExp.SetImgIndex(g_WMainImages, 464);
  DBCollectState.Left := 11;
  DBCollectState.Top := 27;
  DBCollectExp.Left := 16;
  DBCollectExp.Top := 62;
  DBCollectIPExp.Left := 27;
  DBCollectIPExp.Top := 62;

  d := g_WMainImages.Images[751];
  DWBuildAcus.SetImgIndex(g_WMainImages, 751);
  DWBuildAcus.Left := SCREENWIDTH - 384 - 80;
  DWBuildAcus.Top := ((SCREENHEIGHT - 250) - DWBuildAcus.Height) div 2;

  DWBuildAcusClose.SetImgIndex(g_WMain2Images, 148);
  DWBuildAcusClose.Left := 363;
  DWBuildAcusClose.Top := 3;

  DBBuildAcusHelp.SetImgIndex(g_WMainImages, 776);
  DBBuildAcusHelp.Left := 15;
  DBBuildAcusHelp.Top := 153;

  DBBuildAcusMaterial.SetImgIndex(g_WMainImages, 774);
  DBBuildAcusMaterial.Left := 15;
  DBBuildAcusMaterial.Top := 179;

  DBBuildAcusStart.SetImgIndex(g_WMainImages, 770);
  DBBuildAcusStart.Left := 15;
  DBBuildAcusStart.Top := 214;

  DBAcus1.SetImgIndex(g_WMainImages, 790);
  DBAcus1.Left := 141;
  DBAcus1.Top := 194;
  DBAcus2.SetImgIndex(g_WMainImages, 790);
  DBAcus2.Left := 187;
  DBAcus2.Top := 194;
  DBAcus3.SetImgIndex(g_WMainImages, 790);
  DBAcus3.Left := 118;
  DBAcus3.Top := 238;
  DBAcus4.SetImgIndex(g_WMainImages, 790);
  DBAcus4.Left := 164;
  DBAcus4.Top := 238;
  DBAcus5.SetImgIndex(g_WMainImages, 790);
  DBAcus5.Left := 210;
  DBAcus5.Top := 238;

  DBCharm1.SetImgIndex(g_WMainImages, 791);
  DBCharm1.Left := 296;
  DBCharm1.Top := 196;
  DBCharm2.SetImgIndex(g_WMainImages, 791);
  DBCharm2.Left := 271;
  DBCharm2.Top := 236;
  DBCharm3.SetImgIndex(g_WMainImages, 791);
  DBCharm3.Left := 320;
  DBCharm3.Top := 236;

  d := g_WMain3Images.Images[298];
  DGameShop.SetImgIndex(g_WMain3Images, 298);
  DGameShop.Left := 0;
  DGameShop.Top := 0;

  DGameShopClose.Left := 606;
  DGameShopClose.Top := 5;
  DGameShopClose.SetImgIndex(g_WMainImages, 64);
  DButtonShop1.Left := 177;
  DButtonShop1.Top := 14;
  DButtonShop1.SetImgIndex(g_WMain3Images, 299);
  DButtonShop2.Left := 177 + 58 * 1;
  DButtonShop2.Top := 14;
  DButtonShop2.SetImgIndex(g_WMain3Images, 299 + 1);
  DButtonShop3.Left := 177 + 58 * 2;
  DButtonShop3.Top := 14;
  DButtonShop3.SetImgIndex(g_WMain3Images, 299 + 1 * 2);
  DButtonShop4.Left := 177 + 58 * 3;
  DButtonShop4.Top := 14;
  DButtonShop4.SetImgIndex(g_WMain3Images, 299 + 1 * 3);
  DButtonShop5.Left := 177 + 58 * 4;
  DButtonShop5.Top := 14;
  DButtonShop5.SetImgIndex(g_WMain3Images, 299 + 1 * 4);
  DButtonShop6.Left := 329;
  DButtonShop6.Top := 365;
  DButtonShop6.SetImgIndex(g_WMain3Images, 304);
  DButtonShop7.Left := 329 + 58 * 1;
  DButtonShop7.Top := 365;
  DButtonShop7.SetImgIndex(g_WMain3Images, 305);
  DButtonShop8.Left := 329 + 58 * 2;
  DButtonShop8.Top := 365;
  DButtonShop8.SetImgIndex(g_WMain3Images, 306);
  DButtonShop9.Left := 197;
  DButtonShop9.Top := 349;
  DButtonShop9.SetImgIndex(g_WMainImages, 388);
  DButtonShop10.Left := 287;
  DButtonShop10.Top := 349;
  DButtonShop10.SetImgIndex(g_WMainImages, 387);

  DGridShop1.Left := 180;
  DGridShop1.Top := 58;
  DGridShop1.Width := 328;
  DGridShop1.Height := 266;

  DGridShop2.Left := 518;
  DGridShop2.Top := 66;
  DGridShop2.Width := 88;
  DGridShop2.Height := 320;

  DButtonShopEffect.Left := 20;
  DButtonShopEffect.Top := 35;

  {-------------------------------------------------------------------------}
{$IFDEF UI_0508}
  {----- DStateWin -----}
  d := g_WMainImages.Images[800];
  DStateWin.SetImgIndex(g_WMainImages, 800);
  DStateWin.Left := SCREENWIDTH - 232;
  DStateWin.Top := 0;

  DBState.SetImgIndex(g_WMainImages, 802, 3, 62);
  DBState2.SetImgIndex(g_WMain2Images, 744, 41, 30);

  DBConRandom.SetImgIndex(g_WMainImages, 901, 82, 97);
  DBTrainVenation.SetImgIndex(g_WMainImages, 814, 42, 259);
  DBConKey.SetImgIndex(g_WMainImages, 901, 140, 97);

  DBV1.SetImgIndex(g_WMainImages, 812, 174, 70);
  DBV2.SetImgIndex(g_WMainImages, 812, 174, 70 + 23);
  DBV3.SetImgIndex(g_WMainImages, 812, 174, 70 + 46);
  DBV4.SetImgIndex(g_WMainImages, 812, 174, 70 + 69);

  DSeMag1.SetImgIndex(g_WMainImages, 903, 56 + 34 * 0, 60);
  DSeMag2.SetImgIndex(g_WMainImages, 903, 56 + 34 * 1, 60);
  DSeMag3.SetImgIndex(g_WMainImages, 903, 56 + 34 * 2, 60);
  DSeMag4.SetImgIndex(g_WMainImages, 903, 56 + 34 * 3, 60);

  DListBoxSSkill.Left := 56 + 34 * 0;
  DListBoxSSkill.Top := 60;
  DListBoxSSkill.SetImgIndex(g_WMainImages, 911);
  DListBoxSSkill.FOnChangeSelect := DListBoxSSkillChangeSelect2;
  DListBoxSSkill.FOnMouseMoveSelect := DListBoxSSkillMouseMove2;
  CheckBox_ShowFashion.SetImgIndex(g_WMain3Images, 488, 122, 393);
  CheckBox_ShowFashion.Width := CheckBox_ShowFashion.Width + 48;

  DStMag0.AdjustPos(62, 131, 40, 40);
  DStMag1.AdjustPos(46, 57, 31, 33);
  DStMag2.AdjustPos(46, 94, 31, 33);
  DStMag3.AdjustPos(46, 132, 31, 33);
  DStMag4.AdjustPos(46, 169, 31, 33);
  DStMag5.AdjustPos(46, 206, 31, 33);
  DStMag6.AdjustPos(46, 243, 31, 33);

  DCloseState.SetImgIndex(g_WMainImages, 371, 8, 39);
  DStPageUp.SetImgIndex(g_WMainImages, 398, 213, 113);
  DStPageDown.SetImgIndex(g_WMainImages, 396, 213, 143);

  DCloseState.OnDirectPaint := DPrevStateDirectPaint;
  DStPageUp.OnDirectPaint := DMsgDlgOkDirectPaint;
  DStPageDown.OnDirectPaint := DMsgDlgOkDirectPaint;

  DSWNecklace.AdjustPos(168, 87, 34, 31);
  DSWHelmet.AdjustPos(115, 93, 18, 18);
  DSWLight.AdjustPos(168, 125, 34, 31);
  DSWArmRingR.AdjustPos(42, 176, 34, 31);
  DSWArmRingL.AdjustPos(168, 176, 34, 31);
  DSWRingR.AdjustPos(42, 215, 34, 31);
  DSWRingL.AdjustPos(168, 215, 34, 31);
  DSWWeapon.AdjustPos(47, 80, 47, 87);
  DSWDress.AdjustPos(96, 122, 53, 112);
  DSWBujuk.AdjustPos(42, 254, 34, 31);
  DSWBelt.AdjustPos(84, 254, 34, 31);
  DSWBoots.AdjustPos(126, 254, 34, 31);
  DSWCharm.AdjustPos(168, 254, 34, 31);
  DSWDrum.AdjustPos(230, 390, 34, 31);
  DSWHorse.AdjustPos(276, 390, 34, 31);

  {----- HStateWin -----}
  d := g_WMainImages.Images[808];
  DHStateWin.SetImgIndex(g_WMainImages, 808, SCREENWIDTH - 232 * 2, 0);

  DBHState.SetImgIndex(g_WMainImages, 802, 3, 62);
  DBHState2.SetImgIndex(g_WMain2Images, 744, 41, 30);

  DBHConRandom.SetImgIndex(g_WMainImages, 901, 82, 97);
  DBHTrainVenation.SetImgIndex(g_WMainImages, 814, 42, 259);

  DBHV1.SetImgIndex(g_WMainImages, 812, 174, 70);
  DBHV2.SetImgIndex(g_WMainImages, 812, 174, 70 + 23);
  DBHV3.SetImgIndex(g_WMainImages, 812, 174, 70 + 46);
  DBHV4.SetImgIndex(g_WMainImages, 812, 174, 70 + 69);

  DHSeMag1.SetImgIndex(g_WMainImages, 903, 56 + 34 * 0, 60);
  DHSeMag2.SetImgIndex(g_WMainImages, 903, 56 + 34 * 1, 60);
  DHSeMag3.SetImgIndex(g_WMainImages, 903, 56 + 34 * 2, 60);
  DHSeMag4.SetImgIndex(g_WMainImages, 903, 56 + 34 * 3, 60);

  DHStMag0.AdjustPos(62, 131, 40, 40);
  DHStMag1.AdjustPos(46, 57, 31, 33);
  DHStMag2.AdjustPos(46, 94, 31, 33);
  DHStMag3.AdjustPos(46, 132, 31, 33);
  DHStMag4.AdjustPos(46, 169, 31, 33);
  DHStMag5.AdjustPos(46, 206, 31, 33);
  DHStMag6.AdjustPos(46, 243, 31, 33);

  DHListBoxSSkill.Left := 56 + 34 * 0;
  DHListBoxSSkill.Top := 60;
  DHListBoxSSkill.SetImgIndex(g_WMainImages, 911);
  DHListBoxSSkill.FOnChangeSelect := DHListBoxSSkillChangeSelect2;
  DHListBoxSSkill.FOnMouseMoveSelect := DHListBoxSSkillMouseMove2;

  CheckBox_hShowFashion.SetImgIndex(g_WMain3Images, 488, 122, 393);
  CheckBox_hShowFashion.Width := CheckBox_hShowFashion.Width + 48;

  DHCloseState.SetImgIndex(g_WMainImages, 371, 8, 39);
  DHStPageUp.SetImgIndex(g_WMainImages, 398, 213, 113);
  DHStPageDown.SetImgIndex(g_WMainImages, 396, 213, 143);

  DHCloseState.OnDirectPaint := DPrevStateDirectPaint;
  DHStPageUp.OnDirectPaint := DMsgDlgOkDirectPaint;
  DHStPageDown.OnDirectPaint := DMsgDlgOkDirectPaint;

  DHSWNecklace.AdjustPos(168, 87, 34, 31);
  DHSWHelmet.AdjustPos(115, 93, 18, 18);
  DHSWLight.AdjustPos(168, 125, 34, 31);
  DHSWArmRingR.AdjustPos(42, 176, 34, 31);
  DHSWArmRingL.AdjustPos(168, 176, 34, 31);
  DHSWRingR.AdjustPos(42, 215, 34, 31);
  DHSWRingL.AdjustPos(168, 215, 34, 31);
  DHSWWeapon.AdjustPos(47, 80, 47, 87);
  DHSWDress.AdjustPos(96, 122, 53, 112);
  DHSWBujuk.AdjustPos(42, 254, 34, 31);
  DHSWBelt.AdjustPos(84, 254, 34, 31);
  DHSWBoots.AdjustPos(126, 254, 34, 31);
  DHSWCharm.AdjustPos(168, 254, 34, 31);
  DHSWDrum.AdjustPos(230, 390, 34, 31);
  DHSWHorse.AdjustPos(276, 390, 34, 31);

  {----- UserState -----}
  d := g_WMainImages.Images[800];
  DUserState1.SetImgIndex(g_WMainImages, 800, SCREENWIDTH - 232, 0);

  DNecklaceUS1.AdjustPos(168, 87, 34, 31);
  DHelmetUS1.AdjustPos(115, 93, 18, 18);
  DLightUS1.AdjustPos(168, 125, 34, 31);
  DArmringRUS1.AdjustPos(42, 176, 34, 31);
  DArmringLUS1.AdjustPos(168, 176, 34, 31);
  DRingRUS1.AdjustPos(42, 215, 34, 31);
  DRingLUS1.AdjustPos(168, 215, 34, 31);
  DWeaponUS1.AdjustPos(47, 80, 47, 87);
  DDressUS1.AdjustPos(96, 122, 53, 112);
  DBujukUS1.AdjustPos(42, 254, 34, 31);
  DBeltUS1.AdjustPos(84, 254, 34, 31);
  DBootsUS1.AdjustPos(126, 254, 34, 31);
  DCharmUS1.AdjustPos(168, 254, 34, 31);
  DDrumUS1.AdjustPos(230, 390, 34, 31);
  DHorseUS1.AdjustPos(276, 390, 34, 31);

  DStMagUS0.Visible := False;
  DStMagUS1.Visible := False;
  DStMagUS2.Visible := False;
  DStMagUS3.Visible := False;
  DStMagUS4.Visible := False;
  DStMagUS5.Visible := False;
  DStMagUS6.Visible := False;

  DCloseUS1.SetImgIndex(g_WMainImages, 371, 8, 39);
  DCloseUS1.OnDirectPaint := DPrevStateDirectPaint;
  //DPageUS1.SetImgIndex(g_Wui, 3262, 7, 123);

  DPageUS1.Visible := False;
{$ELSE}
  {----- DStateWin -----}
  d := g_Wui.Images[3220];
  DStateWin.SetImgIndex(g_Wui, 3220);
  DStateWin.Left := SCREENWIDTH - 340;
  DStateWin.Top := 0;

  DBState.SetImgIndex(g_Wui, 3235, 7, 123);
  DBState2.SetImgIndex(g_Wui, 2245, 51, 97);

  DBConRandom.SetImgIndex(g_WMainImages, 901, 160, 182);
  DBTrainVenation.SetImgIndex(g_WMainImages, 814, 64, 357);
  DBConKey.SetImgIndex(g_WMainImages, 901, 228, 182);

  DBV1.SetImgIndex(g_WMainImages, 812, 253, 70 + 80);
  DBV2.SetImgIndex(g_WMainImages, 812, 253, 70 + 23 + 80);
  DBV3.SetImgIndex(g_WMainImages, 812, 253, 70 + 46 + 80);
  DBV4.SetImgIndex(g_WMainImages, 812, 253, 70 + 69 + 80);

  DSeMag1.SetImgIndex(g_WMainImages, 903, 81 + 55 * 0, 139);
  DSeMag2.SetImgIndex(g_WMainImages, 903, 81 + 55 * 1, 139);
  DSeMag3.SetImgIndex(g_WMainImages, 903, 81 + 55 * 2, 139);
  DSeMag4.SetImgIndex(g_WMainImages, 903, 81 + 55 * 3, 139);

  DListBoxSSkill.Left := 56 + 34 * 0;
  DListBoxSSkill.Top := 60;
  DListBoxSSkill.SetImgIndex(g_WMainImages, 911);
  DListBoxSSkill.FOnChangeSelect := DListBoxSSkillChangeSelect2;
  DListBoxSSkill.FOnMouseMoveSelect := DListBoxSSkillMouseMove2;
  CheckBox_ShowFashion.SetImgIndex(g_WMain3Images, 488, 122, 393);
  CheckBox_ShowFashion.Width := CheckBox_ShowFashion.Width + 48;

  DStMag0.AdjustPos(62, 131, 40, 40);
  DStMag1.AdjustPos(52, 139, 31, 33);
  DStMag2.AdjustPos(52, 185, 31, 33);
  DStMag3.AdjustPos(52, 231, 31, 33);
  DStMag4.AdjustPos(52, 277, 31, 33);
  DStMag5.AdjustPos(52, 323, 31, 33);
  DStMag6.AdjustPos(52, 369, 31, 33);

  DCloseState.SetImgIndex(g_WMain2Images, 148, 315, 59);
  DStPageUp.SetImgIndex(g_Wui, 3042, 220, 409);
  DStPageDown.SetImgIndex(g_Wui, 3039, 282, 409);

  DSWNecklace.AdjustPos(281, 262, 34, 31);
  DSWHelmet.AdjustPos(169, 206, 18, 18);
  DSWLight.AdjustPos(39, 262, 34, 31);
  DSWArmRingR.AdjustPos(39, 305, 34, 31);
  DSWArmRingL.AdjustPos(282, 305, 34, 31);
  DSWRingR.AdjustPos(39, 348, 34, 31);
  DSWRingL.AdjustPos(281, 348, 34, 31);
  DSWWeapon.AdjustPos(100, 170, 47, 87);
  DSWDress.AdjustPos(152, 231, 53, 112);
  DSWBujuk.AdjustPos(47, 390, 34, 31);
  DSWBelt.AdjustPos(92, 390, 34, 31);
  DSWBoots.AdjustPos(139, 390, 34, 31);
  DSWCharm.AdjustPos(185, 390, 34, 31);
  DSWDrum.AdjustPos(230, 390, 34, 31);
  DSWHorse.AdjustPos(276, 390, 34, 31);

  {----- HStateWin -----}
  d := g_Wui.Images[3220];
  DHStateWin.SetImgIndex(g_Wui, 3285);
  DHStateWin.Left := SCREENWIDTH - 340;
  DHStateWin.Top := 0;

  DBHState.SetImgIndex(g_Wui, 3235, 7, 123 - 2);
  DBHState2.SetImgIndex(g_Wui, 2245, 51, 97 - 2);

  DBHConRandom.SetImgIndex(g_WMainImages, 901, 160, 182 - 2);
  DBHTrainVenation.SetImgIndex(g_WMainImages, 814, 64, 357 - 2);

  DBHV1.SetImgIndex(g_WMainImages, 812, 253, 70 + 80 - 2);
  DBHV2.SetImgIndex(g_WMainImages, 812, 253, 70 + 23 + 80 - 2);
  DBHV3.SetImgIndex(g_WMainImages, 812, 253, 70 + 46 + 80 - 2);
  DBHV4.SetImgIndex(g_WMainImages, 812, 253, 70 + 69 + 80 - 2);

  DHSeMag1.SetImgIndex(g_WMainImages, 903, 81 + 55 * 0, 139 - 2);
  DHSeMag2.SetImgIndex(g_WMainImages, 903, 81 + 55 * 1, 139 - 2);
  DHSeMag3.SetImgIndex(g_WMainImages, 903, 81 + 55 * 2, 139 - 2);
  DHSeMag4.SetImgIndex(g_WMainImages, 903, 81 + 55 * 3, 139 - 2);

  DHListBoxSSkill.Left := 56 + 34 * 0;
  DHListBoxSSkill.Top := 60;
  DHListBoxSSkill.SetImgIndex(g_WMainImages, 911);
  DHListBoxSSkill.FOnChangeSelect := DHListBoxSSkillChangeSelect2;
  DHListBoxSSkill.FOnMouseMoveSelect := DHListBoxSSkillMouseMove2;

  DHSWNecklace.AdjustPos(281, 262 - 2, 34, 31);
  DHSWHelmet.AdjustPos(169, 206 - 2, 18, 18);
  DHSWLight.AdjustPos(39, 262 - 2, 34, 31);
  DHSWArmRingR.AdjustPos(39, 305 - 2, 34, 31);
  DHSWArmRingL.AdjustPos(282, 305 - 2, 34, 31);
  DHSWRingR.AdjustPos(39, 348 - 2, 34, 31);
  DHSWRingL.AdjustPos(281, 348 - 2, 34, 31);
  DHSWWeapon.AdjustPos(100, 170 - 2, 47, 87);
  DHSWDress.AdjustPos(152, 231 - 2, 53, 112);
  DHSWBujuk.AdjustPos(47, 390 - 2, 34, 31);
  DHSWBelt.AdjustPos(92, 390 - 2, 34, 31);
  DHSWBoots.AdjustPos(139, 390 - 2, 34, 31);
  DHSWCharm.AdjustPos(185, 390 - 2, 34, 31);
  DHSWDrum.AdjustPos(230, 390 - 2, 34, 31);
  DHSWHorse.AdjustPos(276, 390 - 2, 34, 31);

  DHStPageUp.SetImgIndex(g_Wui, 3042, 220, 409 - 2);
  DHStPageDown.SetImgIndex(g_Wui, 3039, 282, 409 - 2);
  DHCloseState.SetImgIndex(g_WMain2Images, 148, 315, 68);

  CheckBox_hShowFashion.SetImgIndex(g_WMain3Images, 488, 122, 393);
  CheckBox_hShowFashion.Width := CheckBox_hShowFashion.Width + 48;

  DHStMag0.AdjustPos(62, 131 - 2, 40, 40);
  DHStMag1.AdjustPos(52, 139 - 2, 31, 33);
  DHStMag2.AdjustPos(52, 185 - 2, 31, 33);
  DHStMag3.AdjustPos(52, 231 - 2, 31, 33);
  DHStMag4.AdjustPos(52, 277 - 2, 31, 33);
  DHStMag5.AdjustPos(52, 323 - 2, 31, 33);
  DHStMag6.AdjustPos(52, 369 - 2, 31, 33);

  {----- UserState -----}
  d := g_Wui.Images[3220];
  DUserState1.SetImgIndex(g_Wui, 3220, SCREENWIDTH - 340, 0);

  DNecklaceUS1.AdjustPos(281, 262, 34, 31);
  DHelmetUS1.AdjustPos(169, 206, 18, 18);
  DLightUS1.AdjustPos(39, 262, 34, 31);
  DArmringRUS1.AdjustPos(39, 305, 34, 31);
  DArmringLUS1.AdjustPos(282, 305, 34, 31);
  DRingRUS1.AdjustPos(39, 348, 34, 31);
  DRingLUS1.AdjustPos(281, 348, 34, 31);
  DWeaponUS1.AdjustPos(100, 170, 47, 87);
  DDressUS1.AdjustPos(152, 231, 53, 112);
  DBujukUS1.AdjustPos(47, 390, 34, 31);
  DBeltUS1.AdjustPos(92, 390, 34, 31);
  DBootsUS1.AdjustPos(139, 390, 34, 31);
  DCharmUS1.AdjustPos(185, 390, 34, 31);
  DDrumUS1.AdjustPos(230, 390, 34, 31);
  DHorseUS1.AdjustPos(276, 390, 34, 31);

  DStMagUS0.AdjustPos(62, 131, 40, 40);
  DStMagUS1.AdjustPos(44, 197, 31, 33);
  DStMagUS2.AdjustPos(44, 234, 31, 33);
  DStMagUS3.AdjustPos(44, 275, 31, 33);
  DStMagUS4.AdjustPos(44, 314, 31, 33);
  DStMagUS5.AdjustPos(44, 353, 31, 33);
  DStMagUS6.AdjustPos(44, 392, 31, 33);

  DCloseUS1.SetImgIndex(g_WMain2Images, 148, 315, 59);
  DPageUS1.SetImgIndex(g_Wui, 3262, 7, 123);
{$ENDIF}

  {----- DItemBag -----}
  DItemBag.SetImgIndex(g_WMain2Images, 180);
  DItemBag.Left := 0;
  DItemBag.Top := 60;

  DItemGrid.Left := 29;
  DItemGrid.Top := 41;
  DItemGrid.Width := 286;
  DItemGrid.Height := 162;
  DItemGrid.FRightClick := True;

  DGold.SetImgIndex(g_WMainImages, 29);
  DGold.Left := 18;
  DGold.Top := 218;

  DBGameGold.SetImgIndex(g_WMain2Images, 182);
  DBGameGold.Left := 218;
  DBGameGold.Top := 207;
  //DBGameGold.FFloating := True;

  DRefineItem.SetImgIndex(g_WMain2Images, 183);
  DRefineItem.Left := 299;
  DRefineItem.Top := 212;
  DRefineItem.Width := 32;
  DRefineItem.Height := 32;

  DRefurbishItem.SetImgIndex(g_WMainImages, 1614);
  DRefurbishItem.Left := 238;
  DRefurbishItem.Top := 260;

  DCloseBag.SetImgIndex(g_WMainImages, 371);
  DCloseBag.Left := 336;
  DCloseBag.Top := 59;
  DCloseBag.Width := 14;
  DCloseBag.Height := 20;

  DCloseHeroBag.SetImgIndex(g_WMainImages, 371);
  DCloseHeroBag.Left := 208;
  DCloseHeroBag.Top := 0;

  DHeroItemGrid.Left := 17;
  DHeroItemGrid.Top := 14;
  DHeroItemGrid.Width := 5 * 36;
  DHeroItemGrid.Height := 2 * 32;
  DHeroItemGrid.FRightClick := True;

  DHeroItemBag.SetImgIndex(g_WMain3Images, 375);
  DHeroItemBag.Left := 28;
  DHeroItemBag.Top := 100;
  //DHeroItemBag.FRightClick := True;

  d := g_WMain3Images.Images[462];
  DWRefine.SetImgIndex(g_WMain3Images, 462);
  DWRefine.Left := SCREENWIDTH div 4;
  DWRefine.Top := (SCREENHEIGHT - 212) div 2;

  DBRefineOK.SetImgIndex(g_WMain3Images, 463);
  DBRefineOK.Left := 90;
  DBRefineOK.Top := 175;
  DBRefineClose.SetImgIndex(g_WMainImages, 64);
  DBRefineClose.Left := 231;
  DBRefineClose.Top := 0;
  DBRefineItem1.Left := 110;
  DBRefineItem1.Top := 41;
  DBRefineItem2.Left := 49;
  DBRefineItem2.Top := 118;
  DBRefineItem3.Left := 49 + 121;
  DBRefineItem3.Top := 119;

  if (g_opui.Images[0] <> nil) and (g_opui.Images[01] <> nil) and (g_opui.Images[02] <> nil) and (g_opui.Images[03] <> nil) and
    (g_opui.Images[10] <> nil) and (g_opui.Images[11] <> nil) and (g_opui.Images[12] <> nil) and (g_opui.Images[13] <> nil) and
    (g_opui.Images[14] <> nil) and (g_opui.Images[15] <> nil) and (g_opui.Images[16] <> nil) and (g_opui.Images[17] <> nil) then begin
    g_WinBottomType := g_WinBottomRetry;
    d := g_opui.Images[0];
    DBottom.Left := 0;
    DBottom.Top := SCREENHEIGHT - d.Height;
    DBottom.Width := SCREENWIDTH;
    DBottom.Height := d.Height;
//    BuildBottomWinSurface();
  end else begin
    g_WinBottomType := 0;
    d := g_WMain3Images.Images[BOTTOMBOARD800];
    if d <> nil then begin
      DBottom.SetImgIndex(g_WMain3Images, BOTTOMBOARD800);
      DBottom.Left := 0;
      DBottom.Top := SCREENHEIGHT - d.Height;
      DBottom.Width := d.Width;
      DBottom.Height := d.Height;
      DBottom.FRightClick := True;
    end else begin
      DBottom.SetImgIndex(g_WMain3Images, BOTTOMBOARD800);
      DBottom.Left := 0;
      DBottom.Top := SCREENHEIGHT - 251;
      DBottom.Width := 800;
      DBottom.Height := 251;
      DBottom.FRightClick := True;
    end;
  end;

  DBHeroEnergy.Left := -30;
  DBHeroEnergy.Top := 7;

  DBHideChat.Visible := False;

  DBRefuseSay.SetImgIndex(g_WMain3Images, 280);
  DBRefuseSay.Left := 176;
  DBRefuseSay.Top := 120;
  DBRefuseSay.tag := 0;

  DBRefuseCry.SetImgIndex(g_WMain3Images, 282);
  DBRefuseCry.Left := 176;
  DBRefuseCry.Top := 120 + 22;
  DBRefuseCry.tag := 0;

  DBRefuseWhisper.SetImgIndex(g_WMain3Images, 284);
  DBRefuseWhisper.Left := 176;
  DBRefuseWhisper.Top := 120 + 22 * 2;
  DBRefuseWhisper.tag := 0;

  DBRefuseGuild.SetImgIndex(g_WMain3Images, 286);
  DBRefuseGuild.Left := 176;
  DBRefuseGuild.Top := 120 + 22 * 3;
  DBRefuseGuild.tag := 0;

  DBAotoSay.SetImgIndex(g_WMain3Images, 288);
  DBAotoSay.Left := 176;
  DBAotoSay.Top := 120 + 22 * 4;
  DBAotoSay.tag := 1;

  DBCommand.SetImgIndex(g_WMain3Images, 284);
  DBCommand.Left := 176;
  DBCommand.Top := 120 + 22 * 5;
  DBCommand.tag := 0;

  DBotGuild.SetImgIndex(g_WMainImages, DlgConf.DBotGuild.Image {134});
  DBotGuild.Left := DlgConf.DBotGuild.Left {219 + 30*2};
  DBotGuild.Top := DlgConf.DBotGuild.Top {104};

  DBotGroup.SetImgIndex(g_WMainImages, DlgConf.DBotGroup.Image {128});
  DBotGroup.Left := DlgConf.DBotGroup.Left {219 + 30*3};
  DBotGroup.Top := DlgConf.DBotGroup.Top {104};
  DBotGroup.FRightClick := True;

  DBotPlusAbil.SetImgIndex(g_WMainImages, DlgConf.DBotPlusAbil.Image {140});
  DBotPlusAbil.Left := DlgConf.DBotPlusAbil.Left {219 + 30*4};
  DBotPlusAbil.Top := DlgConf.DBotPlusAbil.Top {104};

  DBotFriend.SetImgIndex(g_WMain3Images, DlgConf.DBotFriend.Image {530});
  DBotFriend.Left := DlgConf.DBotFriend.Left {219 + 30*5};
  DBotFriend.Top := DlgConf.DBotFriend.Top {104};

  DBotDare.SetImgIndex(g_WMain3Images, DlgConf.DBotDare.Image {530});
  DBotDare.Left := DlgConf.DBotDare.Left {219 + 30*5};
  DBotDare.Top := DlgConf.DBotDare.Top {104};

  DBotLevelRank.SetImgIndex(g_WMain3Images, DlgConf.DBotLevelRank.Image {530});
  DBotLevelRank.Left := DlgConf.DBotLevelRank.Left {219 + 30*5};
  DBotLevelRank.Top := DlgConf.DBotLevelRank.Top {104};

//  DBotStore.SetImgIndex(g_bui, 4);
  DBotStore.SetImgIndex(g_opui, g_StallBot0);
  DBotStore.Left := DlgConf.DBotLevelRank.Left + 30;
  DBotStore.Top := DlgConf.DBotLevelRank.Top;

  DBotExit.SetImgIndex(g_WMainImages, 138);
  DBotExit.Left := SCREENWIDTH div 2 + (SCREENWIDTH div 2 - (400 - 160));
  DBotExit.Top := 104;
  DBotLogout.SetImgIndex(g_WMainImages, 136);
  DBotLogout.Left := SCREENWIDTH div 2 + (SCREENWIDTH div 2 - (400 - 160)) - 30;
  DBotLogout.Top := 104;

  DMyState.SetImgIndex(g_WMainImages, 8);
  DMyState.Left := SCREENWIDTH div 2 + (SCREENWIDTH div 2 - (400 - 243)) {643};
  DMyState.Top := 62;
  DMyBag.SetImgIndex(g_WMainImages, 9);
  DMyBag.Left := SCREENWIDTH div 2 + (SCREENWIDTH div 2 - (400 - 282)) {682};
  DMyBag.Top := 42;
  DMyMagic.SetImgIndex(g_WMainImages, 10);
  DMyMagic.Left := SCREENWIDTH div 2 + (SCREENWIDTH div 2 - (400 - 322)) {722};
  DMyMagic.Top := 22;
  DOption.SetImgIndex(g_WMainImages, 11);
  DOption.Left := SCREENWIDTH div 2 + (SCREENWIDTH div 2 - (400 - 364)) {764};
  DOption.Top := 12;
  DButtonShop.SetImgIndex(g_WMain3Images, 297);
  DButtonShop.Left := SCREENWIDTH - 47;
  DButtonShop.Top := 203;

  DBAttackMode.CaptionEx := '';
  DBAttackMode.AdjustPos(SCREENWIDTH - 162, 126, 79, 14);
  DBAttackMode.Visible := True;
  //DBAttackMode.FFloating := true;

  DBMissionOpen.SetImgIndex(g_WMainImages, 283);
  DBMissionOpen.Left := SCREENWIDTH - 200 + 1;
  DBMissionOpen.Top := 64;

  //Hero
  DButtonRecallHero.SetImgIndex(g_WMain3Images, 372);
  DButtonRecallHero.Left := SCREENWIDTH - 162;
  DButtonRecallHero.Top := 109;
  DButtonHeroState.SetImgIndex(g_WMain3Images, 373);
  DButtonHeroState.Left := DButtonRecallHero.Left + DButtonRecallHero.Width + 6;
  DButtonHeroState.Top := 108;
  DButtonHeroBag.SetImgIndex(g_WMain3Images, 374);
  DButtonHeroBag.Left := DButtonHeroState.Left + DButtonHeroState.Width + 6 + 1;
  DButtonHeroBag.Top := 108;

  //DBHeroEnergy.SetImgIndex(g_WMain3Images, 410);
  DBHeroEnergy.Left := SCREENWIDTH - 197;
  DBHeroEnergy.Top := 86;

  DBHeroGlory.Left := SCREENWIDTH - 79;
  DBHeroGlory.Top := 152;

  DBRefuseSay.SetImgIndex(g_WMain3Images, 280);
  DBRefuseSay.Left := 176;
  DBRefuseSay.Top := 120;
  DBRefuseSay.tag := 0;

  DBRefuseCry.SetImgIndex(g_WMain3Images, 282);
  DBRefuseCry.Left := 176;
  DBRefuseCry.Top := 120 + 22;
  DBRefuseCry.tag := 0;

  DBRefuseWhisper.SetImgIndex(g_WMain3Images, 284);
  DBRefuseWhisper.Left := 176;
  DBRefuseWhisper.Top := 120 + 22 * 2;
  DBRefuseWhisper.tag := 0;

  DBRefuseGuild.SetImgIndex(g_WMain3Images, 286);
  DBRefuseGuild.Left := 176;
  DBRefuseGuild.Top := 120 + 22 * 3;
  DBRefuseGuild.tag := 0;

  DBAotoSay.SetImgIndex(g_WMain3Images, 288);
  DBAotoSay.Left := 176;
  DBAotoSay.Top := 120 + 22 * 4;
  DBAotoSay.tag := 1;

  DBCommand.SetImgIndex(g_WMain3Images, 284);
  DBCommand.Left := 176;
  DBCommand.Top := 120 + 22 * 5;
  DBCommand.tag := 0;

  DBotMiniMap.SetImgIndex(g_WMainImages, DlgConf.DBotMiniMap.Image {130});
  DBotMiniMap.Left := DlgConf.DBotMiniMap.Left {219};
  DBotMiniMap.Top := DlgConf.DBotMiniMap.Top {104};
  DBotMiniMap.OnDirectPaint := DBotGroupDirectPaint;

  DBotTrade.SetImgIndex(g_WMainImages, DlgConf.DBotTrade.Image {132});
  DBotTrade.Left := DlgConf.DBotTrade.Left {219 + 30}; //560 - 30;
  DBotTrade.Top := DlgConf.DBotTrade.Top {104};
  DBotTrade.OnDirectPaint := DBotGroupDirectPaint;

  DBotGuild.SetImgIndex(g_WMainImages, DlgConf.DBotGuild.Image {134});
  DBotGuild.Left := DlgConf.DBotGuild.Left {219 + 30*2};
  DBotGuild.Top := DlgConf.DBotGuild.Top {104};
  DBotGroup.SetImgIndex(g_WMainImages, DlgConf.DBotGroup.Image {128});
  DBotGroup.Left := DlgConf.DBotGroup.Left {219 + 30*3};
  DBotGroup.Top := DlgConf.DBotGroup.Top {104};

  DBotPlusAbil.SetImgIndex(g_WMainImages, DlgConf.DBotPlusAbil.Image {140});
  DBotPlusAbil.Left := DlgConf.DBotPlusAbil.Left {219 + 30*4};
  DBotPlusAbil.Top := DlgConf.DBotPlusAbil.Top {104};

  DBotFriend.SetImgIndex(g_WMain3Images, DlgConf.DBotFriend.Image {530});
  DBotFriend.Left := DlgConf.DBotFriend.Left {219 + 30*5};
  DBotFriend.Top := DlgConf.DBotFriend.Top {104};

  DBotDare.SetImgIndex(g_WMain3Images, DlgConf.DBotDare.Image {530});
  DBotDare.Left := DlgConf.DBotDare.Left {219 + 30*5};
  DBotDare.Top := DlgConf.DBotDare.Top {104};

  DBotLevelRank.SetImgIndex(g_WMain3Images, DlgConf.DBotLevelRank.Image {530});
  DBotLevelRank.Left := DlgConf.DBotLevelRank.Left {219 + 30*5};
  DBotLevelRank.Top := DlgConf.DBotLevelRank.Top {104};

  DBotExit.SetImgIndex(g_WMainImages, 138);
  DBotExit.Left := SCREENWIDTH div 2 + (SCREENWIDTH div 2 - (400 - 160));
  DBotExit.Top := 104;
  DBotLogout.SetImgIndex(g_WMainImages, 136);
  DBotLogout.Left := SCREENWIDTH div 2 + (SCREENWIDTH div 2 - (400 - 160)) - 30;
  DBotLogout.Top := 104;

  {//$IF SWH = SWH800}
  DBelt1.Left := SCREENWIDTH div 2 - 115; //285;
  DBelt1.Width := 32;
  DBelt1.Top := 59;
  DBelt1.Height := 29;

  DBelt2.Left := DBelt1.Left + 43; //328;
  DBelt2.Width := 32;
  DBelt2.Top := 59;
  DBelt2.Height := 29;

  DBelt3.Left := DBelt2.Left + 43; //371;
  DBelt3.Width := 32;
  DBelt3.Top := 59;
  DBelt3.Height := 29;

  DBelt4.Left := DBelt3.Left + 43; //415;
  DBelt4.Width := 32;
  DBelt4.Top := 59;
  DBelt4.Height := 29;

  DBelt5.Left := DBelt4.Left + 43; //459;
  DBelt5.Width := 32;
  DBelt5.Top := 59;
  DBelt5.Height := 29;

  DBelt6.Left := DBelt5.Left + 43; //503;
  DBelt6.Width := 32;
  DBelt6.Top := 59;
  DBelt6.Height := 29;

  d := g_WMainImages.Images[384];
  DMerchantDlg.Left := 0;
  DMerchantDlg.Top := 0;
  DMerchantDlg.SetImgIndex(g_WMainImages, 384);

  DMerchantDlgClose.Left := 399;
  DMerchantDlgClose.Top := 1;
  DMerchantDlgClose.SetImgIndex(g_WMainImages, 64);
  DMerchantDlgClose.OnDirectPaint := DConfigDlgCloseDirectPaint;

  d := g_WMainImages.Images[385];
  DMenuDlg.Left := 138;
  DMenuDlg.Top := 163;
  DMenuDlg.SetImgIndex(g_WMainImages, 385);

  DMenuPrev.Left := 43;
  DMenuPrev.Top := 175;
  DMenuPrev.SetImgIndex(g_WMainImages, 388);
  DMenuNext.Left := 90;
  DMenuNext.Top := 175;
  DMenuNext.SetImgIndex(g_WMainImages, 387);
  DMenuBuy.Left := 215;
  DMenuBuy.Top := 171;
  DMenuBuy.SetImgIndex(g_WMainImages, 386);
  DMenuClose.Left := 291;
  DMenuClose.Top := 0;
  DMenuClose.SetImgIndex(g_WMainImages, 64);

  d := g_WMainImages.Images[392];
  DSellDlg.Left := 328;
  DSellDlg.Top := 163;
  DSellDlg.SetImgIndex(g_WMainImages, 392);

  DSellDlgOk.Left := 85;
  DSellDlgOk.Top := 150;
  DSellDlgOk.SetImgIndex(g_WMainImages, 393);
  DSellDlgClose.Left := 115;
  DSellDlgClose.Top := 0;
  DSellDlgClose.SetImgIndex(g_WMainImages, 64);
  DSellDlgSpot.Left := 27;
  DSellDlgSpot.Top := 67;
  DSellDlgSpot.Width := 61;
  DSellDlgSpot.Height := 52;

  d := g_WMain3Images.Images[126];
  DKeySelDlg.SetImgIndex(g_WMain3Images, 126);
  DKeySelDlg.Left := (SCREENWIDTH - 376) div 2;
  DKeySelDlg.Top := (SCREENHEIGHT - 179 - 250) div 2;

  DKsIcon.Left := 51;
  DKsIcon.Top := 31;
  DKsF1.SetImgIndex(g_WMainImages, 232);
  DKsF1.Left := 25;
  DKsF1.Top := 78;
  DKsF2.SetImgIndex(g_WMainImages, 234);
  DKsF2.Left := 57;
  DKsF2.Top := 78;
  DKsF3.SetImgIndex(g_WMainImages, 236);
  DKsF3.Left := 89;
  DKsF3.Top := 78;
  DKsF4.SetImgIndex(g_WMainImages, 238);
  DKsF4.Left := 121;
  DKsF4.Top := 78;
  DKsF5.SetImgIndex(g_WMainImages, 240);
  DKsF5.Left := 160;
  DKsF5.Top := 78;
  DKsF6.SetImgIndex(g_WMainImages, 242);
  DKsF6.Left := 192;
  DKsF6.Top := 78;
  DKsF7.SetImgIndex(g_WMainImages, 244);
  DKsF7.Left := 224;
  DKsF7.Top := 78;
  DKsF8.SetImgIndex(g_WMainImages, 246);
  DKsF8.Left := 256;
  DKsF8.Top := 78;

  DKsConF1.SetImgIndex(g_WMain3Images, 132 + 2 * 0);
  DKsConF1.Left := 25;
  DKsConF1.Top := 120;
  DKsConF2.SetImgIndex(g_WMain3Images, 132 + 2 * 1);
  DKsConF2.Left := 57;
  DKsConF2.Top := 120;
  DKsConF3.SetImgIndex(g_WMain3Images, 132 + 2 * 2);
  DKsConF3.Left := 89;
  DKsConF3.Top := 120;
  DKsConF4.SetImgIndex(g_WMain3Images, 132 + 2 * 3);
  DKsConF4.Left := 121;
  DKsConF4.Top := 120;
  DKsConF5.SetImgIndex(g_WMain3Images, 132 + 2 * 4);
  DKsConF5.Left := 160;
  DKsConF5.Top := 120;
  DKsConF6.SetImgIndex(g_WMain3Images, 132 + 2 * 5);
  DKsConF6.Left := 192;
  DKsConF6.Top := 120;
  DKsConF7.SetImgIndex(g_WMain3Images, 132 + 2 * 6);
  DKsConF7.Left := 224;
  DKsConF7.Top := 120;
  DKsConF8.SetImgIndex(g_WMain3Images, 132 + 2 * 7);
  DKsConF8.Left := 256;
  DKsConF8.Top := 120;
  DKsOk.SetImgIndex(g_WMain3Images, 127);
  DKsOk.Left := 296;
  DKsOk.Top := 120;
  DKsNone.SetImgIndex(g_WMain3Images, 129);
  DKsNone.Left := 296;
  DKsNone.Top := 78;

  d := g_WMainImages.Images[120];
  DGroupDlg.Left := (SCREENWIDTH - 276) div 2;
  DGroupDlg.Top := (SCREENHEIGHT - 242) div 2;
  DGroupDlg.SetImgIndex(g_WMainImages, 120);

  DGrpDlgClose.SetImgIndex(g_WMainImages, 64);
  DGrpDlgClose.Left := 260;
  DGrpDlgClose.Top := 0;
  DGrpAllowGroup.SetImgIndex(g_WMainImages, 122);
  DGrpAllowGroup.Left := 20;
  DGrpAllowGroup.Top := 18;
  DGrpCreate.SetImgIndex(g_WMainImages, 123);
  DGrpCreate.Left := 21 + 1;
  DGrpCreate.Top := 202 + 1;
  DGrpAddMem.SetImgIndex(g_WMainImages, 124);
  DGrpAddMem.Left := 96 + 1;
  DGrpAddMem.Top := 202 + 1;
  DGrpDelMem.SetImgIndex(g_WMainImages, 125);
  DGrpDelMem.Left := 171 + 1;
  DGrpDelMem.Top := 202 + 1;

  d := g_WMainImages.Images[389];
  DDealDlg.Left := SCREENWIDTH - 236;
  DDealDlg.Top := 0;
  DDealDlg.SetImgIndex(g_WMainImages, 389);

  DDGrid.Left := 21;
  DDGrid.Top := 56;
  DDGrid.Width := 36 * 5;
  DDGrid.Height := 33 * 2;
  DDealOk.SetImgIndex(g_WMainImages, 391);
  DDealOk.Left := 155;
  DDealOk.Top := 193 - 65;
  DDealClose.SetImgIndex(g_WMainImages, 64);
  DDealClose.Left := 220;
  DDealClose.Top := 42;
  DDGold.SetImgIndex(g_WMainImages, 28);
  DDGold.Left := 11;
  DDGold.Top := 202 - 65;

  d := g_WMainImages.Images[390];
  DDealRemoteDlg.Left := DDealDlg.Left - 220;
  DDealRemoteDlg.Top := 0;
  DDealRemoteDlg.SetImgIndex(g_WMainImages, 390);

  DDRGrid.Left := 21;
  DDRGrid.Top := 56;
  DDRGrid.Width := 36 * 5;
  DDRGrid.Height := 33 * 2;
  DDRGold.SetImgIndex(g_WMainImages, 28);
  DDRGold.Left := 11;
  DDRGold.Top := 202 - 65;

  d := g_WMainImages.Images[180];
  DGuildDlg.Left := 0;
  DGuildDlg.Top := 0;
  DGuildDlg.SetImgIndex(g_WMainImages, 180);

  DGDClose.Left := 584;
  DGDClose.Top := 6;
  DGDClose.SetImgIndex(g_WMainImages, 64);
  DGDHome.Left := 13;
  DGDHome.Top := 411;
  DGDHome.SetImgIndex(g_WMainImages, 198);
  DGDList.Left := 13;
  DGDList.Top := 429;
  DGDList.SetImgIndex(g_WMainImages, 200);
  DGDChat.Left := 94;
  DGDChat.Top := 429;
  DGDChat.SetImgIndex(g_WMainImages, 190);
  DGDAddMem.Left := 243;
  DGDAddMem.Top := 411;
  DGDAddMem.SetImgIndex(g_WMainImages, 182);
  DGDDelMem.Left := 243;
  DGDDelMem.Top := 429;
  DGDDelMem.SetImgIndex(g_WMainImages, 192);
  DGDEditNotice.Left := 325;
  DGDEditNotice.Top := 411;
  DGDEditNotice.SetImgIndex(g_WMainImages, 196);
  DGDEditGrade.Left := 325;
  DGDEditGrade.Top := 429;
  DGDEditGrade.SetImgIndex(g_WMainImages, 194);
  DGDAlly.Left := 407;
  DGDAlly.Top := 411;
  DGDAlly.SetImgIndex(g_WMainImages, 184);
  DGDBreakAlly.Left := 407;
  DGDBreakAlly.Top := 429;
  DGDBreakAlly.SetImgIndex(g_WMainImages, 186);
  DGDWar.Left := 529;
  DGDWar.Top := 411;
  DGDWar.SetImgIndex(g_WMainImages, 202);
  DGDCancelWar.Left := 529;
  DGDCancelWar.Top := 429;
  DGDCancelWar.SetImgIndex(g_WMainImages, 188);

  DGDUp.Left := 595;
  DGDUp.Top := 239;
  DGDUp.SetImgIndex(g_WMainImages, 373);
  DGDDown.Left := 595;
  DGDDown.Top := 291;
  DGDDown.SetImgIndex(g_WMainImages, 372);

  DGuildEditNotice.SetImgIndex(g_WMainImages, 204);
  DGEOk.SetImgIndex(g_WMainImages, 361);
  DGEOk.Left := 514;
  DGEOk.Top := 287;
  DGEClose.SetImgIndex(g_WMainImages, 64);
  DGEClose.Left := 584;
  DGEClose.Top := 6;

  DAdjustAbility.SetImgIndex(g_WMainImages, 226);
  DAdjustAbilClose.SetImgIndex(g_WMainImages, 64);
  DAdjustAbilClose.Left := 316;
  DAdjustAbilClose.Top := 1;
  DAdjustAbilOk.SetImgIndex(g_WMainImages, 224);
  DAdjustAbilOk.Left := 220;
  DAdjustAbilOk.Top := 298;

  DPlusDC.SetImgIndex(g_WMainImages, 212);
  DPlusDC.Left := 217;
  DPlusDC.Top := 101;
  DPlusMC.SetImgIndex(g_WMainImages, 212);
  DPlusMC.Left := 217;
  DPlusMC.Top := 121;
  DPlusSC.SetImgIndex(g_WMainImages, 212);
  DPlusSC.Left := 217;
  DPlusSC.Top := 140;
  DPlusAC.SetImgIndex(g_WMainImages, 212);
  DPlusAC.Left := 217;
  DPlusAC.Top := 160;
  DPlusMAC.SetImgIndex(g_WMainImages, 212);
  DPlusMAC.Left := 217;
  DPlusMAC.Top := 181;
  DPlusHP.SetImgIndex(g_WMainImages, 212);
  DPlusHP.Left := 217;
  DPlusHP.Top := 201;
  DPlusMP.SetImgIndex(g_WMainImages, 212);
  DPlusMP.Left := 217;
  DPlusMP.Top := 220;
  DPlusHit.SetImgIndex(g_WMainImages, 212);
  DPlusHit.Left := 217;
  DPlusHit.Top := 240;
  DPlusSpeed.SetImgIndex(g_WMainImages, 212);
  DPlusSpeed.Left := 217;
  DPlusSpeed.Top := 261;

  DMinusDC.SetImgIndex(g_WMainImages, 214);
  DMinusDC.Left := 237;
  DMinusDC.Top := 101;
  DMinusMC.SetImgIndex(g_WMainImages, 214);
  DMinusMC.Left := 237;
  DMinusMC.Top := 121;
  DMinusSC.SetImgIndex(g_WMainImages, 214);
  DMinusSC.Left := 237;
  DMinusSC.Top := 140;
  DMinusAC.SetImgIndex(g_WMainImages, 214);
  DMinusAC.Left := 237;
  DMinusAC.Top := 160;
  DMinusMAC.SetImgIndex(g_WMainImages, 214);
  DMinusMAC.Left := 237;
  DMinusMAC.Top := 181;
  DMinusHP.SetImgIndex(g_WMainImages, 214);
  DMinusHP.Left := 237;
  DMinusHP.Top := 201;
  DMinusMP.SetImgIndex(g_WMainImages, 214);
  DMinusMP.Left := 237;
  DMinusMP.Top := 220;
  DMinusHit.SetImgIndex(g_WMainImages, 214);
  DMinusHit.Left := 237;
  DMinusHit.Top := 240;
  DMinusSpeed.SetImgIndex(g_WMainImages, 214);
  DMinusSpeed.Left := 237;
  DMinusSpeed.Top := 261;

  d := g_WMain3Images.Images[475];
  DFriendDlg.SetImgIndex(g_WMain3Images, 475);
  DFriendDlg.Left := 160;
  DFriendDlg.Top := 120;

  DFrdClose.SetImgIndex(g_WMainImages, 64);
  DFrdClose.Left := 194;
  DFrdClose.Top := 2;

  DFrdPgUp.SetImgIndex(g_WMainImages, 396);
  DFrdPgUp.Left := 166;
  DFrdPgUp.Top := 142;
  DFrdPgDn.SetImgIndex(g_WMainImages, 398);
  DFrdPgDn.Left := 166;
  DFrdPgDn.Top := 90;

  DFrdFriend.SetImgIndex(g_WMain3Images, 481);
  DFrdFriend.Left := 17;
  DFrdFriend.Top := 20;
  DFrdMaster.SetImgIndex(g_WMain3Images, 482);
  DFrdMaster.Left := 63;
  DFrdMaster.Top := 20;
  DFrdBlackList.SetImgIndex(g_WMain3Images, 483);
  DFrdBlackList.Left := 109;
  DFrdBlackList.Top := 20;

  DFrdAdd.SetImgIndex(g_WMain3Images, 485);
  DFrdAdd.Left := $1F;
  DFrdAdd.Top := $E7;
  DFrdDel.SetImgIndex(g_WMain3Images, 484);
  DFrdDel.Left := $61;
  DFrdDel.Top := $E7;

  DFrdMemo.SetImgIndex(g_WMain3Images, 478);
  DFrdMemo.Left := $9;
  DFrdMemo.Top := $26;

  DBDetectBox.Left := 1;
  DBDetectBox.Top := 55;
  //DBDetectBox.SetImgIndex(g_WMainImages, 265);
  DBDetectBox.Width := 33;
  DBDetectBox.Height := 30;
  //DBDetectBox.FFloating := true;

  DButtonHP.Left := 40;
  DButtonHP.Top := 91;
  DButtonHP.Width := 45;
  DButtonHP.Height := 90;

  DButtonMP.Left := 40 + 47;
  DButtonMP.Top := 91;
  DButtonMP.Width := 45;
  DButtonMP.Height := 90;

  DBVigour.Left := 40 + 22;
  DBVigour.Top := 91;
  DBVigour.Width := 45;
  DBVigour.Height := 90;

  d := g_opui.Images[g_sHeroStatusWindow];
  DWHeroStatus.SetImgIndex(g_opui, g_sHeroStatusWindow);
  DWHeroStatus.Left := 0;
  DWHeroStatus.Top := 0;

  d := g_opui.Images[g_sGameConfigBackGround];
  DWGameConfig.SetImgIndex(g_opui, g_sGameConfigBackGround);
  DWGameConfig.Left := (SCREENWIDTH - 416) div 2;
  DWGameConfig.Top := (SCREENHEIGHT - 261) div 2;
  //DWGameConfig.FRightClick := True;

  DMBVolume.SetImgIndex(g_WMain2Images, 297);
  DMBVolume.Left := 35 + 120 * 2 + 12 * 4 + 2;
  DMBVolume.tag := DMBVolume.Left;
  DMBVolume.TypeRLeft := DMBVolume.Left;
  DMBVolume.TypeRTop := 70 + 24 * 2 + 2;
  DMBVolume.Top := DMBVolume.TypeRTop;
  DMBVolume.SlotLen := 64 + 4;
  DMBVolume.Max := 64 + 4;

  DMBHitSpeed.SetImgIndex(g_WMain2Images, 297);
  DMBHitSpeed.Left := 35;
  DMBHitSpeed.tag := 35;
  DMBHitSpeed.TypeRLeft := 35;
  DMBHitSpeed.Top := 220;
  DMBHitSpeed.SlotLen := 64 + 4;
  DMBHitSpeed.Max := 64 + 4;

  DxEditHitSpeed.Top := DMBHitSpeed.Top + 1;
  DxEditHitSpeed.Left := DMBHitSpeed.Left + 72;
  DxEditHitSpeed.Height := 16;

  DMBMagSpeed.SetImgIndex(g_WMain2Images, 297);
  DMBMagSpeed.Left := 35 + 120;
  DMBMagSpeed.tag := DMBMagSpeed.Left;
  DMBMagSpeed.TypeRLeft := 35 + 120;
  DMBMagSpeed.Top := 220;
  DMBMagSpeed.SlotLen := 64 + 4;
  DMBMagSpeed.Max := 64 + 4;
  DxEditMagSpeed.Top := DMBMagSpeed.Top + 1;
  DxEditMagSpeed.Left := DMBMagSpeed.Left + 72;
  DxEditMagSpeed.Height := 16;

  DMBMoveSpeed.SetImgIndex(g_WMain2Images, 297);
  DMBMoveSpeed.Left := 35 + 120 * 2;
  DMBMoveSpeed.tag := DMBMoveSpeed.Left;
  DMBMoveSpeed.TypeRLeft := 35 + 120 * 2;
  DMBMoveSpeed.Top := 220;
  DMBMoveSpeed.SlotLen := 64 + 4;
  DMBMoveSpeed.Max := 64 + 4;
  DxEditMoveSpeed.Top := DMBMoveSpeed.Top + 1;
  DxEditMoveSpeed.Left := DMBMoveSpeed.Left + 72;
  DxEditMoveSpeed.Height := 16;

  //DBGCClose.SetImgIndex(g_WMain2Images, 279);
  DBGCClose.SetImgIndex(g_opui, g_sGameConfigClose1);
  DBGCClose.Left := 394;
  DBGCClose.Top := 1;

  DxEditExpFilter.Width := g_ptGeneral[3].Right - g_ptGeneral[3].Left - 4;
  DxEditExpFilter.Height := g_ptGeneral[3].Bottom - g_ptGeneral[3].Top;

  DxEditRenewHPPercent.Width := 30;
  DxEditRenewHPPercent.Height := 16;
  DxEditRenewMPPercent.Width := 30;
  DxEditRenewMPPercent.Height := 16;
  DxEditRenewSpecialPercent.Width := 30;
  DxEditRenewSpecialPercent.Height := 16;

  DxEditRenewHPPercentHero.Width := 30;
  DxEditRenewHPPercentHero.Height := 16;
  DxEditRenewMPPercentHero.Width := 30;
  DxEditRenewMPPercentHero.Height := 16;
  DxEditRenewSpecialPercentHero.Width := 30;
  DxEditRenewSpecialPercentHero.Height := 16;
  DxEditPerHeroSidestep.Width := 30;
  DxEditPerHeroSidestep.Height := 16;

  DxEditRenewBookPercent.Width := 30;
  DxEditRenewBookPercent.Height := 16;

  DxEditRenewHPTime.Width := 40;
  DxEditRenewHPTime.Height := 16;
  DxEditRenewMPTime.Width := 40;
  DxEditRenewMPTime.Height := 16;
  DxEditRenewSpecialTime.Width := 40;
  DxEditRenewSpecialTime.Height := 16;
  DxEditRenewHPTimeHero.Width := 40;
  DxEditRenewHPTimeHero.Height := 16;
  DxEditRenewMPTimeHero.Width := 40;
  DxEditRenewMPTimeHero.Height := 16;
  DxEditRenewSpecialTimeHero.Width := 40;
  DxEditRenewSpecialTimeHero.Height := 16;

  DxEditRenewBookTime.Width := 40;
  DxEditRenewBookTime.Height := 16;

  DxEditPractice.Width := 20;
  DxEditPractice.Height := 16;

  DLBRenewBookNowBook.Items.Clear;
  for i := Low(g_sRenewBooks) to High(g_sRenewBooks) do
    if g_sRenewBooks[i] <> '' then
      DLBRenewBookNowBook.Items.Add(g_sRenewBooks[i]);
  //DLBRenewBookNowBook.SetImgIndex(g_WMainImages, 911);
  DLBRenewBookNowBook.Width := 80 + 4;
  DLBRenewBookNowBook.Height := 15 * DLBRenewBookNowBook.Items.Count + 1;

  DCBRenewBookNowBook.Width := 80;
  DCBRenewBookNowBook.Height := 16;
  DCBRenewBookNowBook.Caption := DLBRenewBookNowBook.Items[0];
  g_gnProtectPercent[6] := 0;

  DLBPractice.Width := 100;

  DCBPractice.Width := 100 - 4;
  DCBPractice.Height := 16;
  DCBPractice.Caption := '';

  DEHeroCallHeroPre.Width := 100;
  DEHeroCallHeroPre.Height := 16;
  DEHeroCallHeroPre.Caption := '';
  DEHeroSetTargetPre.Width := 100;
  DEHeroSetTargetPre.Height := 16;
  DEHeroSetTargetPre.Caption := 'Ctrl+W';
  DEHeroUnionHitPre.Width := 100;
  DEHeroUnionHitPre.Height := 16;
  DEHeroUnionHitPre.Caption := 'Ctrl+S';
  DEHeroSetAttackStatePre.Width := 100;
  DEHeroSetAttackStatePre.Height := 16;
  DEHeroSetAttackStatePre.Caption := 'Ctrl+E';
  DEHeroSetGuardPre.Width := 100;
  DEHeroSetGuardPre.Height := 16;
  DEHeroSetGuardPre.Caption := 'Ctrl+Q';
  DESwitchAttackModePre.Width := 100;
  DESwitchAttackModePre.Height := 16;
  DESwitchAttackModePre.Caption := 'Ctrl+H';
  DESwitchMiniMapPre.Width := 100;
  DESwitchMiniMapPre.Height := 16;
  DESwitchMiniMapPre.Caption := 'Ctrl+M';
  DxEditSSkillPre.Width := 100;
  DxEditSSkillPre.Height := 16;
  DxEditSSkillPre.Caption := 'Ctrl+D';

  DEHeroCallHero.Width := 100;
  DEHeroCallHero.Height := 16;
  DEHeroCallHero.Caption := '';
  DEHeroSetTarget.Width := 100;
  DEHeroSetTarget.Height := 16;
  DEHeroSetTarget.Caption := '';
  DEHeroUnionHit.Width := 100;
  DEHeroUnionHit.Height := 16;
  DEHeroUnionHit.Caption := '';
  DEHeroSetAttackState.Width := 100;
  DEHeroSetAttackState.Height := 16;
  DEHeroSetAttackState.Caption := '';
  DEHeroSetGuard.Width := 100;
  DEHeroSetGuard.Height := 16;
  DEHeroSetGuard.Caption := '';
  DESwitchAttackMode.Width := 100;
  DESwitchAttackMode.Height := 16;
  DESwitchAttackMode.Caption := '';
  DESwitchMiniMap.Width := 100;
  DESwitchMiniMap.Height := 16;
  DESwitchMiniMap.Caption := '';
  DxEditSSkill.Width := 100;
  DxEditSSkill.Height := 16;
  DxEditSSkill.Caption := '';

  DBGCActivePage1.SetImgIndex(g_opui, g_sGameConfigPage1);
//  DBGCActivePage1.SetImgIndex(g_WMain2Images, 608);
  DBGCActivePage1.Left := 10 + 48 * 0;
  DBGCActivePage1.Top := 15;
  DBGCActivePage1.PageActive := True;
  DBGCActivePage2.SetImgIndex(g_opui, g_sGameConfigPage1);
//  DBGCActivePage2.SetImgIndex(g_WMain2Images, 608);
  DBGCActivePage2.Left := 10 + 48 * 1;
  DBGCActivePage2.Top := 15;
  DBGCActivePage3.SetImgIndex(g_opui, g_sGameConfigPage1);
//  DBGCActivePage3.SetImgIndex(g_WMain2Images, 608);
  DBGCActivePage3.Left := 10 + 48 * 2;
  DBGCActivePage3.Top := 15;
  DBGCActivePage4.SetImgIndex(g_opui, g_sGameConfigPage1);
//  DBGCActivePage4.SetImgIndex(g_WMain2Images, 608);
  DBGCActivePage4.Left := 10 + 48 * 3;
  DBGCActivePage4.Top := 15;
  DBGCActivePage5.SetImgIndex(g_opui, g_sGameConfigPage1);
//  DBGCActivePage5.SetImgIndex(g_WMain2Images, 608);
  DBGCActivePage5.Left := 10 + 48 * 4;
  DBGCActivePage5.Top := 15;
  DBGCActivePage6.SetImgIndex(g_opui, g_sGameConfigPage1);
//  DBGCActivePage6.SetImgIndex(g_WMain2Images, 608);
  DBGCActivePage6.Left := 10 + 48 * 5;
  DBGCActivePage6.Top := 15;
  DBGCActivePage7.SetImgIndex(g_opui, g_sGameConfigPage1);
//  DBGCActivePage7.SetImgIndex(g_WMain2Images, 608);
  DBGCActivePage7.Left := 10 + 48 * 6;
  DBGCActivePage7.Top := 15;

  DCBPractice.Left := g_ptTec[8].Left + 4;
  DCBPractice.Top := g_ptTec[8].Top + 4;
  DLBPractice.Left := g_ptTec[8].Left;
  DLBPractice.Top := g_ptTec[8].Top + 4 + 16;
  DxEditPractice.Left := g_ptTec[7].Left + 80;
  DxEditPractice.Top := g_ptTec[7].Top + 4;

  DEHeroCallHeroPre.Left := g_ptHotkey[1].Left + 95;
  DEHeroCallHeroPre.Top := g_ptHotkey[1].Top;
  DEHeroCallHero.Left := g_ptHotkey[1].Left + 205;
  DEHeroCallHero.Top := g_ptHotkey[1].Top;

  DEHeroSetTargetPre.Left := g_ptHotkey[2].Left + 95;
  DEHeroSetTargetPre.Top := g_ptHotkey[2].Top;
  DEHeroSetTarget.Left := g_ptHotkey[2].Left + 205;
  DEHeroSetTarget.Top := g_ptHotkey[2].Top;

  DEHeroUnionHit.Left := g_ptHotkey[3].Left + 205;
  DEHeroUnionHit.Top := g_ptHotkey[3].Top;
  DEHeroUnionHitPre.Left := g_ptHotkey[3].Left + 95;
  DEHeroUnionHitPre.Top := g_ptHotkey[3].Top;

  DEHeroSetAttackStatePre.Left := g_ptHotkey[4].Left + 95;
  DEHeroSetAttackStatePre.Top := g_ptHotkey[4].Top;
  DEHeroSetAttackState.Left := g_ptHotkey[4].Left + 205;
  DEHeroSetAttackState.Top := g_ptHotkey[4].Top;

  DEHeroSetGuardPre.Left := g_ptHotkey[5].Left + 95;
  DEHeroSetGuardPre.Top := g_ptHotkey[5].Top;
  DEHeroSetGuard.Left := g_ptHotkey[5].Left + 205;
  DEHeroSetGuard.Top := g_ptHotkey[5].Top;

  DESwitchAttackModePre.Left := g_ptHotkey[6].Left + 95;
  DESwitchAttackModePre.Top := g_ptHotkey[6].Top;
  DESwitchAttackMode.Left := g_ptHotkey[6].Left + 205;
  DESwitchAttackMode.Top := g_ptHotkey[6].Top;

  DESwitchMiniMapPre.Left := g_ptHotkey[7].Left + 95;
  DESwitchMiniMapPre.Top := g_ptHotkey[7].Top;
  DESwitchMiniMap.Left := g_ptHotkey[7].Left + 205;
  DESwitchMiniMap.Top := g_ptHotkey[7].Top;

  DxEditSSkillPre.Left := g_ptHotkey[8].Left + 95;
  DxEditSSkillPre.Top := g_ptHotkey[8].Top;
  DxEditSSkill.Left := g_ptHotkey[8].Left + 205;
  DxEditSSkill.Top := g_ptHotkey[8].Top;

  DxEditExpFilter.Left := g_ptGeneral[3].Left + 4;
  DxEditExpFilter.Top := g_ptGeneral[3].Top + 24;

  DxEditRenewHPPercent.Left := g_ptProtect[0].Left + 60;
  DxEditRenewHPPercent.Top := g_ptProtect[0].Top + 4;
  DxEditRenewHPTime.Left := g_ptProtect[0].Left + 100;
  DxEditRenewHPTime.Top := g_ptProtect[0].Top + 4;
  DxEditRenewHPPercentHero.Left := g_ptProtect[7].Left + 60;
  DxEditRenewHPPercentHero.Top := g_ptProtect[7].Top + 4;
  DxEditRenewHPTimeHero.Left := g_ptProtect[7].Left + 100;
  DxEditRenewHPTimeHero.Top := g_ptProtect[7].Top + 4;
  DxEditRenewMPPercent.Left := g_ptProtect[1].Left + 60;
  DxEditRenewMPPercent.Top := g_ptProtect[1].Top + 4;
  DxEditRenewMPTime.Left := g_ptProtect[1].Left + 100;
  DxEditRenewMPTime.Top := g_ptProtect[1].Top + 4;
  DxEditRenewMPPercentHero.Left := g_ptProtect[8].Left + 60;
  DxEditRenewMPPercentHero.Top := g_ptProtect[8].Top + 4;
  DxEditRenewMPTimeHero.Left := g_ptProtect[8].Left + 100;
  DxEditRenewMPTimeHero.Top := g_ptProtect[8].Top + 4;
  DxEditRenewSpecialPercent.Left := g_ptProtect[3].Left + 60;
  DxEditRenewSpecialPercent.Top := g_ptProtect[3].Top + 4;
  DxEditRenewSpecialTime.Left := g_ptProtect[3].Left + 100;
  DxEditRenewSpecialTime.Top := g_ptProtect[3].Top + 4;
  DxEditRenewSpecialPercentHero.Left := g_ptProtect[9].Left + 60;
  DxEditRenewSpecialPercentHero.Top := g_ptProtect[9].Top + 4;
  DxEditRenewSpecialTimeHero.Left := g_ptProtect[9].Left + 100;
  DxEditRenewSpecialTimeHero.Top := g_ptProtect[9].Top + 4;
  DxEditPerHeroSidestep.Left := g_ptProtect[10].Left + 60;
  DxEditPerHeroSidestep.Top := g_ptProtect[10].Top + 4;
  DxEditRenewBookPercent.Left := g_ptProtect[5].Left + 60;
  DxEditRenewBookPercent.Top := g_ptProtect[5].Top + 4;
  DxEditRenewBookTime.Left := g_ptProtect[5].Left + 100;
  DxEditRenewBookTime.Top := g_ptProtect[5].Top + 4;

  DCBRenewBookNowBook.Left := g_ptProtect[6].Left + 60;
  DCBRenewBookNowBook.Top := g_ptProtect[6].Top + 4;
  DLBRenewBookNowBook.Left := g_ptProtect[6].Left + 60 - 4;
  DLBRenewBookNowBook.Top := g_ptProtect[6].Top + 4 + 16;

  DBMiniMap.Left := 200 - 6;
  DBMiniMap.Top := 59 - 19;
  DBMiniMap.Width := 200;
  DBMiniMap.Height := 200;
  DBMiniMap.FRightClick := True;

  /////////////////////
  DListBox_Hero.Items.Clear;
  DListBox_Hero.Width := 285 + 4;
  DListBox_Hero.Height := 15 * DListBox_Hero.Items.Count + 1;

  DComboBox_Hero.Width := 285;
  DComboBox_Hero.Height := 17;
  DComboBox_Hero.Caption := '';

  DListBox_Hero.Left := 45 + 60 - 4;
  DListBox_Hero.Top := 45 + 4 + 16;

  DComboBox_Hero.Left := 45 + 60;
  DComboBox_Hero.Top := 45 + 4;

  /////////////
  DListBox_Items.Items.Clear;
  DListBox_Items.Items.Add('所有分类');
  DListBox_Items.Items.Add('服装类');
  DListBox_Items.Items.Add('武器类');
  DListBox_Items.Items.Add('首饰类');
  DListBox_Items.Items.Add('药品类');
  DListBox_Items.Items.Add('其他类');

  DListBox_Items.Width := 80 + 4;
  DListBox_Items.Height := 15 * DListBox_Items.Items.Count + 1;
  DListBox_Items.FOnChangeSelect := DListBox_ItemsOnChangeSelect;

  DComboBox_Items.Width := 80;
  DComboBox_Items.Height := 16;
  DComboBox_Items.Caption := '';

  DListBox_Items.Left := g_ptItems0[7].Left - 4;
  DListBox_Items.Top := g_ptItems0[7].Top + 20 + 6 + 16;

  DComboBox_Items.Left := g_ptItems0[7].Left;
  DComboBox_Items.Top := g_ptItems0[7].Top + 20 + 6;
  DComboBox_Items.Caption := DListBox_Items.Items[0];

  ///
  DxEdit_Items.Width := 100;
  DxEdit_Items.Height := 16;
  DxEdit_Items.Left := g_ptItems0[7].Left + 90;
  DxEdit_Items.Top := g_ptItems0[7].Top + 20 + 6;
  DxEdit_Items.m_InputHint := '输入物品名字查找';

  DxEdit_Items.OnTextChanged := DxEdit_Items_Search_OnTextChanged;

  DBIUP.SetImgIndex(g_WMain2Images, 292);
  DBIUP.Left := 384;
  DBIUP.Top := 38;
  DBIDown.SetImgIndex(g_WMain2Images, 294);
  DBIDown.Left := 384;
  DBIDown.Top := 227;
  //DBIDown.FFloating := true;

  DMoveButton_items.SetImgIndex(g_WMain2Images, 581);
  DMoveButton_items.Left := 384;
  DMoveButton_items.tag := DMoveButton_items.Left;
  DMoveButton_items.TypeRLeft := DMoveButton_items.Left;

  DMoveButton_items.Top := 38 + DBIUP.Height - 1;
  DMoveButton_items.TypeRTop := DMoveButton_items.Top;

  DMoveButton_items.SlotLen := 175;
  DMoveButton_items.Max := 300;
  DMoveButton_items.LeftToRight := False;

  d := g_WMainImages.Images[280];
  DWMissions.SetImgIndex(g_WMainImages, 280);
  DWMissions.Left := SCREENWIDTH - 328;
  DWMissions.Top := 0;

  DBMissionsClose.SetImgIndex(g_WMainImages, 64);
  DBMissionsClose.Left := 308;
  DBMissionsClose.Top := 4;

  DBMUP1.SetImgIndex(g_WMain2Images, 292);
  DBMUP1.Left := 288;
  DBMUP1.Top := 140;
  DBMDown1.SetImgIndex(g_WMain2Images, 294);
  DBMDown1.Left := 288;
  DBMDown1.Top := 160;

  DBMUP2.SetImgIndex(g_WMain2Images, 292);
  DBMUP2.Left := 288;
  DBMUP2.Top := 305;
  DBMDown2.SetImgIndex(g_WMain2Images, 294);
  DBMDown2.Left := 288;
  DBMDown2.Top := 305 + 20;

  DBMS1.SetImgIndex(g_WMainImages, 286);
  DBMS1.Left := 20 + 56 * 0;
  DBMS1.Top := 40;
  DBMS1.PageActive := True;

  DBMS2.SetImgIndex(g_WMainImages, 286);
  DBMS2.Left := 20 + 56 * 1;
  DBMS2.Top := 40;

  DBMS3.SetImgIndex(g_WMainImages, 286);
  DBMS3.Left := 20 + 56 * 2;
  DBMS3.Top := 40;

  DBMS4.SetImgIndex(g_WMainImages, 286);
  DBMS4.Left := 20 + 56 * 3;
  DBMS4.Top := 40;

  DEYBDealCharName.Left := 93;
  DEYBDealCharName.Top := 114;
  DEYBDealCount.Left := 93;
  DEYBDealCount.Top := 144;

  d := g_WMain3Images.Images[420];
  DWRank.SetImgIndex(g_WMain3Images, 420);
  DWRank.Left := (SCREENWIDTH - 344) div 2;
  DWRank.Top := (SCREENHEIGHT - 419 - 120) div 2;

  DBLRHunam.SetImgIndex(g_WMain3Images, 443);
  DBLRHunam.Left := 30 + 95 * 0;
  DBLRHunam.Top := 60;
  DBLRHunam.PageActive := True;
  DBLRHero.SetImgIndex(g_WMain3Images, 444);
  DBLRHero.Left := 30 + 94 * 1;
  DBLRHero.Top := 60;
  DBLRMaster.SetImgIndex(g_WMain3Images, 445);
  DBLRMaster.Left := 30 + 95 * 2;
  DBLRMaster.Top := 60;

  DBLRAll.SetImgIndex(g_WMain3Images, 427);
  DBLRWarr.SetImgIndex(g_WMain3Images, 431);
  DBLRWizard.SetImgIndex(g_WMain3Images, 433);
  DBLRTaos.SetImgIndex(g_WMain3Images, 435);
  DBLRAll.Left := 90;
  DBLRAll.Top := 15 + 100;
  DBLRWarr.Left := 90;
  DBLRWarr.Top := 15 + 150;
  DBLRWizard.Left := 90;
  DBLRWizard.Top := 15 + 200;
  DBLRTaos.Left := 90;
  DBLRTaos.Top := 15 + 250;

  DBLRClose.SetImgIndex(g_WMainImages, 371);
  DBLRClose.Left := 325;
  DBLRClose.Top := 47;

  DBLRFirst.SetImgIndex(g_WMain3Images, 450);
  DBLRFirst.Left := 23 + 25 * 0;
  DBLRFirst.Top := 345;
  DBLRPrior.SetImgIndex(g_WMain3Images, 452);
  DBLRPrior.Left := 23 + 56;
  DBLRPrior.Top := 345;
  DBLRNext.SetImgIndex(g_WMain3Images, 454);
  DBLRNext.Left := 23 + 56 + 52;
  DBLRNext.Top := 345;
  DBLRLast.SetImgIndex(g_WMain3Images, 456);
  DBLRLast.Left := 23 + 56 + 52 * 2;
  DBLRLast.Top := 345;
  DBLRMyRank.SetImgIndex(g_WMain3Images, 458);
  DBLRMyRank.Left := 23 + 56 + 52 * 3;
  DBLRMyRank.Top := 345;

  d := g_opui.Images[g_sBookBkgnd];
  DWBookBkgnd.Left := (SCREENWIDTH - 528) div 2;
  DWBookBkgnd.Top := (SCREENHEIGHT - 371 - 200) div 2;

  d := g_WMain3Images.Images[510];
  DWBoxBKGnd.SetImgIndex(g_WMain3Images, 510);
  DWBoxBKGnd.Left := SCREENWIDTH div 2 - 152;
  DWBoxBKGnd.Top := SCREENHEIGHT - 250 - 260;

  DBRareItem1.Left := 80 - 50;
  DBRareItem1.Top := 26;
  DBRareItem1.Width := 34;
  DBRareItem1.Height := 31;
  DBRareItem1.SetImgIndex(g_WMain3Images, 514);

  DBRareItem2.Left := 80 + 50 - 50;
  DBRareItem2.Top := 26;
  DBRareItem2.Width := 34;
  DBRareItem2.Height := 31;
  DBRareItem2.SetImgIndex(g_WMain3Images, 514);

  DBRareItem3.Left := 80 + 50 * 2 - 50;
  DBRareItem3.Top := 26;
  DBRareItem3.Width := 34;
  DBRareItem3.Height := 31;
  DBRareItem3.SetImgIndex(g_WMain3Images, 514);

  DBRareItem4.Left := 80 + 50 * 2 - 50;
  DBRareItem4.Top := 26 + 50 * 1;
  DBRareItem4.Width := 34;
  DBRareItem4.Height := 31;
  DBRareItem4.SetImgIndex(g_WMain3Images, 514);

  DBRareItem5.Left := 80 + 50 * 2 - 50;
  DBRareItem5.Top := 26 + 50 * 2;
  DBRareItem5.Width := 34;
  DBRareItem5.Height := 31;
  DBRareItem5.SetImgIndex(g_WMain3Images, 514);

  DBRareItem6.Left := 80 + 50 * 1 - 50;
  DBRareItem6.Top := 26 + 50 * 2;
  DBRareItem6.Width := 34;
  DBRareItem6.Height := 31;
  DBRareItem6.SetImgIndex(g_WMain3Images, 514);

  DBRareItem7.Left := 80 + 50 * 0 - 50;
  DBRareItem7.Top := 26 + 50 * 2;
  DBRareItem7.Width := 34;
  DBRareItem7.Height := 31;
  DBRareItem7.SetImgIndex(g_WMain3Images, 514);

  DBRareItem8.Left := 80 + 50 * 0 - 50;
  DBRareItem8.Top := 26 + 50 * 1;
  DBRareItem8.Width := 34;
  DBRareItem8.Height := 31;
  DBRareItem8.SetImgIndex(g_WMain3Images, 514);

  DBRareItem9.Left := 80 + 50 * 1 - 5 - 50;
  DBRareItem9.Top := 26 + 50 * 1 - 5;
  DBRareItem9.Width := 34;
  DBRareItem9.Height := 31;
  DBRareItem9.SetImgIndex(g_WMain3Images, 513);

  DBFlashRareBox.Left := 80 + 50 * 1 - 3 - 50;
  DBFlashRareBox.Top := 25 + 50 * 3;
  DBFlashRareBox.Width := 34;
  DBFlashRareBox.Height := 31;

  DBFlashRareBox.SetImgIndex(g_WMain3Images, 511);

  g_RareBoxWindow := TRareBoxWindow.Create(DWBoxBKGnd.Left, DWBoxBKGnd.Top);

  /////////////////////////////////////////////////////////////////////
  d := g_WMain3Images.Images[176];
  DItemMarketDlg.Left := 0;
  DItemMarketDlg.Top := 176;
  DItemMarketDlg.SetImgIndex(g_WMain3Images, 176);

  DEditItemFind.Width := 132;
  DEditItemFind.Height := 16;
  DEditItemFind.Left := 15;
  DEditItemFind.Top := 331;

  DItemListPrev.Left := 216;
  DItemListPrev.Top := 389 - 34;
  DItemListPrev.SetImgIndex(g_WMainImages, 388);
  DItemListNext.Left := 303;
  DItemListNext.Top := 389 - 34;
  DItemListNext.SetImgIndex(g_WMainImages, 387);
  DItemListRefresh.Left := 259;
  DItemListRefresh.Top := 388 - 32;
  DItemListRefresh.SetImgIndex(g_WMain3Images, 177);

  DItemBuy.Left := 346 - 16;
  DItemBuy.Top := 353 - 27;
  DItemBuy.SetImgIndex(g_WMain3Images, 178);

  DItemSellCancel.Left := 346 - 16;
  DItemSellCancel.Top := 353 - 27;
  DItemSellCancel.SetImgIndex(g_WMain3Images, 197);

  DItemCancel.Left := 415 - 18;
  DItemCancel.Top := 353 - 27;
  DItemCancel.SetImgIndex(g_WMain3Images, 180);

  DItemFind.Left := 180 - 35;
  DItemFind.Top := 353 - 27;
  DItemFind.SetImgIndex(g_WMain3Images, 182);

  DMarketMemo.Left := 316 - 16;
  DMarketMemo.Top := 353 - 27;
  DMarketMemo.SetImgIndex(g_WMain3Images, 187);

  DItemMarketClose.Left := 491 - 45;
  DItemMarketClose.Top := 6;
  DItemMarketClose.SetImgIndex(g_WMainImages, 64);

  d := g_WMain3Images.Images[209];
  DWYBDealDlg.Left := SCREENWIDTH - 208 - 30;
  DWYBDealDlg.Top := 0;
  DWYBDealDlg.SetImgIndex(g_WMain3Images, 209);

  DBYBDealDlgClose.Left := 190;
  DBYBDealDlgClose.Top := 2;
  DBYBDealDlgClose.SetImgIndex(g_WMainImages, 64);

  DBYBDealOK.Left := 87;
  DBYBDealOK.Top := 173;
  DBYBDealOK.SetImgIndex(g_WMain3Images, 210);

  DBYBDealCalcel.Left := 148;
  DBYBDealCalcel.Top := 173;
  DBYBDealCalcel.SetImgIndex(g_WMain3Images, 212);

  DEYBDealCharName.Width := 132;
  DEYBDealCharName.Height := 18;
  DEYBDealCount.Width := 132;
  DEYBDealCount.Height := 18;

  DGridYBDeal.Left := 15;
  DGridYBDeal.Top := 29;
  DGridYBDeal.Width := 36 * 5;
  DGridYBDeal.Height := 33 * 2;

  d := g_WMain3Images.Images[277];
  DWYbDealItems.Left := 0;
  DWYbDealItems.Top := 176;
  DWYbDealItems.SetImgIndex(g_WMain3Images, 277);

  DBYbBuyItems.Left := 35;
  DBYbBuyItems.Top := 182;
  DBYbBuyItems.SetImgIndex(g_WMain3Images, 247);

  DBYbBuyCancel.Left := 35 + 80;
  DBYbBuyCancel.Top := 182;
  DBYbBuyCancel.SetImgIndex(g_WMain3Images, 249);

  DBYbCalcelSell.Left := 35 + 160;
  DBYbCalcelSell.Top := 182;
  DBYbCalcelSell.SetImgIndex(g_WMain3Images, 251);

  DBYbDealItemsClose.Left := 291;
  DBYbDealItemsClose.Top := 0;
  DBYbDealItemsClose.SetImgIndex(g_WMainImages, 64);

  DWHint1.Left := 300;
  DWHint1.Top := 200;
  FillChar(m_HintStrs, SizeOf(m_HintStrs), 0);
  m_HintStrs.Strs := TList.Create;

  DBHint1Close.CaptionEx := 'X';
  DBHint1Close.FFloating := False;
  DBHint1Close.Top := 2;
  DBHint1Close.Left := 1;
  DBHint1Close.Width := 8;
  DBHint1Close.Height := 10;

  //d := g_bui.Images[0];
  d := g_opui.Images[g_WStall];
  DWHeroStore.SetImgIndex(g_opui, g_WStall);
  DWHeroStore.Left := 100;
  DWHeroStore.Top := 160;

  DWUserStall.SetImgIndex(g_opui, g_WStall);
  DWUserStall.Left := 100;
  DWUserStall.Top := 280;

  DxEditStoreName.Left := 30;
  DxEditStoreName.Top := 36;

  DGridStore.Left := 28;
  DGridStore.Top := 55;
  DGridStore.Width := 38 * 5 + 2;
  DGridStore.Height := 35 * 2 + 2;

  DBStoreBuy.SetImgIndex(g_WMain2Images, 275);
  DBStoreBuy.Left := 47;
  DBStoreBuy.Top := 143;
  //DBStoreBuy.FFloating := True;

  DBStoreCancel.SetImgIndex(g_WMain2Images, 275);
  DBStoreCancel.Left := 126;
  DBStoreCancel.Top := 143;
  //DBStoreCancel.FFloating := True;

  DBStoreClose.SetImgIndex(g_WMainImages, 64);
  DBStoreClose.Left := 239;
  DBStoreClose.Top := 1;
  //DBStoreClose.FFloating := True;

  DGridUserStall.Left := 28;
  DGridUserStall.Top := 55;
  DGridUserStall.Width := 38 * 5 + 2;
  DGridUserStall.Height := 35 * 2 + 2;

  DBUserStallBuy.SetImgIndex(g_WMain2Images, 275);
  DBUserStallBuy.Left := 120;
  DBUserStallBuy.Top := 143;

  DBUserStallClose.SetImgIndex(g_WMainImages, 64);
  DBUserStallClose.Left := 239;
  DBUserStallClose.Top := 1;

  //d := g_bui.Images[1];
  d := g_opui.Images[g_WStallPrice];
  DWStoreItemPrice.SetImgIndex(g_opui, g_WStallPrice);
  DWStoreItemPrice.Left := (SCREENWIDTH - 324) div 2;
  DWStoreItemPrice.Top := ((SCREENHEIGHT - 40) - DWStoreItemPrice.Height) div 2;

  //DBStorePage1.SetImgIndex(g_bui, 2);
  DBStorePage1.SetImgIndex(g_opui, g_PStallPrice0);
  DBStorePage1.Left := 10;
  DBStorePage1.Top := 15;
  //DBStorePage1.FFloating := True;

  //DBStorePage2.SetImgIndex(g_bui, 2);
  DBStorePage2.SetImgIndex(g_opui, g_PStallPrice1);
  DBStorePage2.Left := 110;
  DBStorePage2.Top := 15;
  DBStorePage2.PageActive := True;
  //DBStorePage2.FFloating := True;

  DxEditStoreItemPrice.Left := 128;
  DxEditStoreItemPrice.Top := 80;

  DBStoreItemPriceOk.SetImgIndex(g_WMain2Images, 277);
  DBStoreItemPriceOk.Left := 180;
  DBStoreItemPriceOk.Top := 106;
  //DBStoreItemPriceOk.FFloating := True;

  DBStoreItemPriceCancel.SetImgIndex(g_WMain2Images, 277);
  DBStoreItemPriceCancel.Left := 232;
  DBStoreItemPriceCancel.Top := 106;
  //DBStoreItemPriceCancel.FFloating := True;

  DBStorePriceClose.SetImgIndex(g_opui, g_sGameConfigClose1);
  DBStorePriceClose.Left := 302;
  DBStorePriceClose.Top := 1;
  //DBStorePriceClose.FFloating := True;

  //InitializeNext

  {-----ChatRecordList-----}
  DWChatRecordList.SetImgIndex(g_WMainImages, 1150);
  DWChatRecordList.Left := (SCREENWIDTH - 400) div 2;
  DWChatRecordList.Top := (SCREENHEIGHT - 261 - 100) div 2;
  DBotDare.SetImgIndex(g_WMainImages, 1151);
  DBotDare.Left := 209 + 30 * 5;
  DBotDare.Top := 104;
  DBChatRecordListClose.SetImgIndex(g_WMain3Images, 233);
  DBChatRecordListClose.Left := 394;
  DBChatRecordListClose.Top := 0;

  //Window_ChatRecordList.ClipRect := Rect(20, 45, 340, 192);

  DBDBChatRecordScroll.Visible := True;
  DBDBChatRecordScroll.SetImgIndex(g_WMain2Images, 581 {574}); //581

  DBDBChatRecordScroll.Left := 366;
  DBDBChatRecordScroll.Top := 42 + 15;
  DBDBChatRecordScroll.tag := DBDBChatRecordScroll.Left;
  DBDBChatRecordScroll.TypeRLeft := DBDBChatRecordScroll.Left;
  DBDBChatRecordScroll.TypeRTop := DBDBChatRecordScroll.Top;
  DBDBChatRecordScroll.SlotLen := 171;
  DBDBChatRecordScroll.Max := 300;
  DBDBChatRecordScroll.LeftToRight := False;

  DBChatRecordPrev.SetImgIndex(g_WMain2Images, 292);
  DBChatRecordPrev.Left := 366;
  DBChatRecordPrev.Top := 42;
  DBChatRecordNext.SetImgIndex(g_WMain2Images, 294);
  DBChatRecordNext.Left := 366;
  DBChatRecordNext.Top := 42 + 209 - 24 - 1;

  DBChatPrev.SetImgIndex(g_opui, 21);
  DBChatPrev.Left := SCREENWIDTH - 207;
  DBChatPrev.Top := 251 - 135;

  DBChatNext.SetImgIndex(g_opui, 24);
  DBChatNext.Left := SCREENWIDTH - 207;
  DBChatNext.Top := 251 - 28;

    {-----Chat-----} //聊天框拉伸条
  DBDBChatScroll.Visible := True;
  DBDBChatScroll.SetImgIndex(g_opui, 27);
  DBDBChatScroll.Left := SCREENWIDTH - 207;
  DBDBChatScroll.Top := 251 - 126;
  DBDBChatScroll.tag := DBDBChatScroll.Left;
  DBDBChatScroll.TypeRLeft := DBDBChatScroll.Left;
  DBDBChatScroll.TypeRTop := DBDBChatScroll.Top;
  DBDBChatScroll.SlotLen := 101;
  DBDBChatScroll.Max := 300; //用于设置滚动条所能代表最大值。 = Position
  DBDBChatScroll.LeftToRight := False;


  g_DlgInitialize := False;
end;

procedure TFrmDlg.Initialize(FirstStep: Boolean);
var
  i: Integer;
  d: TCustomLockableTexture;
begin
  if FirstStep then begin
    g_DWinMan.ClearAll;

    DBackground.Left := 0;
    DBackground.Top := 0;
    DBackground.Width := SCREENWIDTH;
    DBackground.Height := SCREENHEIGHT;
    DBackground.Background := True;
    g_DWinMan.AddDControl(DBackground, True);

    d := g_WMainImages.Images[360];
    DMsgDlg.SetImgIndex(g_WMainImages, 360);
    DMsgDlg.Left := (SCREENWIDTH - 452) div 2;
    DMsgDlg.Top := (SCREENHEIGHT - 179) div 2;
    DMsgDlg.Width := 452;
    DMsgDlg.Width := 179;

    DMsgDlgOk.SetImgIndex(g_WMainImages, 361);
    DMsgDlgYes.SetImgIndex(g_WMainImages, 363);
    DMsgDlgCancel.SetImgIndex(g_WMainImages, 365);
    DMsgDlgNo.SetImgIndex(g_WMainImages, 367);
    DMsgDlgOk.Top := 126;
    DMsgDlgYes.Top := 126;
    DMsgDlgCancel.Top := 126;
    DMsgDlgNo.Top := 126;
{$IF Var_UI = Var_176}
    d := g_WMainImages.Images[60];
    DLogin.SetImgIndex(g_WMainImages, 60);
    DLogIn.Left := (SCREENWIDTH - d.Width) div 2;
    DLogIn.Top := (SCREENHEIGHT - d.Height) div 2;
    DLoginNew.SetImgIndex (g_WMainImages, 61);
    DLoginNew.Left := 24;
    DLoginNew.Top  := 207;
    DLoginOk.SetImgIndex (g_WMainImages, 62);
    DLoginOk.Left := 171;
    DLoginOk.Top := 165;
    DLoginChgPw.SetImgIndex (g_WMainImages, 53);
    DLoginChgPw.Left := 130;
    DLoginChgPw.Top  := 207;
    DLoginClose.SetImgIndex (g_WMainImages, 64);
    DLoginClose.Left := 252;
    DLoginClose.Top := 28;

    DxEditLoginID.Left := 97; //帐户输入
    DxEditLoginID.Top := 88;
    DxEditLoginID.Width := 137;
    DxEditLoginID.Height := 16;

    DxEditPassword.Left := 97; //密码输入
    DxEditPassword.Top := 120;
    DxEditPassword.Width := 137;
    DxEditPassword.Height := 16;

    DxEdChrName.Left := 73; //新建角色界面
    DxEdChrName.Top := 109;
    DxEdChrName.Width := 135;
    DxEdChrName.Height := 15;
{$ELSE}
    d := g_WMain3Images.Images[18];
    DLogin.SetImgIndex(g_WMain3Images, 18);
    DLogin.Left := (SCREENWIDTH - 296) div 2;
    DLogin.Top := (SCREENHEIGHT - 314) div 2;

    DLoginNew.SetImgIndex(g_WMainImages, 61);
    DLoginNew.Left := 32;
    DLoginNew.Top := 172;
    DLoginOk.SetImgIndex(g_WMain3Images, 10);
    DLoginOk.Left := 164;
    DLoginOk.Top := 172;
    DLoginChgPw.SetImgIndex(g_WMain3Images, 28);
    DLoginChgPw.Left := 164;
    DLoginChgPw.Top := 215;
    DLoginClose.SetImgIndex(g_WMainImages, 64);
    DLoginClose.Left := 258;
    DLoginClose.Top := 24;

    DxEditLoginID.Left := 125;
    DxEditLoginID.Top := 75;
    DxEditLoginID.Width := 136;
    DxEditLoginID.Height := 16;

    DxEdChrName.Left := 73;
    DxEdChrName.Top := 109;
    DxEdChrName.Width := 135;
    DxEdChrName.Height := 15;

    DxEditPassword.Left := 125;
    DxEditPassword.Top := 107;
    DxEditPassword.Width := 136;
    DxEditPassword.Height := 16;
{$IFEND}
    d := g_WMainImages.Images[256];
    DSelServerDlg.SetImgIndex(g_WMainImages, 256, (SCREENWIDTH - 308) div 2, (SCREENHEIGHT - 450) div 2);

    DSSrvClose.SetImgIndex(g_WMainImages, 64);
    DSSrvClose.Left := 245;
    DSSrvClose.Top := 31;

    DSServer1.SetImgIndex(g_WMain3Images, 2);
    DSServer1.Left := 65;
    DSServer1.Top := 100;

    DSServer2.SetImgIndex(g_WMain3Images, 2);
    DSServer2.Left := 65;
    DSServer2.Top := 145;

    DSServer3.SetImgIndex(g_WMain3Images, 2);
    DSServer3.Left := 65;
    DSServer3.Top := 190;

    DSServer4.SetImgIndex(g_WMain3Images, 2);
    DSServer4.Left := 65;
    DSServer4.Top := 235;

    DSServer5.SetImgIndex(g_WMain3Images, 2);
    DSServer5.Left := 65;
    DSServer5.Top := 280;

    DSServer6.SetImgIndex(g_WMain3Images, 2);
    DSServer6.Left := 65;
    DSServer6.Top := 325;

    DEngServer1.Visible := False;
    DSServer1.Visible := False;
    DSServer2.Visible := False;
    DSServer3.Visible := False;
    DSServer4.Visible := False;
    DSServer5.Visible := False;
    DSServer6.Visible := False;

    d := g_WMainImages.Images[63];
    DNewAccount.SetImgIndex(g_WMainImages, 63);
    DNewAccount.Left := (SCREENWIDTH - 640) div 2;
    DNewAccount.Top := (SCREENHEIGHT - 473) div 2;

    DNewAccountOk.SetImgIndex(g_WMainImages, 62);
    DNewAccountOk.Left := 158;
    DNewAccountOk.Top := 416;
    DNewAccountCancel.SetImgIndex(g_WMainImages, 52);
    DNewAccountCancel.Left := 446;
    DNewAccountCancel.Top := 419;
    DNewAccountClose.SetImgIndex(g_WMainImages, 64);
    DNewAccountClose.Left := 587;
    DNewAccountClose.Top := 33;

    d := g_WMainImages.Images[50];
    DChgPw.SetImgIndex(g_WMainImages, 50);
    DChgPw.Left := (SCREENWIDTH - 420) div 2;
    DChgPw.Top := (SCREENHEIGHT - 299) div 2;

    DChgpwOk.SetImgIndex(g_WMainImages, 81);
    DChgpwOk.Left := 181;
    DChgpwOk.Top := 253;
    DChgpwCancel.SetImgIndex(g_WMainImages, 52);
    DChgpwCancel.Left := 276;
    DChgpwCancel.Top := 252;

    DSelectChr.Left := 0;
    DSelectChr.Top := 0;
    DSelectChr.Width := SCREENWIDTH;
    DSelectChr.Height := SCREENHEIGHT;
    DscSelect1.SetImgIndex(g_WMainImages, 66);
    DscSelect1.Left := (SCREENWIDTH - 800) div 2 + 134 {134};
    DscSelect1.Top := (SCREENHEIGHT - 600) div 2 + 454 {454};
    DscSelect2.SetImgIndex(g_WMainImages, 67);
    DscSelect2.Left := (SCREENWIDTH - 800) div 2 + 685 {685};
    DscSelect2.Top := (SCREENHEIGHT - 600) div 2 + 454 {454};
    {$IF Var_UI = Var_176}
    DscStart.SetImgIndex(g_WMainImages, 68);
    DscStart.Left := (SCREENWIDTH - 68) div 2 + 19;
    DscStart.Top := (SCREENHEIGHT - 600) div 2 + 456;
    {$ELSE}
    d := g_opui.Images[g_sDscStart0];
    DscStart.SetImgIndex(g_opui, g_sDscStart0);
    DscStart.Left := (SCREENWIDTH - 68) div 2 + 5;
    DscStart.Top := (SCREENHEIGHT - 600) div 2 + 455;
    {$IFEND}

    DscNewChr.SetImgIndex(g_WMainImages, 69);
    DscNewChr.Left := (SCREENWIDTH - 800) div 2 + 348 {348};
    DscNewChr.Top := (SCREENHEIGHT - 600) div 2 + 486 {486};
    DscEraseChr.SetImgIndex(g_WMainImages, 70);
    DscEraseChr.Left := (SCREENWIDTH - 800) div 2 + 347 {347};
    DscEraseChr.Top := (SCREENHEIGHT - 600) div 2 + 506 {506};
    {$IF Var_UI = Var_176}
    DscCredits.SetImgIndex(g_WMainImages, 71);
    DscCredits.Left := (SCREENWIDTH - 800) div 2 + 346 +16 {362};
    DscCredits.Top := (SCREENHEIGHT - 600) div 2 + 527 {527};
    {$ELSE}
    DscCredits.SetImgIndex(g_WMainImages, 405);
    DscCredits.Left := (SCREENWIDTH - 800) div 2 + 346 {362};
    DscCredits.Top := (SCREENHEIGHT - 600) div 2 + 527 {527};
    {$IFEND}
    DscExit.SetImgIndex(g_WMainImages, 72);
    DscExit.Left := (SCREENWIDTH - 800) div 2 + 379 {379};
    DscExit.Top := (SCREENHEIGHT - 600) div 2 + 547 {547};

    d := g_WMain3Images.Images[406];
    DBDelCharList.SetImgIndex(g_WMain3Images, 406);
    DBDelCharList.Left := 120;
    DBDelCharList.Top := 88;
    DBGetDelCharClose.SetImgIndex(g_WMainImages, 64);
    DBGetDelCharClose.Left := 247;
    DBGetDelCharClose.Top := 30;
    DBGetBackDelChar.SetImgIndex(g_WMain3Images, 407);
    DBGetBackDelChar.Left := 300 div 2 - 50;
    DBGetBackDelChar.Top := 417 - 55;

    d := g_WMainImages.Images[73];
    DCreateChr.SetImgIndex(g_WMainImages, 73);
    DCreateChr.Left := (SCREENWIDTH - 300) div 2;
    DCreateChr.Top := (SCREENHEIGHT - 417) div 2;

    DccWarrior.SetImgIndex(g_WMainImages, 74);
    DccWizzard.SetImgIndex(g_WMainImages, 75);
    DccMonk.SetImgIndex(g_WMainImages, 76);
    DccMale.SetImgIndex(g_WMainImages, 77);
    DccFemale.SetImgIndex(g_WMainImages, 78);
    DccLeftHair.SetImgIndex(g_WMainImages, 79);
    DccRightHair.SetImgIndex(g_WMainImages, 80);
    DccOk.SetImgIndex(g_WMainImages, 62);
    DccClose.SetImgIndex(g_WMainImages, 64);
    DccWarrior.Left := 48;
    DccWarrior.Top := 157;
    DccWizzard.Left := 93;
    DccWizzard.Top := 157;
    DccMonk.Left := 138;
    DccMonk.Top := 157;

    DccMale.Left := 93;
    DccMale.Top := 231;
    DccFemale.Left := 138;
    DccFemale.Top := 231;
    DccLeftHair.Left := 76;
    DccLeftHair.Top := 308;
    DccRightHair.Left := 170;
    DccRightHair.Top := 308;
    DccOk.Left := 103;
    DccOk.Top := 360;
    DccClose.Left := 248;
    DccClose.Top := 31;

    InitGrobalSurface();
  end else begin
    //
  end;
end;

procedure InitMainImagesSecond();
//var
  //dwExitCode                : DWORD;
begin
  //EnterCriticalSection(ThreadCS);
  //try
  FrmDlg.InitializeNext();
  //finally
  //  LeaveCriticalSection(ThreadCS);
  //end;
  //ExitThread(dwExitCode);
end;

procedure TFrmDlg.OpenSoundOption(bkg: Boolean);
var
  ini: TiniFile;
begin
  //ini := TiniFile.Create('.\Config\' + g_sServerName + '.' + frmMain.m_sCharName + '.Set');
  ini := TIniFile.Create('.\lscfg.ini');
  if not bkg then begin
    g_SndMgr.Silent := not g_SndMgr.Silent;
    g_gcGeneral[11] := not g_SndMgr.Silent;
    if not g_SndMgr.Silent then begin
      DScreen.AddChatBoardString('[游戏声音已打开]', clWhite, clBlack);
      if (g_nLastMapMusic >= 0) then begin
        g_SndMgr.PlaySound('.\Music\' + IntToStr(g_nLastMapMusic) + '.mp3', -1, -1, True);
      end;
    end else begin
      DScreen.AddChatBoardString('[游戏声音已关闭]', clWhite, clBlack);
      g_SndMgr.SilenceSound;
    end;
    ini.WriteBool('Setup', 'EffectSound', g_gcGeneral[11]);
    ini.free;
    Exit;
  end;

  {if g_gcGeneral[12] then begin
    //PlayMapMusic(True);
    DScreen.AddChatBoardString('[背景音乐已打开]', clWhite, clBlack);
  end else begin
    //if MP3 <> nil then MP3.Stop;   //PlayMapMusic(False);
    DScreen.AddChatBoardString('[背景音乐已关闭]', clWhite, clBlack);
  end;}
  ini.WriteBool('Setup', 'EffectBKGSound', g_gcGeneral[12]);
  ini.free;
end;

procedure TFrmDlg.OpenMyStatus;
begin
  PageChanged;
  DStateWin.Visible := not DStateWin.Visible;
end;

procedure TFrmDlg.OpenHeroStatus;
begin
  if not g_boHero then Exit;
  HeroPageChanged;
  DHStateWin.Visible := not DHStateWin.Visible;
end;

procedure TFrmDlg.OpenUserState(UserState: TUserStateInfo);
begin
{$IFNDEF UI_0508}
  uStatePage := 0;
  USPageChanged;
{$ENDIF}
  UserState1 := UserState;
  DUserState1.Visible := True;
end;

procedure TFrmDlg.OpenItemBag;
begin
  DItemBag.Visible := not DItemBag.Visible;
  if DItemBag.Visible then begin
    if DHeroItemBag.Visible or DWHeroStore.Visible then begin
      DHeroItemBag.Left := 28;
      DItemBag.Left := DHeroItemGrid.Width + 28 * 2;
      DHeroItemBag.Top := 100;
      DItemBag.Top := 60;
    end;
    if DWHeroStore.Visible then begin
      DItemBag.Left := DWHeroStore.Width + 110;
      DItemBag.Top := 60;
    end;
    ArrangeItembag;
  end;
end;

procedure TFrmDlg.OpenHeroItemBag;
begin
  if not g_boHero then Exit;
  DHeroItemBag.Visible := not DHeroItemBag.Visible;
  if DItemBag.Visible then begin
    if DHeroItemBag.Visible then begin
      DHeroItemBag.Left := 28;
      DItemBag.Left := DHeroItemGrid.Width + 28 * 2;
      DHeroItemBag.Top := 100;
      DItemBag.Top := 60;
    end;
    if DHeroItemBag.Visible then
      ArrangeHeroItembag;
  end;
end;

procedure TFrmDlg.ViewBottomBox(Visible: Boolean);
begin
  DBottom.Visible := Visible;
  g_fGetRenderBottom := Visible;
end;

procedure TFrmDlg.CancelItemMoving;
var
  idx, n: Integer;
begin
  if g_boItemMoving and (g_MovingItem.item.s.Name <> '') then begin
    g_boItemMoving := False;
    idx := g_MovingItem.Index;
    if idx < 0 then begin
      if (idx <= -20) and (idx > -30) then
        AddDealItem(g_MovingItem.item)
      else if (idx <= -30) and (idx > -39) then
        AddYbDealItem(g_MovingItem.item)
      else begin
        n := -(idx + 1);
        if n in [0..U_FASHION] then
          g_UseItems[n] := g_MovingItem.item
        else begin
          n := -(idx + 1 + HERO_MIIDX_OFFSET);
          if n in [0..U_FASHION] then
            g_HeroUseItems[n] := g_MovingItem.item;
        end;
      end;
    end else begin

      if IsDetectItem(idx) then begin
        g_DetectItem := g_MovingItem.item;
      end else if IsStallItem(idx) then begin
        AddStallItem(g_MovingItem.item);
      end
      else if idx in [0..MAXBAGITEM - 1] then begin
        if g_ItemArr[idx].s.Name = '' then
          g_ItemArr[idx] := g_MovingItem.item
        else
          AddItemBag(g_MovingItem.item, idx);
        ArrangeItembag;
      end else if (idx >= HERO_MIIDX_OFFSET) and (idx <= ({MAXBAGITEM} g_nHeroBagSize - 1 + HERO_MIIDX_OFFSET)) then begin
        if g_HeroItemArr[idx - HERO_MIIDX_OFFSET].s.Name = '' then
          g_HeroItemArr[idx - HERO_MIIDX_OFFSET] := g_MovingItem.item
        else
          HeroAddItemBag(g_MovingItem.item);
        ArrangeHeroItembag;
      end;
    end;
    g_MovingItem.item.s.Name := '';
  end;
end;

procedure TFrmDlg.CheckBox_ShowFashionClick(Sender: TObject; X, Y: Integer);
var
  DefMsg: TDefaultMessage;
begin
  DefMsg := EDcode.MakeDefaultMsg(CM_PLAYERCONFIG, byte(Sender = CheckBox_hShowFashion), 0, 0, MakeWord(byte((Sender as TDCheckBox).Checked), 0));
  frmMain.SendSocket(EncodeMessage(DefMsg));
end;

procedure TFrmDlg.CheckBox_ShowFashionDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
  lx, ly, Col: Integer;
begin
  d := nil;
{$IFNDEF UI_0508}
  with Sender as TDCheckBox do begin
    lx := SurfaceX(Left);
    ly := SurfaceY(Top);
    d := WLib.Images[FaceIndex + byte(Checked)];
    if d <> nil then begin
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
      if Arrived then
        dsurface.BoldTextOut(lx + d.Width + 2, ly + 3, Caption, clWhite, clBlack)
      else
        dsurface.BoldTextOut(lx + d.Width + 2, ly + 3, Caption, clSilver, clBlack);
    end;
  end;
{$ENDIF}
end;

procedure TFrmDlg.CheckBox_ShowFashionInRealArea(Sender: TObject; X, Y: Integer; var IsRealArea: Boolean);
begin
  IsRealArea := True;
end;

procedure TFrmDlg.DropMovingItem;
var
  idx, DlopCount: Integer;
  valstr: string;
  MsgResult: Integer;
begin
  if g_boItemMoving then begin
    g_boItemMoving := False;
    if g_MovingItem.item.s.Name <> '' then begin
      if g_MovingItem.item.s.Overlap > 0 then begin

        DlopCount := 0;
        Total := g_MovingItem.item.Dura;
        if Total = 1 then begin
          DlgEditText := '1';
          MsgResult := mrOk;
        end else begin
          MsgResult := DMessageDlg(Format('你想扔下多少 %s ？', [g_MovingItem.item.s.Name]), [mbOk, mbCancel, mbAbort], IntToStr(g_MovingItem.item.Dura));
        end;
        g_boItemMoving := True;
        if (MsgResult = mrCancel) then begin
          CancelItemMoving;
          Exit;
        end else if MsgResult = mrOk then begin

          GetValidStrVal(DlgEditText, valstr, [' ']);
          DlopCount := Str_ToInt(valstr, 0);

          if DlopCount <= 0 then DlopCount := 0;
          if DlopCount > g_MovingItem.item.Dura then DlopCount := g_MovingItem.item.Dura;
          if DlopCount = g_MovingItem.item.Dura then begin
            frmMain.SendDropItem(g_MovingItem.item.s.Name, g_MovingItem.item.MakeIndex, DlopCount);
            AddDropItem(g_MovingItem.item);
            g_MovingItem.item.s.Name := '';
            //g_MovingItem.item.Dura := 0;
            g_boItemMoving := False;
          end else if (DlopCount > 0) then begin
            frmMain.SendDropItem(g_MovingItem.item.s.Name, g_MovingItem.item.MakeIndex, DlopCount);
          end;
          CancelItemMoving;
          Exit;
        end;
      end else begin
        frmMain.SendDropItem(g_MovingItem.item.s.Name, g_MovingItem.item.MakeIndex, 0);
        AddDropItem(g_MovingItem.item);
        g_MovingItem.item.s.Name := '';
      end;
    end;
  end;
end;

procedure TFrmDlg.HeroDropMovingItem;
var
  idx, DlopCount: Integer;
  valstr: string;
  MsgResult: Integer;
begin
  if g_boItemMoving then begin
    g_boItemMoving := False;
    if g_MovingItem.item.s.Name <> '' then begin
      if g_MovingItem.item.s.Overlap > 0 then begin

        DlopCount := 0;
        Total := g_MovingItem.item.Dura;
        if Total = 1 then begin
          DlgEditText := '1';
          MsgResult := mrOk;
        end else
          MsgResult := DMessageDlg(Format('(英雄) 你想扔下多少 %s ？', [g_MovingItem.item.s.Name]), [mbOk, mbCancel, mbAbort], IntToStr(g_MovingItem.item.Dura));
        g_boItemMoving := True;
        if (MsgResult = mrCancel) then begin
          CancelItemMoving;
          Exit;
        end else if MsgResult = mrOk then begin

          GetValidStrVal(DlgEditText, valstr, [' ']);
          DlopCount := Str_ToInt(valstr, 0);

          if DlopCount <= 0 then DlopCount := 0;
          if DlopCount > g_MovingItem.item.Dura then DlopCount := g_MovingItem.item.Dura;
          if DlopCount = g_MovingItem.item.Dura then begin
            frmMain.SendHeroDropItem(g_MovingItem.item.s.Name, g_MovingItem.item.MakeIndex, DlopCount);
            AddDropItem(g_MovingItem.item);
            g_MovingItem.item.s.Name := '';
            //g_MovingItem.item.Dura := 0;
            g_boItemMoving := False;
          end else if (DlopCount > 0) then begin
            frmMain.SendHeroDropItem(g_MovingItem.item.s.Name, g_MovingItem.item.MakeIndex, DlopCount);
          end;
          CancelItemMoving;
          Exit;
        end;
      end else begin
        frmMain.SendHeroDropItem(g_MovingItem.item.s.Name, g_MovingItem.item.MakeIndex, 0);
        AddDropItem(g_MovingItem.item);
        g_MovingItem.item.s.Name := '';
      end;
    end;
  end;
end;

procedure TFrmDlg.OpenAdjustAbility;
begin
  DAdjustAbility.Left := 0;
  DAdjustAbility.Top := 0;
  g_nSaveBonusPoint := g_nBonusPoint;
  FillChar(g_BonusAbilChg, SizeOf(TNakedAbility), #0);
  DAdjustAbility.Visible := True;
end;

procedure TFrmDlg.DBackgroundBackgroundClick(Sender: TObject);
var
  dropgold: Integer;
  valstr: string;
begin
  if g_boItemMoving then begin
    //DScreen.AddChatBoardString(IntToStr(g_MovingItem.Index), clRed, clWhite);
    DBackground.WantReturn := True;
    if g_MovingItem.item.s.Name = g_sGoldName {'金币'} then begin
      g_boItemMoving := False;
      g_MovingItem.item.s.Name := '';
      DialogSize := 1;
      DMessageDlg('输入你想扔掉' + g_sGoldName + '的数量？', [mbOk, mbAbort]);
      GetValidStrVal(DlgEditText, valstr, [' ']);
      dropgold := Str_ToInt(valstr, 0);
      frmMain.SendDropGold(dropgold);
    end;
    if IsDetectItem(g_MovingItem.Index) then Exit;
    if IsStallItem(g_MovingItem.Index) then Exit;
    if g_MovingItem.Index >= HERO_MIIDX_OFFSET then
      HeroDropMovingItem()
    else if IsBagItem(g_MovingItem.Index)
{$IFDEF  WEAPON_DROP}
    or IsEquItem(g_MovingItem.Index)
{$ENDIF}
    then begin
      DropMovingItem;
    end;
  end;
end;

procedure TFrmDlg.DBackgroundMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  if g_boItemMoving then
    DBackground.WantReturn := True;
end;

procedure TFrmDlg.DBAcus1Click(Sender: TObject; X, Y: Integer);
var
  ok: Boolean;
  i, n, idx: Integer;
  cuTemp: TMovingItem;
begin
  if g_Myself = nil then Exit;
  if g_BuildAcusesStep = 1 then Exit;
  idx := TDButton(Sender).tag;
  if idx in [0..7] then begin //30..34
    if g_boItemMoving and
      (g_MovingItem.item.s.Name <> '') and
      (g_MovingItem.item.s.StdMode = 41) and
      (g_MovingItem.item.s.Shape in [10..14, 30..34]) then begin

      if (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) then Exit;
      if (g_MovingItem.item.s.Overlap >= 1) and (g_MovingItem.item.Dura <> 1) then Exit;

      if (g_MovingItem.Index >= 0) and (g_MovingItem.Index < HERO_MIIDX_OFFSET) then begin
        ok := ((g_MovingItem.item.s.Shape in [30..34]) and (idx in [5..7])) or ((g_MovingItem.item.s.Shape in [10..14]) and (idx in [0..4]));
        if not ok then Exit;
        g_BuildAcusesStep := 0;
        g_SndMgr.ItemClickSound(g_MovingItem.item.s);
        n := 0;
        for i := 0 to 7 do begin
          if g_BuildAcuses[i].item.s.Name <> '' then
            Inc(n);
        end;
        if n = 0 then begin
          g_BAFirstShape := g_MovingItem.item.s.Shape mod 20;
          g_BuildAcuses[idx] := g_MovingItem;
          g_MovingItem.item.s.Name := '';
          g_boItemMoving := False;
        end else begin
          if g_BAFirstShape = (g_MovingItem.item.s.Shape mod 20) then begin
            if g_BuildAcuses[idx].item.s.Name <> '' then begin
              cuTemp := g_BuildAcuses[idx];
              g_BuildAcuses[idx] := g_MovingItem;
              g_boItemMoving := True;
              g_MovingItem := cuTemp;
            end else begin
              g_BuildAcuses[idx] := g_MovingItem;
              g_MovingItem.item.s.Name := '';
              g_boItemMoving := False;
            end;
          end else begin
            if g_BuildAcuses[idx].item.s.Name <> '' then begin
              cuTemp := g_BuildAcuses[idx];
              g_BuildAcuses[idx] := g_MovingItem;
              g_BAFirstShape := g_MovingItem.item.s.Shape mod 20;
              g_boItemMoving := True;
              g_MovingItem := cuTemp;
              for i := 0 to 7 do begin
                if idx = i then Continue;
                if (g_BuildAcuses[i].item.s.Name <> '') and ((g_BuildAcuses[i].item.s.Shape mod 20) <> g_BAFirstShape) then begin
                  AddItemBag(g_BuildAcuses[i].item);
                  g_BuildAcuses[i].item.s.Name := '';
                end;
              end;
            end else begin
              g_BAFirstShape := g_MovingItem.item.s.Shape mod 20;
              g_BuildAcuses[idx] := g_MovingItem;
              g_MovingItem.item.s.Name := '';
              g_boItemMoving := False;
              for i := 0 to 7 do begin
                if idx = i then Continue;
                if (g_BuildAcuses[i].item.s.Name <> '') and ((g_BuildAcuses[i].item.s.Shape mod 20) <> g_BAFirstShape) then begin
                  AddItemBag(g_BuildAcuses[i].item);
                  g_BuildAcuses[i].item.s.Name := '';
                end;
              end;
            end;
          end;
        end;
      end;
    end else begin
      if g_BuildAcuses[idx].item.s.Name <> '' then begin
        g_BuildAcusesStep := 0;
        g_SndMgr.ItemClickSound(g_BuildAcuses[idx].item.s);
        g_MovingItem := g_BuildAcuses[idx];
        g_BuildAcuses[idx].item.s.Name := '';
        g_boItemMoving := True;
        n := 0;
        for i := 0 to 7 do begin
          if g_BuildAcuses[i].item.s.Name <> '' then
            Inc(n);
        end;
        if n = 0 then
          g_BAFirstShape := -1;
      end;
    end;
  end;

  n := 0;
  for i := 0 to 7 do begin
    if g_BuildAcuses[i].item.s.Name <> '' then begin
      case g_BuildAcuses[i].item.s.Shape of
        10: Inc(n, 8);
        11: Inc(n, 14);
        12: Inc(n, 20);
        13: Inc(n, 20);
        14: Inc(n, 20);
        30..34: Inc(n, 20);
      end;
    end;
  end;
  if g_BuildAcusesRate <> n then begin
    g_BuildAcusesRate := _MIN(100, n);
  end;
end;

procedure TFrmDlg.DBAcus1DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  b, ok: Boolean;
  off, idx, nfidx: Integer;
  d: TCustomLockableTexture;
begin
  d := nil;
  if not (DWBuildAcus.tag in [1, 2]) then Exit;
  with Sender as TDButton do begin
    if not (tag in [0..7]) then Exit;
    if g_BuildAcuses[tag].item.s.Name <> '' then begin
      idx := g_BuildAcuses[tag].item.s.looks;
      if idx >= 0 then begin
        //d := g_WBagItemImages.Images[idx];
        d := frmMain.GetWBagItemImg(idx);
        if d <> nil then
          dsurface.Draw(SurfaceX(Left + (Width - d.Width) div 2), SurfaceY(Top + (Height - d.Height) div 2), d.ClientRect, d, True);
      end;
    end else begin
      if tag in [0..7] then begin
        b := False;
        if g_boItemMoving and (g_MovingItem.item.s.Name <> '') and (g_MovingItem.item.s.StdMode = 41) and (g_MovingItem.item.s.Shape in [10..14, 30..34]) then begin
          if (g_MovingItem.Index <> -97) and (g_MovingItem.Index <> -98) then begin
            if (g_MovingItem.Index >= 0) and (g_MovingItem.Index < HERO_MIIDX_OFFSET) then begin
              if (g_MovingItem.item.s.Overlap = 0) or (g_MovingItem.item.Dura = 1) then
                b := True;
            end;
          end;
        end;
        ok := b and (((g_MovingItem.item.s.Shape in [30..34]) and (tag in [5..7])) or ((g_MovingItem.item.s.Shape in [10..14]) and (tag in [0..4])));
        if ok and (g_MovingItem.item.s.Name <> '') and (g_MovingItem.item.s.StdMode = 41) then begin
          if (g_BAFirstShape <> -1) and (g_BAFirstShape = (g_MovingItem.item.s.Shape mod 20)) then begin
            off := 780;
            if ((g_MovingItem.item.s.Shape in [30..34]) and (tag in [5..7])) then
              off := 785;
            nfidx := FaceIndex;
            if g_BAFirstShape in [11..14] then
              nfidx := off + g_BAFirstShape - 11;
//            d := WLib.Images[nfidx];
//            if d <> nil then begin
//              g_ImgMixSurface.Draw(0, 0, d.ClientRect, d, False);
//              DrawEffect(0, 0, d.Width, d.Height, g_ImgMixSurface, ceYellow);
//              dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, g_ImgMixSurface, True);
//            end;
          end else begin
            off := 790;
            if ((g_MovingItem.item.s.Shape in [30..34]) and (tag in [5..7])) then
              off := 785;
            nfidx := FaceIndex;
            if g_BAFirstShape in [11..14] then
              nfidx := off + g_BAFirstShape - 11;
//            d := WLib.Images[nfidx];
//            if d <> nil then begin
//              if g_BAFirstShape <> -1 then begin
//                g_ImgMixSurface.Draw(0, 0, d.ClientRect, d, False);
//                DrawEffect(0, 0, d.Width, d.Height, g_ImgMixSurface, ceRed);
//                dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, g_ImgMixSurface, True);
//              end else begin
//                g_ImgMixSurface.Draw(0, 0, d.ClientRect, d, False);
//                DrawEffect(0, 0, d.Width, d.Height, g_ImgMixSurface, ceYellow);
//                dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, g_ImgMixSurface, True);
//              end;
//            end;
          end;
        end else begin
          off := 790;
          if ({(g_MovingItem.item.s.Shape in [30..34]) and}(tag in [5..7])) then
            off := 785;
          nfidx := FaceIndex;
          if g_BAFirstShape in [11..14] then
            nfidx := off + g_BAFirstShape - 11;
          d := WLib.Images[nfidx];
          if d <> nil then
            dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
          if g_BuildAcusesStep = 1 then begin
            d := g_WMainImages.Images[758];
            if d <> nil then
              dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DBAcus1MouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
begin
  with Sender as TDButton do begin
    if not (tag in [0..7]) then Exit;
    DScreen.ClearHint;
    if (g_BuildAcuses[tag].item.s.Name <> '') then begin
      g_MouseItem := g_BuildAcuses[tag].item;
    end;

    if (tag in [0..4]) then
      DScreen.ShowHint(SurfaceX(Left), SurfaceY(Top), '金针', clYellow, True)
    else
      DScreen.ShowHint(SurfaceX(Left), SurfaceY(Top), '幸运符', clYellow, True);

  end;
end;

procedure TFrmDlg.DBAttackModeClick(Sender: TObject; X, Y: Integer);
begin
  if (g_Myself <> nil) then
    frmMain.SendSay('@AttackMode');
end;

procedure TFrmDlg.DBAttackModeDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TCustomCanvas;
begin
  //94 95 93
  d := nil;
  with Sender as TDButton do begin
    if Downed then begin
      dsurface.BoldTextOut(SurfaceX(Left + 1), SurfaceY(Top + 1), GetRGB(161), clBlack, Caption)
    end else if Arrived then begin
      dsurface.BoldTextOut(SurfaceX(Left), SurfaceY(Top), clWhite, clBlack, Caption)
    end else
      dsurface.BoldTextOut(SurfaceX(Left), SurfaceY(Top), GetRGB(246), clBlack, Caption);
  end;
end;

procedure TFrmDlg.DBottomMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
  n: Integer;
  Str: string;
begin
  if (X >= 208) and (X <= 208 + 374) and (Y >= SCREENHEIGHT - 130) and (Y <= SCREENHEIGHT - 130 + 12 * 9) then begin
    n := DScreen.ChatBoardTop + (Y - (SCREENHEIGHT - 130)) div 12;
    if (n < DScreen.ChatStrs.Count) then begin
      FrmDlg.DEdChat.Visible := True;
      SetDFocus(FrmDlg.DEdChat);

      if ssCtrl in Shift then
        FrmDlg.DEdChat.Text := DScreen.ChatStrs[n]
      else
        FrmDlg.DEdChat.Text := '/' + ExtractUserName(DScreen.ChatStrs[n]) + ' ';
      FrmDlg.DEdChat.ChangeCurPos(AnsiTextLength(FrmDlg.DEdChat.Text), True);
      FrmDlg.DEdChat.SelLength := 0;
    end else
      FrmDlg.DEdChat.Text := '';
  end;
end;

function TFrmDlg.DMessageDlg(msgstr: string; DlgButtons: TMsgDlgButtons; deftext: string; nt: byte; len: Integer): TModalResult;
const
  XBase = 330;
var
  i: Integer;
  lx, ly: Integer;
  d: TCustomLockableTexture;

  procedure ShowDice();
  var
    i: Integer;
    bo05: Boolean;
  begin
    if m_nDiceCount = 1 then begin
      if m_Dice[0].n67C < 20 then begin
        if GetTickCount - m_Dice[0].dwPlayTick > 100 then begin
          if m_Dice[0].n67C div 5 = 4 then begin
            m_Dice[0].nPlayPoint := Random(6) + 1;
          end else begin
            m_Dice[0].nPlayPoint := m_Dice[0].n67C div 5 + 8;
          end;
          m_Dice[0].dwPlayTick := GetTickCount();
          Inc(m_Dice[0].n67C);
        end;
        Exit;
      end;
      m_Dice[0].nPlayPoint := m_Dice[0].nDicePoint;
      if GetTickCount - m_Dice[0].dwPlayTick > 1500 then begin
        DMsgDlg.Visible := False;
      end;
      Exit;
    end;

    bo05 := True;
    for i := 0 to m_nDiceCount - 1 do begin
      if m_Dice[i].n67C < m_Dice[i].n680 then begin
        if GetTickCount - m_Dice[i].dwPlayTick > 100 then begin
          if m_Dice[i].n67C div 5 = 4 then begin
            m_Dice[i].nPlayPoint := Random(6) + 1;
          end else begin
            m_Dice[i].nPlayPoint := m_Dice[i].n67C div 5 + 8;
          end;
          m_Dice[i].dwPlayTick := GetTickCount();
          Inc(m_Dice[i].n67C);
        end;
        bo05 := False;
      end else begin
        m_Dice[i].nPlayPoint := m_Dice[i].nDicePoint;
        if GetTickCount - m_Dice[i].dwPlayTick < 2000 then begin
          bo05 := False;
        end;
      end;
    end;
    if bo05 then DMsgDlg.Visible := False;
  end;

var
  inputstat, procMsg: Boolean;
  //ln                        : Longint;
  MaxLen: Integer;
begin
  //if DConfigDlg.Visible then //打开提示框时关闭选项框
  //  DOptionClick();
  d := nil;
  DScreen.ClearHint;
  procMsg := False;
  lx := XBase;
  ly := 126;
  case DialogSize of
    0: begin
        d := g_WMainImages.Images[381];
        DMsgDlg.SetImgIndex(g_WMainImages, 381);
        DMsgDlg.Left := (SCREENWIDTH - 188) div 2;
        DMsgDlg.Top := (SCREENHEIGHT - 105) div 2;
        msglx := 39;
        msgly := 38;
        lx := 90;
        ly := 36;
      end;
    1: begin
        d := g_WMainImages.Images[360];
        DMsgDlg.SetImgIndex(g_WMainImages, 360);
        DMsgDlg.Left := (SCREENWIDTH - 452) div 2;
        DMsgDlg.Top := (SCREENHEIGHT - 179) div 2;
        msglx := 39;
        msgly := 38;
        lx := XBase;
        ly := 126;
      end;
    2: begin
        d := g_WMainImages.Images[380];
        DMsgDlg.SetImgIndex(g_WMainImages, 380);
        DMsgDlg.Left := (SCREENWIDTH - 256) div 2;
        DMsgDlg.Top := (SCREENHEIGHT - 359) div 2;
        msglx := 23;
        msgly := 20;
        lx := 90;
        ly := 305;
      end;
  end;
  MsgText := msgstr;
  ViewDlgEdit := False;
  DMsgDlg.Floating := True;
  DxDlgEdit.Visible := False;
  DMsgDlgOk.Visible := False;
  DMsgDlgYes.Visible := False;
  DMsgDlgCancel.Visible := False;
  DMsgDlgNo.Visible := False;
  DMsgDlg.Left := (SCREENWIDTH - DMsgDlg.Width) div 2;
  DMsgDlg.Top := (SCREENHEIGHT - DMsgDlg.Height) div 2;

  for i := 0 to m_nDiceCount - 1 do begin
    m_Dice[i].n67C := 0;
    m_Dice[i].n680 := Random(m_nDiceCount + 2) * 5 + 10;
    m_Dice[i].nPlayPoint := 1;
    m_Dice[i].dwPlayTick := GetTickCount();
  end;

  //EdDlgEdit.Clear;
  DxDlgEdit.Text := '';
  //ln := GetWindowLong(EdDlgEdit.Handle, GWL_STYLE);
  inputstat := DxDlgEdit.NomberOnly;
  if nt = 1 then begin
    //SetWindowLong(EdDlgEdit.Handle, GWL_STYLE, ln or ES_NUMBER);
    DxDlgEdit.NomberOnly := True;
  end;
  MaxLen := DxDlgEdit.MaxLength;
  if len >= 1 then DxDlgEdit.MaxLength := len;
  try
    if mbCancel in DlgButtons then begin
      DMsgDlgCancel.Left := lx;
      DMsgDlgCancel.Top := ly;
      DMsgDlgCancel.Visible := True;
      lx := lx - 92;
    end;
    if mbNo in DlgButtons then begin
      DMsgDlgNo.Left := lx;
      DMsgDlgNo.Top := ly;
      DMsgDlgNo.Visible := True;
      lx := lx - 92;
    end;
    if mbYes in DlgButtons then begin
      DMsgDlgYes.Left := lx;
      DMsgDlgYes.Top := ly;
      DMsgDlgYes.Visible := True;
      lx := lx - 92;
    end;
    if (mbOk in DlgButtons) or (lx = XBase) then begin
      DMsgDlgOk.Left := lx;
      DMsgDlgOk.Top := ly;
      DMsgDlgOk.Visible := True;
      lx := lx - 92;
    end;
    HideAllControls;
    DMsgDlg.ShowModal;

    if mbAbort in DlgButtons then begin
      ViewDlgEdit := True;
      DMsgDlg.Floating := False;
      with DxDlgEdit do begin
        Text := deftext;
        //Width := DMsgDlg.Width - 70;
        //Left := (SCREENWIDTH - DxDlgEdit.Width) div 2;
        //Top := (SCREENHEIGHT - DxDlgEdit.Height) div 2 - 10;
      end;
    end;
    Result := mrOk;

    while True do begin
      if not DMsgDlg.Visible then Break;
      frmMain.ProcOnIdle;
      Application.ProcessMessages;
      if m_nDiceCount > 0 then begin
        m_boPlayDice := True;
        for i := 0 to m_nDiceCount - 1 do begin
          m_Dice[i].nX := ((DMsgDlg.Width div 2 + 6) - ((m_nDiceCount * 32 + m_nDiceCount) div 2)) + (i * 32 + i);
          m_Dice[i].nY := DMsgDlg.Height div 2 - 14;
        end;
        ShowDice();
      end;
      if Application.Terminated then Exit;
    end;
  finally
    DxDlgEdit.Visible := False;
    RestoreHideControls;
    DlgEditText := DxDlgEdit.Text;
    if FrmDlg.DEdChat.Visible then FrmDlg.DEdChat.SetFocus;
    ViewDlgEdit := False;
    Result := DMsgDlg.DialogResult;
    DialogSize := 1;
    m_nDiceCount := 0;
    m_boPlayDice := False;

    DxDlgEdit.Text := ''; //Clear;
    DxDlgEdit.MaxLength := MaxLen;
    //SetWindowLong(EdDlgEdit.Handle, GWL_STYLE, ln);
    DxDlgEdit.NomberOnly := inputstat;
  end;
end;

procedure TFrmDlg.DMsgDlgOkClick(Sender: TObject; X, Y: Integer);
begin
  if Sender = DMsgDlgOk then DMsgDlg.DialogResult := mrOk;
  if Sender = DMsgDlgYes then DMsgDlg.DialogResult := mrYes;
  if Sender = DMsgDlgCancel then DMsgDlg.DialogResult := mrCancel;
  if Sender = DMsgDlgNo then DMsgDlg.DialogResult := mrNo;
  DMsgDlg.Visible := False;
end;

procedure TFrmDlg.DMsgDlgKeyDown(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin
  if Key = 13 then begin
    if DMsgDlgOk.Visible {and not (DMsgDlgYes.Visible or DMsgDlgCancel.Visible or DMsgDlgNo.Visible)} then begin
      DMsgDlg.DialogResult := mrOk;
      DMsgDlg.Visible := False;
    end;
    if DMsgDlgYes.Visible {and not (DMsgDlgOk.Visible or DMsgDlgCancel.Visible or DMsgDlgNo.Visible)} then begin
      DMsgDlg.DialogResult := mrYes;
      DMsgDlg.Visible := False;
    end;
  end;
  if Key = 27 then begin
    if DMsgDlgCancel.Visible then begin
      DMsgDlg.DialogResult := mrCancel;
      DMsgDlg.Visible := False;
    end;
    if DMsgDlgNo.Visible then begin
      DMsgDlg.DialogResult := mrNo;
      DMsgDlg.Visible := False;
    end;
  end;
end;

procedure TFrmDlg.DMsgDlgOkDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
begin
  with Sender as TDButton do begin
    if not Downed then
      d := WLib.Images[FaceIndex]
    else
      d := WLib.Images[FaceIndex + 1];
    if d <> nil then dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
  end;
end;

procedure TFrmDlg.DMsgDlgDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  i: Integer;
  d: TCustomLockableTexture;
  ly: Integer;
  Str, data: string;
  nX, nY: Integer;
begin
  d := nil;
  with Sender as TDWindow do begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);

    if m_boPlayDice then begin
      for i := 0 to m_nDiceCount - 1 do begin
        //d := g_WBagItemImages.GetCachedImage(m_Dice[i].nPlayPoint + 376 - 1, nX, nY);
        d := frmMain.GetWBagItemImg(m_Dice[i].nPlayPoint + 376 - 1, nX, nY);
        if d <> nil then begin
          dsurface.Draw(SurfaceX(Left) + m_Dice[i].nX + nX - 14, SurfaceY(Top) + m_Dice[i].nY + nY + 38, d.ClientRect, d, True);
        end;
      end;
    end;

    ly := msgly;
    Str := MsgText;
    while True do begin
      if Str = '' then Break;
      Str := GetValidStr3(Str, data, ['\']);
      if data <> '' then
        dsurface.BoldTextOut(SurfaceX(Left + msglx), SurfaceY(Top + ly), clWhite, clBlack, data);
      ly := ly + 14;
    end;
  end;
  if ViewDlgEdit then begin
    if not DxDlgEdit.Visible then begin
      DxDlgEdit.Visible := True;
      DxDlgEdit.SetFocus;
    end;
  end;
end;

procedure TFrmDlg.DLoginNewDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
begin
  d := nil;
  with Sender as TDButton do begin

    {if (DLoginOk = Sender) then begin
      d := g_cbohum3.GetCachedSurface(16940);
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    end;}

    if TDButton(Sender).Downed then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    end;
  end;
end;

procedure TFrmDlg.DLoginNewClick(Sender: TObject; X, Y: Integer);
begin
  //FrmDlg.DMessageDlg('[提示]：请用登陆器上的“注册帐号”注册ID', [mbOk]);
  LoginScene.NewClick;
end;

procedure TFrmDlg.DLoginOkClick(Sender: TObject; X, Y: Integer);
begin
    LoginScene.OkClick;
end;

procedure TFrmDlg.DLoginCloseClick(Sender: TObject; X, Y: Integer);
var
  nLeft, nTop: Integer;
begin
  frmMain.Close;
end;

procedure TFrmDlg.DListBoxSSkillDirectPaint(Sender: TObject;
  dsurface: TCustomCanvas);
var
  fy, nY, L, T, i, oSize: Integer;
  OldColor: TColor;
  d: TCustomLockableTexture;
begin
  d := nil;
  with DListBoxSSkill do begin
    L := SurfaceX(Left);
    T := SurfaceY(Top);
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(L, T, d.ClientRect, d, True);

    with dsurface do begin //连击技能不显示名字
      try
        L := L + 3;
        T := T + 3;
        OldColor := Font.Color;
        oSize := Font.Size;
        Font.Color := clYellow;
        Font.Size := 9;
        Brush.Color := SelectionColor;
        if FSelected <> -1 then begin
          nY := T + (-Font.Height + LineSpace) * FSelected;
          fy := nY + (-Font.Height + LineSpace);
          if (nY < T + Height - 1) and (fy > T + 1) then begin
            if (fy > T + Height - 1) then fy := T + Height - 1;
            if (nY < T + 1) then nY := T + 1;
            FillRect(IntRectBDS(L, nY - 1, Width - 6, (-Font.Height + LineSpace)), clBlue);
          end;
        end;
        Brush.Style := bsClear;
        for i := 0 to g_SeriesSkillSelList.Count - 1 do
          TextOut(L + 2, 1 + T + (-Font.Height + LineSpace) * i, g_SeriesSkillSelList.Strings[i]);
        Font.Color := OldColor;
        Font.Size := oSize;
      finally

      end;
    end;
  end;
end;

procedure TFrmDlg.DListBoxSSkillChangeSelect2(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
  TmpSel: Integer;
begin
  with Sender as TDx9CustomListBox do begin

    TmpSel := FSelected;

    if (g_SeriesSkillSelList.Count = 0) then
      FSelected := -1
    else
      FSelected := (-Top + Y) div (-Font.Height + LineSpace);

    if FSelected > g_SeriesSkillSelList.Count - 1 then
      FSelected := -1;

    if (FSelected <> -1) and (tag in [0..High(TSeriesSkillArr)]) then begin
      frmMain.SendSetSeriesSkill(tag, Integer(g_SeriesSkillSelList.Objects[FSelected]), 0);
    end;

  end;
end;

procedure TFrmDlg.DHListBoxSSkillChangeSelect2(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
  TmpSel: Integer;
begin
  with Sender as TDx9CustomListBox do begin

    TmpSel := FSelected;

    if (g_hSeriesSkillSelList.Count = 0) then
      FSelected := -1
    else
      FSelected := (-Top + Y) div (-Font.Height + LineSpace);

    if FSelected > g_hSeriesSkillSelList.Count - 1 then
      FSelected := -1;

    if (FSelected <> -1) and (tag in [0..High(TSeriesSkillArr)]) then begin
      frmMain.SendSetSeriesSkill(tag, Integer(g_hSeriesSkillSelList.Objects[FSelected]), 1);
    end;

  end;
end;

procedure TFrmDlg.DListBoxSSkillMouseMove2(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  TmpSel: Integer;
begin
  with Sender as TDx9CustomListBox do begin
    TmpSel := FSelected;
    if (g_SeriesSkillSelList.Count = 0) then
      FSelected := -1
    else
      FSelected := (-Top + Y) div (-Font.Height + LineSpace);
    if FSelected > g_SeriesSkillSelList.Count - 1 then
      FSelected := -1;
  end;
end;

procedure TFrmDlg.DHListBoxSSkillMouseMove2(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  TmpSel: Integer;
begin
  with Sender as TDx9CustomListBox do begin
    TmpSel := FSelected;
    if (g_hSeriesSkillSelList.Count = 0) then
      FSelected := -1
    else
      FSelected := (-Top + Y) div (-Font.Height + LineSpace);
    if FSelected > g_hSeriesSkillSelList.Count - 1 then
      FSelected := -1;
  end;
end;

procedure TFrmDlg.DLoginChgPwClick(Sender: TObject; X, Y: Integer);
begin
  LoginScene.ChgPwClick;
end;

procedure TFrmDlg.DLoginNewClickSound(Sender: TObject;
  Clicksound: TClickSound);
begin
  case Clicksound of
    csNorm: g_SndMgr.PlaySound(s_norm_button_click);
    csStone: g_SndMgr.PlaySound(s_rock_button_click);
    csGlass: g_SndMgr.PlaySound(s_glass_button_click);
  end;
end;

procedure TFrmDlg.ShowSelectServerDlg;
begin
  case g_ServerList.Count of
    1: begin
        DSServer1.Visible := True;
        DSServer1.Top := 204;
        DSServer2.Visible := False;
        DSServer3.Visible := False;
        DSServer4.Visible := False;
        DSServer5.Visible := False;
        DSServer6.Visible := False;
      end;
    2: begin
        DSServer1.Visible := True;
        DSServer1.Top := 190;
        DSServer2.Visible := True;
        DSServer2.Top := 235;
        DSServer3.Visible := False;
        DSServer4.Visible := False;
        DSServer5.Visible := False;
        DSServer6.Visible := False;
      end;
    3: begin
        DSServer1.Visible := True;
        DSServer2.Visible := True;
        DSServer3.Visible := True;
        DSServer4.Visible := False;
        DSServer5.Visible := False;
        DSServer6.Visible := False;
      end;
    4: begin
        DSServer1.Visible := True;
        DSServer2.Visible := True;
        DSServer3.Visible := True;
        DSServer4.Visible := True;
        DSServer5.Visible := False;
        DSServer6.Visible := False;
      end;
    5: begin
        DSServer1.Visible := True;
        DSServer2.Visible := True;
        DSServer3.Visible := True;
        DSServer4.Visible := True;
        DSServer5.Visible := True;
        DSServer6.Visible := False;
      end;
    6: begin
        DSServer1.Visible := True;
        DSServer2.Visible := True;
        DSServer3.Visible := True;
        DSServer4.Visible := True;
        DSServer5.Visible := True;
        DSServer6.Visible := True;
      end;
  else begin
      DSServer1.Visible := True;
      DSServer2.Visible := True;
      DSServer3.Visible := True;
      DSServer4.Visible := True;
      DSServer5.Visible := True;
      DSServer6.Visible := True;
    end;
  end;
  DSelServerDlg.Visible := True;
end;

procedure TFrmDlg.DSServer1Click(Sender: TObject; X, Y: Integer);
var
  svname: string;
begin
  svname := '';
  if Sender = DSServer1 then begin
    svname := g_ServerList.Strings[0];
    g_sServerMiniName := svname;
  end;
  if Sender = DSServer2 then begin //辑滚 4锅..
    svname := g_ServerList.Strings[1];
    g_sServerMiniName := svname;
  end;
  if Sender = DSServer3 then begin //辑滚 1锅..
    svname := g_ServerList.Strings[2];
    g_sServerMiniName := svname;
  end;
  if Sender = DSServer4 then begin //辑滚 2锅..
    svname := g_ServerList.Strings[3];
    g_sServerMiniName := svname;
  end;
  if Sender = DSServer5 then begin //辑滚 3锅..
    svname := g_ServerList.Strings[4];
    g_sServerMiniName := svname;
  end;
  if Sender = DSServer6 then begin
    svname := g_ServerList.Strings[5];
    g_sServerMiniName := svname;
  end;
  if svname <> '' then begin
    frmMain.SendSelectServer(svname);
    DSelServerDlg.Visible := False;
    g_sServerName := svname;
    Application.Title := g_sServerName;
    frmMain.Caption := g_sServerName;
//    Application.Title := g_sServerName + '程序定制QQ5608395';
//    frmMain.Caption := g_sServerName + ' - 程序定制QQ5608395';
  end;
end;

procedure TFrmDlg.DEngServer1Click(Sender: TObject; X, Y: Integer);
var
  svname: string;
begin
  svname := 'LegendSoft';
  g_sServerMiniName := 'LegendSoft';
  if svname <> '' then begin
    frmMain.SendSelectServer(svname);
    DSelServerDlg.Visible := False;
    g_sServerName := svname;
  end;
end;

procedure TFrmDlg.DSSrvCloseClick(Sender: TObject; X, Y: Integer);
begin
  DSelServerDlg.Visible := False;
  frmMain.Close;
end;

procedure TFrmDlg.DNewAccountOkClick(Sender: TObject; X, Y: Integer);
begin
  LoginScene.NewAccountOk;
end;

procedure TFrmDlg.DNewAccountCloseClick(Sender: TObject; X, Y: Integer);
begin
  LoginScene.NewAccountClose;
end;

procedure TFrmDlg.DNewAccountDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
  i: Integer;
begin
  d := nil;
  with Canvas do begin
    with DNewAccount do begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    end;

    for i := 0 to NAHelps.Count - 1 do begin
      dsurface.TextOut((SCREENWIDTH div 2 - 320) + 386 + 10, (SCREENHEIGHT div 2 - 238) + 119 + 5 + i * 14, NAHelps[i], clSilver);
    end;
    dsurface.BoldTextOut(79 + 283, 64 + 57, clWhite, clBlack, NewAccountTitle);
  end;
end;

procedure TFrmDlg.DChgpwOkClick(Sender: TObject; X, Y: Integer);
begin
  if Sender = DChgpwOk then LoginScene.ChgpwOk;
  if Sender = DChgpwCancel then LoginScene.ChgpwCancel;
end;

procedure TFrmDlg.DscSelect1DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
begin
  d := nil;
  with Sender as TDButton do begin
    if Downed then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(Left, Top, d.ClientRect, d, True);
    end;
  end;
end;

var
  g_dwDscStartTick: LongWord;

procedure TFrmDlg.DscStartDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
begin
  d := nil;

 {$IF Var_UI = Var_176}
  with Sender as TDButton do begin
    if Downed then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(Left, Top, d.ClientRect, d, True);
    end;
  end;
  {$ELSE}
  with Sender as TDButton do begin
    if (FrmDlg.DscStart.tag > 0) and g_ReSelChr and (GetTickCount - g_dwDscStartTick > 120) then begin
      g_dwDscStartTick := GetTickCount;
      DscStart.tag := DscStart.tag - 1;
    end;
    if DscStart.tag = 0 then DscStart.OnbtnState := tnor;
       d := WLib.Images[FaceIndex + byte(Downed)];

    if d <> nil then begin
      if DscStart.tag = 0 then begin
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
      end else begin
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
        dsurface.FillRectAlpha(IntRect(SurfaceX(Left),SurfaceY(Top) + d.Height - DscStart.tag, d.Width, d.Height + DscStart.tag - d.Height),clBlack,170);
      end;
    end;
  end;
 {$IFEND}
end;

procedure TFrmDlg.DscSelect1Click(Sender: TObject; X, Y: Integer);
begin
  if Sender = DscSelect1 then SelectChrScene.SelChrSelect1Click;
  if Sender = DscSelect2 then SelectChrScene.SelChrSelect2Click;
  if Sender = DscStart then SelectChrScene.SelChrStartClick;
  if Sender = DscNewChr then SelectChrScene.SelChrNewChrClick;
  if Sender = DscEraseChr then SelectChrScene.SelChrEraseChrClick;
  if Sender = DscCredits then SelectChrScene.SelChrCreditsClick;
  if Sender = DscExit then SelectChrScene.SelChrExitClick;
end;

procedure TFrmDlg.DccCloseDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
begin
  d := nil;
  with Sender as TDButton do begin
    {if Sender = DBYBDealDlgClose then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    end;}
    if Downed then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    end else begin
      {if Sender = DBMissionsClose then begin
        d := WLib.Images[FaceIndex];
        if d <> nil then
          dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
        exit;
      end;}
      d := nil;
      if Sender = DccWarrior then begin
        with SelectChrScene do
          if ChrArr[NewIndex].UserChr.job = 0 then d := WLib.Images[55];
      end;
      if Sender = DccWizzard then begin
        with SelectChrScene do
          if ChrArr[NewIndex].UserChr.job = 1 then d := WLib.Images[56];
      end;
      if Sender = DccMonk then begin
        with SelectChrScene do
          if ChrArr[NewIndex].UserChr.job = 2 then d := WLib.Images[57];
      end;
      if Sender = DccMale then begin
        with SelectChrScene do
          if ChrArr[NewIndex].UserChr.sex = 0 then d := WLib.Images[58];
      end;
      if Sender = DccFemale then begin
        with SelectChrScene do
          if ChrArr[NewIndex].UserChr.sex = 1 then d := WLib.Images[59];
      end;
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    end;
  end;
end;

procedure TFrmDlg.DccCloseClick(Sender: TObject; X, Y: Integer);
begin
  if Sender = DccClose then SelectChrScene.SelChrNewClose;
  if Sender = DccWarrior then SelectChrScene.SelChrNewJob(0);
  if Sender = DccWizzard then SelectChrScene.SelChrNewJob(1);
  if Sender = DccMonk then SelectChrScene.SelChrNewJob(2);
  if Sender = DccReserved then SelectChrScene.SelChrNewJob(3);
  if Sender = DccMale then SelectChrScene.SelChrNewm_btSex(0);
  if Sender = DccFemale then SelectChrScene.SelChrNewm_btSex(1);
  if Sender = DccLeftHair then SelectChrScene.SelChrNewPrevHair;
  if Sender = DccRightHair then SelectChrScene.SelChrNewNextHair;
  if Sender = DccOk then SelectChrScene.SelChrNewOk;
end;

procedure TFrmDlg.DStateWinDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  i, L, M, pgidx, magline, bbx, bby, mmx, idx, ax, ay, trainlv, FontColor: Integer;
  pm: PTClientMagic;
  d: TCustomLockableTexture;
  nl, hcolor, old, keyimg: Integer;
  iname, d1, d2, d3, d4: string;
  useable: Boolean;
  rc: TIntRect;
begin
  d := nil;
  if g_Myself = nil then
    Exit;
  with DStateWin do begin
{$IFDEF UI_0508}
    if not g_Myself.n_boState then begin
      if StatePage <> 1 then
        d := WLib.Images[800]
      else
        d := WLib.Images[806];
    end else begin
      d := WLib.Images[800];
    end;
    if d <> nil then dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);

    DBStateDirectPaint(DBState, dsurface);

    if g_Myself.m_nIPowerLvl > 0 then begin
      d := g_WMain2Images.Images[744 + Integer(g_Myself.n_boState)];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left + 41), SurfaceY(Top + 30), d.ClientRect, d, True);
    end;

    if not g_Myself.n_boState then begin
      case StatePage of
        0: begin
            if g_Myself.m_btSex = 1 then
              pgidx := 30
            else
              pgidx := 29;
            bbx := Left + 38;
            bby := Top + 50;
            d := g_WMain3Images.Images[pgidx];
            if d <> nil then
              dsurface.Draw(SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, False);
            bbx := bbx - 7;
            bby := bby + 44;

            if g_Myself.m_btHairEx <= 0 then begin
              idx := 440 + g_Myself.m_btHair div 2 + g_Myself.m_btSex;
              if idx > 0 then begin
                d := g_WMainImages.GetCachedImage(idx, ax, ay);
                if d <> nil then
                  dsurface.Draw(SurfaceX(bbx + ax), SurfaceY(bby + ay), d.ClientRect, d, True);
              end;
            end;

            if g_UseItems[U_DRESS].s.Name <> '' then begin
              idx := g_UseItems[U_DRESS].s.looks;
              if idx >= 0 then begin
                d := frmMain.GetWStateImg(idx, ax, ay);
                if d <> nil then
                  dsurface.Draw(SurfaceX(bbx + ax), SurfaceY(bby + ay), d.ClientRect, d, True);

                if g_UseItems[U_DRESS].s.reserve[3] = 1 then begin
                  d := frmMain.GetWStateImg(2425 + g_Myself.m_btSex, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end;
                if g_UseItems[U_DRESS].s.reserve[3] = 2 then begin
                  d := frmMain.GetWStateImg(2541 + g_Myself.m_btSex * 2, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end;
                if g_UseItems[U_DRESS].s.reserve[3] = 3 then begin

                  if GetTickCount - g_sDressEffectTick > 200 then begin
                    g_sDressEffectTick := GetTickCount;
                    Inc(g_sDressEffectIdx);
                    if g_sDressEffectIdx >= 20 then
                      g_sDressEffectIdx := 0;
                  end;

                  d := frmMain.GetWStateImg(2600 + g_sDressEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end;
                if g_UseItems[U_DRESS].s.reserve[3] = 4 then begin

                  if GetTickCount - g_sDressEffectTick > 200 then begin
                    g_sDressEffectTick := GetTickCount;
                    Inc(g_sDressEffectIdx);
                    if g_sDressEffectIdx >= 10 then
                      g_sDressEffectIdx := 0;
                  end;

                  if g_Myself.m_btSex = 0 then
                    d := frmMain.GetWStateImg(3550 + g_sDressEffectIdx, ax, ay)
                  else
                    d := frmMain.GetWStateImg(3570 + g_sDressEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end;
                if g_UseItems[U_DRESS].s.reserve[3] = 5 then begin

                  if GetTickCount - g_sDressEffectTick > 200 then begin
                    g_sDressEffectTick := GetTickCount;
                    Inc(g_sDressEffectIdx);
                    if g_sDressEffectIdx >= 8 then
                      g_sDressEffectIdx := 0;
                  end;

                  if g_Myself.m_btSex = 0 then
                    d := frmMain.GetWStateImg(3680 + g_sDressEffectIdx, ax, ay)
                  else
                    d := frmMain.GetWStateImg(3690 + g_sDressEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if g_UseItems[U_DRESS].s.reserve[3] = 6 then begin
                  if GetTickCount - g_hDressEffectTick > 200 then begin
                    g_hDressEffectTick := GetTickCount;
                    Inc(g_hDressEffectIdx);
                    if g_hDressEffectIdx >= 8 then
                      g_hDressEffectIdx := 0;
                  end;
                  d := frmMain.GetWStateImg(3800 + g_hDressEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if g_UseItems[U_DRESS].s.reserve[3] = 7 then begin
                  if GetTickCount - g_hDressEffectTick > 200 then begin
                    g_hDressEffectTick := GetTickCount;
                    Inc(g_hDressEffectIdx);
                    if g_hDressEffectIdx >= 9 then
                      g_hDressEffectIdx := 0;
                  end;
                  if g_Myself.m_btSex = 0 then
                    d := frmMain.GetWStateImg(3950 + g_hDressEffectIdx, ax, ay)
                  else
                    d := frmMain.GetWStateImg(3959 + g_hDressEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if g_UseItems[U_DRESS].s.reserve[3] = 8 then begin
                  if GetTickCount - g_hDressEffectTick > 200 then begin
                    g_hDressEffectTick := GetTickCount;
                    Inc(g_hDressEffectIdx);
                    if g_hDressEffectIdx >= 10 then
                      g_hDressEffectIdx := 0;
                  end;
                  if g_Myself.m_btSex = 0 then
                    d := frmMain.GetWStateImg(3968 + g_hDressEffectIdx, ax, ay)
                  else
                    d := frmMain.GetWStateImg(3978 + g_hDressEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if g_UseItems[U_DRESS].s.reserve[3]  in [100..249] then begin  //自定义特效四格 衣服  看自己

                  if GetTickCount - g_hDressEffectTick > 200 then begin
                    g_hDressEffectTick := GetTickCount;
                    Inc(g_hDressEffectIdx);
                    if g_hDressEffectIdx >= 20 then
                      g_hDressEffectIdx := 0;
                  end;
                  d := frmMain.GetWStateImg(30000 + (g_UseItems[U_DRESS].s.reserve[3]+1 - 100) * 20-20 + g_hDressEffectIdx, ax, ay);
                  if d = nil then begin
                    g_hDressEffectIdx := 0;
                    d := frmMain.GetWStateImg(30000 + (g_UseItems[U_DRESS].s.reserve[3]+1 - 100) * 20-20 + g_hDressEffectIdx, ax, ay);
                  end;
                  if d <> nil then begin
                     dsurface.DrawBlend(SurfaceX(bbx + ax), SurfaceY(bby + ay), d, 1);
                  end;

                end;
              end;
            end;
            if g_UseItems[U_WEAPON].s.Name <> '' then begin
              idx := g_UseItems[U_WEAPON].s.looks;
              if idx >= 0 then begin
                d := frmMain.GetWStateImg(idx, ax, ay);
                if d <> nil then
                  dsurface.Draw(SurfaceX(bbx + ax), SurfaceY(bby + ay), d.ClientRect, d, True);

                if g_UseItems[U_WEAPON].s.reserve[3] = 3 then begin
                  d := frmMain.GetWStateImg(2427, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if g_UseItems[U_WEAPON].s.reserve[3] = 1 then begin
                  d := frmMain.GetWStateImg(1403, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if (g_UseItems[U_WEAPON].s.reserve[3] = 2) {and (idx = 1880)} then begin
                  if GetTickCount - g_sWeaponEffectTick > 200 then begin
                    g_sWeaponEffectTick := GetTickCount;
                    Inc(g_sWeaponEffectIdx);
                    if g_sWeaponEffectIdx > 9 then
                      g_sWeaponEffectIdx := 0;
                  end;

                  d := frmMain.GetWStateImg(1890 + g_sWeaponEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if (g_UseItems[U_WEAPON].s.reserve[3] = 4) then begin
                  //if (idx = 2523) then begin
                  if GetTickCount - g_sWeaponEffectTick > 200 then begin
                    g_sWeaponEffectTick := GetTickCount;
                    Inc(g_sWeaponEffectIdx);
                    if g_sWeaponEffectIdx > 7 then
                      g_sWeaponEffectIdx := 0;
                  end;

                  d := frmMain.GetWStateImg(2530 + g_sWeaponEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                  //end;
                end else if (g_UseItems[U_WEAPON].s.reserve[3] = 5) then begin
                  //if (idx = 2524) then begin
                  if GetTickCount - g_sWeaponEffectTick > 200 then begin
                    g_sWeaponEffectTick := GetTickCount;
                    Inc(g_sWeaponEffectIdx);
                    if g_sWeaponEffectIdx > 9 then
                      g_sWeaponEffectIdx := 0;
                  end;

                  d := frmMain.GetWStateImg(2550 + g_sWeaponEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                  //end;
                end else if (g_UseItems[U_WEAPON].s.reserve[3] = 6) then begin
                  //if (idx = 2525) then begin
                  if GetTickCount - g_sWeaponEffectTick > 200 then begin
                    g_sWeaponEffectTick := GetTickCount;
                    Inc(g_sWeaponEffectIdx);
                    if g_sWeaponEffectIdx > 9 then
                      g_sWeaponEffectIdx := 0;
                  end;

                  d := frmMain.GetWStateImg(2560 + g_sWeaponEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                  //end;
                end else if (g_UseItems[U_WEAPON].s.reserve[3] in [7..9]) then begin
                  if GetTickCount - g_sWeaponEffectTick > 200 then begin
                    g_sWeaponEffectTick := GetTickCount;
                    Inc(g_sWeaponEffectIdx);
                    if g_sWeaponEffectIdx > 13 then
                      g_sWeaponEffectIdx := 0;
                  end;

                  d := frmMain.GetWStateImg(3480 + (g_UseItems[U_WEAPON].s.reserve[3] - 7) * 20 + g_sWeaponEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if (g_UseItems[U_WEAPON].s.reserve[3] in [10..12]) then begin
                  if GetTickCount - g_sWeaponEffectTick > 200 then begin
                    g_sWeaponEffectTick := GetTickCount;
                    Inc(g_sWeaponEffectIdx);
                    if g_sWeaponEffectIdx >= 18 then
                      g_sWeaponEffectIdx := 0;
                  end;

                  d := frmMain.GetWStateImg(3610 + (g_UseItems[U_WEAPON].s.reserve[3] - 10) * 20 + g_sWeaponEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if (g_UseItems[U_WEAPON].s.reserve[3] in [13..15]) then begin
                  if GetTickCount - g_sWeaponEffectTick > 200 then begin
                    g_sWeaponEffectTick := GetTickCount;
                    Inc(g_sWeaponEffectIdx);
                    if g_sWeaponEffectIdx >= 18 then
                      g_sWeaponEffectIdx := 0;
                  end;

                  d := frmMain.GetWStateImg(3820 + (g_UseItems[U_WEAPON].s.reserve[3] - 13) * 20 + g_sWeaponEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if (g_UseItems[U_WEAPON].s.reserve[3] in [16]) then begin
                  if GetTickCount - g_sWeaponEffectTick > 200 then begin
                    g_sWeaponEffectTick := GetTickCount;
                    Inc(g_sWeaponEffectIdx);
                    if g_sWeaponEffectIdx >= 16 then
                      g_sWeaponEffectIdx := 0;
                  end;

                  d := frmMain.GetWStateImg(2850 + g_sWeaponEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if (g_UseItems[U_WEAPON].s.reserve[3] in [100..249]) then begin //自定义特效四格 武器  看自己
                  if GetTickCount - g_sWeaponEffectTick > 200 then begin
                    g_sWeaponEffectTick := GetTickCount;
                    Inc(g_sWeaponEffectIdx);
                    if g_sWeaponEffectIdx >= 20 then
                      g_sWeaponEffectIdx := 0;
                  end;
                  d := frmMain.GetWStateImg(30000 + (g_UseItems[U_WEAPON].s.reserve[3]+1 - 100) * 20-20+g_sWeaponEffectIdx, ax, ay);
                  if d = nil then begin
                    g_sWeaponEffectIdx := 0;
                    d := frmMain.GetWStateImg(30000 + (g_UseItems[U_WEAPON].s.reserve[3]+1 - 100) * 20-20+g_sWeaponEffectIdx, ax, ay);
                  end;
                  if d <> nil then begin
                    dsurface.DrawBlend(SurfaceX(bbx + ax), SurfaceY(bby + ay), d, 1);
                  end;
                end;

              end;
            end;

            trainlv := 1;
            if g_UseItems[U_HELMETEX].s.Name <> '' then begin
              idx := g_UseItems[U_HELMETEX].s.looks;
              if idx >= 0 then begin
                if g_UseItems[U_HELMETEX].s.Source <> 0 then
                  trainlv := 1
                else
                  trainlv := 0;
                d := frmMain.GetWStateImg(idx, ax, ay);
                if d <> nil then
                  dsurface.Draw(SurfaceX(bbx + ax), SurfaceY(bby + ay), d.ClientRect, d, True);
              end;
            end;
            if (g_UseItems[U_HELMET].s.Name <> '') then begin
              idx := g_UseItems[U_HELMET].s.looks;
              if idx >= 0 then begin
                if (trainlv <> 0) then begin
                  d := frmMain.GetWStateImg(idx, ax, ay);
                  if d <> nil then
                    dsurface.Draw(SurfaceX(bbx + ax), SurfaceY(bby + ay), d.ClientRect, d, True);
                end;
                if (g_UseItems[U_HELMET].s.Shape = 190) or (g_UseItems[U_HELMET].s.reserve[3] = 4) then begin
                  if GetTickCount - g_UseItemsShine[U_HELMET].tick > 60 then begin
                    g_UseItemsShine[U_HELMET].tick := GetTickCount;
                    Inc(g_UseItemsShine[U_HELMET].idx);
                    if g_UseItemsShine[U_HELMET].idx > 31 then
                      g_UseItemsShine[U_HELMET].idx := 0;
                  end;
                  d := g_Wui.Images[220 + g_UseItemsShine[U_HELMET].idx];
                  if d <> nil then
                    dsurface.DrawBlend(SurfaceX(bbx + ax - 12), SurfaceY(bby + ay - 10), d, 1);
                end else if g_UseItems[U_HELMET].s.reserve[3] = 3 then begin
                  if GetTickCount - g_UseItemsShine[U_HELMET].tick > 100 then begin
                    g_UseItemsShine[U_HELMET].tick := GetTickCount;
                    Inc(g_UseItemsShine[U_HELMET].idx);
                    if g_UseItemsShine[U_HELMET].idx >= 10 then
                      g_UseItemsShine[U_HELMET].idx := 0;
                  end;
                  d := g_StateEffect.Images[580 + g_UseItemsShine[U_HELMET].idx];
                  if d <> nil then
                    dsurface.DrawBlend(SurfaceX(bbx + ax - d.Width div 4), SurfaceY(bby + ay - d.Height div 4), d, 1);
                end else if g_UseItems[U_HELMET].s.reserve[3] >= 100 then begin   //20200927四格头盔自己
                  if GetTickCount - g_UseItemsShine[U_HELMET].tick > 200 then begin
                    g_UseItemsShine[U_HELMET].tick := GetTickCount;
                    Inc(g_UseItemsShine[U_HELMET].idx);
                    if g_UseItemsShine[U_HELMET].idx > 19 then
                      g_UseItemsShine[U_HELMET].idx := 0;
                  end;
                  d := frmMain.GetWStateImg(30000 + (g_UseItems[U_HELMET].s.reserve[3]+1 - 100) * 20-20+ g_UseItemsShine[U_HELMET].idx);
                  if d = nil then begin
                    g_UseItemsShine[U_HELMET].idx := 0;
                    d := frmMain.GetWStateImg(30000 + (g_UseItems[U_HELMET].s.reserve[3]+1 - 100) * 20-20+g_UseItemsShine[U_HELMET].idx);
                  end;
                  if d <> nil then begin
                  dsurface.DrawBlend(SurfaceX(bbx + ax - 4 - d.Width div 4), SurfaceY(bby + ay - d.Height div 4), d, 1);
                  end;
                end;

              end;
            end;

            if g_Myself.m_btAttribute in [1..5] then begin
              with dsurface do begin
                case g_Myself.m_btAttribute of
                  1: FontColor := GetRGB(149);
                  2: FontColor := GetRGB(221);
                  3: FontColor := GetRGB(147);
                  4: FontColor := GetRGB(057);
                  5: FontColor := GetRGB(045);
                end;
                BoldTextOut(SurfaceX(Left + 170), SurfaceY(Top + 52), g_sHumAttr[g_Myself.m_btAttribute], FontColor, clBlack, [], 24, '隶书');
              end;
            end;

            //检测是否有斗笠
          end;
        1: begin
            L := Left + 110;
            M := Top + 96;
            with dsurface do begin
              FontColor := clWhite;
              TextOut(SurfaceX(L + 0), SurfaceY(M + 2), IntToStr(LoWord(g_Myself.m_Abil.AC)) + '-' + IntToStr(HiWord(g_Myself.m_Abil.AC)), FontColor);
              TextOut(SurfaceX(L + 0), SurfaceY(M + 22), IntToStr(LoWord(g_Myself.m_Abil.MAC)) + '-' + IntToStr(HiWord(g_Myself.m_Abil.MAC)), FontColor);
              TextOut(SurfaceX(L + 0), SurfaceY(M + 42), IntToStr(LoWord(g_Myself.m_Abil.DC)) + '-' + IntToStr(HiWord(g_Myself.m_Abil.DC)), FontColor);
              TextOut(SurfaceX(L + 0), SurfaceY(M + 62), IntToStr(LoWord(g_Myself.m_Abil.MC)) + '-' + IntToStr(HiWord(g_Myself.m_Abil.MC)), FontColor);
              TextOut(SurfaceX(L + 0), SurfaceY(M + 82), IntToStr(LoWord(g_Myself.m_Abil.SC)) + '-' + IntToStr(HiWord(g_Myself.m_Abil.SC)), FontColor);
              TextOut(SurfaceX(L + 0), SurfaceY(M + 102), IntToStr(g_Myself.m_Abil.HP) + '/' + IntToStr(g_Myself.m_Abil.MaxHP), FontColor);
              TextOut(SurfaceX(L + 0), SurfaceY(M + 122), IntToStr(g_Myself.m_Abil.MP) + '/' + IntToStr(g_Myself.m_Abil.MaxMP), FontColor);
            end;
          end;
        2: begin
            bbx := Left + 38;
            bby := Top + 50;
            d := g_WMain3Images.Images[32];
            if d <> nil then dsurface.Draw(SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, False);
            bbx := bbx + 20;
            bby := bby + 10;
            with dsurface do begin
              mmx := bbx + 75;
              FontColor := clSilver;
              TextOut(bbx, bby, '当前经验', FontColor);
              TextOut(mmx, bby, IntToStr(g_Myself.m_Abil.Exp), FontColor);
              TextOut(bbx, bby + 14 * 1, '升级经验', FontColor);
              TextOut(mmx, bby + 14 * 1, IntToStr(g_Myself.m_Abil.MaxExp), FontColor);

              TextOut(bbx, bby + 14 * 2, '背包重量', FontColor);
              if g_Myself.m_Abil.Weight > g_Myself.m_Abil.MaxWeight then FontColor := clRed;
              TextOut(mmx, bby + 14 * 2, IntToStr(g_Myself.m_Abil.Weight) + '/' + IntToStr(g_Myself.m_Abil.MaxWeight), FontColor);

              FontColor := clSilver;
              TextOut(bbx, bby + 14 * 3, '穿戴重量', FontColor);
              if g_Myself.m_Abil.WearWeight > g_Myself.m_Abil.MaxWearWeight then FontColor := clRed;
              TextOut(mmx, bby + 14 * 3, IntToStr(g_Myself.m_Abil.WearWeight) + '/' + IntToStr(g_Myself.m_Abil.MaxWearWeight), FontColor);

              FontColor := clSilver;
              TextOut(bbx, bby + 14 * 4, '腕力', FontColor);
              if g_Myself.m_Abil.HandWeight > g_Myself.m_Abil.MaxHandWeight then FontColor := clRed;
              TextOut(mmx, bby + 14 * 4, IntToStr(g_Myself.m_Abil.HandWeight) + '/' + IntToStr(g_Myself.m_Abil.MaxHandWeight), FontColor);

              FontColor := clSilver;
              TextOut(bbx, bby + 14 * 5, '准确度', FontColor);
              TextOut(mmx, bby + 14 * 5, IntToStr(g_nMyHitPoint), FontColor);

              TextOut(bbx, bby + 14 * 6, '敏捷度', FontColor);
              TextOut(mmx, bby + 14 * 6, IntToStr(g_nMySpeedPoint), FontColor);

              TextOut(bbx, bby + 14 * 7, '魔法躲避', FontColor);
              TextOut(mmx, bby + 14 * 7, '+' + IntToStr(g_nMyAntiMagic * 10) + '%', FontColor);

              TextOut(bbx, bby + 14 * 8, '毒物躲避', FontColor);
              TextOut(mmx, bby + 14 * 8, '+' + IntToStr(g_nMyAntiPoison * 10) + '%', FontColor);

              TextOut(bbx, bby + 14 * 9, '中毒恢复', FontColor);
              TextOut(mmx, bby + 14 * 9, '+' + IntToStr(g_nMyPoisonRecover * 10) + '%', FontColor);

              TextOut(bbx, bby + 14 * 10, '体力恢复', FontColor);
              TextOut(mmx, bby + 14 * 10, '+' + IntToStr(g_nMyHealthRecover * 10) + '%', FontColor);

              TextOut(bbx, bby + 14 * 11, '魔法恢复', FontColor);
              TextOut(mmx, bby + 14 * 11, '+' + IntToStr(g_nMySpellRecover * 10) + '%', FontColor);

              TextOut(bbx, bby + 14 * 12, '金刚石数', FontColor);
              TextOut(mmx, bby + 14 * 12, IntToStr(g_Myself.m_nGameDiamd), FontColor);

              TextOut(bbx, bby + 14 * 13, '灵符数量', FontColor);
              TextOut(mmx, bby + 14 * 13, IntToStr(g_Myself.m_nGameGird), FontColor);

              FontColor := clYellow;
              TextOut(bbx, bby + 14 * 14, '元宝数量', FontColor);
              TextOut(mmx, bby + 14 * 14, IntToStr(g_Myself.m_nGameGold), FontColor);

              FontColor := clSilver;
              TextOut(bbx, bby + 14 * 15, '内力恢复', FontColor);
              TextOut(mmx, bby + 14 * 15, IntToStr(g_nMyIPowerRecover), FontColor);
            end;
          end;
        3: begin //魔法
            bbx := Left + 38;
            bby := Top + 50;
            d := g_WMain2Images.Images[743]; //g_WMain3Images.Images[33];
            if d <> nil then begin
              rc := d.ClientRect;
//              Dec(rc.Right, 3);
//              Dec(rc.Bottom, 4);
              dsurface.Draw(SurfaceX(bbx), SurfaceY(bby), rc, d, False);
            end;
            m_nMagTop := MagicPage * 6;
            magline := _MIN(MagicPage * 6 + 6, g_MagicList.Count);
            for i := m_nMagTop to magline - 1 do begin
              pm := PTClientMagic(g_MagicList[i]);
              M := i - m_nMagTop;
              keyimg := 0;
              case byte(pm.Key) of
                byte('E'): keyimg := 148;
                byte('F'): keyimg := 149;
                byte('G'): keyimg := 150;
                byte('H'): keyimg := 151;
                byte('I'): keyimg := 152;
                byte('J'): keyimg := 153;
                byte('K'): keyimg := 154;
                byte('L'): keyimg := 155;
                byte('1'): keyimg := 156;
                byte('2'): keyimg := 157;
                byte('3'): keyimg := 158;
                byte('4'): keyimg := 159;
                byte('5'): keyimg := 160;
                byte('6'): keyimg := 161;
                byte('7'): keyimg := 162;
                byte('8'): keyimg := 163;
              end;
              if keyimg > 0 then begin
                d := g_WMain3Images.Images[keyimg];
                if d <> nil then
                  dsurface.Draw(bbx + 145, bby + 8 + M * 37, d.ClientRect, d, True);
              end;
              d := g_WMainImages.Images[112]; //Level
              if d <> nil then
                dsurface.Draw(bbx + 48, bby + 8 + 15 + M * 37, d.ClientRect, d, True);
              d := g_WMainImages.Images[111]; //exp
              if d <> nil then
                dsurface.Draw(bbx + 48 + 26, bby + 8 + 15 + M * 37, d.ClientRect, d, True);
            end;

            with dsurface do begin
              FontColor := clSilver;
              for i := m_nMagTop to magline - 1 do begin
                pm := PTClientMagic(g_MagicList[i]);
                M := i - m_nMagTop;
                TextOut(bbx + 48, bby + 8 + M * 37, pm.Def.sMagicName, FontColor);
                trainlv := _MIN(14, pm.Level);
                TextOut(bbx + 48 + 16, bby + 8 + 15 + M * 37, IntToStr(pm.Level), FontColor);
                if pm.Def.MaxTrain[trainlv] > 0 then begin
                  if trainlv < pm.Def.btTrainLv then
                    TextOut(bbx + 48 + 46, bby + 8 + 15 + M * 37, IntToStr(pm.CurTrain) + '/' + IntToStr(pm.Def.MaxTrain[trainlv]), FontColor)
                  else
                    TextOut(bbx + 48 + 46, bby + 8 + 15 + M * 37, '-', FontColor);
                end;
              end;
            end;
          end;
      end;
    end else if g_Myself.m_nIPowerLvl > 0 then begin
      case m_nIPStatePage of
        0: begin
            bbx := Left + 38;
            bby := Top + 50;
            d := g_WMain2Images.Images[741];
            if d <> nil then begin
              rc := d.ClientRect;
//              Dec(rc.Right, 3);
//              Dec(rc.Bottom, 1);
              dsurface.Draw(SurfaceX(bbx), SurfaceY(bby), rc, d, False);
            end;
            d := g_WMain2Images.Images[752];
            if d <> nil then begin
              dsurface.Draw(SurfaceX(bbx + 87), SurfaceY(bby + 50 + 27 * 0), rc, d, False);
              dsurface.Draw(SurfaceX(bbx + 87), SurfaceY(bby + 50 + 27 * 1), rc, d, False);
              dsurface.Draw(SurfaceX(bbx + 87), SurfaceY(bby + 50 + 27 * 2), rc, d, False);
              dsurface.Draw(SurfaceX(bbx + 87), SurfaceY(bby + 50 + 27 * 3), rc, d, False);
              dsurface.Draw(SurfaceX(bbx + 87), SurfaceY(bby + 50 + 27 * 4), rc, d, False);
              dsurface.Draw(SurfaceX(bbx + 87), SurfaceY(bby + 50 + 27 * 5), rc, d, False);
              dsurface.Draw(SurfaceX(bbx + 87), SurfaceY(bby + 50 + 27 * 6), rc, d, False);
            end;
            L := Left + 48;
            M := Top + 105;
            dsurface.BoldTextOut( SurfaceX(L + 00), SurfaceY(M + 27 * 0), clSilver, clBlack, '当前内功等级');
            dsurface.BoldTextOut( SurfaceX(L + 00), SurfaceY(M + 27 * 1), clSilver, clBlack, '当前内功经验');
            dsurface.BoldTextOut( SurfaceX(L + 00), SurfaceY(M + 27 * 2), clSilver, clBlack, '升级所需经验');
            dsurface.BoldTextOut( SurfaceX(L + 00), SurfaceY(M + 27 * 3), clSilver, clBlack, '内   力   值');
            dsurface.BoldTextOut( SurfaceX(L + 00), SurfaceY(M + 27 * 4), clSilver, clBlack, '内功恢复速度');
            dsurface.BoldTextOut( SurfaceX(L + 00), SurfaceY(M + 27 * 5), clSilver, clBlack, '内功增加伤害');
            dsurface.BoldTextOut( SurfaceX(L + 00), SurfaceY(M + 27 * 6), clSilver, clBlack, '内功减免伤害');
            with dsurface do begin
              FontColor := clSilver;
              TextOut(SurfaceX(L + 83), SurfaceY(M + 27 * 0 - 1), IntToStr(g_Myself.m_nIPowerLvl), FontColor);
              TextOut(SurfaceX(L + 83), SurfaceY(M + 27 * 1 - 1), IntToStr(g_Myself.m_nIPowerExp), FontColor);
              TextOut(SurfaceX(L + 83), SurfaceY(M + 27 * 2 - 1), IntToStr(g_dwIPNeedInfo[g_Myself.m_nIPowerLvl].dwPExp), FontColor);
              TextOut(SurfaceX(L + 83), SurfaceY(M + 27 * 3 - 1), Format('%d/%d', [g_Myself.m_nIPower, g_dwIPNeedInfo[g_Myself.m_nIPowerLvl].nPower]), FontColor);
              TextOut(SurfaceX(L + 83), SurfaceY(M + 27 * 4 - 1), IntToStr(g_nMyIPowerRecover), FontColor);
              TextOut(SurfaceX(L + 83), SurfaceY(M + 27 * 5 - 1), IntToStr(g_nMyAddDamage), FontColor);
              TextOut(SurfaceX(L + 83), SurfaceY(M + 27 * 6 - 1), IntToStr(g_nMyDecDamage), FontColor);
            end;
          end;
        1: begin
            bbx := Left + 38;
            bby := Top + 50;
            d := g_WMain2Images.Images[743]; //g_WMain3Images.Images[33];
            if d <> nil then begin
              rc := d.ClientRect;
//              Dec(rc.Right, 3);
//              Dec(rc.Bottom, 1);
              dsurface.Draw(SurfaceX(bbx), SurfaceY(bby), rc, d, False);
            end;
            m_nMagTop := IPMagicPage * 6;
            magline := _MIN(IPMagicPage * 6 + 6, g_IPMagicList.Count);
            for i := m_nMagTop to magline - 1 do begin
              pm := PTClientMagic(g_IPMagicList[i]);
              M := i - m_nMagTop;
              d := g_WMainImages.Images[112]; //Level
              if d <> nil then
                dsurface.Draw(bbx + 48, bby + 8 + 15 + M * 37, d.ClientRect, d, True);
              d := g_WMainImages.Images[111]; //exp
              if d <> nil then
                dsurface.Draw(bbx + 48 + 26, bby + 8 + 15 + M * 37, d.ClientRect, d, True);
            end;

            with dsurface do begin
              FontColor := clSilver;
              for i := m_nMagTop to magline - 1 do begin
                pm := PTClientMagic(g_IPMagicList[i]);
                M := i - m_nMagTop;
                TextOut(bbx + 48, bby + 8 + M * 37, pm.Def.sMagicName, FontColor);
                trainlv := _MIN(14, pm.Level);
                TextOut(bbx + 48 + 16, bby + 8 + 15 + M * 37, IntToStr(pm.Level), FontColor);
                if pm.Def.MaxTrain[trainlv] > 0 then begin
                  if trainlv < pm.Def.btTrainLv then
                    TextOut(bbx + 48 + 46, bby + 8 + 15 + M * 37, IntToStr(pm.CurTrain) + '/' + IntToStr(pm.Def.MaxTrain[trainlv]), FontColor)
                  else
                    TextOut(bbx + 48 + 46, bby + 8 + 15 + M * 37, '-', FontColor);
                end;
              end;
            end;
          end;
        2: begin
            bbx := Left + 38;
            bby := Top + 50;
            if DStateWin.tag in [0] then
              d := g_WMainImages.Images[821 + Integer(g_Myself.m_btSex) * 2]
            else if DStateWin.tag in [1..3] then
              d := g_WMainImages.Images[820 + Integer(g_Myself.m_btSex) * 2];
            if d <> nil then
              dsurface.Draw(SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, False);

            d := g_WMainImages.Images[830 + DStateWin.tag];
            if d <> nil then
              dsurface.Draw(bbx + 96, bby + 5, d.ClientRect, d, True);

            //0 未通 1通 2一重
            d := g_WMainImages.Images[860 + DStateWin.tag * 10 + g_VenationInfos[DStateWin.tag].Level];
            if d <> nil then
              dsurface.DrawBlend(bbx, bby, d, 1);

            dsurface.BoldTextOut(
              SurfaceX(bbx + 122),
              SurfaceY(bby + 143),
              GetRGB(93),
              clBlack,
              g_VenationLvStrArr[g_VenationInfos[DStateWin.tag].Level]);

            d := g_WMainImages.Images[840 + DStateWin.tag];
            if d <> nil then
              dsurface.Draw(bbx, bby, d.ClientRect, d, True);
          end;
        3: begin
            bbx := Left + 38;
            bby := Top + 50;
            d := g_WMainImages.Images[900];
            if d <> nil then begin
              rc := d.ClientRect;
              //Dec(rc.Right, 3);
              //Dec(rc.Bottom, 4);
              dsurface.Draw(SurfaceX(bbx), SurfaceY(bby), rc, d, False);
            end;

            for i := 0 to g_MagicList2.Count - 1 do begin
              pm := PTClientMagic(g_MagicList2[i]);
              M := i + 2;
              d := g_WMainImages.Images[112]; //Level
              if d <> nil then
                dsurface.Draw(bbx + 48, bby + 30 + M * 37, d.ClientRect, d, True);
              d := g_WMainImages.Images[111]; //exp
              if d <> nil then
                dsurface.Draw(bbx + 48 + 26, bby + 30 + M * 37, d.ClientRect, d, True);
            end;

            with dsurface do begin
              FontColor := clSilver;
              for i := 0 to g_MagicList2.Count - 1 do begin
                if i >= 4 then Break;
                pm := PTClientMagic(g_MagicList2[i]);
                M := i + 2;
                trainlv := _MIN(14, pm.Level);
                trainlv := g_VLvDamageExRate[trainlv] + g_VPoDamageExRate[i];
                TextOut(bbx + 48, bby + 15 + M * 37, pm.Def.sMagicName + ' +' + Format('%d', [trainlv]) + '%暴击', FontColor);
                trainlv := _MIN(14, pm.Level);
                TextOut(bbx + 48 + 16, bby + 30 + M * 37, IntToStr(pm.Level), FontColor);
                if pm.Def.MaxTrain[trainlv] > 0 then begin
                  if trainlv < pm.Def.btTrainLv then
                    TextOut(bbx + 48 + 46, bby + 30 + M * 37, IntToStr(pm.CurTrain) + '/' + IntToStr(pm.Def.MaxTrain[trainlv]), FontColor)
                  else
                    TextOut(bbx + 48 + 46, bby + 30 + M * 37, '-', FontColor);
                end;
              end;
            end;
          end;
      end;
    end;

    if (g_VMouseInfo <> '') and (g_VMouseInfoTag in [0..3]) then begin
      with dsurface do begin
        FontColor := clYellow;
        TextOut(SurfaceX(Left + 37), SurfaceY(Top + 272 + 37), g_VMouseInfo, FontColor);
        FontColor := clWhite;
        trainlv := FontManager.Default.TextWidth(g_VMouseInfo) + 5;
        d4 := g_VLvHints[g_VenationInfos[g_VMouseInfoTag].Level];
        case g_VenationInfos[g_VMouseInfoTag].Level of
          1: d4 := Format(d4, [g_JobofSeriesSkill[g_Myself.m_btJob][g_VMouseInfoTag]]);
          2: d4 := Format(d4, [g_JobofSeriesSkill[g_Myself.m_btJob][g_VMouseInfoTag], g_JobofSeriesSkill[g_Myself.m_btJob][g_VMouseInfoTag], g_VLvDamageExRate[g_VenationInfos[g_VMouseInfoTag].Level - 1], '%', 1.5]);
          3: d4 := Format(d4, [g_JobofSeriesSkill[g_Myself.m_btJob][g_VMouseInfoTag], g_VLvDamageExRate[g_VenationInfos[g_VMouseInfoTag].Level - 1], '%', 1.5]);
          4: d4 := Format(d4, [g_JobofSeriesSkill[g_Myself.m_btJob][g_VMouseInfoTag], g_VLvDamageExRate[g_VenationInfos[g_VMouseInfoTag].Level - 1], '%', 1.5]);
          5: d4 := Format(d4, [g_JobofSeriesSkill[g_Myself.m_btJob][g_VMouseInfoTag], g_VLvDamageExRate[g_VenationInfos[g_VMouseInfoTag].Level - 1], '%', 1.5]);
          6: d4 := Format(d4, [g_JobofSeriesSkill[g_Myself.m_btJob][g_VMouseInfoTag], g_VLvDamageExRate[g_VenationInfos[g_VMouseInfoTag].Level - 1], '%', 1.5]);
        end;
        if d4 <> '' then begin
          L := 0;
          while True do begin
            if d4 = '' then Break;
            d4 := GetValidStr3(d4, d3, ['\']);
            if d3 <> '' then begin
              if L = 0 then
                TextOut(SurfaceX(Left + 37 + trainlv), SurfaceY(Top + 272 + 37 + (FontManager.Default.TextHeight('A') + 2) * (L)), d3, FontColor)
              else
                TextOut(SurfaceX(Left + 37), SurfaceY(Top + 272 + 37 + (FontManager.Default.TextHeight('A') + 2) * (L)), d3, FontColor);
            end;
            Inc(L);
            if L > 2 then Break;
          end;
        end;
      end;
    end;

    if g_VMouseInfo2 <> '' then begin
      with dsurface do begin
        FontColor := clYellow;
        TextOut(SurfaceX(Left + 37), SurfaceY(Top + 272 + 37), g_VMouseInfo2, FontColor);
        FontColor := clWhite;
        trainlv := FontManager.Default.TextWidth(g_VMouseInfo2) + 5;
        d4 := g_VLvHints2;
        if d4 <> '' then begin
          L := 0;
          while True do begin
            if d4 = '' then Break;
            d4 := GetValidStr3(d4, d3, ['\']);
            if d3 <> '' then begin
              if L = 0 then
                TextOut(SurfaceX(Left + 37 + trainlv), SurfaceY(Top + 272 + 37 + (FontManager.Default.TextHeight('A') + 2) * (L)), d3, FontColor)
              else
                TextOut(SurfaceX(Left + 37), SurfaceY(Top + 272 + 37 + (FontManager.Default.TextHeight('A') + 2) * (L)), d3, FontColor);
            end;
            Inc(L);
            if L > 2 then Break;
          end;
        end;
      end;
    end;

    with dsurface do begin
      FontColor := g_Myself.m_nNameColor;
      TextOut(SurfaceX(Left + 122 - FontManager.Default.TextWidth(frmMain.m_sCharName) div 2), SurfaceY(Top + 23 - 6), g_Myself.m_sUserName, FontColor);
      if (StatePage = 0) and not g_Myself.n_boState then begin
        FontColor := clSilver;
        TextOut(SurfaceX(Left + 45), SurfaceY(Top + 55), g_sGuildName + ' ' + g_sGuildRankName, FontColor);
      end;
    end;
{$ELSE}
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);

    DBStateDirectPaint(DBState, dsurface);

    if g_Myself.m_nIPowerLvl > 0 then begin
      with DBState2 do begin
        d := WLib.Images[FaceIndex - byte(g_Myself.n_boState)];
        if d <> nil then
          dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);

        with dsurface do begin
          try
            if not g_Myself.n_boState then begin
              BoldTextOut(
                SurfaceX(Left + 60),
                SurfaceY(Top + 4), '基础',
                GetRGB(103),
                clBlack,
                [fsBold], 10);
              BoldTextOut(
                SurfaceX(Left + 140),
                SurfaceY(Top + 4), '内功',
                GetRGB(92),
                clBlack,
                [fsBold], 10);
            end else begin
              BoldTextOut(
                SurfaceX(Left + 60),
                SurfaceY(Top + 4), '基础',
                GetRGB(92),
                clBlack,
                [fsBold], 10);
              BoldTextOut(
                SurfaceX(Left + 140),
                SurfaceY(Top + 4), '内功',
                GetRGB(103),
                clBlack,
                [fsBold], 10);
            end;
          finally
          end;
        end;
      end;
    end;

    if not g_Myself.n_boState then begin
      case StatePage of
        0: begin
            if g_Myself.m_btSex = 1 then
              pgidx := 3222
            else
              pgidx := 3221;
            bbx := Left + 38 - 5;
            bby := Top + 50 + 77;
            d := g_Wui.Images[pgidx];
            if d <> nil then
              dsurface.Draw(SurfaceX(bbx), SurfaceY(bby), d);

            bbx := bbx - 7 + 59;
            bby := bby + 44 + 34;

            if g_Myself.m_btHairEx <= 0 then begin
              idx := 440 + g_Myself.m_btHair div 2 + g_Myself.m_btSex;
              if idx > 0 then begin
                d := g_WMainImages.GetCachedImage(idx, ax, ay);
                if d <> nil then
                  dsurface.Draw(SurfaceX(bbx + ax), SurfaceY(bby + ay), d.ClientRect, d, True);
              end;
            end;

            if g_UseItems[U_DRESS].s.Name <> '' then begin
              idx := g_UseItems[U_DRESS].s.looks;
              if idx >= 0 then begin
                d := frmMain.GetWStateImg(idx, ax, ay);
                if d <> nil then
                  dsurface.Draw(SurfaceX(bbx + ax), SurfaceY(bby + ay), d.ClientRect, d, True);

                if g_UseItems[U_DRESS].s.reserve[3] = 1 then begin
                  d := frmMain.GetWStateImg(2425 + g_Myself.m_btSex, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if g_UseItems[U_DRESS].s.reserve[3] = 2 then begin
                  d := frmMain.GetWStateImg(2541 + g_Myself.m_btSex * 2, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if g_UseItems[U_DRESS].s.reserve[3] = 3 then begin

                  if GetTickCount - g_sDressEffectTick > 200 then begin
                    g_sDressEffectTick := GetTickCount;
                    Inc(g_sDressEffectIdx);
                    if g_sDressEffectIdx >= 20 then
                      g_sDressEffectIdx := 0;
                  end;

                  d := frmMain.GetWStateImg(2600 + g_sDressEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if g_UseItems[U_DRESS].s.reserve[3] = 4 then begin

                  if GetTickCount - g_sDressEffectTick > 200 then begin
                    g_sDressEffectTick := GetTickCount;
                    Inc(g_sDressEffectIdx);
                    if g_sDressEffectIdx >= 10 then
                      g_sDressEffectIdx := 0;
                  end;

                  if g_Myself.m_btSex = 0 then
                    d := frmMain.GetWStateImg(3550 + g_sDressEffectIdx, ax, ay)
                  else
                    d := frmMain.GetWStateImg(3570 + g_sDressEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if g_UseItems[U_DRESS].s.reserve[3] = 5 then begin

                  if GetTickCount - g_sDressEffectTick > 200 then begin
                    g_sDressEffectTick := GetTickCount;
                    Inc(g_sDressEffectIdx);
                    if g_sDressEffectIdx >= 8 then
                      g_sDressEffectIdx := 0;
                  end;

                  if g_Myself.m_btSex = 0 then
                    d := frmMain.GetWStateImg(3680 + g_sDressEffectIdx, ax, ay)
                  else
                    d := frmMain.GetWStateImg(3690 + g_sDressEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if g_UseItems[U_DRESS].s.reserve[3] = 6 then begin
                  if GetTickCount - g_hDressEffectTick > 200 then begin
                    g_hDressEffectTick := GetTickCount;
                    Inc(g_hDressEffectIdx);
                    if g_hDressEffectIdx >= 8 then
                      g_hDressEffectIdx := 0;
                  end;
                  d := frmMain.GetWStateImg(3800 + g_hDressEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if g_UseItems[U_DRESS].s.reserve[3] = 7 then begin
                  if GetTickCount - g_hDressEffectTick > 200 then begin
                    g_hDressEffectTick := GetTickCount;
                    Inc(g_hDressEffectIdx);
                    if g_hDressEffectIdx >= 9 then
                      g_hDressEffectIdx := 0;
                  end;
                  if g_Myself.m_btSex = 0 then
                    d := frmMain.GetWStateImg(3950 + g_hDressEffectIdx, ax, ay)
                  else
                    d := frmMain.GetWStateImg(3959 + g_hDressEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if g_UseItems[U_DRESS].s.reserve[3] = 8 then begin
                  if GetTickCount - g_hDressEffectTick > 200 then begin
                    g_hDressEffectTick := GetTickCount;
                    Inc(g_hDressEffectIdx);
                    if g_hDressEffectIdx >= 10 then
                      g_hDressEffectIdx := 0;
                  end;
                  if g_Myself.m_btSex = 0 then
                    d := frmMain.GetWStateImg(3968 + g_hDressEffectIdx, ax, ay)
                  else
                    d := frmMain.GetWStateImg(3978 + g_hDressEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if g_UseItems[U_DRESS].s.reserve[3]  in [100..249] then begin  //自定义特效六格 衣服  看自己

                  if GetTickCount - g_hDressEffectTick > 200 then begin
                    g_hDressEffectTick := GetTickCount;
                    Inc(g_hDressEffectIdx);
                    if g_hDressEffectIdx >= 20 then
                      g_hDressEffectIdx := 0;
                  end;
                  d := frmMain.GetWStateImg(30000 + (g_UseItems[U_DRESS].s.reserve[3]+1 - 100) * 20-20 + g_hDressEffectIdx, ax, ay);
                  if d = nil then begin
                    g_hDressEffectIdx := 0;
                    d := frmMain.GetWStateImg(30000 + (g_UseItems[U_DRESS].s.reserve[3]+1 - 100) * 20-20 + g_hDressEffectIdx, ax, ay);
                  end;
                  if d <> nil then begin
                     dsurface.DrawBlend(SurfaceX(bbx + ax), SurfaceY(bby + ay), d, 1);
                  end;

                end;
              end;
            end;
            if g_UseItems[U_WEAPON].s.Name <> '' then begin
              idx := g_UseItems[U_WEAPON].s.looks;
              if idx >= 0 then begin
                d := frmMain.GetWStateImg(idx, ax, ay);
                if d <> nil then
                  dsurface.Draw(SurfaceX(bbx + ax), SurfaceY(bby + ay), d.ClientRect, d, True);

                if g_UseItems[U_WEAPON].s.reserve[3] = 3 then begin
                  d := frmMain.GetWStateImg(2427, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if g_UseItems[U_WEAPON].s.reserve[3] = 1 then begin
                  d := frmMain.GetWStateImg(1403, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if (g_UseItems[U_WEAPON].s.reserve[3] = 2) {and (idx = 1880)} then begin
                  if GetTickCount - g_sWeaponEffectTick > 200 then begin
                    g_sWeaponEffectTick := GetTickCount;
                    Inc(g_sWeaponEffectIdx);
                    if g_sWeaponEffectIdx > 9 then
                      g_sWeaponEffectIdx := 0;
                  end;

                  d := frmMain.GetWStateImg(1890 + g_sWeaponEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if (g_UseItems[U_WEAPON].s.reserve[3] = 4) then begin
                  //if (idx = 2523) then begin
                  if GetTickCount - g_sWeaponEffectTick > 200 then begin
                    g_sWeaponEffectTick := GetTickCount;
                    Inc(g_sWeaponEffectIdx);
                    if g_sWeaponEffectIdx > 7 then
                      g_sWeaponEffectIdx := 0;
                  end;

                  d := frmMain.GetWStateImg(2530 + g_sWeaponEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                  //end;
                end else if (g_UseItems[U_WEAPON].s.reserve[3] = 5) then begin
                  //if (idx = 2524) then begin
                  if GetTickCount - g_sWeaponEffectTick > 200 then begin
                    g_sWeaponEffectTick := GetTickCount;
                    Inc(g_sWeaponEffectIdx);
                    if g_sWeaponEffectIdx > 9 then
                      g_sWeaponEffectIdx := 0;
                  end;

                  d := frmMain.GetWStateImg(2550 + g_sWeaponEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                  //end;
                end else if (g_UseItems[U_WEAPON].s.reserve[3] = 6) then begin
                  //if (idx = 2525) then begin
                  if GetTickCount - g_sWeaponEffectTick > 200 then begin
                    g_sWeaponEffectTick := GetTickCount;
                    Inc(g_sWeaponEffectIdx);
                    if g_sWeaponEffectIdx > 9 then
                      g_sWeaponEffectIdx := 0;
                  end;

                  d := frmMain.GetWStateImg(2560 + g_sWeaponEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                  //end;
                end else if (g_UseItems[U_WEAPON].s.reserve[3] in [7..9]) then begin
                  if GetTickCount - g_sWeaponEffectTick > 200 then begin
                    g_sWeaponEffectTick := GetTickCount;
                    Inc(g_sWeaponEffectIdx);
                    if g_sWeaponEffectIdx > 13 then
                      g_sWeaponEffectIdx := 0;
                  end;

                  d := frmMain.GetWStateImg(3480 + (g_UseItems[U_WEAPON].s.reserve[3] - 7) * 20 + g_sWeaponEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if (g_UseItems[U_WEAPON].s.reserve[3] in [10..12]) then begin
                  if GetTickCount - g_sWeaponEffectTick > 200 then begin
                    g_sWeaponEffectTick := GetTickCount;
                    Inc(g_sWeaponEffectIdx);
                    if g_sWeaponEffectIdx >= 18 then
                      g_sWeaponEffectIdx := 0;
                  end;

                  d := frmMain.GetWStateImg(3610 + (g_UseItems[U_WEAPON].s.reserve[3] - 10) * 20 + g_sWeaponEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if (g_UseItems[U_WEAPON].s.reserve[3] in [13..15]) then begin
                  if GetTickCount - g_sWeaponEffectTick > 200 then begin
                    g_sWeaponEffectTick := GetTickCount;
                    Inc(g_sWeaponEffectIdx);
                    if g_sWeaponEffectIdx >= 18 then
                      g_sWeaponEffectIdx := 0;
                  end;

                  d := frmMain.GetWStateImg(3820 + (g_UseItems[U_WEAPON].s.reserve[3] - 13) * 20 + g_sWeaponEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if (g_UseItems[U_WEAPON].s.reserve[3] in [16]) then begin
                  if GetTickCount - g_sWeaponEffectTick > 200 then begin
                    g_sWeaponEffectTick := GetTickCount;
                    Inc(g_sWeaponEffectIdx);
                    if g_sWeaponEffectIdx >= 16 then
                      g_sWeaponEffectIdx := 0;
                  end;

                  d := frmMain.GetWStateImg(2850 + g_sWeaponEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if (g_UseItems[U_WEAPON].s.reserve[3] in [100..249]) then begin //自定义特效六格 武器  看自己
                  if GetTickCount - g_sWeaponEffectTick > 200 then begin
                    g_sWeaponEffectTick := GetTickCount;
                    Inc(g_sWeaponEffectIdx);
                    if g_sWeaponEffectIdx >= 20 then
                      g_sWeaponEffectIdx := 0;
                  end;
                  d := frmMain.GetWStateImg(30000 + (g_UseItems[U_WEAPON].s.reserve[3]+1 - 100) * 20-20+g_sWeaponEffectIdx, ax, ay);
                  if d = nil then begin
                    g_sWeaponEffectIdx := 0;
                    d := frmMain.GetWStateImg(30000 + (g_UseItems[U_WEAPON].s.reserve[3]+1 - 100) * 20-20+g_sWeaponEffectIdx, ax, ay);
                  end;
                  if d <> nil then begin
                    dsurface.DrawBlend(SurfaceX(bbx + ax), SurfaceY(bby + ay), d, 1);
                  end;
                end;
              end;
            end;

            trainlv := 1;
            if g_UseItems[U_HELMETEX].s.Name <> '' then begin
              idx := g_UseItems[U_HELMETEX].s.looks;
              if idx >= 0 then begin
                if g_UseItems[U_HELMETEX].s.Source <> 0 then
                  trainlv := 1
                else
                  trainlv := 0;
                d := frmMain.GetWStateImg(idx, ax, ay);
                if d <> nil then
                  dsurface.Draw(SurfaceX(bbx + ax), SurfaceY(bby + ay), d.ClientRect, d, True);
              end;
            end;
            if (g_UseItems[U_HELMET].s.Name <> '') then begin
              idx := g_UseItems[U_HELMET].s.looks;
              if idx >= 0 then begin
                if (trainlv <> 0) then begin
                  d := frmMain.GetWStateImg(idx, ax, ay);
                  if d <> nil then
                    dsurface.Draw(SurfaceX(bbx + ax), SurfaceY(bby + ay), d.ClientRect, d, True);
                end;
                if (g_UseItems[U_HELMET].s.Shape = 190) or (g_UseItems[U_HELMET].s.reserve[3] = 4) then begin
                  if GetTickCount - g_UseItemsShine[U_HELMET].tick > 60 then begin
                    g_UseItemsShine[U_HELMET].tick := GetTickCount;
                    Inc(g_UseItemsShine[U_HELMET].idx);
                    if g_UseItemsShine[U_HELMET].idx > 31 then
                      g_UseItemsShine[U_HELMET].idx := 0;
                  end;
                  d := g_Wui.Images[220 + g_UseItemsShine[U_HELMET].idx];
                  if d <> nil then
                    dsurface.DrawBlend(SurfaceX(bbx + ax - 12), SurfaceY(bby + ay - 10), d, 1);
                end else if g_UseItems[U_HELMET].s.reserve[3] = 3 then begin
                  if GetTickCount - g_UseItemsShine[U_HELMET].tick > 100 then begin
                    g_UseItemsShine[U_HELMET].tick := GetTickCount;
                    Inc(g_UseItemsShine[U_HELMET].idx);
                    if g_UseItemsShine[U_HELMET].idx >= 10 then
                      g_UseItemsShine[U_HELMET].idx := 0;
                  end;
                  d := g_StateEffect.Images[580 + g_UseItemsShine[U_HELMET].idx];
                  if d <> nil then
                    dsurface.DrawBlend(SurfaceX(bbx + ax - d.Width div 4), SurfaceY(bby + ay - d.Height div 4), d, 1);
                end else if g_UseItems[U_HELMET].s.reserve[3] >= 100 then begin   //20200927六格头盔自己
                  if GetTickCount - g_UseItemsShine[U_HELMET].tick > 200 then begin
                    g_UseItemsShine[U_HELMET].tick := GetTickCount;
                    Inc(g_UseItemsShine[U_HELMET].idx);
                    if g_UseItemsShine[U_HELMET].idx > 19 then
                      g_UseItemsShine[U_HELMET].idx := 0;
                  end;
                  d := frmMain.GetWStateImg(30000 + (g_UseItems[U_HELMET].s.reserve[3]+1 - 100) * 20-20+ g_UseItemsShine[U_HELMET].idx);
                  if d = nil then begin
                    g_UseItemsShine[U_HELMET].idx := 0;
                    d := frmMain.GetWStateImg(30000 + (g_UseItems[U_HELMET].s.reserve[3]+1 - 100) * 20-20+g_UseItemsShine[U_HELMET].idx);
                  end;
                  if d <> nil then begin
                  dsurface.DrawBlend(SurfaceX(bbx + ax - 4 - d.Width div 4), SurfaceY(bby + ay - d.Height div 4), d, 1);
                  end;
                end;

              end;
            end;

            if g_Myself.m_btAttribute in [1..5] then begin
              with dsurface do begin
                case g_Myself.m_btAttribute of
                  1: FontColor := GetRGB(149);
                  2: FontColor := GetRGB(221);
                  3: FontColor := GetRGB(147);
                  4: FontColor := GetRGB(057);
                  5: FontColor := GetRGB(045);
                end;
                BoldTextOut(SurfaceX(Left + 28), SurfaceY(Top + 88), g_sHumAttr[g_Myself.m_btAttribute], FontColor, clBlack, [], 24, '隶书');
              end;
            end;

            //检测是否有斗笠
          end;
        1: begin
            if g_Myself.m_btSex = 1 then
              pgidx := 3284
            else
              pgidx := 3283;
            bbx := Left + 38 - 5;
            bby := Top + 50 + 77;
            d := g_Wui.Images[pgidx];
            if d <> nil then
              dsurface.Draw(SurfaceX(bbx), SurfaceY(bby), d);

            bbx := bbx - 7 + 59;
            bby := bby + 44 + 34;

            idx := 442 + g_Myself.m_btSex;
            d := g_WMainImages.GetCachedImage(idx, ax, ay);
            if d <> nil then
              dsurface.Draw(SurfaceX(bbx + ax), SurfaceY(bby + ay), d);
            if g_UseItems[U_FASHION].s.Name <> '' then begin
              idx := g_UseItems[U_FASHION].s.looks;
              if idx >= 0 then begin
                d := frmMain.GetWStateImg(idx, ax, ay);
                if d <> nil then
                  dsurface.Draw(SurfaceX(bbx + ax), SurfaceY(bby + ay), d.ClientRect, d, True);

                if g_UseItems[U_FASHION].s.reserve[3] = 1 then begin
                  d := frmMain.GetWStateImg(2425 + g_Myself.m_btSex, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if g_UseItems[U_FASHION].s.reserve[3] = 2 then begin
                  d := frmMain.GetWStateImg(2541 + g_Myself.m_btSex * 2, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if g_UseItems[U_FASHION].s.reserve[3] = 3 then begin

                  if GetTickCount - g_sDressEffectTick > 200 then begin
                    g_sDressEffectTick := GetTickCount;
                    Inc(g_sDressEffectIdx);
                    if g_sDressEffectIdx >= 20 then
                      g_sDressEffectIdx := 0;
                  end;

                  d := frmMain.GetWStateImg(2600 + g_sDressEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if g_UseItems[U_FASHION].s.reserve[3] = 4 then begin

                  if GetTickCount - g_sDressEffectTick > 200 then begin
                    g_sDressEffectTick := GetTickCount;
                    Inc(g_sDressEffectIdx);
                    if g_sDressEffectIdx >= 10 then
                      g_sDressEffectIdx := 0;
                  end;

                  if g_Myself.m_btSex = 0 then
                    d := frmMain.GetWStateImg(3550 + g_sDressEffectIdx, ax, ay)
                  else
                    d := frmMain.GetWStateImg(3570 + g_sDressEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if g_UseItems[U_FASHION].s.reserve[3] = 5 then begin

                  if GetTickCount - g_sDressEffectTick > 200 then begin
                    g_sDressEffectTick := GetTickCount;
                    Inc(g_sDressEffectIdx);
                    if g_sDressEffectIdx >= 8 then
                      g_sDressEffectIdx := 0;
                  end;

                  if g_Myself.m_btSex = 0 then
                    d := frmMain.GetWStateImg(3680 + g_sDressEffectIdx, ax, ay)
                  else
                    d := frmMain.GetWStateImg(3690 + g_sDressEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if g_UseItems[U_FASHION].s.reserve[3] = 6 then begin
                  if GetTickCount - g_hDressEffectTick > 200 then begin
                    g_hDressEffectTick := GetTickCount;
                    Inc(g_hDressEffectIdx);
                    if g_hDressEffectIdx >= 8 then
                      g_hDressEffectIdx := 0;
                  end;
                  d := frmMain.GetWStateImg(3800 + g_hDressEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if g_UseItems[U_FASHION].s.reserve[3] = 7 then begin
                  if GetTickCount - g_hDressEffectTick > 200 then begin
                    g_hDressEffectTick := GetTickCount;
                    Inc(g_hDressEffectIdx);
                    if g_hDressEffectIdx >= 9 then
                      g_hDressEffectIdx := 0;
                  end;
                  if g_Myself.m_btSex = 0 then
                    d := frmMain.GetWStateImg(3950 + g_hDressEffectIdx, ax, ay)
                  else
                    d := frmMain.GetWStateImg(3959 + g_hDressEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if g_UseItems[U_FASHION].s.reserve[3] = 8 then begin
                  if GetTickCount - g_hDressEffectTick > 200 then begin
                    g_hDressEffectTick := GetTickCount;
                    Inc(g_hDressEffectIdx);
                    if g_hDressEffectIdx >= 10 then
                      g_hDressEffectIdx := 0;
                  end;
                  if g_Myself.m_btSex = 0 then
                    d := frmMain.GetWStateImg(3968 + g_hDressEffectIdx, ax, ay)
                  else
                    d := frmMain.GetWStateImg(3978 + g_hDressEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if g_UseItems[U_FASHION].s.reserve[3]  in [100..249] then begin  //自定义特效六格  时装 看自己

                  if GetTickCount - g_hDressEffectTick > 200 then begin
                    g_hDressEffectTick := GetTickCount;
                    Inc(g_hDressEffectIdx);
                    if g_hDressEffectIdx >= 20 then
                      g_hDressEffectIdx := 0;
                  end;
                  d := frmMain.GetWStateImg(30000 + (g_UseItems[U_FASHION].s.reserve[3]+1 - 100) * 20-20 + g_hDressEffectIdx, ax, ay);
                  if d = nil then begin
                    g_hDressEffectIdx := 0;
                    d := frmMain.GetWStateImg(30000 + (g_UseItems[U_FASHION].s.reserve[3]+1 - 100) * 20-20 + g_hDressEffectIdx, ax, ay);
                  end;
                  if d <> nil then begin
                     dsurface.DrawBlend(SurfaceX(bbx + ax), SurfaceY(bby + ay), d, 1);
                  end;

                end;
              end;
            end;
          end;
        2: begin
            bbx := Left + 100;
            bby := Top + 70;
            mmx := bbx + 70;
            with dsurface do begin
              try
                TextOut(bbx, bby + 14 * 6, '职业', clSilver);
                TextOut(mmx, bby + 14 * 6, Format('：%s', [IntToJob(g_Myself.m_btJob)]), clSilver);
                TextOut(bbx, bby + 14 * 7, '等级', clSilver);
                TextOut(mmx, bby + 14 * 7, Format('：%d', [g_Myself.m_Abil.Level]), clSilver);
                TextOut(bbx, bby + 14 * 8, '当前经验', clSilver);
                TextOut(mmx, bby + 14 * 8, Format('：%s', [IntToStr(g_Myself.m_Abil.Exp)]), clSilver);
                TextOut(bbx, bby + 14 * 9, '升级经验', clSilver);
                TextOut(mmx, bby + 14 * 9, Format('：%s', [IntToStr(g_Myself.m_Abil.MaxExp)]), clSilver);
                TextOut(bbx, bby + 14 * 10, '体力值', clSilver);
                TextOut(mmx, bby + 14 * 10, Format('：%d/%d', [g_Myself.m_Abil.HP, g_Myself.m_Abil.MaxHP]), clSilver);
                TextOut(bbx, bby + 14 * 11, '魔法值', clSilver);
                TextOut(mmx, bby + 14 * 11, Format('：%d/%d', [g_Myself.m_Abil.MP, g_Myself.m_Abil.MaxMP]), clSilver);

                TextOut(bbx, bby + 14 * 12, '金刚石数');
                TextOut(mmx, bby + 14 * 12, '：' + IntToStr(g_Myself.m_nGameDiamd), clSilver);

                TextOut(bbx, bby + 14 * 13, '灵符数量', clSilver);
                TextOut(mmx, bby + 14 * 13, '：' + IntToStr(g_Myself.m_nGameGird), clSilver);

                FontColor := clYellow;
                TextOut(bbx, bby + 14 * 14, g_sGameGoldName + '数量', FontColor);
                TextOut(mmx, bby + 14 * 14, '：' + IntToStr(g_Myself.m_nGameGold), FontColor);
              finally
              end;
            end;

          end;
        3: begin
            bbx := Left + 38 - 5;
            bby := Top + 50 + 77;
            d := g_Wui.Images[3226];
            if d <> nil then begin
              dsurface.Draw(SurfaceX(bbx), SurfaceY(bby), d);
            end;
            bbx := Left + 70;
            bby := Top + 70 + 14 * 6;
            mmx := bbx + 45;

            with dsurface do begin
              try
                TextOut(bbx, bby + 14 * 1, '防御', clSilver);
                TextOut(mmx, bby + 14 * 1, Format('%d-%d', [LoWord(g_Myself.m_Abil.AC), HiWord(g_Myself.m_Abil.AC)]), clSilver);
                TextOut(bbx, bby + 14 * 2, '魔防', clSilver);
                TextOut(mmx, bby + 14 * 2, Format('%d-%d', [LoWord(g_Myself.m_Abil.MAC), HiWord(g_Myself.m_Abil.MAC)]), clSilver);
                TextOut(bbx, bby + 14 * 3, '攻击', clSilver);
                TextOut(mmx, bby + 14 * 3, Format('%d-%d', [LoWord(g_Myself.m_Abil.DC), HiWord(g_Myself.m_Abil.DC)]), clSilver);
                TextOut(bbx, bby + 14 * 4, '魔法', clSilver);
                TextOut(mmx, bby + 14 * 4, Format('%d-%d', [LoWord(g_Myself.m_Abil.MC), HiWord(g_Myself.m_Abil.MC)]), clSilver);
                TextOut(bbx, bby + 14 * 5, '道术', clSilver);
                TextOut(mmx, bby + 14 * 5, Format('%d-%d', [LoWord(g_Myself.m_Abil.SC), HiWord(g_Myself.m_Abil.SC)]), clSilver);
                TextOut(bbx, bby + 14 * 6, '准确度', clSilver);
                TextOut(mmx, bby + 14 * 6, Format('%d', [g_nMyHitPoint]), clSilver);
                TextOut(bbx, bby + 14 * 7, '敏捷度', clSilver);
                TextOut(mmx, bby + 14 * 7, Format('%d', [g_nMySpeedPoint]), clSilver);

                bbx := Left + 190;
                mmx := bbx + 55;
                TextOut(bbx, bby + 14 * 1, '背包重量', clSilver);
                hcolor := clSilver;
                if g_Myself.m_Abil.Weight > g_Myself.m_Abil.MaxWeight then
                  hcolor := clRed;
                FontColor := hcolor;
                TextOut(mmx, bby + 14 * 1, Format('%d/%d', [g_Myself.m_Abil.Weight, g_Myself.m_Abil.MaxWeight]), FontColor);

                TextOut(bbx, bby + 14 * 2, '穿戴重量', FontColor);
                hcolor := clSilver;
                if g_Myself.m_Abil.WearWeight > g_Myself.m_Abil.MaxWearWeight then
                  hcolor := clRed;
                FontColor := hcolor;
                TextOut(mmx, bby + 14 * 2, Format('%d/%d', [g_Myself.m_Abil.WearWeight, g_Myself.m_Abil.MaxWearWeight]), FontColor);

                TextOut(bbx, bby + 14 * 3, '腕力', FontColor);
                hcolor := clSilver;
                if g_Myself.m_Abil.HandWeight > g_Myself.m_Abil.MaxHandWeight then
                  hcolor := clRed;
                FontColor := hcolor;
                TextOut(mmx, bby + 14 * 3, Format('%d/%d', [g_Myself.m_Abil.HandWeight, g_Myself.m_Abil.MaxHandWeight]), FontColor);

                FontColor := clSilver;
                TextOut(bbx, bby + 14 * 4, '魔法躲避', FontColor);
                TextOut(mmx, bby + 14 * 4, '+' + IntToStr(g_nMyAntiMagic * 10) + '%', FontColor);

                TextOut(bbx, bby + 14 * 5, '毒物躲避', FontColor);
                TextOut(mmx, bby + 14 * 5, '+' + IntToStr(g_nMyAntiPoison * 10) + '%', FontColor);

                TextOut(bbx, bby + 14 * 6, '中毒恢复', FontColor);
                TextOut(mmx, bby + 14 * 6, '+' + IntToStr(g_nMyPoisonRecover * 10) + '%', FontColor);

                TextOut(bbx, bby + 14 * 7, '体力恢复', FontColor);
                TextOut(mmx, bby + 14 * 7, '+' + IntToStr(g_nMyHealthRecover * 10) + '%', FontColor);

                TextOut(bbx, bby + 14 * 8, '魔法恢复', FontColor);
                TextOut(mmx, bby + 14 * 8, '+' + IntToStr(g_nMySpellRecover * 10) + '%', FontColor);

                TextOut(bbx, bby + 14 * 9, '内力恢复', FontColor);
                TextOut(mmx, bby + 14 * 9, IntToStr(g_nMyIPowerRecover), FontColor);

                TextOut(bbx, bby + 14 * 10, '内伤增加', FontColor);
                TextOut(mmx, bby + 14 * 10, IntToStr(g_nMyAddDamage), FontColor);

                TextOut(bbx, bby + 14 * 11, '内伤减免', FontColor);
                TextOut(mmx, bby + 14 * 11, IntToStr(g_nMyDecDamage), FontColor);
              finally

              end;
            end;

          end;
        4: begin
            bbx := Left + 38 - 5;
            bby := Top + 50 + 77;
            d := g_Wui.Images[3228];
            if d <> nil then begin
              dsurface.Draw(SurfaceX(bbx), SurfaceY(bby), d);
            end;
            //bby := Top + 70 + 14 * 6;
            //bbx := Left + 190;
            //mmx := bbx + 55;

            //g_GE.Font.Print(bbx, bby + 14 * 4, clSilver, '魔法躲避');
            //g_GE.Font.Print(mmx, bby + 14 * 4, clSilver, '+' + IntToStr(g_nMyAntiMagic * 10) + '%');

          end;
        5: begin //魔法
            bbx := Left + 38 - 5;
            bby := Top + 50 + 77;
            d := g_Wui.Images[3227];
            if d <> nil then begin
              dsurface.Draw(SurfaceX(bbx), SurfaceY(bby), d);
            end;
            bbx := bbx + 10;
            bby := bby + 8;

            m_nMagTop := MagicPage * 6;
            magline := _MIN(MagicPage * 6 + 6, g_MagicList.Count);
            for i := m_nMagTop to magline - 1 do begin
              pm := PTClientMagic(g_MagicList[i]);
              M := i - m_nMagTop;
              keyimg := 0;
              case byte(pm.Key) of
                byte('E'): keyimg := 148;
                byte('F'): keyimg := 149;
                byte('G'): keyimg := 150;
                byte('H'): keyimg := 151;
                byte('I'): keyimg := 152;
                byte('J'): keyimg := 153;
                byte('K'): keyimg := 154;
                byte('L'): keyimg := 155;
                byte('1'): keyimg := 156;
                byte('2'): keyimg := 157;
                byte('3'): keyimg := 158;
                byte('4'): keyimg := 159;
                byte('5'): keyimg := 160;
                byte('6'): keyimg := 161;
                byte('7'): keyimg := 162;
                byte('8'): keyimg := 163;
              end;
              if keyimg > 0 then begin
                d := g_WMain3Images.Images[keyimg];
                if d <> nil then
                  dsurface.Draw(bbx + 168, bby + 8 + M * 46, d);
              end;
              d := g_WMainImages.Images[112]; //Level
              if d <> nil then
                dsurface.Draw(bbx + 48, bby + 8 + 15 + M * 46, d);
              d := g_WMainImages.Images[111]; //exp
              if d <> nil then
                dsurface.Draw(bbx + 48 + 26, bby + 8 + 15 + M * 46, d);
            end;

            for i := m_nMagTop to magline - 1 do begin
              pm := PTClientMagic(g_MagicList[i]);
              M := i - m_nMagTop;
              dsurface.BoldTextOut(bbx + 48, bby + 8 + M * 46, clSilver, clBlack, pm.Def.sMagicName);
              trainlv := _MIN(14, pm.Level);
              dsurface.BoldTextOut(bbx + 48 + 16, bby + 8 + 15 + M * 46, clSilver, clBlack, IntToStr(pm.Level));
              if pm.Def.MaxTrain[trainlv] > 0 then begin
                if trainlv < pm.Def.btTrainLv then
                  dsurface.BoldTextOut(bbx + 48 + 46, bby + 8 + 15 + M * 46, clSilver, clBlack, IntToStr(pm.CurTrain) + '/' + IntToStr(pm.Def.MaxTrain[trainlv]))
                else
                  dsurface.BoldTextOut(bbx + 48 + 46, bby + 8 + 15 + M * 46, clSilver, clBlack, '-');
              end;
            end;

            dsurface.BoldTextOut(bbx + 210, bby + 273,
              GetRGB(93), clBlack,
              Format('%d/%d', [MagicPage + 1, (g_MagicList.Count + 5) div 6]));

          end;
      end;
    end else if g_Myself.m_nIPowerLvl > 0 then begin
      case m_nIPStatePage of
        0: begin
            bbx := Left + 38 - 5;
            bby := Top + 50 + 77;
            d := g_Wui.Images[3260];
            if d <> nil then begin
              dsurface.Draw(SurfaceX(bbx), SurfaceY(bby), d);
            end;

            L := Left + 48 + 55;
            M := Top + 105 + 80;
            with dsurface do begin
              BoldTextOut(SurfaceX(L + 00), SurfaceY(M + 23 * 0), clSilver, clBlack, '当前内功等级');
              BoldTextOut(SurfaceX(L + 00), SurfaceY(M + 23 * 1), clSilver, clBlack, '当前内功经验');
              BoldTextOut(SurfaceX(L + 00), SurfaceY(M + 23 * 2), clSilver, clBlack, '升级所需经验');
              BoldTextOut(SurfaceX(L + 00), SurfaceY(M + 23 * 3), clSilver, clBlack, '内   力   值');
              BoldTextOut(SurfaceX(L + 00), SurfaceY(M + 23 * 4), clSilver, clBlack, '内功恢复速度');
              BoldTextOut(SurfaceX(L + 00), SurfaceY(M + 23 * 5), clSilver, clBlack, '内功增加伤害');
              BoldTextOut(SurfaceX(L + 00), SurfaceY(M + 23 * 6), clSilver, clBlack, '内功减免伤害');

              BoldTextOut(SurfaceX(L + 83), SurfaceY(M + 23 * 0 - 1), clSilver, clBlack, IntToStr(g_Myself.m_nIPowerLvl));
              BoldTextOut(SurfaceX(L + 83), SurfaceY(M + 23 * 1 - 1), clSilver, clBlack, IntToStr(g_Myself.m_nIPowerExp));
              BoldTextOut(SurfaceX(L + 83), SurfaceY(M + 23 * 2 - 1), clSilver, clBlack, IntToStr(g_dwIPNeedInfo[g_Myself.m_nIPowerLvl].dwPExp));
              BoldTextOut(SurfaceX(L + 83), SurfaceY(M + 23 * 3 - 1), clSilver, clBlack, Format('%d/%d', [g_Myself.m_nIPower, g_dwIPNeedInfo[g_Myself.m_nIPowerLvl].nPower]));
              BoldTextOut(SurfaceX(L + 83), SurfaceY(M + 23 * 4 - 1), clSilver, clBlack, IntToStr(g_nMyIPowerRecover));
              BoldTextOut(SurfaceX(L + 83), SurfaceY(M + 23 * 5 - 1), clSilver, clBlack, IntToStr(g_nMyAddDamage));
              BoldTextOut(SurfaceX(L + 83), SurfaceY(M + 23 * 6 - 1), clSilver, clBlack, IntToStr(g_nMyDecDamage));
            end;
          end;
        1: begin
            bbx := Left + 38 - 5;
            bby := Top + 50 + 77;
            d := g_Wui.Images[3227];
            if d <> nil then begin
              dsurface.Draw(SurfaceX(bbx), SurfaceY(bby), d);
            end;

            bbx := bbx + 10;
            bby := bby + 8;

            m_nMagTop := IPMagicPage * 6;
            magline := _MIN(IPMagicPage * 6 + 6, g_IPMagicList.Count);
            for i := m_nMagTop to magline - 1 do begin
              pm := PTClientMagic(g_IPMagicList[i]);
              M := i - m_nMagTop;
              d := g_WMainImages.Images[112]; //Level
              if d <> nil then
                dsurface.Draw(bbx + 48, bby + 8 + 15 + M * 46, d);
              d := g_WMainImages.Images[111]; //exp
              if d <> nil then
                dsurface.Draw(bbx + 48 + 26, bby + 8 + 15 + M * 46, d);
            end;

            for i := m_nMagTop to magline - 1 do begin
              pm := PTClientMagic(g_IPMagicList[i]);
              M := i - m_nMagTop;
              dsurface.BoldTextOut(bbx + 48, bby + 8 + M * 46, clSilver, clBlack, pm.Def.sMagicName);
              trainlv := _MIN(14, pm.Level);
              dsurface.BoldTextOut(bbx + 48 + 16, bby + 8 + 15 + M * 46, clSilver, clBlack, IntToStr(pm.Level));
              if pm.Def.MaxTrain[trainlv] > 0 then begin
                if trainlv < pm.Def.btTrainLv then
                  dsurface.BoldTextOut(bbx + 48 + 46, bby + 8 + 15 + M * 46, clSilver, clBlack, IntToStr(pm.CurTrain) + '/' + IntToStr(pm.Def.MaxTrain[trainlv]))
                else
                  dsurface.BoldTextOut(bbx + 48 + 46, bby + 8 + 15 + M * 46, clSilver, clBlack, '-');
              end;
            end;
            dsurface.BoldTextOut(bbx + 210, bby + 273,
              GetRGB(93), clBlack,
              Format('%d/%d', [IPMagicPage + 1, (g_IPMagicList.Count + 5) div 6]));
          end;
        2: begin
            bbx := Left + 38 - 5;
            bby := Top + 50 + 77;
            if DBState.tag in [0] then
              d := g_Wui.Images[3253 - Integer(g_Myself.m_btSex) * 3]
            else if DBState.tag in [1..3] then
              d := g_Wui.Images[3252 - Integer(g_Myself.m_btSex) * 1];
            if d <> nil then
              dsurface.Draw(SurfaceX(bbx), SurfaceY(bby), d);

            bbx := bbx + 70;
            bby := bby + 30;

            d := g_WMainImages.Images[830 + DBState.tag];
            if d <> nil then
              dsurface.Draw(bbx + 96, bby + 5, d);

            bbx := bbx - 14;
            bby := bby + 7;
            //0 未通 1通 2一重
            d := g_WMainImages.Images[860 + DBState.tag * 10 + g_VenationInfos[DBState.tag].Level];
            if d <> nil then
              dsurface.DrawBlend(bbx, bby, d, 1);

            dsurface.BoldTextOut(
              SurfaceX(bbx + 122),
              SurfaceY(bby + 142),
              GetRGB(93),
              clBlack,
              g_VenationLvStrArr[g_VenationInfos[DBState.tag].Level]);

            d := g_WMainImages.Images[840 + DBState.tag];
            if d <> nil then
              dsurface.Draw(bbx, bby, d);
          end;
        3: begin
            bbx := Left + 38 - 5;
            bby := Top + 50 + 77;
            d := g_Wui.Images[3261];
            if d <> nil then begin
              dsurface.Draw(SurfaceX(bbx), SurfaceY(bby), d);
            end;

            bbx := bbx + 10;
            bby := bby + 0;

            for i := 0 to g_MagicList2.Count - 1 do begin
              pm := PTClientMagic(g_MagicList2[i]);
              M := i + 2;
              d := g_WMainImages.Images[112]; //Level
              if d <> nil then
                dsurface.Draw(bbx + 48, bby + 30 + M * 46, d);
              d := g_WMainImages.Images[111]; //exp
              if d <> nil then
                dsurface.Draw(bbx + 48 + 26, bby + 30 + M * 46, d);
            end;

            for i := 0 to g_MagicList2.Count - 1 do begin
              if i >= 4 then Break;
              pm := PTClientMagic(g_MagicList2[i]);
              M := i + 2;
              trainlv := _MIN(14, pm.Level);
              trainlv := g_VLvDamageExRate[trainlv] + g_VPoDamageExRate[i];
              dsurface.BoldTextOut(bbx + 48, bby + 15 + M * 46, clSilver, clBlack, pm.Def.sMagicName + ' +' + Format('%d', [trainlv]) + '%暴击');
              trainlv := _MIN(14, pm.Level);
              dsurface.BoldTextOut(bbx + 48 + 16, bby + 30 + M * 46, clSilver, clBlack, IntToStr(pm.Level));
              if pm.Def.MaxTrain[trainlv] > 0 then begin
                if trainlv < pm.Def.btTrainLv then
                  dsurface.BoldTextOut(bbx + 48 + 46, bby + 30 + M * 46, clSilver, clBlack, IntToStr(pm.CurTrain) + '/' + IntToStr(pm.Def.MaxTrain[trainlv]))
                else
                  dsurface.BoldTextOut(bbx + 48 + 46, bby + 30 + M * 46, clSilver, clBlack, '-');
              end;
            end;
          end;
      end;
    end;

    if (g_VMouseInfo <> '') and (g_VMouseInfoTag in [0..3]) then begin
      with dsurface do begin
        FontColor := clYellow;
        TextOut(SurfaceX(Left + 60), SurfaceY(Top + 390), g_VMouseInfo, FontColor);
        FontColor := clWhite;
        trainlv := FontManager.Default.TextWidth(g_VMouseInfo) + 5;
        d4 := g_VLvHints[g_VenationInfos[g_VMouseInfoTag].Level];
        //g_JobofSeriesSkill
        case g_VenationInfos[g_VMouseInfoTag].Level of
          1: d4 := Format(d4, [g_JobofSeriesSkill[g_Myself.m_btJob][g_VMouseInfoTag]]);
          2: d4 := Format(d4, [g_JobofSeriesSkill[g_Myself.m_btJob][g_VMouseInfoTag], g_JobofSeriesSkill[g_Myself.m_btJob][g_VMouseInfoTag], g_VLvDamageExRate[g_VenationInfos[g_VMouseInfoTag].Level - 1], '%', 1.5]);
          3: d4 := Format(d4, [g_JobofSeriesSkill[g_Myself.m_btJob][g_VMouseInfoTag], g_VLvDamageExRate[g_VenationInfos[g_VMouseInfoTag].Level - 1], '%', 1.5]);
          4: d4 := Format(d4, [g_JobofSeriesSkill[g_Myself.m_btJob][g_VMouseInfoTag], g_VLvDamageExRate[g_VenationInfos[g_VMouseInfoTag].Level - 1], '%', 1.5]);
          5: d4 := Format(d4, [g_JobofSeriesSkill[g_Myself.m_btJob][g_VMouseInfoTag], g_VLvDamageExRate[g_VenationInfos[g_VMouseInfoTag].Level - 1], '%', 1.5]);
          6: d4 := Format(d4, [g_JobofSeriesSkill[g_Myself.m_btJob][g_VMouseInfoTag], g_VLvDamageExRate[g_VenationInfos[g_VMouseInfoTag].Level - 1], '%', 1.5]);
        end;
        if d4 <> '' then begin
          L := 0;
          while True do begin
            if d4 = '' then Break;
            d4 := GetValidStr3(d4, d3, ['\']);
            if d3 <> '' then begin
              if L = 0 then
                TextOut(SurfaceX(Left + 60 + trainlv), SurfaceY(Top + 390 + (FontManager.Default.TextHeight('A') + 2) * (L)), d3, FontColor)
              else
                TextOut(SurfaceX(Left + 60), SurfaceY(Top + 390 + (FontManager.Default.TextHeight('A') + 2) * (L)), d3, FontColor);
            end;
            Inc(L);
            if L > 2 then Break;
          end;
        end;
      end;
    end;

    if g_VMouseInfo2 <> '' then begin
      with dsurface do begin
        FontColor := clYellow;
        TextOut(SurfaceX(Left + 60), SurfaceY(Top + 390), g_VMouseInfo2, FontColor);
        FontColor := clWhite;
        trainlv := FontManager.Default.TextWidth(g_VMouseInfo2) + 5;
        d4 := g_VLvHints2;
        if d4 <> '' then begin
          L := 0;
          while True do begin
            if d4 = '' then Break;
            d4 := GetValidStr3(d4, d3, ['\']);
            if d3 <> '' then begin
              if L = 0 then
                TextOut(SurfaceX(Left + 60 + trainlv), SurfaceY(Top + 390 + (FontManager.Default.TextHeight('A') + 2) * (L)), d3, FontColor)
              else
                TextOut(SurfaceX(Left + 60), SurfaceY(Top + 390 + (FontManager.Default.TextHeight('A') + 2) * (L)), d3, FontColor);
            end;
            Inc(L);
            if L > 2 then Break;
          end;
        end;
      end;
    end;

    with dsurface do begin
      FontColor := g_Myself.m_nNameColor;
      TextOut(
        SurfaceX(Left + (Width - FontManager.Default.TextWidth(frmMain.m_sCharName)) div 2),
        SurfaceY(Top + 62),
        g_Myself.m_sUserName, FontColor);

      if (StatePage = 0) and not g_Myself.n_boState then begin
        FontColor := clSilver;
        TextOut(
          SurfaceX(Left + (Width - FontManager.Default.TextWidth(g_sGuildName + ' ' + g_sGuildRankName)) div 2),
          SurfaceY(Top + 81),
          g_sGuildName + ' ' + g_sGuildRankName, FontColor);
      end;
    end;
{$ENDIF}
  end;
end;

procedure TFrmDlg.DSWLightDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  X, Y, idx, sel, eft: Integer;
  d: TCustomLockableTexture;
begin
  d := nil;
  if (StatePage = 0) and not g_Myself.n_boState then begin
    sel := -1;
    eft := -1;
    if Sender = DSWNecklace then begin
      sel := U_NECKLACE;
      eft := 1;
    end else if Sender = DSWLight then begin
      sel := U_RIGHTHAND;
      eft := 1;
    end else if Sender = DSWArmRingR then begin
      sel := U_ARMRINGR;
      eft := 1;
    end else if Sender = DSWArmRingL then begin
      sel := U_ARMRINGL;
      eft := 1;
    end else if Sender = DSWRingR then begin
      sel := U_RINGR;
      eft := 1;
    end else if Sender = DSWRingL then begin
      sel := U_RINGL;
      eft := 1;
    end else if Sender = DSWBelt then begin
      sel := U_BELT;
      eft := 1;
    end else if Sender = DSWBoots then begin
      sel := U_BOOTS;
      eft := 1;
{$IFNDEF UI_0508}
    end else if Sender = DSWDrum then begin
      sel := U_DRUM;
      eft := 1;
    end else if Sender = DSWHorse then begin
      sel := U_HORSE;
      eft := 1;
{$ENDIF}
    end else if Sender = DSWBujuk then begin
      sel := U_BUJUK;
    end else if Sender = DSWCharm then begin
      sel := U_CHARM;
    end;
    if (sel in [0..U_FASHION]) and (g_UseItems[sel].s.Name <> '') then begin
      idx := g_UseItems[sel].s.looks;
      if idx >= 0 then begin
        with Sender as TDButton do begin
          d := frmMain.GetWStateImg(idx);
          if d <> nil then
            dsurface.Draw(SurfaceX(Left + (Width - d.Width) div 2),
              SurfaceY(Top + (Height - d.Height) div 2),
              d);

          if eft > 0 then begin
            if (g_UseItems[sel].s.Shape = 190) or (g_UseItems[sel].s.reserve[3] = 4) then begin
              if GetTickCount - g_UseItemsShine[sel].tick > 60 then begin
                g_UseItemsShine[sel].tick := GetTickCount;
                Inc(g_UseItemsShine[sel].idx);
                if g_UseItemsShine[sel].idx > 31 then
                  g_UseItemsShine[sel].idx := 0;
              end;
              d := g_Wui.Images[180 + g_UseItemsShine[sel].idx];
              if d <> nil then
                dsurface.DrawBlend(
                  SurfaceX(Left + (Width - d.Width) div 2),
                  SurfaceY(Top + (Height - d.Height) div 2),
                  d, 1);
            end else if g_UseItems[sel].s.reserve[3] = 1 then begin
              if GetTickCount - g_UseItemsShine[sel].tick > 100 then begin
                g_UseItemsShine[sel].tick := GetTickCount;
                Inc(g_UseItemsShine[sel].idx);
                if g_UseItemsShine[sel].idx > 8 then
                  g_UseItemsShine[sel].idx := 0;
              end;
              d := g_WMainImages.Images[640 + g_UseItemsShine[sel].idx];
              if d <> nil then
                dsurface.DrawBlend(
                  SurfaceX(Left + (Width - d.Width) div 2),
                  SurfaceY(Top + (Height - d.Height) div 2),
                  d, 1);
            end else if g_UseItems[sel].s.reserve[3] = 2 then begin
              if GetTickCount - g_UseItemsShine[sel].tick > 100 then begin
                g_UseItemsShine[sel].tick := GetTickCount;
                Inc(g_UseItemsShine[sel].idx);
                if g_UseItemsShine[sel].idx > 5 then
                  g_UseItemsShine[sel].idx := 0;
              end;
              d := g_WMain2Images.Images[260 + g_UseItemsShine[sel].idx];
              if d <> nil then
                dsurface.DrawBlend(
                  SurfaceX(Left + (Width - d.Width) div 2),
                  SurfaceY(Top + (Height - d.Height) div 2),
                  d, 1);
            end else if g_UseItems[sel].s.reserve[3] = 3 then begin
              if GetTickCount - g_UseItemsShine[sel].tick > 100 then begin
                g_UseItemsShine[sel].tick := GetTickCount;
                Inc(g_UseItemsShine[sel].idx);
                if g_UseItemsShine[sel].idx > 9 then
                  g_UseItemsShine[sel].idx := 0;
              end;
              d := g_StateEffect.Images[550 + g_UseItemsShine[sel].idx];
              if d <> nil then
                dsurface.DrawBlend(
                  SurfaceX(Left + (Width - d.Width) div 2),
                  SurfaceY(Top + (Height - d.Height) div 2),
                  d, 1);
            end else if g_UseItems[sel].s.reserve[3] = 5 then begin
              if GetTickCount - g_UseItemsShine[sel].tick > 100 then begin
                g_UseItemsShine[sel].tick := GetTickCount;
                Inc(g_UseItemsShine[sel].idx);
                if g_UseItemsShine[sel].idx > 9 then
                  g_UseItemsShine[sel].idx := 0;
              end;
              d := g_WStateItemImages.Images[3910 + g_UseItemsShine[sel].idx];
              if d <> nil then
                dsurface.DrawBlend(
                  SurfaceX(Left + (Width - d.Width) div 2),
                  SurfaceY(Top + (Height - d.Height) div 2),
                  d, 1);
            end else if g_UseItems[sel].s.reserve[3] in [6..10] then begin
              d := g_WMain3Images.Images[750 + (g_UseItems[sel].s.reserve[3] - 6) * 2];
              if d <> nil then
                dsurface.DrawBlend(
                  SurfaceX(Left + (Width - d.Width) div 2),
                  SurfaceY(Top + (Height - d.Height) div 2),
                  d, 1);
            end else if g_UseItems[sel].s.reserve[3] in [100..249] then begin //20200927特效首饰人物穿戴
              if GetTickCount - g_UseItemsShine[sel].tick > 200 then begin
                g_UseItemsShine[sel].tick := GetTickCount;
                Inc(g_UseItemsShine[sel].idx);
                if g_UseItemsShine[sel].idx > 19 then
                  g_UseItemsShine[sel].idx := 0;
              end;
              d := frmMain.GetWStateImg(30000 + (g_UseItems[sel].s.reserve[3] +1 - 100) * 20-20 + g_UseItemsShine[sel].idx);
              if d = nil then begin
               g_UseItemsShine[sel].idx := 0;
                d := frmMain.GetWStateImg(30000 + (g_UseItems[sel].s.reserve[3] +1 - 100) * 20-20 + g_UseItemsShine[sel].idx);
              end;
              if d <> nil then
                dsurface.DrawBlend(
                  SurfaceX(Left + (Width - d.Width) div 2),
                  SurfaceY(Top + (Height - d.Height) div 2),
                  d, 1);
            end;

          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DCloseStateClick(Sender: TObject; X, Y: Integer);
begin
  DStateWin.Visible := False;
end;

procedure TFrmDlg.DPrevStateDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
begin
  d := nil;
  with Sender as TDButton do begin
    if TDButton(Sender).Downed then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    end;
  end;
end;

procedure TFrmDlg.PageChanged;
begin
  if g_Myself = nil then Exit;
{$IFNDEF UI_0508}
  DStMag1.AdjustPos(52, 139);
  DStMag2.AdjustPos(52, 185);
  DStMag3.AdjustPos(52, 231);
  DStMag4.AdjustPos(52, 277);
  DStMag5.AdjustPos(52, 323);
  DStMag6.AdjustPos(52, 369);
{$ENDIF}
  DSWNecklace.Visible := False;
  DSWLight.Visible := False;
  DSWArmRingL.Visible := False;
  DSWArmRingR.Visible := False;
  DSWRingL.Visible := False;
  DSWRingR.Visible := False;

  DSWBujuk.Visible := False;
  DSWBelt.Visible := False;
  DSWBoots.Visible := False;
  DSWCharm.Visible := False;
  DSWDrum.Visible := False;
  DSWHorse.Visible := False;

  DSWDress.Visible := False;
  DSWWeapon.Visible := False;
  DSWHelmet.Visible := False;

  DStMag0.Visible := False;
  DStMag1.Visible := False;
  DStMag2.Visible := False;
  DStMag3.Visible := False;
  DStMag4.Visible := False;
  DStMag5.Visible := False;
  DStMag6.Visible := False;
  DStPageUp.Visible := False;
  DStPageDown.Visible := False;

  DListBoxSSkill.Visible := False;
  DSeMag1.Visible := False;
  DSeMag2.Visible := False;
  DSeMag3.Visible := False;
  DSeMag4.Visible := False;
  DBConRandom.Visible := False;
  DBTrainVenation.Visible := False;
  DBConKey.Visible := False;

  DBV1.Visible := False;
  DBV2.Visible := False;
  DBV3.Visible := False;
  DBV4.Visible := False;

  DBP1.Visible := False;
  DBP2.Visible := False;
  DBP3.Visible := False;
  DBP4.Visible := False;
  DBP5.Visible := False;

  DBPH1.Visible := False;
  DBPH2.Visible := False;
  DBPH3.Visible := False;
  DBPH4.Visible := False;
  DBPH5.Visible := False;

  CheckBox_ShowFashion.Visible := False;
{$IFDEF UI_0508}
  if not g_Myself.n_boState then begin
    case StatePage of
      0: begin
          DSWNecklace.Visible := True;
          DSWLight.Visible := True;
          DSWArmRingL.Visible := True;
          DSWArmRingR.Visible := True;
          DSWRingL.Visible := True;
          DSWRingR.Visible := True;

          DSWBujuk.Visible := True;
          DSWBelt.Visible := True;
          DSWBoots.Visible := True;
          DSWCharm.Visible := True;
          DSWDrum.Visible := True;
          DSWHorse.Visible := True;

          DSWDress.Visible := True;
          DSWWeapon.Visible := True;
          DSWHelmet.Visible := True;
        end;
      3: begin
          DStMag1.Visible := True;
          DStMag2.Visible := True;
          DStMag3.Visible := True;
          DStMag4.Visible := True;
          DStMag5.Visible := True;
          DStMag6.Visible := True;
          DStPageUp.Visible := True;
          DStPageDown.Visible := True;
          MagicPage := 0;
        end;
    end;
  end else begin
    case m_nIPStatePage of
      1: begin
          DStMag1.Visible := True;
          DStMag2.Visible := True;
          DStMag3.Visible := True;
          DStMag4.Visible := True;
          DStMag5.Visible := True;
          DStMag6.Visible := True;
          DStPageUp.Visible := True;
          DStPageDown.Visible := True;
          IPMagicPage := 0;
        end;
      2: begin
          DBTrainVenation.Visible := True;

          DBV1.Visible := True;
          DBV2.Visible := g_VenationInfos[0].Point >= 5;
          DBV3.Visible := g_VenationInfos[1].Point >= 5;
          DBV4.Visible := g_VenationInfos[2].Point >= 5;

          DBTrainVenation.Visible := True;

          DBP1.Visible := True;
          DBP2.Visible := True;
          DBP3.Visible := True;
          DBP4.Visible := True;
          DBP5.Visible := True;

          DBPH1.Visible := True;
          DBPH2.Visible := True;
          DBPH3.Visible := True;
          DBPH4.Visible := True;
          DBPH5.Visible := True;

          DBV1Click(DBV1, 0, 0);
        end;
      3: begin
          DStMag3.Visible := True;
          DStMag4.Visible := True;
          DStMag5.Visible := True;
          DStMag6.Visible := True;

          DSeMag1.Visible := True;
          DSeMag2.Visible := True;
          DSeMag3.Visible := True;
          DSeMag4.Visible := True;
          if g_MagicList2.Count > 1 then DBConRandom.Visible := True;
          DBConKey.Visible := True;
        end;
    end;
  end;
{$ELSE}
  if not g_Myself.n_boState then begin
    case StatePage of
      0: begin
          DSWNecklace.Visible := True;
          DSWLight.Visible := True;
          DSWArmRingL.Visible := True;
          DSWArmRingR.Visible := True;
          DSWRingL.Visible := True;
          DSWRingR.Visible := True;

          DSWBujuk.Visible := True;
          DSWBelt.Visible := True;
          DSWBoots.Visible := True;
          DSWCharm.Visible := True;
          DSWDrum.Visible := True;
          DSWHorse.Visible := True;

          DSWDress.Visible := True;
          DSWWeapon.Visible := True;
          DSWHelmet.Visible := True;
        end;
      1: begin
          DSWDress.Visible := True;
          CheckBox_ShowFashion.Visible := True;
        end;
      4: begin
          DStMag1.AdjustPos(44, 197);
          DStMag2.AdjustPos(44, 234);
          DStMag3.AdjustPos(44, 275);
          DStMag4.AdjustPos(44, 314);
          DStMag5.AdjustPos(44, 353);
          DStMag6.AdjustPos(44, 392);

          DStMag0.Visible := True;
          DStMag1.Visible := True;
          DStMag2.Visible := True;
          DStMag3.Visible := True;
          DStMag4.Visible := True;
          DStMag5.Visible := True;
          DStMag6.Visible := True;
        end;
      5: begin
          DStMag1.Visible := True;
          DStMag2.Visible := True;
          DStMag3.Visible := True;
          DStMag4.Visible := True;
          DStMag5.Visible := True;
          DStMag6.Visible := True;
          DStPageUp.Visible := True;
          DStPageDown.Visible := True;
          MagicPage := 0;
        end;
    end;
  end else begin
    case m_nIPStatePage of
      1: begin
          DStMag1.Visible := True;
          DStMag2.Visible := True;
          DStMag3.Visible := True;
          DStMag4.Visible := True;
          DStMag5.Visible := True;
          DStMag6.Visible := True;
          DStPageUp.Visible := True;
          DStPageDown.Visible := True;
          IPMagicPage := 0;
        end;
      2: begin
          DBTrainVenation.Visible := True;

          DBV1.Visible := True;
          DBV2.Visible := g_VenationInfos[0].Point >= 5;
          DBV3.Visible := g_VenationInfos[1].Point >= 5;
          DBV4.Visible := g_VenationInfos[2].Point >= 5;

          DBTrainVenation.Visible := True;

          DBP1.Visible := True;
          DBP2.Visible := True;
          DBP3.Visible := True;
          DBP4.Visible := True;
          DBP5.Visible := True;

          DBPH1.Visible := True;
          DBPH2.Visible := True;
          DBPH3.Visible := True;
          DBPH4.Visible := True;
          DBPH5.Visible := True;

          DBV1Click(DBV1, 0, 0);
        end;
      3: begin
          DStMag3.AdjustPos(53, 224);
          DStMag4.AdjustPos(53, 270);
          DStMag5.AdjustPos(53, 316);
          DStMag6.AdjustPos(53, 362);

          DStMag3.Visible := True;
          DStMag4.Visible := True;
          DStMag5.Visible := True;
          DStMag6.Visible := True;

          DSeMag1.Visible := True;
          DSeMag2.Visible := True;
          DSeMag3.Visible := True;
          DSeMag4.Visible := True;
          if g_MagicList2.Count > 1 then DBConRandom.Visible := True;
          DBConKey.Visible := True;
        end;
    end;
  end;
{$ENDIF}
end;

procedure TFrmDlg.USPageChanged;
begin
{$IFNDEF UI_0508}
  DNecklaceUS1.Visible := False;
  DLightUS1.Visible := False;
  DArmringLUS1.Visible := False;
  DArmringRUS1.Visible := False;
  DRingLUS1.Visible := False;
  DRingRUS1.Visible := False;

  DBujukUS1.Visible := False;
  DBeltUS1.Visible := False;
  DBootsUS1.Visible := False;
  DCharmUS1.Visible := False;

  DDressUS1.Visible := False;
  DWeaponUS1.Visible := False;
  DHelmetUS1.Visible := False;
  DDrumUS1.Visible := False;
  DHorseUS1.Visible := False;

  DStMagUS0.Visible := False;
  DStMagUS1.Visible := False;
  DStMagUS2.Visible := False;
  DStMagUS3.Visible := False;
  DStMagUS4.Visible := False;
  DStMagUS5.Visible := False;
  DStMagUS6.Visible := False;

  case uStatePage of
    0: begin
        DNecklaceUS1.Visible := True;
        DLightUS1.Visible := True;
        DArmringLUS1.Visible := True;
        DArmringRUS1.Visible := True;
        DRingLUS1.Visible := True;
        DRingRUS1.Visible := True;

        DBujukUS1.Visible := True;
        DBeltUS1.Visible := True;
        DBootsUS1.Visible := True;
        DCharmUS1.Visible := True;

        DDressUS1.Visible := True;
        DWeaponUS1.Visible := True;
        DHelmetUS1.Visible := True;
        DDrumUS1.Visible := True;
        DHorseUS1.Visible := True;
      end;
    1: begin
        DDressUS1.Visible := True;
      end;
    2: begin
        DStMagUS0.Visible := True;
        DStMagUS1.Visible := True;
        DStMagUS2.Visible := True;
        DStMagUS3.Visible := True;
        DStMagUS4.Visible := True;
        DStMagUS5.Visible := True;
        DStMagUS6.Visible := True;
      end;
  end;
{$ENDIF}
end;

procedure TFrmDlg.HeroPageChanged;
begin
  if (g_Myself = nil) or (g_Myself.m_HeroObject = nil) then Exit;
{$IFNDEF UI_0508}
  DHStMag1.AdjustPos(52, 139 - 2);
  DHStMag2.AdjustPos(52, 185 - 2);
  DHStMag3.AdjustPos(52, 231 - 2);
  DHStMag4.AdjustPos(52, 277 - 2);
  DHStMag5.AdjustPos(52, 323 - 2);
  DHStMag6.AdjustPos(52, 369 - 2);
{$ENDIF}
  DHSWNecklace.Visible := False;
  DHSWLight.Visible := False;
  DHSWArmRingL.Visible := False;
  DHSWArmRingR.Visible := False;
  DHSWRingL.Visible := False;
  DHSWRingR.Visible := False;
  DHSWBujuk.Visible := False;
  DHSWBelt.Visible := False;
  DHSWBoots.Visible := False;
  DHSWCharm.Visible := False;
  DHSWDress.Visible := False;
  DHSWWeapon.Visible := False;
  DHSWHelmet.Visible := False;
  DHSWDrum.Visible := False;
  DHSWHorse.Visible := False;

  DHStMag0.Visible := False;
  DHStMag1.Visible := False;
  DHStMag2.Visible := False;
  DHStMag3.Visible := False;
  DHStMag4.Visible := False;
  DHStMag5.Visible := False;
  DHStMag6.Visible := False;
  DHStPageUp.Visible := False;
  DHStPageDown.Visible := False;

  DHListBoxSSkill.Visible := False;
  DHSeMag1.Visible := False;
  DHSeMag2.Visible := False;
  DHSeMag3.Visible := False;
  DHSeMag4.Visible := False;
  DBHConRandom.Visible := False;
  DBHTrainVenation.Visible := False;
  DBHConKey.Visible := False;

  DBHV1.Visible := False;
  DBHV2.Visible := False;
  DBHV3.Visible := False;
  DBHV4.Visible := False;

  DBHP1.Visible := False;
  DBHP2.Visible := False;
  DBHP3.Visible := False;
  DBHP4.Visible := False;
  DBHP5.Visible := False;

  DBHPH1.Visible := False;
  DBHPH2.Visible := False;
  DBHPH3.Visible := False;
  DBHPH4.Visible := False;
  DBHPH5.Visible := False;

  CheckBox_hShowFashion.Visible := False;
{$IFDEF UI_0508}
  if not g_Myself.m_HeroObject.n_boState then begin
    case m_nHeroStatePage of
      0: begin
          DHSWNecklace.Visible := True;
          DHSWLight.Visible := True;
          DHSWArmRingL.Visible := True;
          DHSWArmRingR.Visible := True;
          DHSWRingL.Visible := True;
          DHSWRingR.Visible := True;

          DHSWBujuk.Visible := True;
          DHSWBelt.Visible := True;
          DHSWBoots.Visible := True;
          DHSWCharm.Visible := True;

          DHSWDress.Visible := True;
          DHSWWeapon.Visible := True;
          DHSWHelmet.Visible := True;
          DHSWDrum.Visible := True;
          DHSWHorse.Visible := True;
        end;
      3: begin
          DHStMag1.Visible := True;
          DHStMag2.Visible := True;
          DHStMag3.Visible := True;
          DHStMag4.Visible := True;
          DHStMag5.Visible := True;
          DHStMag6.Visible := True;
          DHStPageUp.Visible := True;
          DHStPageDown.Visible := True;
          m_nHeroMagicPage := 0;
        end;
    end;
  end else begin
    case m_nHeroIPStatePage of
      1: begin
          DHStMag1.Visible := True;
          DHStMag2.Visible := True;
          DHStMag3.Visible := True;
          DHStMag4.Visible := True;
          DHStMag5.Visible := True;
          DHStMag6.Visible := True;
          DHStPageUp.Visible := True;
          DHStPageDown.Visible := True;
          m_nHeroIPMagicPage := 0;
        end;
      2: begin
          DBHTrainVenation.Visible := True;

          DBHV1.Visible := True;
          DBHV2.Visible := g_hVenationInfos[0].Point >= 5;
          DBHV3.Visible := g_hVenationInfos[1].Point >= 5;
          DBHV4.Visible := g_hVenationInfos[2].Point >= 5;

          DBHP1.Visible := True;
          DBHP2.Visible := True;
          DBHP3.Visible := True;
          DBHP4.Visible := True;
          DBHP5.Visible := True;

          DBHPH1.Visible := True;
          DBHPH2.Visible := True;
          DBHPH3.Visible := True;
          DBHPH4.Visible := True;
          DBHPH5.Visible := True;

          DBHV1Click(DBHV1, 0, 0);
        end;
      3: begin
          DHStMag3.Visible := True;
          DHStMag4.Visible := True;
          DHStMag5.Visible := True;
          DHStMag6.Visible := True;

          DHSeMag1.Visible := True;
          DHSeMag2.Visible := True;
          DHSeMag3.Visible := True;
          DHSeMag4.Visible := True;
          if g_hMagicList2.Count > 1 then DBHConRandom.Visible := True;
        end;
    end;
  end;
{$ELSE}
  if not g_Myself.m_HeroObject.n_boState then begin
    case m_nHeroStatePage of
      0: begin
          DHSWNecklace.Visible := True;
          DHSWLight.Visible := True;
          DHSWArmRingL.Visible := True;
          DHSWArmRingR.Visible := True;
          DHSWRingL.Visible := True;
          DHSWRingR.Visible := True;

          DHSWBujuk.Visible := True;
          DHSWBelt.Visible := True;
          DHSWBoots.Visible := True;
          DHSWCharm.Visible := True;

          DHSWDress.Visible := True;
          DHSWWeapon.Visible := True;
          DHSWHelmet.Visible := True;
          DHSWDrum.Visible := True;
          DHSWHorse.Visible := True;
        end;
      1: begin
          DHSWDress.Visible := True;
          CheckBox_hShowFashion.Visible := True;
        end;
      4: begin
          DHStMag1.AdjustPos(44, 197 - 2);
          DHStMag2.AdjustPos(44, 234 - 2);
          DHStMag3.AdjustPos(44, 275 - 2);
          DHStMag4.AdjustPos(44, 314 - 2);
          DHStMag5.AdjustPos(44, 353 - 2);
          DHStMag6.AdjustPos(44, 392 - 2);

          DHStMag0.Visible := True;
          DHStMag1.Visible := True;
          DHStMag2.Visible := True;
          DHStMag3.Visible := True;
          DHStMag4.Visible := True;
          DHStMag5.Visible := True;
          DHStMag6.Visible := True;
        end;
      5: begin
          DHStMag1.Visible := True;
          DHStMag2.Visible := True;
          DHStMag3.Visible := True;
          DHStMag4.Visible := True;
          DHStMag5.Visible := True;
          DHStMag6.Visible := True;
          DHStPageUp.Visible := True;
          DHStPageDown.Visible := True;
          m_nHeroMagicPage := 0;
        end;
    end;
  end else begin
    case m_nHeroIPStatePage of
      1: begin
          DHStMag1.Visible := True;
          DHStMag2.Visible := True;
          DHStMag3.Visible := True;
          DHStMag4.Visible := True;
          DHStMag5.Visible := True;
          DHStMag6.Visible := True;
          DHStPageUp.Visible := True;
          DHStPageDown.Visible := True;
          m_nHeroIPMagicPage := 0;
        end;
      2: begin
          DBHTrainVenation.Visible := True;

          DBHV1.Visible := True;
          DBHV2.Visible := g_hVenationInfos[0].Point >= 5;
          DBHV3.Visible := g_hVenationInfos[1].Point >= 5;
          DBHV4.Visible := g_hVenationInfos[2].Point >= 5;

          DBHP1.Visible := True;
          DBHP2.Visible := True;
          DBHP3.Visible := True;
          DBHP4.Visible := True;
          DBHP5.Visible := True;

          DBHPH1.Visible := True;
          DBHPH2.Visible := True;
          DBHPH3.Visible := True;
          DBHPH4.Visible := True;
          DBHPH5.Visible := True;

          DBHV1Click(DBHV1, 0, 0);
        end;
      3: begin
          DHStMag3.AdjustPos(53, 224 - 2);
          DHStMag4.AdjustPos(53, 270 - 2);
          DHStMag5.AdjustPos(53, 316 - 2);
          DHStMag6.AdjustPos(53, 362 - 2);

          DHStMag3.Visible := True;
          DHStMag4.Visible := True;
          DHStMag5.Visible := True;
          DHStMag6.Visible := True;

          DHSeMag1.Visible := True;
          DHSeMag2.Visible := True;
          DHSeMag3.Visible := True;
          DHSeMag4.Visible := True;
          if g_hMagicList2.Count > 1 then DBHConRandom.Visible := True;
        end;
    end;
  end;
{$ENDIF}
end;

procedure TFrmDlg.DSWWeaponClick(Sender: TObject; X, Y: Integer);
var
  where, n, sel: Integer;
  flag, MovCancel: Boolean;
begin
  if (g_Myself = nil) or (g_Myself.n_boState) or not (StatePage in [0, 1]) then Exit;
  if g_boItemMoving then begin
    flag := False;
    MovCancel := False;
    if (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) then Exit;
    if (g_MovingItem.item.s.Name = '') or (g_WaitingUseItem.item.s.Name <> '') then Exit;
    where := GetTakeOnPosition(g_MovingItem.item.s, g_UseItems);
    if (g_MovingItem.Index >= 0) and (g_MovingItem.Index < HERO_MIIDX_OFFSET) then begin
      case where of
{$IFNDEF UI_0508}
        U_DRUM: begin
            if Sender = DSWDrum then flag := True;
          end;
        U_HORSE: begin
            if Sender = DSWHorse then flag := True;
          end;
        U_FASHION: if (Sender = DSWDress) and (StatePage = 1) then begin
            if g_Myself.m_btSex = 0 then
              if g_MovingItem.item.s.StdMode <> 12 then
                Exit;
            if g_Myself.m_btSex = 1 then
              if g_MovingItem.item.s.StdMode <> 13 then
                Exit;
            flag := True;
          end;
{$ENDIF}
        U_DRESS: if (Sender = DSWDress) and (StatePage = 0) then begin
            if g_Myself.m_btSex = 0 then
              if g_MovingItem.item.s.StdMode <> 10 then
                Exit;
            if g_Myself.m_btSex = 1 then
              if g_MovingItem.item.s.StdMode <> 11 then
                Exit;
            flag := True;
          end;
        U_WEAPON: if Sender = DSWWeapon then flag := True;
        U_NECKLACE: if Sender = DSWNecklace then flag := True;
        U_RIGHTHAND: if Sender = DSWLight then flag := True;
        U_HELMET, U_HELMETEX: if Sender = DSWHelmet then flag := True;
        U_RINGR, U_RINGL: begin
            if Sender = DSWRingL then begin
              where := U_RINGL;
              flag := True;
            end;
            if Sender = DSWRingR then begin
              where := U_RINGR;
              flag := True;
            end;
          end;
        U_ARMRINGR: begin
            if Sender = DSWArmRingL then begin
              where := U_ARMRINGL;
              flag := True;
            end;
            if Sender = DSWArmRingR then begin
              where := U_ARMRINGR;
              flag := True;
            end;
          end;
        U_ARMRINGL: begin
            if Sender = DSWArmRingL then begin
              where := U_ARMRINGL;
              flag := True;
            end;
          end;
        U_BUJUK: begin
            if Sender = DSWBujuk then begin
              where := U_BUJUK;
              flag := True;
            end;
            if g_MovingItem.item.s.StdMode <> 42 then begin
              if Sender = DSWArmRingL then begin
                where := U_ARMRINGL;
                flag := True;
              end;
            end;
          end;
        U_BELT: begin
            if Sender = DSWBelt then begin
              where := U_BELT;
              flag := True;
            end;
          end;
        U_BOOTS: begin
            if Sender = DSWBoots then begin
              where := U_BOOTS;
              flag := True;
            end;
          end;
        U_CHARM: begin
            if Sender = DSWCharm then begin
              where := U_CHARM;
              flag := True;
            end;
          end;
      end;
    end else begin
      n := -(g_MovingItem.Index + 1);
      if n in [0..U_FASHION] then begin
        g_SndMgr.ItemClickSound(g_MovingItem.item.s);
        g_UseItems[n] := g_MovingItem.item;
        g_MovingItem.item.s.Name := '';
        g_boItemMoving := False;
      end;
    end;
    if flag then begin
      g_SndMgr.ItemClickSound(g_MovingItem.item.s);
      g_WaitingUseItem := g_MovingItem;
      g_WaitingUseItem.Index := where;
      frmMain.SendTakeOnItem(where, g_MovingItem.item.MakeIndex, g_MovingItem.item.s.Name);
      g_MovingItem.item.s.Name := '';
      g_boItemMoving := False;
    end;
  end else begin
    flag := False;
    if (g_MovingItem.item.s.Name <> '') or (g_WaitingUseItem.item.s.Name <> '') then Exit;
    sel := -1;
    if Sender = DSWDress then begin
{$IFDEF UI_0508}
      sel := U_DRESS;
{$ELSE}
      if StatePage = 0 then
        sel := U_DRESS
      else
        sel := U_FASHION;
{$ENDIF}
    end;
    if Sender = DSWWeapon then sel := U_WEAPON;
    if Sender = DSWHelmet then begin
      if g_UseItems[U_HELMETEX].s.Name <> '' then
        sel := U_HELMETEX
      else
        sel := U_HELMET;
    end;
    if Sender = DSWNecklace then sel := U_NECKLACE;
    if Sender = DSWLight then sel := U_RIGHTHAND;
    if Sender = DSWRingL then sel := U_RINGL;
    if Sender = DSWRingR then sel := U_RINGR;
    if Sender = DSWArmRingL then sel := U_ARMRINGL;
    if Sender = DSWArmRingR then sel := U_ARMRINGR;

    if Sender = DSWBujuk then sel := U_BUJUK;
    if Sender = DSWBelt then sel := U_BELT;
    if Sender = DSWBoots then sel := U_BOOTS;
    if Sender = DSWCharm then sel := U_CHARM;
{$IFNDEF UI_0508}
    if Sender = DSWDrum then sel := U_DRUM;
    if Sender = DSWHorse then sel := U_HORSE;
{$ENDIF}

    if sel >= 0 then begin
      if g_UseItems[sel].s.Name <> '' then begin
        g_SndMgr.ItemClickSound(g_UseItems[sel].s);
        g_MovingItem.Index := -(sel + 1);
        g_MovingItem.item := g_UseItems[sel];
        g_UseItems[sel].s.Name := '';
        g_pweapon := @g_UseItems[sel] ;
          g_boItemMoving := True;
      end;
    end;
  end;
end;

procedure TFrmDlg.DSWWeaponMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  HintLeft, b1, b2: Boolean;
  L, sel: Integer;
  shint: string;
begin
  if not (StatePage in [0..1]) or g_Myself.n_boState then Exit;
  L := 0;
  sel := -1;
  if Sender = DSWDress then begin
{$IFDEF UI_0508}
    sel := U_DRESS;
{$ELSE}
    if StatePage = 0 then
      sel := U_DRESS
    else
      sel := U_FASHION;
{$ENDIF}
  end
  else if Sender = DSWWeapon then sel := U_WEAPON
  else if Sender = DSWHelmet then sel := U_HELMET
  else if Sender = DSWNecklace then sel := U_NECKLACE
  else if Sender = DSWLight then sel := U_RIGHTHAND
  else if Sender = DSWRingL then sel := U_RINGL
  else if Sender = DSWRingR then sel := U_RINGR
  else if Sender = DSWArmRingL then sel := U_ARMRINGL
  else if Sender = DSWArmRingR then sel := U_ARMRINGR
  else if Sender = DSWBujuk then sel := U_BUJUK
  else if Sender = DSWBelt then sel := U_BELT
  else if Sender = DSWBoots then sel := U_BOOTS
{$IFDEF UI_0508}
  else if Sender = DSWCharm then sel := U_CHARM;
{$ELSE}
  else if Sender = DSWCharm then sel := U_CHARM
  else if Sender = DSWDrum then sel := U_DRUM
  else if Sender = DSWHorse then sel := U_HORSE;
{$ENDIF}

  if sel >= 0 then begin
    DScreen.ClearHint;
    L := 0;
    with DStateWin do begin
      X := SurfaceX(Left + {$IFDEF UI_0508}243{$ELSE}372{$ENDIF});
      Y := SurfaceY(Top + 65);

      HintLeft := False;
      if X + 151 > SCREENWIDTH then
        HintLeft := True;

      if g_UseItems[sel].s.Name <> '' then begin
        g_ShowSuite := 1;
        g_SuiteIdx := sel;
        g_MouseItem := g_UseItems[sel];
        if HintLeft then begin
          GetMouseItemInfoHint(g_MouseItem, shint);

          if shint <> '' then begin
            L := DScreen.ShowHint(
              X - 209{$IFNDEF UI_0508} - 164{$ENDIF},
              Y,
              shint,
              clWhite, False, True, True, True);
          end;

          if (sel = U_HELMET) and (g_UseItems[U_HELMETEX].s.Name <> '') then begin
            GetMouseItemInfoHint(g_UseItems[U_HELMETEX], shint);
            if shint <> '' then begin
              DScreen.ShowHint(
                X - 209{$IFNDEF UI_0508} - 164{$ENDIF} + (MAXITEMBOX_WIDTH + 5),
                Y,
                shint,
                clWhite, False, True, True, True, 2);
            end;
          end;

        end else begin
          GetMouseItemInfoHint(g_MouseItem, shint);
          if shint <> '' then begin
            L := DScreen.ShowHint(
              X - 30,
              Y,
              shint,
              clWhite, False, False, True, True);
          end;

          if (sel = U_HELMET) and (g_UseItems[U_HELMETEX].s.Name <> '') then begin
            GetMouseItemInfoHint(g_UseItems[U_HELMETEX], shint);
            if shint <> '' then begin
              DScreen.ShowHint(
                X - 30 - (MAXITEMBOX_WIDTH + 5),
                Y,
                shint,
                clWhite, False, False, True, True, 2);
            end;
          end;

        end;
        g_MouseItem.s.Name := '';
      end else begin
        if HintLeft then begin
          if (sel = U_HELMET) and (g_UseItems[U_HELMETEX].s.Name <> '') then begin
            GetMouseItemInfoHint(g_UseItems[U_HELMETEX], shint);
            if shint <> '' then begin
              DScreen.ShowHint(
                X - 209{$IFNDEF UI_0508} - 164{$ENDIF},
                Y,
                shint,
                clWhite, False, True, True, True, 2);
            end;
          end;
        end else begin
          if (sel = U_HELMET) and (g_UseItems[U_HELMETEX].s.Name <> '') then begin
            GetMouseItemInfoHint(g_UseItems[U_HELMETEX], shint);
            if shint <> '' then begin
              DScreen.ShowHint(
                X - 30,
                Y,
                shint,
                clWhite, False, False, True, True, 2);
            end;
          end;
        end;

      end;
    end;
  end;
end;

procedure TFrmDlg.DStateWinMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  i: Integer;
  p: TPoint;
begin
  DScreen.ClearHint;
  if g_MouseStateItem.s.Name <> '' then
    g_MouseStateItem.s.Name := '';
{$IF SERIESSKILL}
  if g_VMouseInfo <> '' then
    g_VMouseInfo := '';
  if g_VMouseInfo2 <> '' then
    g_VMouseInfo2 := '';
{$IFEND SERIESSKILL}
end;

procedure TFrmDlg.DStMag1DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  idx, icon: Integer;
  d: TCustomLockableTexture;
  pm: PTClientMagic;
  p: pTClientStdItem;
begin
  d := nil;
  with Sender as TDButton do begin
    if (g_Myself = nil) then Exit;
    if not g_Myself.n_boState then begin
      if StatePage = {$IFDEF UI_0508}3{$ELSE}5{$ENDIF} then begin
        idx := _MAX(tag + MagicPage * 6, 0);
        if idx < g_MagicList.Count then begin
          pm := PTClientMagic(g_MagicList[idx]);
          if pm.Def.btEffect in [124..128] then begin
            d := g_WMagIcon2Images.Images[(pm.Def.btEffect - 124) * 2 + 580 + byte(Downed)];
            if d <> nil then
              dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
          end else if pm.Def.btEffect in [120..123] then begin
            d := g_Wui.Images[(pm.Def.btEffect - 120) * 2 + 761 + byte(Downed)];
            if d <> nil then
              dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
          end else if pm.Def.btEffect in [115..117] then begin
            if not Downed then begin
              d := g_WMagIcon2Images.Images[(pm.Def.btEffect - 115) * 2 + 170];
              if d <> nil then
                dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
            end else begin
              d := g_WMagIcon2Images.Images[(pm.Def.btEffect - 115) * 2 + 170 + 1];
              if d <> nil then
                dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
            end;
          end else if pm.Def.btEffect in [118] then begin
            if not Downed then begin
              d := g_WMagIcon2Images.Images[620];
              if d <> nil then
                dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
            end else begin
              d := g_WMagIcon2Images.Images[620 + 1];
              if d <> nil then
                dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
            end;
          end else begin
            icon := pm.Def.btEffect * 2;
            if icon >= 0 then begin
              if not Downed then begin
                d := g_WMagIconImages.Images[icon];
                if d <> nil then
                  dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
              end else begin
                d := g_WMagIconImages.Images[icon + 1];
                if d <> nil then
                  dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
              end;
            end;
          end;
        end;
      end else if StatePage = 4 then begin
{$IFNDEF UI_0508}
        if tag = 6 then begin
          p := GetTitle(g_Myself.m_btTitleIndex);
          if p <> nil then begin
            d := g_Wui.Images[670 + byte(Downed) * 2];
            if d <> nil then
              dsurface.Draw(SurfaceX(Left) + 1, SurfaceY(Top) + 1, d);

            d := g_Wui.Images[p.looks + 3 + byte(Downed)];
            if d <> nil then
              dsurface.Draw(SurfaceX(Left) + 1, SurfaceY(Top) + 1, d);

            dsurface.BoldTextOut(
              SurfaceX(Left + Width) + 10,
              SurfaceY(Top) + 8,
              GetLevelColor(p.Source), clBlack, p.Name);
          end;
        end else if tag in [0..5] then begin
          p := GetTitle(g_Titles[tag].Index);
          if p <> nil then begin
            d := g_Wui.Images[675 + byte(Downed) * 2];
            if d <> nil then
              dsurface.Draw(SurfaceX(Left) + 2, SurfaceY(Top) + 2, d);

            d := g_Wui.Images[p.looks + 1 + byte(Downed)];
            if d <> nil then
              dsurface.Draw(SurfaceX(Left) + 2, SurfaceY(Top) + 2, d);

            dsurface.BoldTextOut(
              SurfaceX(Left + Width) + 10,
              SurfaceY(Top) + 8,
              GetLevelColor(p.Source), clBlack, p.Name);

            if g_Myself.m_btTitleIndex = g_Titles[tag].Index then begin
              d := g_WMain3Images.Images[756];
              if d <> nil then
                dsurface.DrawBlend(
                  (SurfaceX(Left) + (Width - d.Width) div 2),
                  (SurfaceY(Top) + (Height - d.Height) div 2),
                  d, 1);
            end;

          end;
        end;
{$ENDIF}
      end;
    end else begin
      case m_nIPStatePage of
        1: begin
            idx := _MAX(tag + IPMagicPage * 6, 0);
            if idx < g_IPMagicList.Count then begin
              pm := PTClientMagic(g_IPMagicList[idx]);
              icon := pm.Def.btEffect * 2;
              if icon >= 0 then begin
                d := g_WMagIconImages.Images[icon];
                if d <> nil then
                  dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
              end;
            end;
          end;
        3: begin
            idx := tag - 2;
            if idx < g_MagicList2.Count then begin
              pm := PTClientMagic(g_MagicList2[idx]);
              icon := GetSeriesSkillIcon(pm.Def.btEffect);
              if icon >= 0 then begin
                d := g_WMainImages.Images[icon];
                if d <> nil then
                  dsurface.Draw(SurfaceX(Left - 1), SurfaceY(Top + 7), d.ClientRect, d, True);
              end;
            end;
          end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DStMag1MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var
  s, ostr: string;
  i, idx, trainlv: Integer;
  selkey: Word;
  keych: Char;
  pm: PTClientMagic;
  p: pTClientStdItem;
begin
  if not g_Myself.n_boState then begin
    if (StatePage = {$IFDEF UI_0508}3{$ELSE}5{$ENDIF}) then begin
      with TDButton(Sender) do begin
        idx := tag + m_nMagTop;
        if (idx >= 0) and (idx < g_MagicList.Count) then begin
          pm := PTClientMagic(g_MagicList[idx]);
          trainlv := _MIN(14, pm.Level);
          if pm.Level >= pm.Def.btTrainLv then begin
            DScreen.ShowHint(SurfaceX(Left - 2), SurfaceY(Top),
              Format('<%s|C=%d b=Bold s=10>\', [pm.Def.sMagicName, GetRGB(95)]) +
              sFullLevel +
              Format('<%s>\', [g_asSkillDesc[pm.Def.wMagicId], GetRGB(103)]) +
              '<(点击图标设置快捷键)|C=clWhite>',
              GetRGB(103), False, True, True);

          end else begin
            DScreen.ShowHint(SurfaceX(Left - 2), SurfaceY(Top),
              Format('<%s|C=%d b=Bold s=10>\', [pm.Def.sMagicName, GetRGB(95)]) +
              Format(sNextLevel, [pm.Def.TrainLevel[trainlv]]) +
              Format('<%s>\', [g_asSkillDesc[pm.Def.wMagicId], GetRGB(103)]) +
              '<(点击图标设置快捷键)|C=clWhite>',
              GetRGB(103), False, True, True);
          end;
        end;
      end;
    end else if StatePage = 4 then begin
{$IFNDEF UI_0508}
      with TDButton(Sender) do begin
        if tag = 6 then
          p := GetTitle(g_Myself.m_btTitleIndex)
        else
          p := GetTitle(g_Titles[tag].Index);
        if p <> nil then begin
          g_MouseItem.s := p^;
          GetMouseItemInfoHint(g_MouseItem, s);
          if s <> '' then begin
            idx := -1;
            if tag = 6 then begin
              if g_Myself.m_btTitleIndex > 0 then begin
                for i := Low(g_Titles) to High(g_Titles) do begin
                  if g_Myself.m_btTitleIndex = g_Titles[i].Index then begin
                    idx := i;
                    Break;
                  end;
                end;
              end;
            end else begin
              idx := tag;
            end;
            if idx in [0..5] then begin
              if g_Titles[idx].Time >= 24 then
                ostr := Format('<使用时间: |C=clWhite><%d|C=clYellow>< 天|C=clWhite>\', [g_Titles[idx].Time div 24])
              else if g_Titles[idx].Time = -14 then
                ostr := '<使用状态: |C=clWhite><未开启|C=clYellow>\'
              else if g_Titles[idx].Time = -15 then
                ostr := '<使用时间: |C=clWhite><无限|C=clYellow>\'
              else
                ostr := Format('<使用时间: |C=clWhite><%d|C=clYellow>< 小时|C=clWhite>\', [g_Titles[idx].Time]);
            end;
            if ostr <> '' then begin
              if (ostr[Length(ostr)] <> '\') then
                ostr := ostr + '\';
              s := s + '-\' + ostr;
            end;
            DScreen.ShowHint(
              SurfaceX(Left + 102), SurfaceY(Top),
              s,
              clWhite, False, False, True, True);
          end;
        end;
      end;
{$ENDIF}
    end;
  end else begin
    if (m_nIPStatePage = 3) then begin
      with TDButton(Sender) do begin
        idx := tag - 2;
        if (idx >= 0) and (idx < g_MagicList2.Count) then begin
          pm := PTClientMagic(g_MagicList2[idx]);
          trainlv := _MIN(14, pm.Level);
          if pm.Level >= pm.Def.btTrainLv then begin
            DScreen.ShowHint(SurfaceX(Left - 2), SurfaceY(Top),
              Format('<%s|C=%d b=Bold s=10>\', [pm.Def.sMagicName, GetRGB(95)]) +
              sFullLevel +
              Format('<%s>\', [g_asSkillDesc[pm.Def.wMagicId], GetRGB(103)]),
              GetRGB(103), False, True, True);

          end else begin
            DScreen.ShowHint(SurfaceX(Left - 2), SurfaceY(Top),
              Format('<%s|C=%d b=Bold s=10>\', [pm.Def.sMagicName, GetRGB(95)]) +
              Format(sNextLevel2, [pm.Def.TrainLevel[trainlv]]) +
              Format('<%s>\', [g_asSkillDesc[pm.Def.wMagicId], GetRGB(103)]),
              GetRGB(103), False, True, True);
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DStMagUS1DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  idx, icon: Integer;
  d: TCustomLockableTexture;
  pm: PTClientMagic;
  p: pTClientStdItem;
begin
  d := nil;
{$IFNDEF UI_0508}
  with Sender as TDButton do begin
    if uStatePage = 2 then begin
      if tag = 6 then begin
        p := GetTitle(UserState1.ActiveTitle);
        if p <> nil then begin
          d := g_Wui.Images[670 + byte(Downed) * 2];
          if d <> nil then
            dsurface.Draw(SurfaceX(Left) + 1, SurfaceY(Top) + 1, d);

          d := g_Wui.Images[p.looks + 3 + byte(Downed)];
          if d <> nil then
            dsurface.Draw(SurfaceX(Left) + 1, SurfaceY(Top) + 1, d);

          dsurface.BoldTextOut(
            SurfaceX(Left + Width) + 10,
            SurfaceY(Top) + 8,
            GetLevelColor(p.Source), clBlack, p.Name);
        end;
      end else if tag in [0..5] then begin
        p := GetTitle(UserState1.Titles[tag].Index);
        if p <> nil then begin
          d := g_Wui.Images[675 + byte(Downed) * 2];
          if d <> nil then
            dsurface.Draw(SurfaceX(Left) + 2, SurfaceY(Top) + 2, d);
          d := g_Wui.Images[p.looks + 1 + byte(Downed)];
          if d <> nil then
            dsurface.Draw(SurfaceX(Left) + 2, SurfaceY(Top) + 2, d);
          dsurface.BoldTextOut(
            SurfaceX(Left + Width) + 10,
            SurfaceY(Top) + 8,
            GetLevelColor(p.Source), clBlack, p.Name);
          if UserState1.ActiveTitle = UserState1.Titles[tag].Index then begin
            d := g_WMain3Images.Images[756];
            if d <> nil then
              dsurface.DrawBlend(
                (SurfaceX(Left) + (Width - d.Width) div 2),
                (SurfaceY(Top) + (Height - d.Height) div 2),
                d, 1);
          end;
        end;
      end;
    end;
  end;
{$ENDIF}
end;

procedure TFrmDlg.DStMagUS2MouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  s, ostr: string;
  i, idx, trainlv: Integer;
  selkey: Word;
  keych: Char;
  pm: PTClientMagic;
  p: pTClientStdItem;
begin
{$IFNDEF UI_0508}
  if uStatePage = 2 then begin
    with TDButton(Sender) do begin
      if tag = 6 then
        p := GetTitle(UserState1.ActiveTitle)
      else
        p := GetTitle(UserState1.Titles[tag].Index);
      if p <> nil then begin
        g_MouseItem.s := p^;
        GetMouseItemInfoHint(g_MouseItem, s);
        if s <> '' then begin
          idx := -1;
          if tag = 6 then begin
            if UserState1.ActiveTitle > 0 then begin
              for i := Low(UserState1.Titles) to High(UserState1.Titles) do begin
                if UserState1.ActiveTitle = UserState1.Titles[i].Index then begin
                  idx := i;
                  Break;
                end;
              end;
            end;
          end else begin
            idx := tag;
          end;
          if idx in [0..5] then begin
            if UserState1.Titles[idx].Time >= 24 then
              ostr := Format('<使用时间: |C=clWhite><%d|C=clYellow>< 天|C=clWhite>\', [UserState1.Titles[idx].Time div 24])
            else if UserState1.Titles[idx].Time = -14 then
              ostr := '<使用状态: |C=clWhite><未开启|C=clYellow>\'
            else if UserState1.Titles[idx].Time = -15 then
              ostr := '<使用时间: |C=clWhite><无限|C=clYellow>\'
            else
              ostr := Format('<使用时间: |C=clWhite><%d|C=clYellow>< 小时|C=clWhite>\', [UserState1.Titles[idx].Time]);
          end;
          if ostr <> '' then begin
            if (ostr[Length(ostr)] <> '\') then
              ostr := ostr + '\';
            s := s + '-\' + ostr;
          end;
          DScreen.ShowHint(
            SurfaceX(Left + 102), SurfaceY(Top),
            s,
            clWhite, False, False, True, True);
        end;
      end;
    end;
  end;
{$ENDIF}
end;

procedure TFrmDlg.DStMag1Click(Sender: TObject; X, Y: Integer);
var
  i, idx: Integer;
  selkey, selkey2: Word;
  keych: Char;
  pm: PTClientMagic;
  p, p2: pTClientStdItem;
  DefMsg: TDefaultMessage;
begin
  if not g_Myself.n_boState then begin
    if (StatePage = {$IFDEF UI_0508}3{$ELSE}5{$ENDIF}) then begin
      idx := TDButton(Sender).tag + m_nMagTop;
      if (idx >= 0) and (idx < g_MagicList.Count) then begin

        pm := PTClientMagic(g_MagicList[idx]);
        if pm.Def.wMagicId = 67 then begin
          //

        end else begin
          selkey := Word(pm.Key);
          selkey2 := selkey;
          SetMagicKeyDlg(pm.Def.btEffect * 2, pm.Def.sMagicName, selkey);
          if selkey2 = selkey then Exit;
          keych := Char(selkey);
          if keych <> #0 then begin
            for i := 0 to g_MagicList.Count - 1 do begin
              pm := PTClientMagic(g_MagicList[i]);
              if pm.Key = keych then begin
                pm.Key := #0;
                frmMain.SendMagicKeyChange(pm.Def.wMagicId, #0);
                Break;
              end;
            end;
          end;
          pm := PTClientMagic(g_MagicList[idx]);
          pm.Key := keych;
          frmMain.SendMagicKeyChange(pm.Def.wMagicId, keych);
        end;
      end;
    end else if (StatePage = 4) then begin
{$IFNDEF UI_0508}
      if TDButton(Sender).tag = 6 then begin
        p := GetTitle(g_Myself.m_btTitleIndex);
        if p <> nil then begin
          if DMessageDlg('是否确认关闭当前称号？', [mbOk, mbCancel]) = mrOk then begin
            //开关
            DefMsg := EDcode.MakeDefaultMsg(CM_CHANGETITLE, 0, 0, 0, 0);
            frmMain.SendSocket(EncodeMessage(DefMsg));
          end;
        end;
      end else if TDButton(Sender).tag in [0..5] then begin
        p := GetTitle(g_Titles[TDButton(Sender).tag].Index);
        if p <> nil then begin
          if g_Myself.m_btTitleIndex = g_Titles[TDButton(Sender).tag].Index then
            Exit;
          if DMessageDlg(Format('激活[%s]称号？', [p.Name]), [mbOk, mbCancel]) = mrOk then begin
            //请求切换
            DefMsg := EDcode.MakeDefaultMsg(CM_CHANGETITLE, 0, 0, 0, g_Titles[TDButton(Sender).tag].Index);
            frmMain.SendSocket(EncodeMessage(DefMsg));
          end;
        end;
      end;
{$ENDIF}
    end;
  end;
end;

procedure TFrmDlg.DStPageUpClick(Sender: TObject; X, Y: Integer);
begin
  if (g_Myself = nil) then Exit;
  if not g_Myself.n_boState then begin
    if Sender = DStPageUp then begin
      if MagicPage > 0 then
        Dec(MagicPage);
    end else begin
      if MagicPage < (g_MagicList.Count + 5) div 6 - 1 then
        Inc(MagicPage);
    end;
  end else begin
    if Sender = DStPageUp then begin
      if IPMagicPage > 0 then
        Dec(IPMagicPage);
    end else begin
      if IPMagicPage < (g_IPMagicList.Count + 5) div 6 - 1 then
        Inc(IPMagicPage);
    end;
  end;
end;

procedure TFrmDlg.DStPageUpDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  Tex: TCustomLockableTexture;
begin
  with Sender as TDButton do begin
    Tex := nil;
    if Downed then begin
      Tex := WLib.Images[FaceIndex + 2];
    end else begin
      if Arrived then
        Tex := WLib.Images[FaceIndex + 1]
      else
        Tex := WLib.Images[FaceIndex];
    end;
    if Tex <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), Tex);
  end;
end;

procedure TFrmDlg.DBottomDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  btop: Integer;
  d: TCustomLockableTexture;
  rc, rc2: TIntRect;
  sX, sY, i, fcolor, bcolor, lx, ly: Integer;
  r: Real;
  Str: string;
begin
  d := nil;
  btop := SCREENHEIGHT - 251;
  with DBottom do begin
    lx := SurfaceX(Left);
    ly := SurfaceY(Top);

    if g_WinBottomType <> g_WinBottomRetry then begin
      d := g_WMain3Images.Images[BOTTOMBOARD800];
      if d <> nil then begin
        dsurface.Draw(lx, ly, d.ClientRect, d, True);
      end;
    end else begin
      BuildBottomWinSurface(dsurface,g_boHero)
//      if (DBottom.ImageSurface <> nil) then
//        dsurface.Draw(lx, ly, DBottom.ImageSurface.ClientRect, DBottom.ImageSurface, True);
    end;
  end;

  d := nil;
  case g_nDayBright of
    0: d := g_WMainImages.Images[15]; //早上
    1: d := g_WMainImages.Images[12]; //白天
    2: d := g_WMainImages.Images[13]; //傍晚
    3: d := g_WMainImages.Images[14]; //晚上
  end;
  if d <> nil then
    dsurface.Draw(SCREENWIDTH div 2 + (SCREENWIDTH div 2 - (52)), 79 + DBottom.Top, d.ClientRect, d, False);

  if g_Myself <> nil then begin //显示HP及MP图形
    if (g_Myself.m_Abil.MaxHP > 0) and (g_Myself.m_Abil.MaxMP > 0) then begin
      if (g_Myself.m_btJob = 0) and (g_Myself.m_Abil.Level < 28) then begin
        d := g_WMainImages.Images[5];
        if d <> nil then begin
          rc := d.ClientRect;
          rc.Right := d.ClientRect.Right - 2;
          dsurface.Draw(38, btop + 90, rc, d, False);
        end;
        d := g_WMainImages.Images[6];
        if d <> nil then begin
          rc := d.ClientRect;
          rc.Right := d.ClientRect.Right - 2;
          rc.Top := Round(rc.Bottom / g_Myself.m_Abil.MaxHP * (g_Myself.m_Abil.MaxHP - _MIN(g_Myself.m_Abil.MaxHP, g_Myself.m_Abil.HP)));
          dsurface.Draw(38, btop + 90 + rc.Top, rc, d, False);
        end;
      end else begin
        d := g_WMainImages.Images[4];
        if d <> nil then begin //HP 图形
          rc := d.ClientRect;
          rc.Right := d.ClientRect.Right div 2 - 1;
          rc.Top := Round(rc.Bottom / g_Myself.m_Abil.MaxHP * (g_Myself.m_Abil.MaxHP - _MIN(g_Myself.m_Abil.MaxHP, g_Myself.m_Abil.HP)));
          dsurface.Draw(40, btop + 91 + rc.Top, rc, d, False);
          rc := d.ClientRect; //MP 图形
          rc.Left := d.ClientRect.Right div 2 + 1;
          rc.Right := d.ClientRect.Right - 1;
          rc.Top := Round(rc.Bottom / g_Myself.m_Abil.MaxMP * (g_Myself.m_Abil.MaxMP - _MIN(g_Myself.m_Abil.MaxMP, g_Myself.m_Abil.MP)));
          dsurface.Draw(40 + rc.Left, btop + 91 + rc.Top, rc, d, False);
        end;
        if g_Myself.m_nState and $00020000 <> 0 then begin //龙化
          i := (g_Myself.m_nGenAniCount mod 14);
          d := g_WMagic10Images.Images[240 + i];
          if d <> nil then
            dsurface.DrawBlend( 37, btop + 90, d, 1);

          d := g_WMagic10Images.Images[260 + i];
          if d <> nil then
            dsurface.DrawBlend( 32, btop + 90, d, 1);

          d := g_WMagic10Images.Images[280 + i];
          if d <> nil then
            dsurface.DrawBlend( -64, btop - 10, d, 1);
        end;
      end;
    end;

    ///////////////
    if g_Button_DetectBox then begin //绘制灵媒窗体
      d := g_Wui.Images[896];
      if d <> nil then begin
        dsurface.Draw(0, SCREENHEIGHT - 152 - 79, d.ClientRect, d, True);

      end;
    end;

    with dsurface do begin
      //if g_MySelf <> nil then begin
      BoldText(28, SCREENHEIGHT - 37, IntToStr(_MIN(g_Myself.m_Abil.MaxHP, g_Myself.m_Abil.HP)) + '/' + IntToStr(g_Myself.m_Abil.MaxHP), clWhite, clBlack);
      BoldText(88, SCREENHEIGHT - 37, IntToStr(_MIN(g_Myself.m_Abil.MaxMP, g_Myself.m_Abil.MP)) + '/' + IntToStr(g_Myself.m_Abil.MaxMP), clWhite, clBlack); //IntToStr(g_MySelf.m_Abil.MP) + '/' + IntToStr(g_MySelf.m_Abil.MaxMP));

      BoldText(20, SCREENHEIGHT - 17, Format('%s %d:%d', [g_sMapTitle, g_Myself.m_nCurrX, g_Myself.m_nCurrY]), clWhite, clBlack); //g_sMapTitle + ' ' + IntToStr(g_MySelf.m_nCurrX) + ':' + IntToStr(g_MySelf.m_nCurrY));
      //end;
      //BoldTextOut(dsurface, 108, SCREENHEIGHT - 17, clWhite, clBlack, format('%d', [g_PlayScene.m_ActorList.Count]));
    end;

    d := g_opui.Images[20]; //聊天框 拉伸条
    if d <> nil then dsurface.Draw(SCREENWIDTH - 207, SCREENHEIGHT - 127, d.ClientRect, d, True);

    if (g_nMaxSquHitPoint > 0) then begin
      //d := g_WMainImages.ImagesName[5, g_sVigourbar1];
      d := g_opui.Images[g_sVigourbar1];
      if d <> nil then begin
        rc := d.ClientRect;
        rc.Right := d.ClientRect.Right - 2;
        dsurface.Draw(38 + 40, btop + 90, rc, d, False);
      end;
      if (g_nSquHitPoint > 0) then begin
        //d := g_WMainImages.ImagesName[6, g_sVigourbar2];
        d := g_opui.Images[g_sVigourbar2];
        if d <> nil then begin
          rc := d.ClientRect;
          rc.Right := d.ClientRect.Right - 2;
          rc.Top := Round(rc.Bottom / g_nMaxSquHitPoint * (g_nMaxSquHitPoint - g_nSquHitPoint));
          dsurface.Draw(38 + 40, btop + 90 + rc.Top, rc, d, False);
        end;
      end;
    end;

    with dsurface do //等级
      PomiTextOut(dsurface, SCREENWIDTH div 2 + (SCREENWIDTH div 2 - (400 - 260)) {660}, SCREENHEIGHT - 104, IntToStr(g_Myself.m_Abil.Level));

    if (g_Myself.m_Abil.MaxExp > 0) and (g_Myself.m_Abil.MaxWeight > 0) then begin
      d := g_WMainImages.Images[7];
      if d <> nil then begin //经验条
        rc := d.ClientRect;
        if g_Myself.m_Abil.Exp > 0 then
          r := g_Myself.m_Abil.MaxExp / g_Myself.m_Abil.Exp
        else
          r := 0;
        if r > 0 then
          rc.Right := Round(rc.Right / r)
        else
          rc.Right := 0;
        dsurface.Draw(SCREENWIDTH div 2 + (SCREENWIDTH div 2 - (400 - 266)) {666}, SCREENHEIGHT - 73, rc, d, False);

        rc := d.ClientRect; //背包重量条
        if g_Myself.m_Abil.Weight > 0 then
          r := g_Myself.m_Abil.MaxWeight / g_Myself.m_Abil.Weight
        else
          r := 0;
        if r > 0 then
          rc.Right := Round(rc.Right / r)
        else
          rc.Right := 0;
        dsurface.Draw(SCREENWIDTH div 2 + (SCREENWIDTH div 2 - (400 - 266)) {666}, SCREENHEIGHT - 40, rc, d, False);
      end;
    end;

    if (g_Myself.m_HeroObject <> nil) then begin
      if (g_Myself.m_HeroObject.m_nHeroEnergy > 0) then begin
{$IF SERIESSKILL}
        d := g_WMainImages.Images[1127]; {3-410}
        if d <> nil then
          with DBHeroEnergy do
            dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
        d := nil;
        case g_Myself.m_HeroObject.m_nHeroEnergyType of
          0: begin
              //d := g_WMain3Images.Images[411];
              m_bHeroEnergyFlash := True;
            end;
          1: if GetTickCount - m_dwHeroEnergyFlashTick >= 400 then begin
              m_dwHeroEnergyFlashTick := GetTickCount();
              m_bHeroEnergyFlash := not m_bHeroEnergyFlash;
            end;
          2: if GetTickCount - m_dwHeroEnergyFlashTick >= 150 then begin
              m_dwHeroEnergyFlashTick := GetTickCount();
              m_bHeroEnergyFlash := not m_bHeroEnergyFlash;
            end;
        end;
        if m_bHeroEnergyFlash then
          d := g_WMainImages.Images[1128 {411}]
        else
          d := g_WMainImages.Images[1129 {412}];
        if d <> nil then begin
          rc := d.ClientRect;
          rc.Top := Round(rc.Bottom / g_Myself.m_HeroObject.m_nMaxHeroEnergy * (g_Myself.m_HeroObject.m_nMaxHeroEnergy - g_Myself.m_HeroObject.m_nHeroEnergy));
          dsurface.Draw(SCREENWIDTH - 195, SCREENHEIGHT - 131 + rc.Top, rc, d, False);
        end;
{$ELSE}
        d := g_WMain3Images.Images[410];
        if d <> nil then
          with DBHeroEnergy do
            dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
        d := nil;
        case g_Myself.m_HeroObject.m_nHeroEnergyType of
          0: begin
              //d := g_WMain3Images.Images[411];
              m_bHeroEnergyFlash := True;
            end;
          1: if GetTickCount - m_dwHeroEnergyFlashTick >= 400 then begin
              m_dwHeroEnergyFlashTick := GetTickCount();
              m_bHeroEnergyFlash := not m_bHeroEnergyFlash;
            end;
          2: if GetTickCount - m_dwHeroEnergyFlashTick >= 150 then begin
              m_dwHeroEnergyFlashTick := GetTickCount();
              m_bHeroEnergyFlash := not m_bHeroEnergyFlash;
            end;
        end;
        if m_bHeroEnergyFlash then
          d := g_WMain3Images.Images[411]
        else
          d := g_WMain3Images.Images[412];
        if d <> nil then begin
          rc := d.ClientRect;
          rc.Top := Round(rc.Bottom / g_Myself.m_HeroObject.m_nMaxHeroEnergy * (g_Myself.m_HeroObject.m_nMaxHeroEnergy - g_Myself.m_HeroObject.m_nHeroEnergy));
          dsurface.Draw(SCREENWIDTH - 195, SCREENHEIGHT - 145 + rc.Top, rc, d, False);
        end;
{$IFEND SERIESSKILL}
      end;

      //d := g_WMain3Images.ImagesName[391, g_sGloryButton];
      d := g_opui.Images[g_sGloryButton];
      if d <> nil then begin
        with DBHeroGlory do
          dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
        dsurface.TextOut(SCREENWIDTH - 39, SCREENHEIGHT - 95, IntToStr(g_Myself.m_HeroObject.m_wGloryPoint));
      end;
    end;

{$IF SERIESSKILL}
    //g_SeriesSkillStep := msg.tag;
    //g_SeriesSkillReady := True;
    d := nil;
    if g_MagicList2.Count > 0 then begin
      d := g_WMainImages.Images[1120];
      if g_SeriesSkillReady and (g_SeriesSkillStep > 0) then begin
        if (GetTickCount - g_dwSeriesSkillReadyTick >= 350) then begin
          g_dwSeriesSkillReadyTick := GetTickCount();
          g_SeriesSkillReadyFlash := not g_SeriesSkillReadyFlash;
        end;
        d := g_WMainImages.Images[1119 + _MIN(3, g_SeriesSkillStep) * 2 + Integer(g_SeriesSkillReadyFlash)];
      end;
    end;
    if d <> nil then
      dsurface.Draw(SCREENWIDTH - 195, SCREENHEIGHT - 150, d.ClientRect, d, True);
{$IFEND SERIESSKILL}

    dsurface.TextOut(SCREENWIDTH - 128, SCREENHEIGHT - 21, FormatDateTime('HH:MM:SS', GetTime), clWhite);

    //if g_sAttackMode <> '' then BoldTextOut(dsurface, SCREENWIDTH - 164, SCREENHEIGHT - 125, clWhite, clBlack, g_sAttackMode);

    //if FrmDlg.DEdChat.Visible and (FrmDlg.DEdChat.Text = '') and (g_SendSayList.Count > 0) then
    //  BoldTextOut(dsurface, 113 + 200, SCREENHEIGHT - 17, clLime, clBlack, 'CTRL+↑↓');
  end;

  //sX := 208;                            //显示聊天框文字
  //sY := SCREENHEIGHT - 130;
  with DScreen do begin
    for i := ChatBoardTop to ChatBoardTop + VIEWCHATLINE - 1 do begin
      if i > ChatStrs.Count - 1 then Break;
      fcolor := Integer(ChatStrs.Objects[i]);
      bcolor := Integer(ChatBks[i]);
//      dsurface.Canvas.Font.Color := fcolor;
//      dsurface.Canvas.Brush.Color := bcolor;
      dsurface.FillRect(IntRectBDS(208,SCREENHEIGHT - 130 + (i - ChatBoardTop) * 12,
                              FontManager.Default.TextWidth(ChatStrs.Strings[i]),
                             12), bcolor);
      dsurface.TextOut(208, SCREENHEIGHT - 130 + (i - ChatBoardTop) * 12, ChatStrs.Strings[i], fcolor);
    end;
  end;

{$IFDEF OPENCENTERMAG}
  DScreen.DrawScreenCenter(dsurface);
{$ENDIF}
end;

procedure TFrmDlg.DMyStateDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TDButton;
  dd: TCustomLockableTexture;
begin

  if Sender is TDButton then begin
    d := TDButton(Sender);
    if d.Downed then begin
      dd := d.WLib.Images[d.FaceIndex];
      if dd <> nil then
        dsurface.Draw(d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, True);
    end;
  end;
end;

procedure TFrmDlg.DBotGroupDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TDButton;
  dd: TCustomLockableTexture;
begin
  d := nil;
  dd := nil;
  if Sender is TDButton then begin
    d := TDButton(Sender);
    if (d = DBLRAll) and (DWRank.tag = 2) then begin
      if not d.Downed then begin
        dd := d.WLib.Images[d.FaceIndex];
        if dd <> nil then
          dsurface.Draw(d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, True);
      end else begin
        dd := d.WLib.Images[d.FaceIndex - 1];
        if dd <> nil then
          dsurface.Draw(d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, True);
      end;
    end else begin
      if not d.Downed then begin
        dd := d.WLib.Images[d.FaceIndex];
        if dd <> nil then
          dsurface.Draw(d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, True);
      end else begin
        dd := d.WLib.Images[d.FaceIndex + 1];
        if dd <> nil then
          dsurface.Draw(d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, True);
      end;
      if d = DBotGroup then begin
        if g_boAllowGroup then begin
          dd := d.WLib.Images[d.FaceIndex];
          if dd <> nil then begin
//            g_ImgMixSurface.Draw(0, 0, dd.ClientRect, dd, False);
//            DrawEffect(0, 0, dd.Width, dd.Height, g_ImgMixSurface, ceBright);
            dsurface.Draw(d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, True);
            DrawEffect(d.SurfaceX(d.Left), d.SurfaceY(d.Top), dsurface, dd, ceBright, True);
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DBotPlusAbilDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TDButton;
  dd: TCustomLockableTexture;
begin
  if Sender is TDButton then begin
    d := TDButton(Sender);
    if not d.Downed then begin
      if (BlinkCount mod 2 = 0) and (not DAdjustAbility.Visible) then
        dd := d.WLib.Images[d.FaceIndex]
      else
        dd := d.WLib.Images[d.FaceIndex + 2];
      if dd <> nil then
        dsurface.Draw(d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, True);
    end else begin
      dd := d.WLib.Images[d.FaceIndex + 1];
      if dd <> nil then
        dsurface.Draw(d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, True);
    end;

    if GetTickCount - BlinkTime >= 500 then begin
      BlinkTime := GetTickCount;
      Inc(BlinkCount);
      if BlinkCount >= 10 then BlinkCount := 0;
    end;
  end;
end;

procedure TFrmDlg.DBotStoreClick(Sender: TObject; X, Y: Integer);
begin
  if (g_Myself = nil) or not g_boOpenStallSystem then begin
    Exit;
  end;
  if DWHeroStore.Visible then begin
    if not g_Myself.m_StallMgr.OnSale then begin
      DBStoreCloseClick(nil, 0, 0);
      DItemBag.Visible := False;
    end else
      DWHeroStore.Visible := False;
  end else begin
    DWHeroStore.Visible := True;
    if not g_Myself.m_StallMgr.OnSale then begin
      DxEditStoreName.Text := Format('[%s]的摊位', [frmMain.m_sCharName]);
      if not DItemBag.Visible then
        OpenItemBag;
    end else begin
      DxEditStoreName.Text := g_Myself.m_StallMgr.mBlock.StallName;
    end;
  end;
end;

procedure TFrmDlg.DBotStoreDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
begin
  with Sender as TDButton do begin
    d := g_opui.Images[g_StallBot0 + Integer(Downed)];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
  end;
end;

procedure TFrmDlg.DMyStateClick(Sender: TObject; X, Y: Integer);
var
  shint: string;
begin
  if Sender = DMyState then begin
    StatePage := 0;
    if g_Myself <> nil then g_Myself.n_boState := False;
    OpenMyStatus;
  end;
  if Sender = DMyBag then
    OpenItemBag;
  if Sender = DMyMagic then begin
    if g_Myself <> nil then g_Myself.n_boState := False;
    StatePage := {$IFDEF UI_0508}3{$ELSE}5{$ENDIF};
    OpenMyStatus;
  end;
  if Sender = DOption then begin
    OpenSoundOption(False);
  end;

end;

procedure TFrmDlg.DBelt1DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  idx: Integer;
  s: string;
  d: TCustomLockableTexture;
begin
  d := nil;
  with Sender as TDButton do begin
    idx := tag;
    if idx in [0..5] then begin
      if g_ItemArr[idx].s.Name <> '' then begin
        //d := g_WBagItemImages.Images[g_ItemArr[idx].s.looks];
        d := frmMain.GetWBagItemImg(g_ItemArr[idx].s.looks);
        if d <> nil then begin
          dsurface.Draw(SurfaceX(Left + (Width - d.Width) div 2), SurfaceY(Top + (Height - d.Height) div 2), d.ClientRect, d, True);

          if g_ItemArr[idx].s.Overlap > 0 then begin
            s := IntToStr(g_ItemArr[idx].Dura);
            dsurface.BoldTextOut(
              SurfaceX(Left + (Width - d.Width) div 2) + 26 - FontManager.Default.TextWidth(s),
              SurfaceY(Top + (Height - d.Height) div 2) + 20,
              clSilver, clBlack, s);

          end;
        end;
      end;
      //PomiTextOut(dsurface, SurfaceX(Left + 13), SurfaceY(Top + 19), IntToStr(idx + 1));
    end;
  end;
end;

procedure TFrmDlg.DBelt1MouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  idx: Integer;
  shint: string;
begin
  if g_Myself = nil then Exit;
  DScreen.ClearHint;
  idx := TDButton(Sender).tag;
  if idx in [0..5] then
    if g_ItemArr[idx].s.Name <> '' then begin
      g_MouseItem := g_ItemArr[idx];
      GetMouseItemInfoHint(g_MouseItem, shint);
      if shint <> '' then begin
        with Sender as TDButton do
          DScreen.ShowHint(
            SurfaceX(Left),
            SurfaceY(Top) - 10,
            shint,
            clWhite, True, False, True, True);
      end;
      g_MouseItem.s.Name := '';
    end;
end;

{var
  idx                       : Integer;
begin
  idx := TDButton(Sender).tag;
  if idx in [0..5] then
    if g_ItemArr[idx].s.Name <> '' then
      g_MouseItem := g_ItemArr[idx];
end;}

procedure TFrmDlg.DBeltCloseClick(Sender: TObject; X, Y: Integer);
begin
  DBeltWindow.Visible := not DBeltWindow.Visible;
  if not DBeltWindow.Visible then
    SaveBeltConfig();
end;

procedure TFrmDlg.LoadBeltConfig();
var
  ini: TiniFile;
begin
  ini := TiniFile.Create('.\Config\' + g_sServerName + '.' + frmMain.m_sCharName + '.Set');
  g_BeltMode := ini.ReadBool('Options', 'BeltMode', g_BeltMode);
  g_BeltPositionX := ini.ReadInteger('Options', 'BeltPositionX', g_BeltPositionX);
  g_BeltPositionY := ini.ReadInteger('Options', 'BeltPositionY', g_BeltPositionY);
  g_LoadBeltConfig := True;
  ini.free;
end;

procedure TFrmDlg.SaveBeltConfig();
var
  ini: TiniFile;
begin
  ini := TiniFile.Create('.\Config\' + g_sServerName + '.' + frmMain.m_sCharName + '.Set');
  ini.WriteBool('Options', 'BeltMode', g_BeltMode);
  ini.WriteInteger('Options', 'BeltPositionX', DBeltWindow.Left);
  ini.WriteInteger('Options', 'BeltPositionY', DBeltWindow.Top);
  ini.free;
end;

procedure TFrmDlg.DBeltSwapClick(Sender: TObject; X, Y: Integer);
begin
  g_BeltMode := not g_BeltMode;
end;

procedure TFrmDlg.DBeltSwapDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TDButton;
  dd: TCustomLockableTexture;
begin
  if Sender is TDButton then begin
    d := TDButton(Sender);
    if d.Downed then begin
      //
    end else if d.Arrived then begin
      dd := d.WLib.Images[d.FaceIndex];
      if dd <> nil then
        dsurface.Draw(d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, True);
    end;
  end;
end;

procedure TFrmDlg.DBeltWindowMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  nLocalX, nLocalY: Integer;
  nHintX, nHintY: Integer;
  Butt: TDButton;
  sMsg: string;

  al, at: Integer;
begin
  DScreen.ClearHint;
  Butt := TDButton(Sender);
  if Sender = DBeltSwap then
    sMsg := '调转方向'
  else if Sender = DBeltClose then
    sMsg := '关闭';

  nHintX := Butt.SurfaceX(Butt.Left + 16);
  nHintY := Butt.SurfaceY(Butt.Top);
  DScreen.ShowHint(nHintX, nHintY, sMsg, clBlack, False);

  if DBeltWindow = Sender then
    with Sender as TDWindow do begin
      if (MouseCaptureControl = Sender) then begin
        if (SpotX <> X) or (SpotY <> Y) then begin
          al := Left + (X - SpotX);
          at := Top + (Y - SpotY);
          if not g_BeltMode then begin
            if al < -118 then al := -118;
            if al > 0408 then al := 0408;
            if at < -008 then at := -008;
            if at > 0487 then at := 0487;
          end else begin
            if al < 0 then al := 0;
            if al > 750 then al := 750;
            if at < -2 then at := -2;
            if at > 271 then at := 271;
          end;
          Left := al;
          Top := at;
          SpotX := X;
          SpotY := Y;

          //DScreen.AddChatBoardString(format(' - %d %d %d', [tag, Left, Top]), clWhite, clRed);

        end;
      end;
    end;
end;

procedure TFrmDlg.DBelt1Click(Sender: TObject; X, Y: Integer);
var
  mi, idx: Integer;
  temp: TClientItem;
begin
  idx := TDButton(Sender).tag;
  if idx in [0..5] then begin
    if not g_boItemMoving then begin
      if g_ItemArr[idx].s.Name <> '' then begin
        g_SndMgr.ItemClickSound(g_ItemArr[idx].s);
        g_boItemMoving := True;
        g_MovingItem.Index := idx;
        g_MovingItem.item := g_ItemArr[idx];
        g_ItemArr[idx].s.Name := '';
      end;
    end else begin
      mi := g_MovingItem.Index;
      if IsDetectItem(mi) then Exit;
      if IsStallItem(mi) then Exit;
      if (mi = -97) or (mi = -98) then Exit;
      if (mi < (0 - HERO_MIIDX_OFFSET)) and (mi >= -((U_FASHION + 1) + HERO_MIIDX_OFFSET)) then Exit;
      if g_MovingItem.item.s.StdMode <= 3 then begin
        if mi >= HERO_MIIDX_OFFSET then begin
          if (g_Myself = nil) or (g_Myself.m_HeroObject = nil) or (g_Myself.m_HeroObject.m_boDeath) then Exit;
          g_WaitingUseItem := g_MovingItem;
          frmMain.SendHeroItemToMasterBag(g_MovingItem.item.MakeIndex, g_MovingItem.item.s.Name);
          g_MovingItem.item.s.Name := '';
          g_boItemMoving := False;
          g_SndMgr.ItemClickSound(g_MovingItem.item.s);
        end else begin
          if g_ItemArr[idx].s.Name <> '' then begin
            temp := g_ItemArr[idx];
            g_ItemArr[idx] := g_MovingItem.item;
            g_MovingItem.Index := idx;
            g_MovingItem.item := temp
          end else begin
            g_ItemArr[idx] := g_MovingItem.item;
            g_MovingItem.item.s.Name := '';
            g_boItemMoving := False;
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DBelt1DblClick(Sender: TObject);
var
  idx: Integer;
begin
  idx := TDButton(Sender).tag;
  if idx in [0..5] then begin
    if g_ItemArr[idx].s.Name <> '' then begin
      if (g_ItemArr[idx].s.StdMode <= 4) or (g_ItemArr[idx].s.StdMode = 31) then
        frmMain.EatItem(idx);
    end else if g_boItemMoving and (g_MovingItem.Index = idx) and (g_MovingItem.item.s.StdMode <= 4) or (g_MovingItem.item.s.StdMode = 31) then begin
      frmMain.m_nEatRetIdx := idx;
      frmMain.EatItem(-1);
    end;
  end;
end;

{$IF NEWHINTSYS}

procedure TFrmDlg.GetMouseItemInfoHint(CurrMouseItem: TClientItem; var hintstr: string; bIsHero: Boolean = False);

  function GetDuraStr(Dura, maxdura: Integer): string;
  begin
    if not BoNoDisplayMaxDura then
      Result := IntToStr(Round(Dura / 1000)) + '/' + IntToStr(Round(maxdura / 1000))
    else
      Result := IntToStr(Round(Dura / 1000));
  end;

  function GetDura100Str(Dura, maxdura: Integer): string;
  begin
    if not BoNoDisplayMaxDura then
      Result := IntToStr(Round(Dura / 100)) + '/' + IntToStr(Round(maxdura / 100))
    else
      Result := IntToStr(Round(Dura / 100));
  end;

  function GetDura1Str(Dura, maxdura: Integer): string;
  begin
    if not BoNoDisplayMaxDura then
      Result := IntToStr(Dura) + '/' + IntToStr(maxdura)
    else
      Result := IntToStr(Dura);
  end;
var
  i, adv, ncl, ItemWear: Integer;
  Obj: TObject;
  tStr, tStr2: AnsiString;
  ActObject: TActor;
  cl: TColor;
  len, aline: Integer;
  ostr, temp: AnsiString;
  b, bb: Boolean;
  p: pTClientSuiteItems;
  iname: string[ItemNameLen];
  slegend: TtSuiteAbil;
label
  Loop1, Loop2, loop3, loop4;
begin
  hintstr := '';
  g_SuiteSpSkill := 0;
  if g_ShowSuite2 = 0 then
    g_ShowSuite2 := g_ShowSuite;
  g_ShowSuite3 := g_ShowSuite;

  if CurrMouseItem.s.Name <> '' then begin
    if g_Myself = nil then Exit;
    if bIsHero and (g_Myself.m_HeroObject = nil) then Exit;
    if bIsHero then
      ActObject := g_Myself.m_HeroObject
    else
      ActObject := g_Myself;

    ncl := 0;
    if (CurrMouseItem.s.StdMode in [5, 6, 10..13, 15..24, 26..30]) then begin
      for i := 0 to 6 do
        if CurrMouseItem.s.AddOn[i] > 0 then
          Inc(ncl);
    end;
    if CurrMouseItem.s.StdMode = 51 then begin
      hintstr := Format('<%s|C=%d S=11 B=Bold>\-\', [CurrMouseItem.s.Name, GetRGB(222)]);
      goto loop4;
    end;
    //if CurrMouseItem.Dura = 0 then
    //  ncl := 15;
    ItemWear := 0;
    case g_ItemWear of
      0: hintstr := Format('<%s|C=%d S=11 B=Bold>\-\', [CurrMouseItem.s.Name, GetLevelColor(ncl)]);
      1: hintstr := Format(' \<%s|C=%d S=11 B=Bold>\-\', [CurrMouseItem.s.Name, GetLevelColor(ncl)]);
      2: hintstr := Format('<         (已装备)|c=clLime>\<%s|C=%d S=11 B=Bold>\-\', [CurrMouseItem.s.Name, GetLevelColor(ncl)]);
      3: hintstr := Format('<       (已装备) (左)|c=clLime>\<%s|C=%d S=11 B=Bold>\-\', [CurrMouseItem.s.Name, GetLevelColor(ncl)]);
      4: hintstr := Format('<       (已装备) (右)|c=clLime>\<%s|C=%d S=11 B=Bold>\-\', [CurrMouseItem.s.Name, GetLevelColor(ncl)]);
    end;
    if g_ItemWear <> 0 then begin
      ItemWear := g_ItemWear;
      g_ItemWear := 0;
    end;

    case CurrMouseItem.s.Binded of
      1: hintstr := hintstr + Format('<%s|C=%d>\', ['已绑定', $94E752]);
      2: hintstr := hintstr + Format('<%s|C=%d>\', ['已绑定', clRed]);
      3: hintstr := hintstr + Format('<%s|C=%d> <%s|C=clLime>\', ['绑定于其他帐号', $94E752, '(可以使用)']);
      4: hintstr := hintstr + Format('<%s|C=%d>\', ['拾取后绑定', GetRGB(250)]);
      5: hintstr := hintstr + Format('<%s|C=%d>\', ['装备后绑定', GetRGB(250)]);
      6: hintstr := hintstr + Format('<%s|C=%d>\', ['拾取或装备后绑定', GetRGB(250)]);
    end;

    case CurrMouseItem.s.StdMode of
      0: begin //药品
          if CurrMouseItem.s.Shape = 3 then begin
            if CurrMouseItem.s.AC > 0 then begin
              tStr := '+ ' + IntToStr(CurrMouseItem.s.AC) + '元气 ';
              hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
            end;
            if CurrMouseItem.s.Overlap = 1 then begin
              tStr := '重量 ' + IntToStr(CurrMouseItem.Dura div 10);
              hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
              tStr := '数量 ' + IntToStr(CurrMouseItem.Dura);
              hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
            end else if CurrMouseItem.s.Overlap = 2 then begin
              tStr := '重量 ' + IntToStr(CurrMouseItem.s.Weight * CurrMouseItem.Dura);
              hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
              tStr := '数量 ' + IntToStr(CurrMouseItem.Dura);
              hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
            end else begin
              tStr := '重量 ' + IntToStr(CurrMouseItem.s.Weight);
              hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
            end;
          end else begin
            if CurrMouseItem.s.AC > 0 then begin
              tStr := '+ ' + IntToStr(CurrMouseItem.s.AC) + 'HP';
              hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
            end;
            if CurrMouseItem.s.MAC > 0 then begin
              tStr := '+ ' + IntToStr(CurrMouseItem.s.MAC) + 'MP';
              hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
            end;
            if CurrMouseItem.s.Overlap = 1 then begin
              tStr := '重量 ' + IntToStr(CurrMouseItem.Dura div 10);
              hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
              tStr := '数量 ' + IntToStr(CurrMouseItem.Dura);
              hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
            end else if CurrMouseItem.s.Overlap = 2 then begin
              tStr := '重量 ' + IntToStr(CurrMouseItem.s.Weight * CurrMouseItem.Dura);
              hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
              tStr := '数量 ' + IntToStr(CurrMouseItem.Dura);
              hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
            end else begin
              tStr := '重量 ' + IntToStr(CurrMouseItem.s.Weight);
              hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
            end;
          end;
        end;
      2: begin
          tStr := '重量 ' + IntToStr(CurrMouseItem.s.Weight);
          hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
          if CurrMouseItem.s.DuraMax > 0 then
            case CurrMouseItem.s.Shape of
              03: begin
                  //灵气神水
                  tStr := Format('补充 %s 点灵气', [GetDura100Str(CurrMouseItem.Dura, CurrMouseItem.DuraMax)]);
                  hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
                  hintstr := hintstr + '此物为天地灵气之精华，双击可\打开';
                end;
              09: begin
                  tStr := Format('修复 %s 点持久', [GetDura100Str(CurrMouseItem.Dura, CurrMouseItem.DuraMax)]);
                  hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
                end;
              10: begin
                  if CurrMouseItem.Dura < CurrMouseItem.DuraMax then begin
                    tStr := '累积经验 ' + GetDura1Str(CurrMouseItem.Dura, CurrMouseItem.DuraMax) + ' 万';
                    hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
                  end else begin
                    tStr := '累积经验 ' + GetDura1Str(CurrMouseItem.Dura, CurrMouseItem.DuraMax) + ' 万(双击释放)';
                    hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
                  end;
                  tStr := '';
                  case CurrMouseItem.s.Need of
                    1: tStr := '释放需要金币:' + IntToStr(CurrMouseItem.s.Price);
                    2: tStr := '释放需要元宝:' + IntToStr(CurrMouseItem.s.Price);
                    3: tStr := '释放需要金刚石:' + IntToStr(CurrMouseItem.s.Price);
                    4: tStr := '释放需要灵符:' + IntToStr(CurrMouseItem.s.Price);
                  end;
                  //remark
                  if tStr <> '' then hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clMoneyGreen]);
                end;
              11: begin
                  if CurrMouseItem.Dura < CurrMouseItem.DuraMax then begin
                    tStr := '累积内功经验 ' + GetDura1Str(CurrMouseItem.Dura, CurrMouseItem.DuraMax) + ' 万';
                    hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
                  end else begin
                    tStr := '累积内功经验 ' + GetDura1Str(CurrMouseItem.Dura, CurrMouseItem.DuraMax) + ' 万(双击释放)';
                    hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
                  end;
                  tStr := '';
                  case CurrMouseItem.s.Need of
                    1: tStr := '释放需要金币:' + IntToStr(CurrMouseItem.s.Price);
                    2: tStr := '释放需要元宝:' + IntToStr(CurrMouseItem.s.Price);
                    3: tStr := '释放需要金刚石:' + IntToStr(CurrMouseItem.s.Price);
                    4: tStr := '释放需要灵符:' + IntToStr(CurrMouseItem.s.Price);
                  end;
                  if tStr <> '' then hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clMoneyGreen]);
                end;
              13: begin
                  tStr := Format('恢复 %d 点内力值', [CurrMouseItem.DuraMax]);
                  hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
                end;
            else begin
                if CurrMouseItem.Dura = 0 then begin
                  tStr := '使用 ' + GetDuraStr(CurrMouseItem.Dura, CurrMouseItem.DuraMax) + ' 次';
                  hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clRed']);
                end else begin
                  tStr := '使用 ' + GetDuraStr(CurrMouseItem.Dura, CurrMouseItem.DuraMax) + ' 次';
                  hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
                end;
              end;
            end;

        end;
      1, 3: begin
          if CurrMouseItem.s.Overlap = 1 then begin
            tStr := '重量 ' + IntToStr(CurrMouseItem.Dura div 10);
            hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
            tStr := '数量 ' + IntToStr(CurrMouseItem.Dura);
            hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
          end else if CurrMouseItem.s.Overlap = 2 then begin
            tStr := '重量 ' + IntToStr(CurrMouseItem.s.Weight * CurrMouseItem.Dura);
            hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
            tStr := '数量 ' + IntToStr(CurrMouseItem.Dura);
            hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
          end else begin
            tStr := '重量 ' + IntToStr(CurrMouseItem.s.Weight);
            hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
          end;
        end;
      56: begin
          if CurrMouseItem.s.Overlap = 1 then begin
            tStr := '重量 ' + IntToStr(CurrMouseItem.Dura div 10);
            hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
            tStr := '数量 ' + IntToStr(CurrMouseItem.Dura);
            hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
          end else if CurrMouseItem.s.Overlap = 2 then begin
            tStr := '重量 ' + IntToStr(CurrMouseItem.s.Weight * CurrMouseItem.Dura);
            hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
            tStr := '数量 ' + IntToStr(CurrMouseItem.Dura);
            hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
          end else begin
            tStr := '重量 ' + IntToStr(CurrMouseItem.s.Weight);
            hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
          end;
          if CurrMouseItem.s.Shape = 0 then begin
            tStr := Format('等级 %d', [(CurrMouseItem.s.AC)]);
            hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
            tStr := Format('熟练度 %d', [(CurrMouseItem.s.MAC)]);
            hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
          end;
        end;
      4: begin
          if CurrMouseItem.s.Overlap = 1 then begin
            tStr := '重量 ' + IntToStr(CurrMouseItem.Dura div 10);
            hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
            tStr := '数量 ' + IntToStr(CurrMouseItem.Dura);
            hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
          end else if CurrMouseItem.s.Overlap = 2 then begin
            tStr := '重量 ' + IntToStr(CurrMouseItem.s.Weight * CurrMouseItem.Dura);
            hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
            tStr := '数量 ' + IntToStr(CurrMouseItem.Dura);
            hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
          end else begin
            tStr := '重量 ' + IntToStr(CurrMouseItem.s.Weight);
            hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
          end;
          case CurrMouseItem.s.Shape of
            0: begin
                tStr := '武士秘技';
                hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
                tStr := '需要等级 ' + IntToStr(CurrMouseItem.s.DuraMax);
                if (ActObject.m_btJob = 0) and (ActObject.m_Abil.Level >= CurrMouseItem.s.DuraMax) then
                  hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite])
                else
                  hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clRed']);
              end;
            1: begin
                tStr := '法师秘技';
                hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
                tStr := '需要等级 ' + IntToStr(CurrMouseItem.s.DuraMax);
                if (ActObject.m_btJob = 1) and (ActObject.m_Abil.Level >= CurrMouseItem.s.DuraMax) then
                  hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite])
                else
                  hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clRed']);
              end;
            2: begin
                tStr := '道士秘技';
                hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
                tStr := '需要等级 ' + IntToStr(CurrMouseItem.s.DuraMax);
                if (ActObject.m_btJob = 2) and (ActObject.m_Abil.Level >= CurrMouseItem.s.DuraMax) then
                  hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite])
                else
                  hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clRed']);
              end;
            3: begin
                tStr := '合击秘技';
                hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
                tStr := '需要等级 ' + IntToStr(CurrMouseItem.s.DuraMax);
                if (ActObject.m_Abil.Level >= CurrMouseItem.s.DuraMax) and (ActObject.m_btIsHero = 1) then
                  hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite])
                else
                  hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clRed']);
              end;
            4: begin
                tStr := '战士、魔法师、道士均可学习';
                hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
                tStr := '需要内功等级 ' + IntToStr(CurrMouseItem.s.DuraMax);
                if (ActObject.m_nIPowerLvl >= CurrMouseItem.s.DuraMax) then
                  hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite])
                else
                  hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clRed']);
              end;
            99: begin
                tStr := '战士、魔法师、道士均可学习';
                hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
                if CurrMouseItem.s.AniCount = 0 then begin
                  tStr := '需要等级 ' + IntToStr(CurrMouseItem.s.DuraMax);
                  if (ActObject.m_Abil.Level >= CurrMouseItem.s.DuraMax) then
                    hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite])
                  else
                    hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clRed']);
                end else if CurrMouseItem.s.AniCount = 1 then begin
                  tStr := '需要内功等级 ' + IntToStr(CurrMouseItem.s.DuraMax);
                  if (ActObject.m_nIPowerLvl >= CurrMouseItem.s.DuraMax) then
                    hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite])
                  else
                    hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clRed']);
                end;

              end;
          end;
        end;
      5..6: begin
          if CurrMouseItem.s.Reserved and $01 <> 0 then begin
            case ItemWear of
              0: hintstr := Format('<(*) %s|C=%d S=11 B=Bold>\-\', [CurrMouseItem.s.Name, GetLevelColor(ncl)]);
              1: hintstr := Format(' \<(*) %s|C=%d S=11 B=Bold>\-\', [CurrMouseItem.s.Name, GetLevelColor(ncl)]);
              2: hintstr := Format('<         (已装备)|c=clLime>\<(*) %s|C=%d S=11 B=Bold>\-\', [CurrMouseItem.s.Name, GetLevelColor(ncl)]);
              3: hintstr := Format('<       (已装备) (左)|c=clLime>\<(*) %s|C=%d S=11 B=Bold>\-\', [CurrMouseItem.s.Name, GetLevelColor(ncl)]);
              4: hintstr := Format('<       (已装备) (右)|c=clLime>\<(*) %s|C=%d S=11 B=Bold>\-\', [CurrMouseItem.s.Name, GetLevelColor(ncl)]);
            end;
            ItemWear := 0;

            if CurrMouseItem.s.Binded = 1 then
              hintstr := hintstr + Format('<%s|C=%d>\', ['已绑定', $94E752])
            else if CurrMouseItem.s.Binded = 2 then
              hintstr := hintstr + Format('<%s|C=%d>\', ['已绑定', clRed])
            else if CurrMouseItem.s.Binded = 3 then
              hintstr := hintstr + Format('<%s|C=%d>\', ['已绑定(!)', $94E752]);

          end;
          case CurrMouseItem.s.Need of
            0: begin
                tStr := '需要等级 ' + IntToStr(CurrMouseItem.s.NeedLevel);
                if ActObject.m_Abil.Level >= CurrMouseItem.s.NeedLevel then
                  hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite])
                else
                  hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clRed']);
              end;
            1: begin
                tStr := '需要攻击力 ' + IntToStr(CurrMouseItem.s.NeedLevel);
                if HiWord(ActObject.m_Abil.DC) >= CurrMouseItem.s.NeedLevel then
                  hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite])
                else
                  hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clRed']);
              end;
            2: begin
                tStr := '需要魔法值 ' + IntToStr(CurrMouseItem.s.NeedLevel);
                if HiWord(ActObject.m_Abil.MC) >= CurrMouseItem.s.NeedLevel then
                  hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite])
                else
                  hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clRed']);
              end;
            3: begin
                tStr := '需要精神力 ' + IntToStr(CurrMouseItem.s.NeedLevel);
                if HiWord(ActObject.m_Abil.SC) >= CurrMouseItem.s.NeedLevel then
                  hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite])
                else
                  hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clRed']);
              end;
            4: begin
                tStr := '需要转生等级 ' + IntToStr(CurrMouseItem.s.NeedLevel);
                hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite]);
              end;
            40: begin
                tStr := Format('需要等级 %d 和转生等级 %d', [HiWord(CurrMouseItem.s.NeedLevel), LoWord(CurrMouseItem.s.NeedLevel)]);
                hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite]);
              end;
            41: begin
                tStr := Format('需要攻击力 %d 和转生等级 %d', [HiWord(CurrMouseItem.s.NeedLevel), LoWord(CurrMouseItem.s.NeedLevel)]);
                hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite]);
              end;
            42: begin
                tStr := Format('需要魔法力 %d 和转生等级 %d', [HiWord(CurrMouseItem.s.NeedLevel), LoWord(CurrMouseItem.s.NeedLevel)]);
                hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite]);
              end;
            43: begin
                tStr := Format('需要精神力 %d 和转生等级 %d', [HiWord(CurrMouseItem.s.NeedLevel), LoWord(CurrMouseItem.s.NeedLevel)]);
                hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite]);
              end;
            44: begin
                tStr := Format('需要声望 %d 和转生等级 %d', [HiWord(CurrMouseItem.s.NeedLevel), LoWord(CurrMouseItem.s.NeedLevel)]);
                hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite]);
              end;
            5: begin
                tStr := '需要声望点 ' + IntToStr(CurrMouseItem.s.NeedLevel);
                hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite]);
              end;
            6: begin
                tStr := '行会成员专用';
                hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite]);
              end;
            60: begin
                tStr := '行会掌门专用';
                hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite]);
              end;
            7: begin
                tStr := '沙城成员专用';
                hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite]);
              end;
            70: begin
                tStr := '沙城城主专用';
                hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite]);
              end;
            8: begin
                tStr := '会员专用';
                hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite]);
              end;
            81: begin
                tStr := '会员类型 ' + IntToStr(LoWord(CurrMouseItem.s.NeedLevel)) + ' 和会员等级 ' + IntToStr(HiWord(CurrMouseItem.s.NeedLevel));
                hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite]);
              end;
            82: begin
                tStr := '会员类型 ' + IntToStr(LoWord(CurrMouseItem.s.NeedLevel)) + ' 和会员等级 ' + IntToStr(HiWord(CurrMouseItem.s.NeedLevel));
                hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite]);
              end;
          end;
          tStr := '重量 ' + IntToStr(CurrMouseItem.s.Weight);
          hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);

          if CurrMouseItem.Dura = 0 then begin
            tStr := '持久 ' + GetDuraStr(CurrMouseItem.Dura, CurrMouseItem.DuraMax) + ' (请修理)';
            hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clRed'])
          end else begin
            tStr := '持久 ' + GetDuraStr(CurrMouseItem.Dura, CurrMouseItem.DuraMax);
            hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
          end;
          if CurrMouseItem.s.DC > 0 then begin
            adv := CurrMouseItem.s.AddOn[0];
            if adv > 0 then begin
              tStr := Format('攻击 %d-%d', [LoWord(CurrMouseItem.s.DC), HiWord(CurrMouseItem.s.DC)]);
              hintstr := hintstr + Format('<%s|C=%d> <(+%d)|C=$FF00>\', [tStr, clWhite, adv]);
            end else begin
              tStr := '攻击 ' + IntToStr(LoWord(CurrMouseItem.s.DC)) + '-' + IntToStr(HiWord(CurrMouseItem.s.DC));
              hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
            end;
          end;
          if CurrMouseItem.s.MC > 0 then begin
            adv := CurrMouseItem.s.AddOn[1];
            if adv > 0 then begin
              tStr := Format('魔法 %d-%d', [LoWord(CurrMouseItem.s.MC), HiWord(CurrMouseItem.s.MC)]);
              hintstr := hintstr + Format('<%s|C=%d> <(+%d)|C=$FF00>\', [tStr, clWhite, adv]);
            end else begin
              tStr := '魔法 ' + IntToStr(LoWord(CurrMouseItem.s.MC)) + '-' + IntToStr(HiWord(CurrMouseItem.s.MC));
              hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
            end;
          end;
          if CurrMouseItem.s.SC > 0 then begin
            adv := CurrMouseItem.s.AddOn[2];
            if adv > 0 then begin
              tStr := Format('道术 %d-%d', [LoWord(CurrMouseItem.s.SC), HiWord(CurrMouseItem.s.SC)]);
              hintstr := hintstr + Format('<%s|C=%d> <(+%d)|C=$FF00>\', [tStr, clWhite, adv]);
            end else begin
              tStr := '道术 ' + IntToStr(LoWord(CurrMouseItem.s.SC)) + '-' + IntToStr(HiWord(CurrMouseItem.s.SC));
              hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
            end;
          end;

          if (CurrMouseItem.s.reserve[7] > 0) then begin
            tStr := '体力值 +' + IntToStr(CurrMouseItem.s.reserve[7] * 100);
            hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
          end;
          if (CurrMouseItem.s.reserve[8] > 0) then begin
            tStr := '魔法值 +' + IntToStr(CurrMouseItem.s.reserve[8] * 100);
            hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
          end;

          ostr := '';
          //2020年9月13日 咸鱼增加当Source为正数的时候显示强度 根据引擎说明 负数为神圣 正数为强度
          if (CurrMouseItem.s.Source <= -1) and (CurrMouseItem.s.Source >= -50) then begin
            tStr := '神圣 +' + IntToStr(-CurrMouseItem.s.Source);
            ostr := ostr + Format('<%s|C=%s>\', [tStr, 'clSkyBlue']);
          end else
          if (CurrMouseItem.s.Source <= -51) and (CurrMouseItem.s.Source >= -100) then begin
            tStr := '神圣 -' + IntToStr(-CurrMouseItem.s.Source - 50);
            ostr := ostr + Format('<%s|C=%s>\', [tStr, 'clSkyBlue']);
          end else
          if CurrMouseItem.s.Source > 0 then begin
            adv := CurrMouseItem.s.AddOn[7];
            tStr := '强度 ' + IntToStr(CurrMouseItem.s.Source);
            ostr := ostr + Format('<%s|C=%s> <(+%d)|C=$FF00>\', [tStr, 'clWhite',adv]);
          end;

          if HiWord(CurrMouseItem.s.AC) > 0 then begin
            adv := CurrMouseItem.s.AddOn[5];
            if adv > 0 then begin
              tStr := Format('准确 +%d', [HiWord(CurrMouseItem.s.AC)]);
              ostr := ostr + Format('<%s|C=%d> <(+%d)|C=$FF00>\', [tStr, clSkyBlue, adv]);
            end else begin
              tStr := '准确 +' + IntToStr(HiWord(CurrMouseItem.s.AC));
              ostr := ostr + Format('<%s|C=%s>\', [tStr, 'clSkyBlue']);
            end;
          end;
          if HiWord(CurrMouseItem.s.MAC) > 0 then begin
            adv := CurrMouseItem.s.AddOn[6];
            if HiWord(CurrMouseItem.s.MAC) > 10 then begin
              if adv > 0 then begin
                if adv > 10 then begin
                  tStr := '攻击速度 +' + IntToStr(HiWord(CurrMouseItem.s.MAC) - 10);
                  ostr := ostr + Format('<%s|C=%s> <(+%d)|C=$FF00>\', [tStr, 'clSkyBlue', adv - 10]);
                end else begin
                  tStr := '攻击速度 +' + IntToStr(HiWord(CurrMouseItem.s.MAC) - 10);
                  ostr := ostr + Format('<%s|C=%s> <(+%d)|C=$FF00>\', [tStr, 'clSkyBlue', adv]);
                end;
              end else begin
                tStr := '攻击速度 +' + IntToStr(HiWord(CurrMouseItem.s.MAC) - 10);
                ostr := ostr + Format('<%s|C=%s>\', [tStr, 'clSkyBlue']);
              end;
            end else begin
              if adv > 0 then begin
                tStr := '攻击速度 -' + IntToStr(HiWord(CurrMouseItem.s.MAC));
                ostr := ostr + Format('<%s|C=%s> <(-%d)|C=$FF00>\', [tStr, 'clSkyBlue', adv]);
              end else begin
                tStr := '攻击速度 -' + IntToStr(HiWord(CurrMouseItem.s.MAC));
                ostr := ostr + Format('<%s|C=%s>\', [tStr, 'clSkyBlue']);
              end;
            end;

          end;
          if LoWord(CurrMouseItem.s.AC) > 0 then begin
            adv := CurrMouseItem.s.AddOn[3];
            if adv > 0 then begin
              tStr := Format('幸运 +%d', [LoWord(CurrMouseItem.s.AC)]);
              ostr := ostr + Format('<%s|C=%d> <(+%d)|C=$FF00>\', [tStr, clSkyBlue, adv]);
            end else begin
              tStr := '幸运 +' + IntToStr(LoWord(CurrMouseItem.s.AC));
              ostr := ostr + Format('<%s|C=%s>\', [tStr, 'clSkyBlue']);
            end;
          end;
          if LoWord(CurrMouseItem.s.MAC) > 0 then begin
            adv := CurrMouseItem.s.AddOn[4];
            if adv > 0 then begin
              tStr := Format('诅咒 +%d', [LoWord(CurrMouseItem.s.MAC)]);
              ostr := ostr + Format('<%s|C=%d> <(+%d)|C=$FF00>\', [tStr, clSkyBlue, adv]);
            end else begin
              tStr := '诅咒 +' + IntToStr(LoWord(CurrMouseItem.s.MAC));
              ostr := ostr + Format('<%s|C=%s>\', [tStr, 'clSkyBlue']);
            end;
          end;
          if ostr <> '' then
            hintstr := hintstr + {' \' +} ostr;

          ostr := '';
          if CurrMouseItem.s.UniqueItem > 0 then begin
            tStr := '内功恢复速度 +' + IntToStr(CurrMouseItem.s.UniqueItem) + '%';
            ostr := ostr + Format('<%s|C=%d>\', [tStr, GetRGB(145)]);
          end;
          //if CurrMouseItem.S.ItemSet <> 0 then begin
          if Lobyte(CurrMouseItem.s.ItemSet) <> 0 then begin
            tStr := '暴击 +' + IntToStr(Lobyte(CurrMouseItem.s.ItemSet));
            ostr := ostr + Format('<%s|C=%d>\', [tStr, GetRGB(145)]);
          end;
          if Hibyte(CurrMouseItem.s.ItemSet) <> 0 then begin
            tStr := '击杀爆率 +' + IntToStr(Hibyte(CurrMouseItem.s.ItemSet)) + '%';
            ostr := ostr + Format('<%s|C=%d>\', [tStr, GetRGB(145)]);
          end;
          if CurrMouseItem.s.ItemType <> 0 then begin
            tStr := '防爆 +' + IntToStr(CurrMouseItem.s.ItemType) + '%';
            ostr := ostr + Format('<%s|C=%d>\', [tStr, GetRGB(145)]);
          end;
          if ostr <> '' then
            hintstr := hintstr + {' \' +} ostr;
          goto loop3;
        end;
      7: begin
          tStr := '重量 ' + IntToStr(CurrMouseItem.s.Weight);
          hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
          tStr := '';
          if CurrMouseItem.s.DuraMax > 0 then begin
            case CurrMouseItem.s.Shape of
              0: tStr := '使用 ' + GetDuraStr(CurrMouseItem.Dura, CurrMouseItem.DuraMax) + ' 次';
              1: tStr := 'HP ' + GetDuraStr(CurrMouseItem.Dura, CurrMouseItem.DuraMax) + ' 万';
              2: tStr := 'MP ' + GetDuraStr(CurrMouseItem.Dura, CurrMouseItem.DuraMax) + ' 万';
              3: tStr := 'HPMP ' + GetDuraStr(CurrMouseItem.Dura, CurrMouseItem.DuraMax) + ' 万';
              4: tStr := '累积经验 ' + GetDura1Str(CurrMouseItem.Dura, CurrMouseItem.DuraMax) + ' 万';
            end;
            if tStr <> '' then hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
          end;
          goto loop3;
        end;
      10..13: begin
          case CurrMouseItem.s.Need of
            0: begin
                tStr := '需要等级 ' + IntToStr(CurrMouseItem.s.NeedLevel);
                if ActObject.m_Abil.Level >= CurrMouseItem.s.NeedLevel then
                  hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite])
                else
                  hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clRed']);
              end;
            1: begin
                tStr := '需要攻击力 ' + IntToStr(CurrMouseItem.s.NeedLevel);
                if HiWord(ActObject.m_Abil.DC) >= CurrMouseItem.s.NeedLevel then
                  hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite])
                else
                  hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clRed']);
              end;
            2: begin
                tStr := '需要魔法值 ' + IntToStr(CurrMouseItem.s.NeedLevel);
                if HiWord(ActObject.m_Abil.MC) >= CurrMouseItem.s.NeedLevel then
                  hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite])
                else
                  hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clRed']);
              end;
            3: begin
                tStr := '需要精神力 ' + IntToStr(CurrMouseItem.s.NeedLevel);
                if HiWord(ActObject.m_Abil.SC) >= CurrMouseItem.s.NeedLevel then
                  hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite])
                else
                  hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clRed']);
              end;
            4: begin
                tStr := '需要转生等级 ' + IntToStr(CurrMouseItem.s.NeedLevel);
                hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite]);
              end;
            40: begin
                tStr := Format('需要等级 %d 和转生等级 %d', [HiWord(CurrMouseItem.s.NeedLevel), LoWord(CurrMouseItem.s.NeedLevel)]);
                hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite]);
              end;
            41: begin
                tStr := Format('需要攻击力 %d 和转生等级 %d', [HiWord(CurrMouseItem.s.NeedLevel), LoWord(CurrMouseItem.s.NeedLevel)]);
                hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite]);
              end;
            42: begin
                tStr := Format('需要魔法力 %d 和转生等级 %d', [HiWord(CurrMouseItem.s.NeedLevel), LoWord(CurrMouseItem.s.NeedLevel)]);
                hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite]);
              end;
            43: begin
                tStr := Format('需要精神力 %d 和转生等级 %d', [HiWord(CurrMouseItem.s.NeedLevel), LoWord(CurrMouseItem.s.NeedLevel)]);
                hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite]);
              end;
            44: begin
                tStr := Format('需要声望 %d 和转生等级 %d', [HiWord(CurrMouseItem.s.NeedLevel), LoWord(CurrMouseItem.s.NeedLevel)]);
                hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite]);
              end;
            5: begin
                tStr := '需要声望点 ' + IntToStr(CurrMouseItem.s.NeedLevel);
                hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite]);
              end;
            6: begin
                tStr := '行会成员专用';
                hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite]);
              end;
            60: begin
                tStr := '行会掌门专用';
                hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite]);
              end;
            7: begin
                tStr := '沙城成员专用';
                hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite]);
              end;
            70: begin
                tStr := '沙城城主专用';
                hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite]);
              end;
            8: begin
                tStr := '会员专用';
                hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite]);
              end;
            81: begin
                tStr := '会员类型 ' + IntToStr(LoWord(CurrMouseItem.s.NeedLevel)) + ' 和会员等级 ' + IntToStr(HiWord(CurrMouseItem.s.NeedLevel));
                hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite]);
              end;
            82: begin
                tStr := '会员类型 ' + IntToStr(LoWord(CurrMouseItem.s.NeedLevel)) + ' 和会员等级 ' + IntToStr(HiWord(CurrMouseItem.s.NeedLevel));
                hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite]);
              end;
          end;
          tStr := '重量 ' + IntToStr(CurrMouseItem.s.Weight);
          hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
          if CurrMouseItem.Dura = 0 then begin
            tStr := '持久 ' + GetDuraStr(CurrMouseItem.Dura, CurrMouseItem.DuraMax) + ' (请修理)';
            hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clRed'])
          end else begin
            tStr := '持久 ' + GetDuraStr(CurrMouseItem.Dura, CurrMouseItem.DuraMax);
            hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
          end;

          if CurrMouseItem.s.AC > 0 then begin
            adv := CurrMouseItem.s.AddOn[0];
            if adv > 0 then begin
              tStr := Format('防御 %d-%d', [LoWord(CurrMouseItem.s.AC), HiWord(CurrMouseItem.s.AC)]);
              hintstr := hintstr + Format('<%s|C=%d> <(+%d)|C=$FF00>\', [tStr, clWhite, adv]);
            end else begin
              tStr := '防御 ' + IntToStr(LoWord(CurrMouseItem.s.AC)) + '-' + IntToStr(HiWord(CurrMouseItem.s.AC));
              hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
            end;
          end;
          if CurrMouseItem.s.MAC > 0 then begin
            adv := CurrMouseItem.s.AddOn[1];
            if adv > 0 then begin
              tStr := Format('魔防 %d-%d', [LoWord(CurrMouseItem.s.MAC), HiWord(CurrMouseItem.s.MAC)]);
              hintstr := hintstr + Format('<%s|C=%d> <(+%d)|C=$FF00>\', [tStr, clWhite, adv]);
            end else begin
              tStr := '魔防 ' + IntToStr(LoWord(CurrMouseItem.s.MAC)) + '-' + IntToStr(HiWord(CurrMouseItem.s.MAC));
              hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
            end;
          end;
          if CurrMouseItem.s.DC > 0 then begin
            adv := CurrMouseItem.s.AddOn[2];
            if adv > 0 then begin
              tStr := Format('攻击 %d-%d', [LoWord(CurrMouseItem.s.DC), HiWord(CurrMouseItem.s.DC)]);
              hintstr := hintstr + Format('<%s|C=%d> <(+%d)|C=$FF00>\', [tStr, clWhite, adv]);
            end else begin
              tStr := '攻击 ' + IntToStr(LoWord(CurrMouseItem.s.DC)) + '-' + IntToStr(HiWord(CurrMouseItem.s.DC));
              hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
            end;
          end;
          if CurrMouseItem.s.MC > 0 then begin
            adv := CurrMouseItem.s.AddOn[3];
            if adv > 0 then begin
              tStr := Format('魔法 %d-%d', [LoWord(CurrMouseItem.s.MC), HiWord(CurrMouseItem.s.MC)]);
              hintstr := hintstr + Format('<%s|C=%d> <(+%d)|C=$FF00>\', [tStr, clWhite, adv]);
            end else begin
              tStr := '魔法 ' + IntToStr(LoWord(CurrMouseItem.s.MC)) + '-' + IntToStr(HiWord(CurrMouseItem.s.MC));
              hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
            end;
          end;
          if CurrMouseItem.s.SC > 0 then begin
            adv := CurrMouseItem.s.AddOn[4];
            if adv > 0 then begin
              tStr := Format('道术 %d-%d', [LoWord(CurrMouseItem.s.SC), HiWord(CurrMouseItem.s.SC)]);
              hintstr := hintstr + Format('<%s|C=%d> <(+%d)|C=$FF00>\', [tStr, clWhite, adv]);
            end else begin
              tStr := '道术 ' + IntToStr(LoWord(CurrMouseItem.s.SC)) + '-' + IntToStr(HiWord(CurrMouseItem.s.SC));
              hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
            end;
          end;

          if (CurrMouseItem.s.reserve[7] > 0) then begin
            tStr := '体力值 +' + IntToStr(CurrMouseItem.s.reserve[7] * 100);
            hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
          end;
          if (CurrMouseItem.s.reserve[8] > 0) then begin
            tStr := '魔法值 +' + IntToStr(CurrMouseItem.s.reserve[8] * 100);
            hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
          end;

          ostr := '';
          if CurrMouseItem.s.UniqueItem > 0 then begin
            tStr := '内功恢复速度 +' + IntToStr(CurrMouseItem.s.UniqueItem) + '%';
            ostr := ostr + Format('<%s|C=%d>\', [tStr, GetRGB(145)]);
          end;
          //if CurrMouseItem.S.ItemSet <> 0 then begin
          if Lobyte(CurrMouseItem.s.ItemSet) <> 0 then begin
            tStr := '暴击 +' + IntToStr(Lobyte(CurrMouseItem.s.ItemSet));
            ostr := ostr + Format('<%s|C=%d>\', [tStr, GetRGB(145)]);
          end;
          if Hibyte(CurrMouseItem.s.ItemSet) <> 0 then begin
            tStr := '击杀爆率 +' + IntToStr(Hibyte(CurrMouseItem.s.ItemSet)) + '%';
            ostr := ostr + Format('<%s|C=%d>\', [tStr, GetRGB(145)]);
          end;
          if CurrMouseItem.s.ItemType <> 0 then begin
            tStr := '防爆 +' + IntToStr(CurrMouseItem.s.ItemType) + '%';
            ostr := ostr + Format('<%s|C=%d>\', [tStr, GetRGB(145)]);
          end;
          if (CurrMouseItem.s.Reserved <> 0) and (CurrMouseItem.s.Shape = 190) then begin
            tStr := '吸血 +' + IntToStr(CurrMouseItem.s.Reserved);
            ostr := ostr + Format('<%s|C=%d>\', [tStr, GetRGB(145)]);
          end;
          if (CurrMouseItem.s.Reserved <> 0) and (CurrMouseItem.s.Shape = 191) then begin
            tStr := '内伤 +' + IntToStr(CurrMouseItem.s.Reserved);
            ostr := ostr + Format('<%s|C=%d>\', [tStr, GetRGB(145)]);
          end;
          if (CurrMouseItem.s.Reserved <> 0) and (CurrMouseItem.s.Source = 10) then begin
            tStr := '麻痹抗性 +' + IntToStr(CurrMouseItem.s.Reserved) + '%';
            ostr := ostr + Format('<%s|C=%d>\', [tStr, GetRGB(145)]);
          end;
          if (CurrMouseItem.s.Reserved <> 0) and (CurrMouseItem.s.Source = 11) then begin
            tStr := '特殊技能冷却 -' + IntToStr(CurrMouseItem.s.Reserved) + '秒';
            ostr := ostr + Format('<%s|C=%d>\', [tStr, GetRGB(145)]);
          end;
          if ostr <> '' then
            hintstr := hintstr + {' \' +} ostr;

          goto loop3;
        end;
      15..24,
        26..30: begin
          case CurrMouseItem.s.Need of
            0: begin
                tStr := '需要等级 ' + IntToStr(CurrMouseItem.s.NeedLevel);
                if ActObject.m_Abil.Level >= CurrMouseItem.s.NeedLevel then
                  hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite])
                else
                  hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clRed']);
              end;
            1: begin
                tStr := '需要攻击力 ' + IntToStr(CurrMouseItem.s.NeedLevel);
                if HiWord(ActObject.m_Abil.DC) >= CurrMouseItem.s.NeedLevel then
                  hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite])
                else
                  hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clRed']);
              end;
            2: begin
                tStr := '需要魔法值 ' + IntToStr(CurrMouseItem.s.NeedLevel);
                if HiWord(ActObject.m_Abil.MC) >= CurrMouseItem.s.NeedLevel then
                  hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite])
                else
                  hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clRed']);
              end;
            3: begin
                tStr := '需要精神力 ' + IntToStr(CurrMouseItem.s.NeedLevel);
                if HiWord(ActObject.m_Abil.SC) >= CurrMouseItem.s.NeedLevel then
                  hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite])
                else
                  hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clRed']);
              end;
            4: begin
                tStr := '需要转生等级 ' + IntToStr(CurrMouseItem.s.NeedLevel);
                hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite]);
              end;
            40: begin
                tStr := Format('需要等级 %d 和转生等级 %d', [HiWord(CurrMouseItem.s.NeedLevel), LoWord(CurrMouseItem.s.NeedLevel)]);
                hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite]);
              end;
            41: begin
                tStr := Format('需要攻击力 %d 和转生等级 %d', [HiWord(CurrMouseItem.s.NeedLevel), LoWord(CurrMouseItem.s.NeedLevel)]);
                hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite]);
              end;
            42: begin
                tStr := Format('需要魔法力 %d 和转生等级 %d', [HiWord(CurrMouseItem.s.NeedLevel), LoWord(CurrMouseItem.s.NeedLevel)]);
                hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite]);
              end;
            43: begin
                tStr := Format('需要精神力 %d 和转生等级 %d', [HiWord(CurrMouseItem.s.NeedLevel), LoWord(CurrMouseItem.s.NeedLevel)]);
                hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite]);
              end;
            44: begin
                tStr := Format('需要声望 %d 和转生等级 %d', [HiWord(CurrMouseItem.s.NeedLevel), LoWord(CurrMouseItem.s.NeedLevel)]);
                hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite]);
              end;
            5: begin
                tStr := '需要声望点 ' + IntToStr(CurrMouseItem.s.NeedLevel);
                hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite]);
              end;
            6: begin
                tStr := '行会成员专用';
                hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite]);
              end;
            60: begin
                tStr := '行会掌门专用';
                hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite]);
              end;
            7: begin
                tStr := '沙城成员专用';
                hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite]);
              end;
            70: begin
                tStr := '沙城城主专用';
                hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite]);
              end;
            8: begin
                hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite]);
                tStr := '会员专用';
              end;
            81: begin
                tStr := '会员类型 ' + IntToStr(LoWord(CurrMouseItem.s.NeedLevel)) + ' 和会员等级 ' + IntToStr(HiWord(CurrMouseItem.s.NeedLevel));
                hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite]);
              end;
            82: begin
                tStr := '会员类型 ' + IntToStr(LoWord(CurrMouseItem.s.NeedLevel)) + ' 和会员等级 ' + IntToStr(HiWord(CurrMouseItem.s.NeedLevel));
                hintstr := hintstr + Format('<%s|C=%d>\', [tStr, clWhite]);
              end;
          end;
          tStr := '重量 ' + IntToStr(CurrMouseItem.s.Weight);
          hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
          if CurrMouseItem.Dura = 0 then begin
            tStr := '持久 ' + GetDuraStr(CurrMouseItem.Dura, CurrMouseItem.DuraMax) + ' (请修理)';
            hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clRed'])
          end else begin
            tStr := '持久 ' + GetDuraStr(CurrMouseItem.Dura, CurrMouseItem.DuraMax);
            hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
          end;

          if CurrMouseItem.s.StdMode in [19, 20, 21, 23, 24] then begin
            if CurrMouseItem.s.DC > 0 then begin
              adv := CurrMouseItem.s.AddOn[2];
              if adv > 0 then begin
                tStr := Format('攻击 %d-%d', [LoWord(CurrMouseItem.s.DC), HiWord(CurrMouseItem.s.DC)]);
                hintstr := hintstr + Format('<%s|C=%d> <(+%d)|C=$FF00>\', [tStr, clWhite, adv]);
              end else begin
                tStr := '攻击 ' + IntToStr(LoWord(CurrMouseItem.s.DC)) + '-' + IntToStr(HiWord(CurrMouseItem.s.DC));
                hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
              end;
            end;
            if CurrMouseItem.s.MC > 0 then begin
              adv := CurrMouseItem.s.AddOn[3];
              if adv > 0 then begin
                tStr := Format('魔法 %d-%d', [LoWord(CurrMouseItem.s.MC), HiWord(CurrMouseItem.s.MC)]);
                hintstr := hintstr + Format('<%s|C=%d> <(+%d)|C=$FF00>\', [tStr, clWhite, adv]);
              end else begin
                tStr := '魔法 ' + IntToStr(LoWord(CurrMouseItem.s.MC)) + '-' + IntToStr(HiWord(CurrMouseItem.s.MC));
                hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
              end;
            end;
            if CurrMouseItem.s.SC > 0 then begin
              adv := CurrMouseItem.s.AddOn[4];
              if adv > 0 then begin
                tStr := Format('道术 %d-%d', [LoWord(CurrMouseItem.s.SC), HiWord(CurrMouseItem.s.SC)]);
                hintstr := hintstr + Format('<%s|C=%d> <(+%d)|C=$FF00>\', [tStr, clWhite, adv]);
              end else begin
                tStr := '道术 ' + IntToStr(LoWord(CurrMouseItem.s.SC)) + '-' + IntToStr(HiWord(CurrMouseItem.s.SC));
                hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
              end;
            end;

            if (CurrMouseItem.s.reserve[7] > 0) then begin
              tStr := '体力值 +' + IntToStr(CurrMouseItem.s.reserve[7] * 100);
              hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
            end;
            if (CurrMouseItem.s.reserve[8] > 0) then begin
              tStr := '魔法值 +' + IntToStr(CurrMouseItem.s.reserve[8] * 100);
              hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
            end;
          end;

          loop4:
          ostr := '';
          case CurrMouseItem.s.StdMode of
            19: begin //项链
                if HiWord(CurrMouseItem.s.AC) > 0 then begin
                  adv := CurrMouseItem.s.AddOn[0];
                  if adv > 0 then begin
                    tStr := Format('魔法躲避 +%d', [HiWord(CurrMouseItem.s.AC) * 10]);
                    ostr := ostr + Format('<%s|C=%s> <(+%d)|C=$FF00>\', [tStr, 'clSkyBlue', adv * 10]);
                  end else begin
                    tStr := '魔法躲避 +' + IntToStr(HiWord(CurrMouseItem.s.AC) * 10); // + '0%';
                    ostr := ostr + Format('<%s|C=%s>\', [tStr, 'clSkyBlue']);
                  end;
                end;
                if LoWord(CurrMouseItem.s.MAC) > 0 then begin
                  tStr := '诅咒 +' + IntToStr(LoWord(CurrMouseItem.s.MAC));
                  ostr := ostr + Format('<%s|C=%s>\', [tStr, 'clSkyBlue']);
                end;
                if HiWord(CurrMouseItem.s.MAC) > 0 then begin
                  adv := CurrMouseItem.s.AddOn[1];
                  if adv > 0 then begin
                    tStr := Format('幸运 +%d', [HiWord(CurrMouseItem.s.MAC)]);
                    ostr := ostr + Format('<%s|C=%s> <(+%d)|C=$FF00>\', [tStr, 'clSkyBlue', adv]);
                  end else begin
                    tStr := '幸运 +' + IntToStr(HiWord(CurrMouseItem.s.MAC));
                    ostr := ostr + Format('<%s|C=%s>\', [tStr, 'clSkyBlue']);
                  end;
                end;
              end;
            20, 24: begin //项链 及 手镯: MaxAC -> Hit,  MaxMac -> Speed
                if HiWord(CurrMouseItem.s.AC) > 0 then begin
                  adv := CurrMouseItem.s.AddOn[0];
                  if adv > 0 then begin
                    tStr := Format('准确 +%d', [HiWord(CurrMouseItem.s.AC)]);
                    ostr := ostr + Format('<%s|C=%s> <(+%d)|C=$FF00>\', [tStr, 'clSkyBlue', adv]);
                  end else begin
                    tStr := '准确 +' + IntToStr(HiWord(CurrMouseItem.s.AC));
                    ostr := ostr + Format('<%s|C=%s>\', [tStr, 'clSkyBlue']);
                  end;
                end;
                if HiWord(CurrMouseItem.s.MAC) > 0 then begin
                  adv := CurrMouseItem.s.AddOn[1];
                  if adv > 0 then begin
                    tStr := Format('敏捷 +%d', [HiWord(CurrMouseItem.s.MAC)]);
                    ostr := ostr + Format('<%s|C=%s> <(+%d)|C=$FF00>\', [tStr, 'clSkyBlue', adv]);
                  end else begin
                    tStr := '敏捷 +' + IntToStr(HiWord(CurrMouseItem.s.MAC));
                    ostr := ostr + Format('<%s|C=%s>\', [tStr, 'clSkyBlue']);
                  end;
                end;
              end;
            21: begin //项链
                if HiWord(CurrMouseItem.s.AC) > 0 then begin
                  adv := CurrMouseItem.s.AddOn[0];
                  if adv > 0 then begin
                    tStr := Format('体力恢复 +%d', [HiWord(CurrMouseItem.s.AC) * 10]);
                    ostr := ostr + Format('<%s|C=%s> <(+%d)|C=$FF00>\', [tStr, 'clSkyBlue', adv * 10]);
                  end else begin
                    tStr := '体力恢复 +' + IntToStr(HiWord(CurrMouseItem.s.AC) * 10); // + '0%';
                    ostr := ostr + Format('<%s|C=%s>\', [tStr, 'clSkyBlue']);
                  end;
                end;
                if HiWord(CurrMouseItem.s.MAC) > 0 then begin
                  adv := CurrMouseItem.s.AddOn[1];
                  if adv > 0 then begin
                    tStr := Format('魔法恢复 +%d', [HiWord(CurrMouseItem.s.MAC) * 10]);
                    ostr := ostr + Format('<%s|C=%s> <(+%d)|C=$FF00>\', [tStr, 'clSkyBlue', adv * 10]);
                  end else begin
                    tStr := '魔法恢复 +' + IntToStr(HiWord(CurrMouseItem.s.MAC) * 10); // + '0%';
                    ostr := ostr + Format('<%s|C=%s>\', [tStr, 'clSkyBlue']);
                  end;
                end;
                if LoWord(CurrMouseItem.s.AC) > 0 then begin
                  tStr := '攻击速度 +' + IntToStr(LoWord(CurrMouseItem.s.AC));
                  ostr := ostr + Format('<%s|C=%s>\', [tStr, 'clSkyBlue']);
                end;
                if LoWord(CurrMouseItem.s.MAC) > 0 then begin
                  tStr := '攻击速度 -' + IntToStr(LoWord(CurrMouseItem.s.MAC));
                  ostr := ostr + Format('<%s|C=%s>\', [tStr, 'clSkyBlue']);
                end;
              end;
            23: begin //戒指
                if HiWord(CurrMouseItem.s.AC) > 0 then begin
                  adv := CurrMouseItem.s.AddOn[0];
                  if adv > 0 then begin
                    tStr := Format('毒物躲避 +%d', [HiWord(CurrMouseItem.s.AC) * 10]);
                    ostr := ostr + Format('<%s|C=%s> <(+%d)|C=$FF00>\', [tStr, 'clSkyBlue', adv * 10]);
                  end else begin
                    tStr := '毒物躲避 +' + IntToStr(HiWord(CurrMouseItem.s.AC) * 10); // + '0%';
                    ostr := ostr + Format('<%s|C=%s>\', [tStr, 'clSkyBlue']);
                  end;
                end;
                if HiWord(CurrMouseItem.s.MAC) > 0 then begin
                  adv := CurrMouseItem.s.AddOn[1];
                  if adv > 0 then begin
                    tStr := Format('中毒恢复 +%d', [HiWord(CurrMouseItem.s.MAC) * 10]);
                    ostr := ostr + Format('<%s|C=%s> <(+%d)|C=$FF00>\', [tStr, 'clSkyBlue', adv * 10]);
                  end else begin
                    tStr := '中毒恢复 +' + IntToStr(HiWord(CurrMouseItem.s.MAC) * 10); // + '0%';
                    ostr := ostr + Format('<%s|C=%s>\', [tStr, 'clSkyBlue']);
                  end
                end;
                if LoWord(CurrMouseItem.s.AC) > 0 then begin
                  tStr := '攻击速度 +' + IntToStr(LoWord(CurrMouseItem.s.AC));
                  ostr := ostr + Format('<%s|C=%s>\', [tStr, 'clSkyBlue']);
                end;
                if LoWord(CurrMouseItem.s.MAC) > 0 then begin
                  tStr := '攻击速度 -' + IntToStr(LoWord(CurrMouseItem.s.MAC));
                  ostr := ostr + Format('<%s|C=%s>\', [tStr, 'clSkyBlue']);
                end;
              end;
          else begin
              if CurrMouseItem.s.AC > 0 then begin
                adv := CurrMouseItem.s.AddOn[0];
                if adv > 0 then begin
                  tStr := Format('防御 %d-%d', [LoWord(CurrMouseItem.s.AC), HiWord(CurrMouseItem.s.AC)]);
                  hintstr := hintstr + Format('<%s|C=%d> <(+%d)|C=$FF00>\', [tStr, clWhite, adv]);
                end else begin
                  tStr := '防御 ' + IntToStr(LoWord(CurrMouseItem.s.AC)) + '-' + IntToStr(HiWord(CurrMouseItem.s.AC));
                  hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
                end;
              end;
              if CurrMouseItem.s.MAC > 0 then begin
                adv := CurrMouseItem.s.AddOn[1];
                if adv > 0 then begin
                  tStr := Format('魔防 %d-%d', [LoWord(CurrMouseItem.s.MAC), HiWord(CurrMouseItem.s.MAC)]);
                  hintstr := hintstr + Format('<%s|C=%d> <(+%d)|C=$FF00>\', [tStr, clWhite, adv]);
                end else begin
                  tStr := '魔防 ' + IntToStr(LoWord(CurrMouseItem.s.MAC)) + '-' + IntToStr(HiWord(CurrMouseItem.s.MAC));
                  hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
                end;
              end;
              if CurrMouseItem.s.DC > 0 then begin
                adv := CurrMouseItem.s.AddOn[2];
                if adv > 0 then begin
                  tStr := Format('攻击 %d-%d', [LoWord(CurrMouseItem.s.DC), HiWord(CurrMouseItem.s.DC)]);
                  hintstr := hintstr + Format('<%s|C=%d> <(+%d)|C=$FF00>\', [tStr, clWhite, adv]);
                end else begin
                  tStr := '攻击 ' + IntToStr(LoWord(CurrMouseItem.s.DC)) + '-' + IntToStr(HiWord(CurrMouseItem.s.DC));
                  hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
                end;
              end;
              if CurrMouseItem.s.MC > 0 then begin
                adv := CurrMouseItem.s.AddOn[3];
                if adv > 0 then begin
                  tStr := Format('魔法 %d-%d', [LoWord(CurrMouseItem.s.MC), HiWord(CurrMouseItem.s.MC)]);
                  hintstr := hintstr + Format('<%s|C=%d> <(+%d)|C=$FF00>\', [tStr, clWhite, adv]);
                end else begin
                  tStr := '魔法 ' + IntToStr(LoWord(CurrMouseItem.s.MC)) + '-' + IntToStr(HiWord(CurrMouseItem.s.MC));
                  hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
                end;
              end;
              if CurrMouseItem.s.SC > 0 then begin
                adv := CurrMouseItem.s.AddOn[4];
                if adv > 0 then begin
                  tStr := Format('道术 %d-%d', [LoWord(CurrMouseItem.s.SC), HiWord(CurrMouseItem.s.SC)]);
                  hintstr := hintstr + Format('<%s|C=%d> <(+%d)|C=$FF00>\', [tStr, clWhite, adv]);
                end else begin
                  tStr := '道术 ' + IntToStr(LoWord(CurrMouseItem.s.SC)) + '-' + IntToStr(HiWord(CurrMouseItem.s.SC));
                  hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
                end;
              end;
              if (CurrMouseItem.s.reserve[7] > 0) then begin
                tStr := '体力值 +' + IntToStr(CurrMouseItem.s.reserve[7] * 100);
                hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
              end;
              if (CurrMouseItem.s.reserve[8] > 0) then begin
                tStr := '魔法值 +' + IntToStr(CurrMouseItem.s.reserve[8] * 100);
                hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
              end;
            end;
          end;

          if (CurrMouseItem.s.StdMode = 28) and (CurrMouseItem.s.AniCount > 0) then begin
            tStr := '负重 +' + IntToStr(CurrMouseItem.s.AniCount);
            hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clSkyBlue']);
          end;
          if ostr <> '' then
            hintstr := hintstr + {' \' +} ostr;

          ostr := '';
          if CurrMouseItem.s.UniqueItem > 0 then begin
            tStr := '内功恢复速度 +' + IntToStr(CurrMouseItem.s.UniqueItem) + '%';
            ostr := ostr + Format('<%s|C=%d>\', [tStr, GetRGB(145)]);
          end;
          if Lobyte(CurrMouseItem.s.ItemSet) <> 0 then begin
            tStr := '暴击 +' + IntToStr(Lobyte(CurrMouseItem.s.ItemSet));
            ostr := ostr + Format('<%s|C=%d>\', [tStr, GetRGB(145)]);
          end;
          if Hibyte(CurrMouseItem.s.ItemSet) <> 0 then begin
            tStr := '击杀爆率 +' + IntToStr(Hibyte(CurrMouseItem.s.ItemSet)) + '%';
            ostr := ostr + Format('<%s|C=%d>\', [tStr, GetRGB(145)]);
          end;
          if CurrMouseItem.s.ItemType <> 0 then begin
            tStr := '防爆 +' + IntToStr(CurrMouseItem.s.ItemType) + '%';
            ostr := ostr + Format('<%s|C=%d>\', [tStr, GetRGB(145)]);
          end;
          if (CurrMouseItem.s.Reserved <> 0) and (CurrMouseItem.s.Shape = 190) then begin
            tStr := '吸血 +' + IntToStr(CurrMouseItem.s.Reserved);
            ostr := ostr + Format('<%s|C=%d>\', [tStr, GetRGB(145)]);
          end;
          if (CurrMouseItem.s.Reserved <> 0) and (CurrMouseItem.s.Shape = 191) then begin
            tStr := '内伤 +' + IntToStr(CurrMouseItem.s.Reserved);
            ostr := ostr + Format('<%s|C=%d>\', [tStr, GetRGB(145)]);
          end;
          if (CurrMouseItem.s.Reserved <> 0) and (CurrMouseItem.s.Source = 10) then begin
            tStr := '麻痹抗性 +' + IntToStr(CurrMouseItem.s.Reserved) + '%';
            ostr := ostr + Format('<%s|C=%d>\', [tStr, GetRGB(145)]);
          end;
          if (CurrMouseItem.s.Reserved <> 0) and (CurrMouseItem.s.Source = 11) then begin
            tStr := '特殊技能冷却 -' + IntToStr(CurrMouseItem.s.Reserved) + '秒';
            ostr := ostr + Format('<%s|C=%d>\', [tStr, GetRGB(145)]);
          end;
          if ostr <> '' then
            hintstr := hintstr + {' \' +} ostr;

          loop3:
          ostr := '';
          adv := 0;
          if (CurrMouseItem.s.reserve[0] div 16) > 0 then begin
            //ostr := ostr + format('<忽视目标防御 |C=%d><+%d|b=Bold C=clYellow>', [GetRGB(239), CurrMouseItem.s.reserve[0] div 16]) + '< %|b=Bold C=clYellow>\';
            ostr := ostr + Format('<忽视目标防御 |C=%d>', [GetRGB(242)]) + '<' + IntToStr(CurrMouseItem.s.reserve[0] div 16) + '%|C=' + IntToStr(GetRGB(242)) + '>\';
            Inc(adv);
          end;
          if (CurrMouseItem.s.reserve[0] mod 16) > 0 then begin
            //ostr := ostr + format('<增加伤害 |C=%d><+%d|b=Bold C=clYellow>', [GetRGB(239), CurrMouseItem.s.reserve[0] mod 16]) + '< %|b=Bold C=clYellow>\';
            ostr := ostr + Format('<增加伤害 |C=%d>', [GetRGB(242)]) + '<' + IntToStr(CurrMouseItem.s.reserve[0] mod 16) + '%|C=' + IntToStr(GetRGB(242)) + '>\';
            Inc(adv);
          end;
          if (CurrMouseItem.s.reserve[1] div 16) > 0 then begin
            //ostr := ostr + format('<伤害反射 |C=%d><+%d|b=Bold C=clYellow>', [GetRGB(239), CurrMouseItem.s.reserve[1] div 16]) + '< %|b=Bold C=clYellow>\';
            ostr := ostr + Format('<伤害反射 |C=%d>', [GetRGB(242)]) + '<' + IntToStr(CurrMouseItem.s.reserve[1] div 16) + '%|C=' + IntToStr(GetRGB(242)) + '>\';
            Inc(adv);
          end;
          if (CurrMouseItem.s.reserve[1] mod 16) > 0 then begin
            //ostr := ostr + format('<物理伤害减少 |C=%d><+%d|b=Bold C=clYellow>', [GetRGB(239), CurrMouseItem.s.reserve[1] mod 16]) + '< %|b=Bold C=clYellow>\';
            ostr := ostr + Format('<物理伤害减少 |C=%d>', [GetRGB(242)]) + '<' + IntToStr(CurrMouseItem.s.reserve[1] mod 16) + '%|C=' + IntToStr(GetRGB(242)) + '>\';
            Inc(adv);
          end;

          if (CurrMouseItem.s.reserve[2] div 16) > 0 then begin
            //ostr := ostr + format('<魔法伤害减少 |C=%d><+%d|b=Bold C=clYellow>', [GetRGB(239), CurrMouseItem.s.reserve[2] div 16]) + '< %|b=Bold C=clYellow>\';
            ostr := ostr + Format('<魔法伤害减少 |C=%d>', [GetRGB(242)]) + '<' + IntToStr(CurrMouseItem.s.reserve[2] div 16) + '%|C=' + IntToStr(GetRGB(242)) + '>\';
            Inc(adv);
          end;
          if (CurrMouseItem.s.reserve[2] mod 16) > 0 then begin
            //ostr := ostr + format('<经验吸收增加 |C=%d><+%d|b=Bold C=clYellow>', [GetRGB(239), CurrMouseItem.s.reserve[2] mod 16]) + '< %|b=Bold C=clYellow>\';
            ostr := ostr + Format('<经验吸收增加 |C=%d>', [GetRGB(242)]) + '<' + IntToStr(CurrMouseItem.s.reserve[2] mod 16) + '%|C=' + IntToStr(GetRGB(242)) + '>\';
            Inc(adv);
          end;
          if ostr <> '' then
            hintstr := hintstr + Format('-\<元素强化属性：（|c=clMoneyGreen><%d|C=$FF00></6）|c=clMoneyGreen>\', [adv]) + ostr;

          ostr := '';
          if (g_ShowSuite <> 0) and (CurrMouseItem.s.StdMode in [15, 19, 20, 21, 22, 23, 24, 26, 27, 28]) and (CurrMouseItem.s.Shape = 190) then begin
            cl := clGray;

            ostr := ostr + Format('<%s|C=%d>\', ['虎威套装激活需求：', GetRGB(230)]);
            case g_ShowSuite of
              1: for i := Low(g_tui) to High(g_tui) do g_tui[i] := g_UseItems[i];
              2: for i := Low(g_tui) to High(g_tui) do g_tui[i] := g_HeroUseItems[i];
              3: for i := Low(g_tui) to High(g_tui) do g_tui[i] := UserState1.UseItems[i];
            end;

            if (g_tui[U_NECKLACE].s.Name <> '') and (g_tui[U_NECKLACE].s.Shape = 190) then
              ostr := ostr + Format('<%s|C=%d>    ', ['虎威项链', GetRGB(20)])
            else
              ostr := ostr + Format('<%s|C=%d>    ', ['虎威项链', clGray]);

            if (g_tui[U_HELMET].s.Name <> '') and (g_tui[U_HELMET].s.Shape = 190) then
              ostr := ostr + Format('<%s|C=%d>\', ['虎威头盔', GetRGB(20)])
            else
              ostr := ostr + Format('<%s|C=%d>\', ['虎威头盔', clGray]);

            if ((g_tui[U_ARMRINGL].s.Name <> '') and (g_tui[U_ARMRINGL].s.Shape = 190)) or
              ((g_tui[U_ARMRINGR].s.Name <> '') and (g_tui[U_ARMRINGR].s.Shape = 190)) then
              ostr := ostr + Format('<%s|C=%d>    ', ['虎威护腕', GetRGB(20)])
            else
              ostr := ostr + Format('<%s|C=%d>    ', ['虎威护腕', clGray]);

            if ((g_tui[U_RINGL].s.Name <> '') and (g_tui[U_RINGL].s.Shape = 190)) or
              ((g_tui[U_RINGR].s.Name <> '') and (g_tui[U_RINGR].s.Shape = 190)) then
              ostr := ostr + Format('<%s|C=%d>\', ['虎威戒指', GetRGB(20)])
            else
              ostr := ostr + Format('<%s|C=%d>\', ['虎威戒指', clGray]);

            if (g_tui[U_BELT].s.Name <> '') and (g_tui[U_BELT].s.Shape = 190) then
              ostr := ostr + Format('<%s|C=%d>    ', ['虎威腰带', GetRGB(20)])
            else
              ostr := ostr + Format('<%s|C=%d>    ', ['虎威腰带', clGray]);

            if (g_tui[U_BOOTS].s.Name <> '') and (g_tui[U_BOOTS].s.Shape = 190) then
              ostr := ostr + Format('<%s|C=%d>\', ['虎威靴子', GetRGB(20)])
            else
              ostr := ostr + Format('<%s|C=%d>\', ['虎威靴子', clGray]);

            if (g_tui[U_HELMET].s.Name <> '') and
              (g_tui[U_NECKLACE].s.Name <> '') and
              ((g_tui[U_ARMRINGL].s.Name <> '') or (g_tui[U_ARMRINGR].s.Name <> '')) and
              ((g_tui[U_RINGL].s.Name <> '') or (g_tui[U_RINGR].s.Name <> '')) and
              (g_tui[U_BELT].s.Name <> '') and
              (g_tui[U_BOOTS].s.Name <> '') then begin
              cl := clWhite;
            end;
            g_ShowSuite := 0;
            ostr := ostr + Format('<%s|C=%d>\', ['激活套装效果：', GetRGB(230)]);
            ostr := ostr + Format('<吸血效果翻倍|C=%d>\', [cl]);
            ostr := ostr + Format('<吸血成功率大幅度提升|C=%d>\', [cl]);
            ostr := ostr + Format('<%s|C=%d>\', ['防御 5-5 魔御 5-5 攻击 0-10', cl]);
            ostr := ostr + Format('<%s|C=%d>\', ['魔法 0-10 道术0-10', cl]);
          end;
          if ostr <> '' then
            hintstr := hintstr + '-\' + ostr;

          ostr := '';
          if (g_ShowSuite <> 0) and (CurrMouseItem.s.StdMode in [15, 19, 20, 21, 22, 23, 24, 26, 27, 28]) and (CurrMouseItem.s.Shape = 191) then begin
            cl := clGray;
            //FillChar(slegend, SizeOf(slegend), 0);

            case g_ShowSuite of
              1: for i := Low(g_tui) to High(g_tui) do g_tui[i] := g_UseItems[i];
              2: for i := Low(g_tui) to High(g_tui) do g_tui[i] := g_HeroUseItems[i];
              3: for i := Low(g_tui) to High(g_tui) do g_tui[i] := UserState1.UseItems[i];
            end;

            if ((g_tui[U_HELMET].s.Name <> '') and (g_tui[U_HELMET].s.Shape = 191)) and
              ((g_tui[U_NECKLACE].s.Name <> '') and (g_tui[U_NECKLACE].s.Shape = 191)) and

            (((g_tui[U_ARMRINGL].s.Name <> '') and (g_tui[U_ARMRINGL].s.Shape = 191)) or
              ((g_tui[U_ARMRINGR].s.Name <> '') and (g_tui[U_ARMRINGR].s.Shape = 191))) and

            (((g_tui[U_RINGL].s.Name <> '') and (g_tui[U_RINGL].s.Shape = 191)) or
              ((g_tui[U_RINGR].s.Name <> '') and (g_tui[U_RINGR].s.Shape = 191))) and

            ((g_tui[U_BELT].s.Name <> '') and (g_tui[U_BELT].s.Shape = 191)) and
              ((g_tui[U_BOOTS].s.Name <> '') and (g_tui[U_BOOTS].s.Shape = 191)) then begin

              ostr := ostr + Format('<%s|C=%d>\', ['套装效果：', $005CF4FF]);
              ostr := ostr + Format('<%s|C=%d>\', ['内伤等级附加 +40', $005CF4FF]);
              ostr := ostr + Format('<%s|C=%d>\', ['大幅度提升击杀爆率', $005CF4FF]);
            end else if ((g_tui[U_HELMET].s.Name <> '') and (g_tui[U_HELMET].s.Shape = 191)) and
              ((g_tui[U_NECKLACE].s.Name <> '') and (g_tui[U_NECKLACE].s.Shape = 191)) and

            (((g_tui[U_ARMRINGL].s.Name <> '') and (g_tui[U_ARMRINGL].s.Shape = 191)) or
              ((g_tui[U_ARMRINGR].s.Name <> '') and (g_tui[U_ARMRINGR].s.Shape = 191))) and

            (((g_tui[U_RINGL].s.Name <> '') and (g_tui[U_RINGL].s.Shape = 191)) or
              ((g_tui[U_RINGR].s.Name <> '') and (g_tui[U_RINGR].s.Shape = 191))) then begin
              ostr := ostr + Format('<%s|C=%d>\', ['套装效果：', $005CF4FF]);
              ostr := ostr + Format('<%s|C=%d>\', ['内伤等级附加 +30', $005CF4FF]);
              ostr := ostr + Format('<%s|C=%d>\', ['中幅度提升击杀爆率', $005CF4FF]);

            end else if ((g_tui[U_HELMET].s.Name <> '') and (g_tui[U_NECKLACE].s.Shape = 191)) and
              ((g_tui[U_NECKLACE].s.Name <> '') and (g_tui[U_NECKLACE].s.Shape = 191)) and
              ((g_tui[U_BELT].s.Name <> '') and (g_tui[U_BELT].s.Shape = 191)) and
              ((g_tui[U_BOOTS].s.Name <> '') and (g_tui[U_BOOTS].s.Shape = 191)) then begin
              ostr := ostr + Format('<%s|C=%d>\', ['套装效果：', $005CF4FF]);
              ostr := ostr + Format('<%s|C=%d>\', ['内伤等级附加 +25', $005CF4FF]);
              ostr := ostr + Format('<%s|C=%d>\', ['小幅度提升击杀爆率', $005CF4FF]);
            end else if ((g_tui[U_NECKLACE].s.Name <> '') and (g_tui[U_NECKLACE].s.Shape = 191)) and

            (((g_tui[U_ARMRINGL].s.Name <> '') and (g_tui[U_ARMRINGL].s.Shape = 191)) or
              ((g_tui[U_ARMRINGR].s.Name <> '') and (g_tui[U_ARMRINGR].s.Shape = 191))) and

            (((g_tui[U_RINGL].s.Name <> '') and (g_tui[U_RINGL].s.Shape = 191)) or
              ((g_tui[U_RINGR].s.Name <> '') and (g_tui[U_RINGR].s.Shape = 191))) then begin
              ostr := ostr + Format('<%s|C=%d>\', ['套装效果：', $005CF4FF]);
              ostr := ostr + Format('<%s|C=%d>\', ['内伤等级附加 +20', $005CF4FF]);
            end else if ((g_tui[U_HELMET].s.Name <> '') and (g_tui[U_HELMET].s.Shape = 191)) and
              ((g_tui[U_BELT].s.Name <> '') and (g_tui[U_BELT].s.Shape = 191)) and
              ((g_tui[U_BOOTS].s.Name <> '') and (g_tui[U_BOOTS].s.Shape = 191)) then begin
              ostr := ostr + Format('<%s|C=%d>\', ['套装效果：', $005CF4FF]);
              ostr := ostr + Format('<%s|C=%d>\', ['内伤等级附加 +15', $005CF4FF]);
            end else if ((g_tui[U_NECKLACE].s.Name <> '') and (g_tui[U_NECKLACE].s.Shape = 191)) and

            (((g_tui[U_ARMRINGL].s.Name <> '') and (g_tui[U_ARMRINGL].s.Shape = 191)) or
              ((g_tui[U_ARMRINGR].s.Name <> '') and (g_tui[U_ARMRINGR].s.Shape = 191))) and

            (((g_tui[U_RINGL].s.Name <> '') and (g_tui[U_RINGL].s.Shape = 191)) or
              ((g_tui[U_RINGR].s.Name <> '') and (g_tui[U_RINGR].s.Shape = 191))) then begin
              ostr := ostr + Format('<%s|C=%d>\', ['套装效果：', $005CF4FF]);
              ostr := ostr + Format('<%s|C=%d>\', ['内伤等级附加 +10', $005CF4FF]);
            end else if ((g_tui[U_HELMET].s.Name <> '') and (g_tui[U_HELMET].s.Shape = 191)) and

            ((g_tui[U_BELT].s.Name <> '') and (g_tui[U_BELT].s.Shape = 191)) and
              ((g_tui[U_BOOTS].s.Name <> '') and (g_tui[U_BOOTS].s.Shape = 191)) then begin
              ostr := ostr + Format('<%s|C=%d>\', ['套装效果：', $005CF4FF]);
              ostr := ostr + Format('<%s|C=%d>\', ['内伤等级附加 +8', $005CF4FF]);
            end;

            g_ShowSuite := 0;

          end;
          if ostr <> '' then
            hintstr := hintstr + '-\' + ostr;

          //传奇套装
          ostr := '';
          if (g_ShowSuite <> 0) and
            (CurrMouseItem.s.StdMode in [5, 6, 10..13, 15..24, 26..30]) and
            ((CurrMouseItem.s.Shape = 193) or (CurrMouseItem.s.AniCount = 193)) then begin
            cl := clGray;

            GetSuiteAbil(g_ShowSuite, 193, slegend);

            adv := 0;
            if slegend[5] = 1 then slegend[6] := 1;
            if slegend[7] = 1 then slegend[8] := 1;

            ostr := ostr + Format('<%s|C=%d>\', ['传奇套装激活需求：', GetRGB(150)]);
//            for i := Low(slegend) to High(slegend) do begin
//              if g_slegend[i] = '' then Continue;
//              if (slegend[i] = 1) then begin
//                ostr := ostr + Format('<%s|C=%d>\', [g_slegend[i], clYellow])
//              end else if g_slegend[i] <> '' then
//                ostr := ostr + Format('<%s|C=%d>\', [g_slegend[i], clGray]);
//            end;

            if slegend[U_WEAPON] > 0 then begin
              if (slegend[U_HELMET] > 0) and
                (slegend[U_HELMETEX] > 0) and
                (slegend[U_RIGHTHAND] > 0) and
                (slegend[U_NECKLACE] > 0) and
                ((slegend[U_ARMRINGL] > 0) or (slegend[U_ARMRINGR] > 0)) and
                ((slegend[U_RINGL] > 0) or (slegend[U_RINGR] > 0)) and
                (slegend[U_BELT] > 0) and
                (slegend[U_BOOTS] > 0) then begin
                adv := 3;
              end else if (slegend[U_HELMET] > 0) and
                (slegend[U_NECKLACE] > 0) and
                ((slegend[U_ARMRINGL] > 0) or (slegend[U_ARMRINGR] > 0)) and
                ((slegend[U_RINGL] > 0) or (slegend[U_RINGR] > 0)) and
                (slegend[U_BELT] > 0) and
                (slegend[U_BOOTS] > 0) then begin
                adv := 2;
              end else if (slegend[U_HELMET] > 0) and
                (slegend[U_HELMETEX] > 0) and
                (slegend[U_RIGHTHAND] > 0) and
                (slegend[U_BELT] > 0) and
                (slegend[U_BOOTS] > 0) then begin
                adv := 2;
              end else if (slegend[U_HELMET] > 0) and
                (slegend[U_BELT] > 0) and
                (slegend[U_BOOTS] > 0) then begin
                adv := 1;
              end else if (slegend[U_NECKLACE] > 0) and
                ((slegend[U_ARMRINGL] > 0) or (slegend[U_ARMRINGR] > 0)) and
                ((slegend[U_RINGL] > 0) or (slegend[U_RINGR] > 0)) then begin
                adv := 1;
              end else if (slegend[U_HELMETEX] > 0) and
                (slegend[U_RIGHTHAND] > 0) and
                (slegend[U_DRESS] > 0) then begin
                adv := 1;
              end;
            end;
            if adv > 0 then begin
              g_SuiteSpSkill := adv;
              ostr := ostr + Format('<%s|C=%d>\', ['套装效果：', GetRGB(242)]);
              ostr := ostr + Format('<%s|C=%d>\', [Format('召唤巨魔技能lv%d', [adv]), clWhite]);
              case adv of
                1: ostr := ostr + Format('<%s|C=%d>\', ['冰眼巨魔能力获得提升', clWhite]);
                2: ostr := ostr + Format('<%s|C=%d>\', ['冰眼巨魔能力冰眼神技', clWhite]);
                3: ostr := ostr + Format('<%s|C=%d>\', ['冰眼巨魔获得冰眼神技', clWhite]);
              else
                ostr := ostr + Format('<%s|C=%d>\', ['冰眼巨魔获得冰眼神技', clWhite]);
              end;
            end else begin
              ostr := ostr + Format('<%s|C=%d>\', ['套装效果：', GetRGB(242)]);
              ostr := ostr + Format('<%s|C=%d>\', [Format('召唤巨魔技能', [adv]), clGray]);
            end;

            g_ShowSuite := 0;
          end;
          if ostr <> '' then
            hintstr := hintstr + '-\' + ostr;

          //loop3:
          ostr := '';
          if g_ShowSuite2 <> 0 then begin

            ncl := 0;
            case g_ShowSuite2 of
              1: if g_Myself <> nil then ncl := g_Myself.m_btSex;
              2: if g_Myself.m_HeroObject <> nil then ncl := g_Myself.m_HeroObject.m_btSex;
              3: ncl := UserState1.btGender;
            end;

            //Dscreen.AddSysMsg(inttostr(ncl));

            p := getSuiteHint(g_SuiteIdx, CurrMouseItem.s.Name, ncl);
            if p <> nil then begin
              tStr2 := '';
              case g_ShowSuite2 of
                1: for i := Low(g_tui) to High(g_tui) do g_tui[i] := g_UseItems[i];
                2: for i := Low(g_tui) to High(g_tui) do g_tui[i] := g_HeroUseItems[i];
                3: for i := Low(g_tui) to High(g_tui) do g_tui[i] := UserState1.UseItems[i];
              end;
              g_ShowSuite2 := 0;
              adv := 0;
              b := True;
              bb := False;
              for i := Low(g_tui) to High(g_tui) - 1 do begin
                if (p.asSuiteName[i] <> '') then begin
                  if g_tui[i].s.Name = p.asSuiteName[i] then begin
                    if i in [U_ARMRINGL, U_RINGL] then
                      tStr2 := tStr2 + Format('<%s (左)|C=%d>\', [p.asSuiteName[i], GetRGB(p.ItemColor)])
                    else if i in [U_ARMRINGR, U_RINGR] then
                      tStr2 := tStr2 + Format('<%s (右)|C=%d>\', [p.asSuiteName[i], GetRGB(p.ItemColor)])
                    else
                      tStr2 := tStr2 + Format('<%s|C=%d>\', [p.asSuiteName[i], GetRGB(p.ItemColor)]);
                    Inc(adv);
                  end else begin
                    if i in [U_ARMRINGL, U_RINGL] then
                      tStr2 := tStr2 + Format('<%s (左)|C=%d>\', [p.asSuiteName[i], clGray])
                    else if i in [U_ARMRINGR, U_RINGR] then
                      tStr2 := tStr2 + Format('<%s (右)|C=%d>\', [p.asSuiteName[i], clGray])
                    else
                      tStr2 := tStr2 + Format('<%s|C=%d>\', [p.asSuiteName[i], clGray]);
                  end;
                end;
              end;
              if (tStr2 <> '') then begin
                if (tStr2[Length(tStr2)] <> '\') then
                  tStr2 := tStr2 + '\';
                ostr := ostr + Format('<%s：（|c=clMoneyGreen><%d|C=$FF00></%d）|C=clMoneyGreen>\', ['套装激活条件', adv, p.nNeedCount]) + tStr2;
              end;

              ostr := ostr + Format('<%s|C=%d>\', ['激活效果：', clMoneyGreen]);
              cl := clGray;
              if adv = p.nNeedCount then
                cl := GetRGB(p.AbilColor);
              b := True;
              for i := Low(p.aSuitSubRate) to High(p.aSuitSubRate) do
              begin
                if p.aSuitSubRate[i] > 0 then
                begin
                  if g_SuitSubRateBool[i] then
                    tStr := Format(g_SuitSubRateName[i], [p.aSuitSubRate[i]]) + '%'
                  else
                    tStr := Format(g_SuitSubRateName[i], [p.aSuitSubRate[i]]);

                  FillChar(iname[1], ItemNameLen, #$20);
                  if Length(tStr) > 14 then
                    iname[0] := ANSIChar(Length(tStr))
                  else
                    iname[0] := ANSIChar(14);
                  Move(tStr[1], iname[1], Length(tStr));

                  if b then
                    ostr := ostr + Format('<%s|C=%d>', [iname, cl])
                  else
                    ostr := ostr + Format('<%s|C=%d>\', [iname, cl]);
                  b := not b;
                end;
              end;
            end;
            g_ShowSuite2 := 0;
          end;

          if ostr <> '' then begin
            if (ostr[Length(ostr)] <> '\') then
              ostr := ostr + '\';
            hintstr := hintstr + '-\' + ostr;
          end;

        end;
      25: begin
          tStr := '重量 ' + IntToStr(CurrMouseItem.s.Weight);
          hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
          case CurrMouseItem.s.Shape of
            9: begin
                if CurrMouseItem.Dura = 0 then begin
                  tStr := '容量 ' + GetDura1Str(CurrMouseItem.Dura, CurrMouseItem.DuraMax);
                  hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clRed']);
                end else begin
                  tStr := '容量 ' + GetDura1Str(CurrMouseItem.Dura, CurrMouseItem.DuraMax);
                  hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
                end;
              end;
          else begin
              if CurrMouseItem.Dura = 0 then begin
                tStr := '使用 ' + GetDura100Str(CurrMouseItem.Dura, CurrMouseItem.DuraMax) + ' 次';
                hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clRed']);
              end else begin
                tStr := '使用 ' + GetDura100Str(CurrMouseItem.Dura, CurrMouseItem.DuraMax) + ' 次';
                hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
              end;
            end;
          end;
          goto loop3;
        end;
      40: {//肉} begin
          tStr := '重量 ' + IntToStr(CurrMouseItem.s.Weight);
          hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
          tStr := '品质 ' + GetDuraStr(CurrMouseItem.Dura, CurrMouseItem.DuraMax);
          hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
        end;
      42: {//药材} begin
          tStr := '重量 ' + IntToStr(CurrMouseItem.s.Weight);
          hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
          tStr := '纯度 ' + IntToStr(Round(CurrMouseItem.Dura / 1000));
          hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
        end;
      43: {//矿石} begin
          tStr := '重量 ' + IntToStr(CurrMouseItem.s.Weight);
          hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
          tStr := '纯度 ' + IntToStr(Round(CurrMouseItem.Dura / 1000));
          hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
        end;
    else begin
        if CurrMouseItem.s.Overlap = 1 then begin
          tStr := '重量 ' + IntToStr(CurrMouseItem.Dura div 10);
          hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
          tStr := '数量 ' + IntToStr(CurrMouseItem.Dura);
          hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
        end
        else if CurrMouseItem.s.Overlap = 2 then begin
          tStr := '重量 ' + IntToStr(CurrMouseItem.s.Weight * CurrMouseItem.Dura);
          hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
          tStr := '数量 ' + IntToStr(CurrMouseItem.Dura);
          hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
        end
        else begin
          tStr := '重量 ' + IntToStr(CurrMouseItem.s.Weight);
          hintstr := hintstr + Format('<%s|C=%s>\', [tStr, 'clWhite']);
        end;
      end;
    end;

    //CurrMouseItem.s.reserve[6]   //鉴定次数

    if CurrMouseItem.s.StdMode <> 51 then begin
      ostr := GetEvaluationInfo(CurrMouseItem);
      if ostr <> '' then begin
        if (ostr[Length(ostr)] <> '\') then
          ostr := ostr + '\';
        hintstr := hintstr + '-\' + ostr;
      end;
    end;

    ostr := '';
    i := g_ItemDesc.IndexOf(CurrMouseItem.s.Name);
    if i >= 0 then begin
      Obj := g_ItemDesc.Objects[i];
      if Obj <> nil then begin
        tStr2 := string(Pstring(Obj)^);
        if tStr2 <> '' then begin
          ostr := '';
          Loop1:
          len := Length(tStr2);
          temp := '';
          i := 1;
          while True do begin
            if i > len then Break;
            if byte(tStr2[i]) >= 128 then begin
              temp := temp + tStr2[i];
              Inc(i);
              if i <= len then
                temp := temp + tStr2[i]
              else
                Break;
            end else
              temp := temp + tStr2[i];
            //clGray
            aline := FontManager.Default.TextWidth(temp);
            if aline > 160 then begin
              ostr := ostr + Format('<%s|C=%d>\', [temp, $29EF94]);
              tStr2 := Copy(tStr2, i + 1, len - i);
              temp := '';
              Break;
            end;
            Inc(i);
          end;
          if temp <> '' then begin
            ostr := ostr + Format('<%s|C=%d>\', [temp, $29EF94]);
            tStr2 := '';
          end;
          if tStr2 <> '' then begin
            goto Loop1;
          end;
        end;
      end;
    end;
    if ostr <> '' then
      hintstr := hintstr + '-\' + ostr;
    if (hintstr <> '') and (hintstr[Length(hintstr)] = '\') then
      hintstr[Length(hintstr)] := #0;
  end;
end;
{$ELSE}

{$IFEND NEWHINTSYS}

procedure TFrmDlg.DItemBagDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d0, d1, d2, d3, d4: string;
  n, L, FontColor: Integer;
  useable: Boolean;
  d: TCustomLockableTexture;
  DestRect, SrcRect: TRect;
begin
  d := nil;
  if g_Myself = nil then Exit;
  with DItemBag do begin
    //d := ULib.Images[FaceName];
    d := WLib.Images[FaceIndex];
    if d <> nil then dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);

    //GetMouseItemInfo(g_MouseItem, d0, d1, d2, d3, d4, useable);
    with dsurface do begin
      TextOut(SurfaceX(Left + 72), SurfaceY(Top + 212), GetGoldStr(g_Myself.m_nGold), clWhite);
      {if d0 <> '' then begin
        n := TextWidth(d0, False);
        Font.Color := clYellow;
        TextOutA(SurfaceX(Left + 77), SurfaceY(Top + 243), d0);
        Font.Color := clWhite;
        TextOutA(SurfaceX(Left + 77) + n, SurfaceY(Top + 243), d1);
        TextOutA(SurfaceX(Left + 77), SurfaceY(Top + 243 + 14), d2);
        if not useable then Font.Color := clRed;
        TextOutA(SurfaceX(Left + 77), SurfaceY(Top + 243 + 14 * 2), d3);

        if d4 <> '' then begin
          L := 1;
          Font.Color := clLime;
          while True do begin
            if d4 = '' then Break;
            d4 := GetValidStr3(d4, d0, ['\']);
            if d0 <> '' then TextOutA(SurfaceX(Left + 77), SurfaceY(Top + 243 + 14 * (2 + L)), d0);
            Inc(L);
            if L > 2 then Break;
          end;
        end;
      end else begin}
      FontColor := clWhite;
      if g_showgamegoldinfo then begin
        TextOut(SurfaceX(Left + 77), SurfaceY(Top + 243), Format('金刚石数 %d', [g_Myself.m_nGameDiamd]), FontColor);
        TextOut(SurfaceX(Left + 77), SurfaceY(Top + 243 + 14), Format('灵符数量 %d', [g_Myself.m_nGameGird]), FontColor);
        TextOut(SurfaceX(Left + 77), SurfaceY(Top + 243 + 28), Format('元宝数量 %d', [g_Myself.m_nGameGold]), FontColor);
      end else begin
        TextOut(SurfaceX(Left + 77), SurfaceY(Top + 243 + 00), 'CTRL+B 刷新包裹', FontColor);
        if g_boHero then TextOut(SurfaceX(Left + 77), SurfaceY(Top + 243 + 16), 'ALT+B  刷新英雄包裹', FontColor);
      end;
    end;
  end;
end;

procedure TFrmDlg.DCloseBagDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
begin
  with DCloseBag do begin
    if DCloseBag.Downed then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    end;
  end;
end;

procedure TFrmDlg.DCloseBagClick(Sender: TObject; X, Y: Integer);
begin
  DItemBag.Visible := False;
end;

procedure TFrmDlg.DItemGridGridMouseMove(Sender: TObject; //20201005背包显示问题
  X, Y, ACol, ARow: Integer; Shift: TShiftState);
var
  XX, YY, idx, L, M, itemidx0, itemidx, itemidx2: Integer;
  temp: TClientItem;
  iname, d1, d2, d3, shint: string;
  HintLeft, HintDown: Boolean;
  hcolor: TColor;
  b1, b2: Boolean;
label
  labNext;
begin
  if g_Myself = nil then
    Exit;
  DScreen.ClearHint;
  idx := ACol + ARow * DItemGrid.ColCount + 6;
  if idx in [6 .. MAXBAGITEM - 1] then
  begin
    g_MouseItem := g_ItemArr[idx];
    if g_MouseItem.s.Name <> '' then
    begin
      itemidx0 := -1;
      itemidx := -1;
      itemidx2 := -1;

      // if g_gcGeneral[14] then begin
      case g_MouseItem.s.StdMode of
        10, 11:
          begin
            itemidx0 := U_DRESS;
            if g_UseItems[U_DRESS].s.Name <> '' then
              if g_gcGeneral[14] then
                itemidx := U_DRESS;
          end;
        5, 6:
          begin
            itemidx0 := U_WEAPON;
            if g_UseItems[U_WEAPON].s.Name <> '' then
              if g_gcGeneral[14] then
                itemidx := U_WEAPON;
          end;
        30:
          begin
            itemidx0 := U_RIGHTHAND;
            if g_UseItems[U_RIGHTHAND].s.Name <> '' then
              if g_gcGeneral[14] then
                itemidx := U_RIGHTHAND;
          end;
        19, 20, 21:
          begin
            itemidx0 := U_NECKLACE;
            if g_UseItems[U_NECKLACE].s.Name <> '' then
              if g_gcGeneral[14] then
                itemidx := U_NECKLACE;
          end;
        15:
          begin
            itemidx0 := U_HELMET;
            if g_UseItems[U_HELMET].s.Name <> '' then
              if g_gcGeneral[14] then
                itemidx := U_HELMET;
          end;
        16:
          begin
            if g_UseItems[U_HELMETEX].s.Name <> '' then
              if g_gcGeneral[14] then
                itemidx := U_HELMETEX;
          end;
        24, 26:
          begin
            itemidx0 := U_ARMRINGL;
            if g_UseItems[U_ARMRINGL].s.Name <> '' then
              if g_gcGeneral[14] then
                itemidx := U_ARMRINGL;
            if g_UseItems[U_ARMRINGR].s.Name <> '' then
            begin
              itemidx0 := U_ARMRINGR;
              if g_gcGeneral[14] then
              begin
                if itemidx < 0 then
                  itemidx := U_ARMRINGR
                else
                  itemidx2 := U_ARMRINGR;
              end;
            end;
          end;
        22, 23:
          begin
            itemidx0 := U_RINGL;
            if g_UseItems[U_RINGL].s.Name <> '' then
              if g_gcGeneral[14] then
                itemidx := U_RINGL;
            if g_UseItems[U_RINGR].s.Name <> '' then
            begin
              itemidx0 := U_RINGR;
              if g_gcGeneral[14] then
              begin
                if itemidx < 0 then
                  itemidx := U_RINGR
                else
                  itemidx2 := U_RINGR;
              end;
            end;
          end;
        25:
          begin
            itemidx0 := U_BUJUK;
            if g_UseItems[U_BUJUK].s.Name <> '' then
              if g_gcGeneral[14] then
                itemidx := U_BUJUK;
          end;
        27:
          begin
            itemidx0 := U_BELT;
            if g_UseItems[U_BELT].s.Name <> '' then
              if g_gcGeneral[14] then
                itemidx := U_BELT;
          end;
        28:
          begin
            itemidx0 := U_BOOTS;
            if g_UseItems[U_BOOTS].s.Name <> '' then
              if g_gcGeneral[14] then
                itemidx := U_BOOTS;
          end;
        7, 29:
          begin
            itemidx0 := U_CHARM;
            if g_UseItems[U_CHARM].s.Name <> '' then
              if g_gcGeneral[14] then
                itemidx := U_CHARM;
          end;
      end;
      // end;
      with TDGrid(Sender) do
      begin
        XX := SurfaceX(Left + (ACol + 1) * 36);
        Y := SurfaceY(Top + (ARow) * 32 + 2);
        yy:= y;
        if itemidx in [0 .. U_FASHION] then
        begin

          HintLeft := False;
          if XX + (MAXITEMBOX_WIDTH + 5) * (2 + byte(itemidx2 > -1)) > SCREENWIDTH
          then
          begin
            HintLeft := True;
          end;

          if HintLeft then
          begin
            if (itemidx in [0 .. U_FASHION]) and (itemidx2 > -1) then
            begin
              XX := SCREENWIDTH -
                ((MAXITEMBOX_WIDTH + 5) * (2 + byte(itemidx2 > -1))) + 2;
              goto labNext;
            end;
            if itemidx0 in [0 .. 12] then
            begin
              g_ShowSuite := 1;
              g_SuiteIdx := itemidx0;
            end;
            g_ItemWear := byte((itemidx in [0 .. U_FASHION]) or
              (itemidx2 > -1));
            GetMouseItemInfoHint(g_MouseItem, shint);
            if shint <> '' then
            begin
              DScreen.ShowHint(XX - 36 - 3, Y, shint, clWhite, False, True,
                True, True);
            end;

            // 2
            if itemidx in [0 .. U_FASHION] then
            begin
              g_ShowSuite := 1;
              g_SuiteIdx := itemidx;
            end;
            g_MouseItem := g_UseItems[itemidx];

            if itemidx in [U_ARMRINGL, U_RINGL] then
              g_ItemWear := 3
            else if itemidx in [U_ARMRINGR, U_RINGR] then
              g_ItemWear := 4
            else if itemidx in [0 .. U_FASHION] then
              g_ItemWear := 2;

            GetMouseItemInfoHint(g_MouseItem, shint);
            if shint <> '' then
            begin
              L := DScreen.ShowHint(XX - 36 - (MAXITEMBOX_WIDTH + 5) - 3, Y,
                shint, clWhite, False, True, True, True, 2, True);
            end;
          end
          else
          begin
          labNext:
            if itemidx0 in [0 .. 12] then
            begin
              g_ShowSuite := 1;
              g_SuiteIdx := itemidx0;
            end;
            g_ItemWear := byte((itemidx in [0 .. U_FASHION]) or
              (itemidx2 > -1));
            GetMouseItemInfoHint(g_MouseItem, shint);
            if shint <> '' then
            begin
              DScreen.ShowHint(XX, Y, shint, clWhite, False, False, True, True);
            end;

            // 2
            if itemidx in [0 .. U_FASHION] then
            begin
              g_ShowSuite := 1;
              g_SuiteIdx := itemidx;
            end;
            if itemidx in [U_ARMRINGL, U_RINGL] then
              g_ItemWear := 3
            else if itemidx in [U_ARMRINGR, U_RINGR] then
              g_ItemWear := 4
            else if itemidx in [0 .. U_FASHION] then
              g_ItemWear := 2;
            g_MouseItem := g_UseItems[itemidx];
            GetMouseItemInfoHint(g_MouseItem, shint);
            if shint <> '' then
            begin
              DScreen.ShowHint(XX + (MAXITEMBOX_WIDTH + 5), Y, shint, clWhite,
                False, False, True, True, 2, True);
            end;

            // 3
            if itemidx2 > -1 then
            begin
              if itemidx2 in [0 .. U_FASHION] then
              begin
                g_ShowSuite := 1;
                g_SuiteIdx := itemidx2;
              end;
              g_MouseItem := g_UseItems[itemidx2];
              g_ItemWear := 4;
              GetMouseItemInfoHint(g_MouseItem, shint);
              if shint <> '' then
              begin
                DScreen.ShowHint(XX + (MAXITEMBOX_WIDTH + 5) * 2, YY, shint,
                  clWhite, False, False, True, True, 3, True);
              end;
            end;
          end;
        end
        else
        begin
          if itemidx0 in [0 .. 12] then
          begin
            g_ShowSuite := 1;
            g_SuiteIdx := itemidx0;
          end;
          GetMouseItemInfoHint(g_MouseItem, shint);
          if shint <> '' then
          begin
            DScreen.ShowHint(XX, yy, shint, clWhite, False, False, True, True);
          end;
        end;
      end;

      g_MouseItem.s.Name := '';
    end;

  end;
end;


procedure TFrmDlg.DItemGridGridSelect(Sender: TObject; X, Y, ACol, ARow: Integer; Shift: TShiftState);
var
  idx, mi: Integer;
  temp: TClientItem;
  MsgResult, Count: Integer;
  valstr: string;
  keyvalue: TKeyBoardState;
  StallItem: TClientStall;
  DefMsg: TDefaultMessage;
begin
  //if (g_WaitingUseItem.Item.S.Name <> '') then Exit;
  if DItemGrid.OnButton = mbLeft then begin
    FillChar(keyvalue, SizeOf(TKeyBoardState), #0);
    GetKeyboardState(keyvalue);
    idx := ACol + ARow * DItemGrid.ColCount + 6;

    if idx in [6..MAXBAGITEM - 1] then begin
      if not g_boItemMoving then begin
        if g_ItemArr[idx].s.Name <> '' then begin

          if g_ItemArr[idx].s.NeedIdentify = 4 then begin
            g_ItemArr[idx].s.NeedIdentify := 0;
            DelStallItem(g_ItemArr[idx]);
          end else if g_ItemArr[idx].s.NeedIdentify = 5 then
            Exit;

          if (g_ItemArr[idx].s.Overlap > 0) and (g_ItemArr[idx].Dura > 1) and (Shift = [{ssCtrl,} ssShift]) then begin

            MsgResult := DMessageDlg(Format('你想拆分多少 %s ？', [g_ItemArr[idx].s.Name]), [mbOk, mbCancel, mbAbort], IntToStr(g_ItemArr[idx].Dura - 1));

            GetValidStrVal(DlgEditText, valstr, [' ']);
            Count := Str_ToInt(valstr, 0);

            if Count >= g_ItemArr[idx].Dura then Count := g_ItemArr[idx].Dura - 1;
            if (MsgResult = mrCancel) or (Count <= 0) then begin
              Count := 0;
              Exit;
            end;
            frmMain.SendDismantleItem(g_ItemArr[idx].s.Name, g_ItemArr[idx].MakeIndex, Count, 0);

          end else begin
            g_boItemMoving := True;
            g_MovingItem.Index := idx;
            g_MovingItem.item := g_ItemArr[idx];
            g_ItemArr[idx].s.Name := '';
            g_SndMgr.ItemClickSound(g_ItemArr[idx].s);
          end;
        end;
      end else begin
        mi := g_MovingItem.Index;
        if IsDetectItem(mi) then begin
          g_WaitingDetectItem := g_MovingItem;
          g_boItemMoving := False;
          g_MovingItem.Index := 0;
          g_MovingItem.item.s.Name := '';
          DefMsg := EDcode.MakeDefaultMsg(CM_MoveDetectItem, g_WaitingDetectItem.item.MakeIndex, 0, 0, 0);
          frmMain.SendSocket(EncodeMessage(DefMsg));
          Exit;
        end;

        if IsStallItem(mi) then begin
          if g_Myself.m_StallMgr.OnSale then begin
            //if g_WaitingStallItem.Item.s.Name <> '' then exit;
            g_WaitingStallItem := g_MovingItem;
            g_boItemMoving := False;
            g_MovingItem.Index := 0;
            g_MovingItem.item.s.Name := '';

            StallItem.MakeIndex := g_WaitingStallItem.item.MakeIndex;
            DefMsg := EDcode.MakeDefaultMsg(CM_UPDATESTALLITEM, 0, 0, 0, 0);
            frmMain.SendSocket(EncodeMessage(DefMsg) + EncodeBuffer(@StallItem, SizeOf(StallItem)));
          end else begin
            UpdateBagStallItem(g_MovingItem.item, 0);
            DelStallItem(g_MovingItem.item);
            g_boItemMoving := False;
            g_MovingItem.Index := 0;
            g_MovingItem.item.s.Name := '';
          end;
          Exit;
        end;
        if (DDealDlg.Visible) then begin
          if (mi >= 0) and (mi < 6) then begin
            CancelItemMoving;
            DMessageDlg('[注意] 交易时不能将物品放到包裹中', [mbOk]);
            Exit;
          end;
        end;
        if (mi = -97) or (mi = -98) then Exit;
        if (mi < (0 - HERO_MIIDX_OFFSET)) and (mi >= -((U_FASHION + 1) + HERO_MIIDX_OFFSET)) then Exit;

        if (mi < 0) and (mi >= -(U_FASHION + 1)) then begin
          g_SndMgr.ItemClickSound(g_MovingItem.item.s);
          g_WaitingUseItem := g_MovingItem;
          frmMain.SendTakeOffItem(-(g_MovingItem.Index + 1), g_MovingItem.item.MakeIndex, g_MovingItem.item.s.Name);
          g_MovingItem.item.s.Name := '';
          g_boItemMoving := False;
        end else begin
          if (mi <= -20) and (mi > -30) then begin
            DealItemReturnBag(g_MovingItem.item);
            if g_MovingItem.item.s.Overlap > 0 then begin
              g_MovingItem.item.s.Name := '';
              g_boItemMoving := False;
              Exit;
            end;
          end else if (mi <= -30) and (mi > -39) then
            ; //AddYbDealItem(g_MovingItem.Item);

          if mi >= HERO_MIIDX_OFFSET then begin //英雄物品->主人包裹
            if (g_Myself = nil) or (g_Myself.m_HeroObject = nil) or (g_Myself.m_HeroObject.m_boDeath) then Exit;
            g_WaitingUseItem := g_MovingItem;
            frmMain.SendHeroItemToMasterBag(g_MovingItem.item.MakeIndex, g_MovingItem.item.s.Name);
            g_MovingItem.item.s.Name := '';
            g_boItemMoving := False;
            g_SndMgr.ItemClickSound(g_MovingItem.item.s);
          end else begin
            if g_ItemArr[idx].s.Name <> '' then begin

              if g_ItemArr[idx].s.NeedIdentify = 4 then begin
                g_ItemArr[idx].s.NeedIdentify := 0;
                DelStallItem(g_ItemArr[idx]);
              end else if g_ItemArr[idx].s.NeedIdentify = 5 then
                Exit;

              if (g_ItemArr[idx].s.Overlap > 0) and (g_ItemArr[idx].s.Name = g_MovingItem.item.s.Name) then begin

                frmMain.SendItemSumCount(g_ItemArr[idx].MakeIndex, g_MovingItem.item.MakeIndex, 0, g_ItemArr[idx].s.Name, g_MovingItem.item.s.Name);

                //if (mi > 0) and (mi < 100) then
                g_WaitingUseItem := g_MovingItem;
                //CancelItemMoving;
                //else begin
                g_MovingItem.item.s.Name := '';
                g_boItemMoving := False;
                //end;
              end else begin
                temp := g_ItemArr[idx];
                g_ItemArr[idx] := g_MovingItem.item;
                g_MovingItem.Index := idx;
                g_MovingItem.item := temp;
                g_SndMgr.ItemClickSound(g_MovingItem.item.s);
              end;
            end else begin
              g_ItemArr[idx] := g_MovingItem.item;
              g_MovingItem.item.s.Name := '';
              g_boItemMoving := False;
              g_SndMgr.ItemClickSound(g_MovingItem.item.s);
            end;
          end;
        end;
      end;
    end;
    ArrangeItembag;
  end else begin
    if (g_Myself = nil) or (g_Myself.m_HeroObject = nil) then Exit;
    if g_Myself.m_StallMgr.OnSale then Exit;
    if g_WaitingUseItem.item.s.Name <> '' then Exit;
    idx := ACol + ARow * DItemGrid.ColCount + 6;
    if idx in [6..MAXBAGITEM - 1] then begin
      if not g_boItemMoving then begin
        if g_ItemArr[idx].s.Name <> '' then begin
          if (idx = -97) or (idx = -98) then Exit;
          if (idx < 0) and (idx >= -(U_FASHION + 1)) then Exit;
          if (idx <= -20) and (idx > -39) then Exit;
          if idx < HERO_MIIDX_OFFSET then begin
            g_WaitingUseItem.Index := idx;
            g_WaitingUseItem.item := g_ItemArr[idx];
            g_WaitingUseItem.item.s.NeedIdentify := 0;
            frmMain.SendMasterItemToHeroBag(g_WaitingUseItem.item.MakeIndex, g_WaitingUseItem.item.s.Name);
            g_ItemArr[idx].s.Name := '';
            g_ItemArr[idx].s.NeedIdentify := 0;
            g_SndMgr.ItemClickSound(g_WaitingUseItem.item.s);
            ArrangeHeroItembag;
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DItemGridMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
begin
  g_showgamegoldinfo := False;
end;

procedure TFrmDlg.DItemGridDblClick(Sender: TObject);
var
  idx, n: Integer;
  keyvalue: TKeyBoardState;
  cu: TClientItem;
begin
  idx := DItemGrid.Col + DItemGrid.Row * DItemGrid.ColCount + 6;
  if idx in [6..MAXBAGITEM - 1] then begin
    if g_ItemArr[idx].s.Name <> '' then begin
      FillChar(keyvalue, SizeOf(TKeyBoardState), #0);
      GetKeyboardState(keyvalue);
      if g_ItemArr[idx].s.NeedIdentify = 4 then begin
        g_ItemArr[idx].s.NeedIdentify := 0;
        DelStallItem(g_ItemArr[idx]);
      end else if g_ItemArr[idx].s.NeedIdentify = 5 then
        Exit;
      if keyvalue[VK_CONTROL] = $80 then begin
        cu := g_ItemArr[idx];
        g_ItemArr[idx].s.Name := '';
        AddItemBag(cu);
      end else
        frmMain.EatItem(idx);
    end else if g_boItemMoving and (g_MovingItem.item.s.Name <> '') then begin
      frmMain.m_nEatRetIdx := idx;
      FillChar(keyvalue, SizeOf(TKeyBoardState), #0);
      GetKeyboardState(keyvalue);
      if keyvalue[VK_CONTROL] = $80 then begin
        cu := g_MovingItem.item;
        g_MovingItem.item.s.Name := '';
        g_boItemMoving := False;
        AddItemBag(cu);
      end else if (g_MovingItem.Index = idx) then
        frmMain.EatItem(-1);
    end;
  end;
end;

procedure TFrmDlg.DItemGridGridPaint(Sender: TObject; ACol, ARow: Integer; Rect: TRect; State: TGridDrawState; dsurface: TCustomCanvas);
var
  i, n, idx: Integer;
  d: TCustomLockableTexture;
  rc: TIntRect;
begin
  d := nil;
  if not DItemBag.Visible then Exit;
  idx := ACol + ARow * DItemGrid.ColCount + 6;
  if idx in [6..MAXBAGITEM - 1] then begin
    if g_ItemArr[idx].s.Name <> '' then begin

      if (g_ItemArr[idx].s.Overlap < 1) or ((g_ItemArr[idx].s.Overlap > 0) and (g_ItemArr[idx].Dura > 0)) then begin
        d := frmMain.GetWBagItemImg(g_ItemArr[idx].s.looks);
        if d <> nil then
          with DItemGrid do
            dsurface.Draw(SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
              SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
              d.ClientRect,
              d, True);
        if g_ItemArr[idx].s.Overlap > 0 then begin
          dsurface.BoldTextOut(
            DItemGrid.SurfaceX(Rect.Left + 33 - FontManager.Default.TextWidth(IntToStr(g_ItemArr[idx].Dura))),
            DItemGrid.SurfaceY(Rect.Top + 20),
            clSilver, clBlack, IntToStr(g_ItemArr[idx].Dura));
        end;
      end;

      if (g_ItemArr[idx].s.StdMode in [5,6,10,11,15..24, 26..30]) then begin
        if (g_ItemArr[idx].s.Shape = 190) or (g_ItemArr[idx].s.reserve[3] = 4) then begin
          if GetTickCount - g_ItemArrShine[idx].tick > 60 then begin
            g_ItemArrShine[idx].tick := GetTickCount;
            Inc(g_ItemArrShine[idx].idx);
            if g_ItemArrShine[idx].idx > 31 then
              g_ItemArrShine[idx].idx := 0;
          end;

          n := -1;
          d := nil;
          case g_ItemArr[idx].s.StdMode of
            30: n := 6;
            19, 20, 21: n := 2;
            15: n := 3;
            24, 25, 26: n := 0;
            22, 23: n := 1;
            27: n := 5;
            28: n := 4
          end;
          if n >= 0 then
            d := g_Wui.Images[100 + n * 40 + g_ItemArrShine[idx].idx];

          if d <> nil then
            with DItemGrid do
              dsurface.DrawBlend(
                SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                d, 1);
        end else if g_ItemArr[idx].s.reserve[3] = 1 then begin
          n := 0;
          if g_ItemArr[idx].s.StdMode in [15, 16] then
            n := 2;
          if GetTickCount - g_ItemArrShine[idx].tick > 100 then begin
            g_ItemArrShine[idx].tick := GetTickCount;
            Inc(g_ItemArrShine[idx].idx);
            if g_ItemArrShine[idx].idx > (8 + n) then
              g_ItemArrShine[idx].idx := 0;
          end;
          d := g_WMainImages.Images[(640 - n * 10) + g_ItemArrShine[idx].idx];
          if d <> nil then
            with DItemGrid do
              dsurface.DrawBlend(
                SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                d, 1);
        end else if g_ItemArr[idx].s.reserve[3] = 2 then begin
          if GetTickCount - g_ItemArrShine[idx].tick > 100 then begin
            g_ItemArrShine[idx].tick := GetTickCount;
            Inc(g_ItemArrShine[idx].idx);
            if g_ItemArrShine[idx].idx > 5 then
              g_ItemArrShine[idx].idx := 0;
          end;
          d := g_WMain2Images.Images[260 + g_ItemArrShine[idx].idx];
          if d <> nil then
            with DItemGrid do
              dsurface.DrawBlend(
                SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                d, 1);
        end else if g_ItemArr[idx].s.reserve[3] = 3 then begin
          if GetTickCount - g_ItemArrShine[idx].tick > 100 then begin
            g_ItemArrShine[idx].tick := GetTickCount;
            Inc(g_ItemArrShine[idx].idx);
            if g_ItemArrShine[idx].idx > 9 then
              g_ItemArrShine[idx].idx := 0;
          end;
          n := -1;
          d := nil;
          case g_ItemArr[idx].s.StdMode of
            30: n := 6;
            19, 20, 21: n := 2;
            15: n := 5;
            24, 25, 26: n := 1;
            22, 23: n := 0;
            27: n := 4;
            28: n := 3;
          end;
          if n >= 0 then
            d := g_StateEffect.Images[530 + n * 10 + g_ItemArrShine[idx].idx];
          //d := g_StateEffect.Images[530 + (g_ItemArr[idx].s.looks - 2410) * 10 + g_ItemArrShine[idx].idx];
          if d <> nil then
            with DItemGrid do
              dsurface.DrawBlend(
                SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                d, 1);
        end else if g_ItemArr[idx].s.reserve[3] = 5 then begin
          if GetTickCount - g_ItemArrShine[idx].tick > 100 then begin
            g_ItemArrShine[idx].tick := GetTickCount;
            Inc(g_ItemArrShine[idx].idx);
            if g_ItemArrShine[idx].idx > 9 then
              g_ItemArrShine[idx].idx := 0;
          end;
          d := g_WStateItemImages.Images[3910 + g_ItemArrShine[idx].idx];
          if d <> nil then
            with DItemGrid do
              dsurface.DrawBlend(
                SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                d, 1);
        end else if g_ItemArr[idx].s.reserve[3] in [6..10] then begin
          d := g_WMain3Images.Images[750 + (g_ItemArr[idx].s.reserve[3] - 6) * 2];
          if d <> nil then
            with DItemGrid do
              dsurface.DrawBlend(
                SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                d, 1);
        end else if g_ItemArr[idx].s.reserve[3] in [100..249] then begin //20200927背包特效1 主体
          if GetTickCount - g_ItemArrShine[idx].tick > 200 then begin
            g_ItemArrShine[idx].tick := GetTickCount;
            Inc(g_ItemArrShine[idx].idx);
            if g_ItemArrShine[idx].idx > 19 then
              g_ItemArrShine[idx].idx := 0;
          end;
          d := frmMain.GetWBagItemImg(20000 + (g_ItemArr[idx].s.reserve[3] +1 - 100) * 20-20 + g_ItemArrShine[idx].idx);
          if d = nil then begin
           g_ItemArrShine[idx].idx := 0;
            d := frmMain.GetWBagItemImg(20000 + (g_ItemArr[idx].s.reserve[3] +1 - 100) * 20-20 + g_ItemArrShine[idx].idx);
          end;
          if d <> nil then
            with DItemGrid do
              dsurface.DrawBlend(
                SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                d, 1);
        end;
      end;

      UpdateBagStallItem(g_WaitingStallItem.item, 0);
      with DItemGrid do begin
        rc.Left:=  SurfaceX(Rect.Left + (ColWidth - 36) div 2);
        rc.Top:=  SurfaceY(Rect.Top + (RowHeight - 28) div 2);
        rc.Right:=  rc.Left + 33;
        rc.Bottom:=  rc.Top + 30;
        if g_ItemArr[idx].s.NeedIdentify = 4 then begin
          dsurface.FillRectAlpha(rc,GetRGB(2),70);
        end else if g_ItemArr[idx].s.NeedIdentify = 5 then begin
          dsurface.FillRectAlpha(rc,clOlive,70);
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DGoldClick(Sender: TObject; X, Y: Integer);
begin
  if g_Myself = nil then Exit;
  if not g_boItemMoving then begin
    if g_Myself.m_nGold > 0 then begin
      g_SndMgr.PlaySound(s_money);
      g_boItemMoving := True;
      g_MovingItem.Index := -98;
      g_MovingItem.item.s.Name := g_sGoldName {'金币'};
    end;
  end else if (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) then begin
    g_boItemMoving := False;
    g_MovingItem.item.s.Name := '';
    if g_MovingItem.Index = -97 then
      DealZeroGold;
  end;
end;

function atlen(sours,str:string):Integer;
var
 s:string;
 i:Integer;
begin
  result:=0;
  i:=0;
  s:=sours;
  if str='' then Exit;
  while Pos(str,s)<>0 do
  begin
    Delete(s,pos(str,s),1);
    Inc(i);
  end;
  result:= i;
end;

procedure TFrmDlg.ShowMDlg(face: Integer; mname, msgstr: string);
var
  i, l: Integer;
  s: string;
begin
MDlgStr := msgstr;
  s:=MDlgStr;
  l:=atlen(s,'\'); //    这个函数就是判断\  有多少个
  if l < 15 then begin
    StandardNpcDlg:=True; //小于12个就是小框
    DMerchantDlg.SetImgIndex(g_WMainImages, 384)
  end else begin
    StandardNpcDlg:=False;  //大于12或等于12个就是大框。
    DMerchantDlg.SetImgIndex(g_WMainImages, 402)
  end;

  DMerchantDlg.Left := 0;
  DMerchantDlg.Top:=0;
  DMerchantDlg.Visible := True;

  DItemBag.Left := 420;
  DItemBag.Top := 60;
  for i := 0 to MDlgPoints.Count - 1 do
    Dispose(pTClickPoint(MDlgPoints[i]));
  MDlgPoints.Clear;
  RequireAddPoints := True;
  LastestClickTime := GetTickCount;
end;

procedure TFrmDlg.ShowMissionDlg(param: Integer);
var
  i: Integer;
begin
  DWMissions.tag := 0;
  case param of
    1: DBMS1Click(FrmDlg.DBMS1, 0, 0);
    2: DBMS1Click(FrmDlg.DBMS2, 0, 0);
    3: DBMS1Click(FrmDlg.DBMS3, 0, 0);
    4: DBMS1Click(FrmDlg.DBMS4, 0, 0);
  end;
  DWMissions.Visible := True;
end;

procedure TFrmDlg.ResetMenuDlg;
var
  i: Integer;
begin
  CloseDSellDlg;
  for i := 0 to g_MenuItemList.Count - 1 do
    Dispose(PTClientItem(g_MenuItemList[i]));
  g_MenuItemList.Clear;

  for i := 0 to MenuList.Count - 1 do
    Dispose(PTClientGoods(MenuList[i]));
  MenuList.Clear;

  menuindex := -1;
  MenuTopLine := 0;
  BoDetailMenu := False;
  BoStorageMenu := False;
  BoMakeDrugMenu := False;

  DSellDlg.Visible := False;
  DMenuDlg.Visible := False;
end;

procedure TFrmDlg.ResetDelCharMenuDlg;
var
  i: Integer;
begin
  for i := 0 to m_DelCharList.Count - 1 do
    Dispose(pTDelChar(m_DelCharList[i]));
  m_DelCharList.Clear;
end;

procedure TFrmDlg.ShowDelCharInfoDlg;
begin
  m_nDelCharTop := 0;
  m_nDelCharIndex := -1;
  m_nDelCharTopLine := 0;
  DBDelCharList.Visible := True;
end;

procedure TFrmDlg.ShowShopMenuDlg(mode: TMenuDlgMode);
begin
  menuindex := -1;
  DMerchantDlg.Left := 0;
  DMerchantDlg.Top := 0;
  DMerchantDlg.Visible := True;

  DSellDlg.Visible := False;

  DMenuDlg.Left := 0;
  DMenuDlg.Top := 176;
  DMenuDlg.Visible := True;
  MenuTop := 0;

  DItemBag.Left := 420;
  DItemBag.Top := 60 + Integer(mode = dmGetSave) * 110;

  DItemBag.Visible := True;

  LastestClickTime := GetTickCount;
end;

procedure TFrmDlg.ShowShopSellDlg;
begin
  DSellDlg.Left := 260;
  DSellDlg.Top := 176;
  DSellDlg.Visible := True;

  DMenuDlg.Visible := False;

  DItemBag.Left := 420;
  DItemBag.Top := 60;
  DItemBag.Visible := True;

  LastestClickTime := GetTickCount;
  g_sSellPriceStr := '';
end;

procedure TFrmDlg.CloseMDlg;
var
  i: Integer;
begin
  MDlgStr := '';
  DMerchantDlg.Visible := False;
  for i := 0 to MDlgPoints.Count - 1 do
    Dispose(pTClickPoint(MDlgPoints[i]));
  MDlgPoints.Clear;
  DItemBag.Left := 0;
  DItemBag.Top := 60;
  DMenuDlg.Visible := False;
  CloseDSellDlg;
end;

procedure TFrmDlg.CloseMissionDlg;
var
  i: Integer;
begin
  DWMissions.Visible := False;
  m_MissionIdxTitle := 0;
  m_MissionIdxDesc := 0;
  for i := 0 to m_MissionPoints.Count - 1 do
    Dispose(pTClickPoint(m_MissionPoints[i]));
  m_MissionPoints.Clear;
end;

procedure TFrmDlg.CloseDSellDlg;
begin
  DSellDlg.Visible := False;
  if g_SellDlgItem.s.Name <> '' then
    AddItemBag(g_SellDlgItem);
  g_SellDlgItem.s.Name := '';
end;

procedure TFrmDlg.CloseItemMarketDlg;
begin
  DItemMarketCloseClick(DItemMarketClose, 0, 0);
end;

procedure TFrmDlg.DMerchantDlgDirectPaint(Sender: TObject; //20201005临时解决NPC排版问题
  dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
  Str, data,FData, fdata2: string;
  cmdstr, cmdmsg, cmdparam: string;
  i, j, k, lx, ly, sX, L: Integer;
  pcp: pTClickPoint;
  cl: TColor;
  scl: string;
  DestRect: TRect;
  ATexture: TCustomLockableTexture;
begin
  with Sender as TDWindow do
  begin
    Left := 0;
    Top := 0;
    if StandardNpcDlg then
      d := WLib.Images[FaceIndex]
    else
      d := g_WMainImages.Images[402];

    if d <> nil then
    begin
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    end;

    lx := 30;
    ly := 20;
    Str := MDlgStr;

    L := 0;
    while True do
    begin
      if Str = '' then
        Break;
      Str := GetValidStr3(Str, data, ['\']);
      if data <> '' then
      begin
        sX := 0;
        // fdata := '';
        while (data <> '') and (Pos('<', data) > 0) and (Pos('>', data) > 0) do
        begin
          FData := '';
          if data[1] <> '<' then
            data := '<' + GetValidStr3(data, FData, ['<']);
          data := ArrestStringEx(data, '<', '>', cmdstr);

          fdata2 := '';

          if cmdstr <> '' then
          begin
            j := Pos('COLOR=', UpperCase(cmdstr));
            if j > 0 then
            begin
              fdata2 := GetValidStr3(cmdstr, scl, [' ', #9, ',']);
              scl := Copy(scl, 7, Length(scl) - 6);
              cl := clWhite;
              if scl <> '' then
              begin
                if scl[1] = '#' then
                begin
                  cl := StrToInt(Copy(scl, 2, Length(scl) - 1));
                end
                else
                begin
                  if CompareText('clLtGray', scl) = 0 then
                    cl := clLtGray
                  else if CompareText('clDkGray', scl) = 0 then
                    cl := clDkGray
                  else
                    cl := StringToColor(scl);
                end
              end;
              cmdstr := '';
            end
            else
              cmdparam := GetValidStr3(cmdstr, cmdstr, ['/']);
          end
          else
          begin
            DMenuDlg.Visible := False;
            DSellDlg.Visible := False;
          end;

          if FData <> '' then
          begin
             var slx:integer;
            slx:= pos(' ',FData);
            if slx > 1 then
            begin
              for var xxx2 := 0 to slx div 2 + 1 do
              begin
                FData := FData.Replace('  ', ' ', [rfIgnoreCase]);
              end;
            end;
            dsurface.BoldTextOut(SurfaceX(Left + lx + sX), SurfaceY(Top + ly),
              clWhite, clBlack, FData);
            sX := sX + FontManager.Default.TextWidth(FData);
          end;
          if fdata2 <> '' then
          begin
            dsurface.BoldTextOut(SurfaceX(Left + lx + sX), SurfaceY(Top + ly),
              cl, clBlack, fdata2);
            sX := sX + FontManager.Default.TextWidth(fdata2);
          end;

          if cmdstr <> '' then
          begin
            if RequireAddPoints then
            begin
              New(pcp);
              pcp.rc := Rect(lx + sX, ly, lx + sX + FontManager.
                Default.TextWidth(cmdstr), ly + 14);
              pcp.rstr := cmdparam;
              MDlgPoints.Add(pcp);
            end;

            ATexture := FontManager.GetFont('宋体', 9, [fsUnderline])
              .TextOut(cmdstr);
            if SelectMenuStr = cmdparam then
              dsurface.DrawBoldText(SurfaceX(Left + lx + sX),
                SurfaceY(Top + ly), ATexture, clRed, clBlack)
            else
              dsurface.DrawBoldText(SurfaceX(Left + lx + sX),
                SurfaceY(Top + ly), ATexture, clYellow, clBlack);

            sX := sX + FontManager.Default.TextWidth(cmdstr);
            // dsurface.Canvas.Font.Style := dsurface.Canvas.Font.Style - [fsUnderline];
          end;
        end;
        if data <> '' then
          dsurface.BoldTextOut(SurfaceX(Left + lx + sX), SurfaceY(Top + ly),
            clWhite, clBlack, data);
      end;
      ly := ly + 16;
    end;

    RequireAddPoints := False;
  end;

end;

procedure TFrmDlg.DMerchantDlgInRealArea(Sender: TObject; X, Y: Integer;
  var IsRealArea: Boolean);
var
  d: TCustomLockableTexture;
begin
  if StandardNpcDlg then d := g_WMainImages.Images[384]
  else d := g_WMainImages.Images[402];
  if d <> nil then begin
    if d.Pixels(X, Y) > 0 then IsRealArea := TRUE
    else IsRealArea := FALSE;
  end;
end;

procedure TFrmDlg.DMerchantDlgCloseClick(Sender: TObject; X, Y: Integer);
begin
  CloseMDlg;
end;

procedure TFrmDlg.DMenuDlgDirectPaint(Sender: TObject; dsurface: TCustomCanvas);

  function sX(X: Integer): Integer;
  begin
    Result := DMenuDlg.SurfaceX(DMenuDlg.Left + X);
  end;

  function sY(Y: Integer): Integer;
  begin
    Result := DMenuDlg.SurfaceY(DMenuDlg.Top + Y);
  end;
var
  i, lh, k, M, MenuLine, FontColor: Integer;
  d: TCustomLockableTexture;
  pg: PTClientGoods;
  Str: string;
begin
  with dsurface do begin
    with DMenuDlg do begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    end;
    FontColor := clWhite;
    if not BoStorageMenu then begin
      TextOut(sX(019), sY(11), '物品列表');
      TextOut(sX(156), sY(11), '费用');
      TextOut(sX(245), sY(11), '持久');
      lh := LISTLINEHEIGHT;
      MenuLine := _MIN(MAXMENU, MenuList.Count - MenuTop);

      for i := MenuTop to MenuTop + MenuLine - 1 do begin
        M := i - MenuTop;
        if i = menuindex then begin
          FontColor := clRed;
          //TextOutA(sX(12), sY(32 + M * lh), Char(7));
        end else
          FontColor := clWhite;
        pg := PTClientGoods(MenuList[i]);
        TextOut(sX(19), sY(32 + M * lh), pg.Name, FontColor);
        //if (pg.SubMenu = 2) then TextOutA(sX(137), sY(32 + M * lh), '√');
        TextOut(sX(156), sY(32 + M * lh), IntToStr(pg.Price) + g_sGoldName, FontColor);
        //Str := '';
        if pg.Grade = -1 then
          TextOut(sX(245), sY(32 + M * lh), '-->>')
        else
          TextOut(sX(245), sY(32 + M * lh), IntToStr(pg.Grade));
      end;
    end else begin
      TextOut(sX(19), sY(11), '物品列表');
      TextOut(sX(156), sY(11), '持久');
      lh := LISTLINEHEIGHT;
      MenuLine := _MIN(MAXMENU, MenuList.Count - MenuTop);
      for i := MenuTop to MenuTop + MenuLine - 1 do begin
        M := i - MenuTop;
        if i = menuindex then begin
          FontColor := clRed;
//          TextOut(sX(12), sY(32 + M * lh), Char(7), FontColor);
        end else
          FontColor := clWhite;
        pg := PTClientGoods(MenuList[i]);
        TextOut(sX(19), sY(32 + M * lh), pg.Name, FontColor);
        //if (pg.SubMenu = 2) then TextOutA(sX(137), sY(32 + M * lh), '√');
        TextOut(sX(156), sY(32 + M * lh), IntToStr(pg.Stock) + '/' + IntToStr(pg.Grade), FontColor);
      end;
    end;
  end;
end;

procedure TFrmDlg.DMenuDlgClick(Sender: TObject; X, Y: Integer);
var
  lx, ly, idx, itemidx: Integer;
  iname, d1, d2, d3, d4: string;
  useable: Boolean;
  ClientItem: TClientItem;
begin
  DScreen.ClearHint;
  lx := DMenuDlg.LocalX(X) - DMenuDlg.Left;
  ly := DMenuDlg.LocalY(Y) - DMenuDlg.Top;
  if (lx >= 14) and (lx <= 279) and (ly >= 32) and (ly <= 10 * LISTLINEHEIGHT + 32) then begin
    idx := (ly - 32) div LISTLINEHEIGHT + MenuTop;
    if idx < MenuList.Count then begin
      g_SndMgr.PlaySound(s_glass_button_click);
      menuindex := idx;
    end;
  end;

  if BoStorageMenu then begin
    if (menuindex >= 0) and (menuindex < g_SaveItemList.Count) then begin
      with Sender as TDButton do begin
        ClientItem := PTClientItem(g_SaveItemList[menuindex])^;
        itemidx := GetItemWhere(ClientItem);
        if itemidx in [0..U_FASHION] then begin
          g_ShowSuite := 1;
          g_SuiteIdx := itemidx;
        end;
        GetMouseItemInfoHint(ClientItem, iname);
        if iname <> '' then begin
          lx := 243;
          ly := 27 + (menuindex - MenuTop) * LISTLINEHEIGHT;
          DScreen.ShowHint(DMenuDlg.SurfaceX(Left + lx), DMenuDlg.SurfaceY(Top + ly), iname, clWhite,
            False,
            False,
            True,
            True);
        end;
      end;
    end;

  end else begin
    if (menuindex >= 0) and (menuindex < g_MenuItemList.Count) and (PTClientGoods(MenuList[menuindex]).SubMenu in [0, 2]) then begin
      with Sender as TDButton do begin
        ClientItem := PTClientItem(g_MenuItemList[menuindex])^;
        BoNoDisplayMaxDura := True;
        itemidx := GetItemWhere(ClientItem);
        if itemidx in [0..U_FASHION] then begin
          g_ShowSuite := 1;
          g_SuiteIdx := itemidx;
        end;
        GetMouseItemInfoHint(ClientItem, iname);
        BoNoDisplayMaxDura := False;
        if iname <> '' then begin
          lx := 244 + 51;
          ly := 28 + (menuindex - MenuTop) * LISTLINEHEIGHT;
          DScreen.ShowHint(DMenuDlg.SurfaceX(Left + lx),
            DMenuDlg.SurfaceY(Top + ly),
            iname,
            clWhite,
            False,
            False,
            True,
            True);
        end;
      end;
      {g_MouseItem := PTClientItem(g_MenuItemList[menuindex])^;
      BoNoDisplayMaxDura := True;
      GetMouseItemInfo(g_MouseItem, iname, d1, d2, d3, d4, useable);
      BoNoDisplayMaxDura := False;
      if iname <> '' then begin
        lx := 240;
        ly := 32 + (menuindex - MenuTop) * LISTLINEHEIGHT;

        with Sender as TDButton do begin
          if d4 <> '' then
            iname := iname + d1 + '\' + d2 + '\' + d3 + '\' + d4
          else
            iname := iname + d1 + '\' + d2 + '\' + d3;
          DScreen.ShowHint(DMenuDlg.SurfaceX(Left + lx), DMenuDlg.SurfaceY(Top + ly), iname, clYellow, False);
        end

        //with Sender as TDButton do DScreen.ShowHint(DMenuDlg.SurfaceX(Left + lx), DMenuDlg.SurfaceY(Top + ly), iname + d1 + '\' + d2 + '\' + d3, clYellow, False);
      end;
      g_MouseItem.s.Name := '';;}
    end;
  end;
end;

procedure TFrmDlg.DMenuDlgMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
begin
  with DMenuDlg do
    if (X < SurfaceX(Left + 10)) or (X > SurfaceX(Left + Width - 20)) or (Y < SurfaceY(Top + 30)) or (Y > SurfaceY(Top + Height - 50)) then
      DScreen.ClearHint;
end;

procedure TFrmDlg.DMBChatDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
  rc: TRect;
begin
  with Sender as TDMoveButton do begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
  end;
end;

procedure TFrmDlg.DMBChatMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  n: Integer;
begin
  with DScreen do begin
    if ChatStrs.Count >= 2 then begin
      if DMBChat.Position < ChatStrs.Count then
        ChatBoardTop := DMBChat.Position;
    end;
  end;
end;

procedure TFrmDlg.DMBHitSpeedDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
  rc: TIntRect;
begin
  if not g_boSpeedRate or not g_boSpeedRateShow then Exit;
  with Sender as TDMoveButton do begin
    d := g_WMain2Images.Images[302];
    if d <> nil then
      dsurface.Draw(SurfaceX(tag), SurfaceY(Top), d.ClientRect, d, True);

    d := g_WMain2Images.Images[303];
    if d <> nil then begin
      rc := d.ClientRect;
      if Sender = DMBHitSpeed then begin
        rc.Right := Round((rc.Right - rc.Left) / Max * g_HitSpeedRate);
      end else if Sender = DMBMagSpeed then begin
        rc.Right := Round((rc.Right - rc.Left) / Max * g_MagSpeedRate);
      end else if Sender = DMBMoveSpeed then begin
        rc.Right := Round((rc.Right - rc.Left) / Max * g_MoveSpeedRate);
      end;
      dsurface.Draw(SurfaceX(tag), SurfaceY(Top), rc, d, True);
    end;

    d := g_WMain2Images.Images[297];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
  end;
end;

procedure TFrmDlg.DMBHitSpeedMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  idx: Integer;
begin
  if g_boSpeedRate and g_boSpeedRateShow then begin
    idx := (Sender as TDMoveButton).Position;
    if Sender = DMBHitSpeed then begin
      DxEditHitSpeed.Caption := IntToStr(idx);
      g_HitSpeedRate := idx;
    end else if Sender = DMBMagSpeed then begin
      g_MagSpeedRate := idx;
      DxEditMagSpeed.Caption := IntToStr(idx);
    end else if Sender = DMBMoveSpeed then begin
      g_MoveSpeedRate := idx;
      DxEditMoveSpeed.Caption := IntToStr(idx);
    end;

  end;
end;

procedure TFrmDlg.DMBVolumeDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
  rc: TIntRect;
begin
  with Sender as TDMoveButton do begin
    d := g_WMain2Images.Images[302];
    if d <> nil then
      dsurface.Draw(SurfaceX(tag), SurfaceY(Top), d.ClientRect, d, True);

    d := g_WMain2Images.Images[303];
    if d <> nil then begin
      rc := d.ClientRect;
      rc.Right := Round((rc.Right - rc.Left) / Max * g_lWavMaxVol);
      dsurface.Draw(SurfaceX(tag), SurfaceY(Top), rc, d, True);
    end;

    d := g_WMain2Images.Images[297];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
  end;
end;

procedure TFrmDlg.DMBVolumeMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  idx: Integer;
begin
  idx := (Sender as TDMoveButton).Position;
  g_lWavMaxVol := idx; //-(idx * 7);
  g_SndMgr.Volume := Round(g_lWavMaxVol / 68 * 100);
  g_SndMgr.SetVolume(g_SndMgr.Volume);
end;

procedure TFrmDlg.DMenuBuyClick(Sender: TObject; X, Y: Integer);
var
  pg: PTClientGoods;
  MsgResult, Count: Integer;
  valstr: string;
  ci: TClientItem;
begin
  if g_Myself.m_StallMgr.OnSale then Exit;
  if GetTickCount < LastestClickTime then Exit;
  Count := 0;
  if (menuindex >= 0) and (menuindex < MenuList.Count) then begin
    pg := PTClientGoods(MenuList[menuindex]);
    LastestClickTime := GetTickCount + NPC_CILCK_INVTIME;
    if (pg.SubMenu > 0) and (pg.SubMenu <> 2) then begin
      frmMain.SendGetDetailItem(g_nCurMerchant, 0, pg.Name);
      MenuTopLine := 0;
      CurDetailItem := pg.Name;
    end else begin
      if BoStorageMenu then begin
        try
          ci := PTClientItem(g_SaveItemList[menuindex])^;
        except
        end;
        if ci.s.Overlap > 0 then begin
          Total := ci.Dura;
          if Total = 1 then begin
            DlgEditText := '1';
            MsgResult := mrOk;
          end else begin
            MsgResult := DMessageDlg(Format('你想取回多少 %s ？', [ci.s.Name]),
              [mbOk, mbCancel, mbAbort], IntToStr(ci.Dura));
          end;
          GetValidStrVal(DlgEditText, valstr, [' ']);
          Count := Str_ToInt(valstr, 0);

          if Count > ci.Dura then Count := ci.Dura;
          if (MsgResult = mrCancel) or (Count <= 0) then begin
            Count := 0;
            Exit;
          end;
          frmMain.SendTakeBackStorageItem(g_nCurMerchant, pg.Price {MakeIndex}, pg.Name, Word(Count));
        end else
          frmMain.SendTakeBackStorageItem(g_nCurMerchant, pg.Price {MakeIndex}, pg.Name, Word(Count));
        Exit;
      end;
      if BoMakeDrugMenu then begin
        frmMain.SendMakeDrugItem(g_nCurMerchant, pg.Name);
        Exit;
      end;
      if pg.SubMenu = 2 then begin
        Total := 100;
        MsgResult := DMessageDlg('你想购买多少' + pg.Name + '？ (0~' + IntToStr(MAX_OVERLAPITEM) + '之间)', [mbOk, mbCancel, mbAbort]);
        GetValidStrVal(DlgEditText, valstr, [' ']);
        Count := Str_ToInt(valstr, 0);
        if (MsgResult = mrCancel) or (Count <= 0) or (Count > MAX_OVERLAPITEM) then begin
          Exit;
        end;
      end;
      frmMain.SendBuyItem(g_nCurMerchant, pg.Stock, pg.Name, Word(Count))
    end;
  end;
end;

procedure TFrmDlg.DMenuPrevClick(Sender: TObject; X, Y: Integer);
begin
  if g_Myself.m_StallMgr.OnSale then Exit;
  if not BoDetailMenu then begin
    if MenuTop > 0 then Dec(MenuTop, MAXMENU - 1);
    if MenuTop < 0 then MenuTop := 0;
  end else begin
    if MenuTopLine > 0 then begin
      MenuTopLine := _MAX(0, MenuTopLine - 10);
      frmMain.SendGetDetailItem(g_nCurMerchant, MenuTopLine, CurDetailItem);
    end;
  end;
end;

procedure TFrmDlg.DMenuNextClick(Sender: TObject; X, Y: Integer);
begin
  if g_Myself.m_StallMgr.OnSale then Exit;
  if not BoDetailMenu then begin
    if MenuTop + MAXMENU < MenuList.Count then Inc(MenuTop, MAXMENU - 1);
  end else begin
    MenuTopLine := MenuTopLine + 10;
    frmMain.SendGetDetailItem(g_nCurMerchant, MenuTopLine, CurDetailItem);
  end;
end;

procedure TFrmDlg.SoldOutGoods(itemserverindex: Integer);
var
  i: Integer;
  pg: PTClientGoods;
begin
  for i := 0 to MenuList.Count - 1 do begin
    pg := PTClientGoods(MenuList[i]);
    if (pg.Grade >= 0) and (pg.Stock = itemserverindex) then begin
      Dispose(pg);
      MenuList.Delete(i);
      if i < g_MenuItemList.Count then g_MenuItemList.Delete(i);
      if menuindex > MenuList.Count - 1 then menuindex := MenuList.Count - 1;
      Break;
    end;
  end;
end;

procedure TFrmDlg.DelStorageItem(itemserverindex: Integer; remain: Word);
var
  i: Integer;
  pg: PTClientGoods;
begin
  for i := 0 to MenuList.Count - 1 do begin
    pg := PTClientGoods(MenuList[i]);
    if (pg.Price = itemserverindex) then begin
      if (remain > 0) and (PTClientItem(g_SaveItemList[i])^.s.Overlap > 0) then begin
        PTClientItem(g_SaveItemList[i])^.Dura := remain;
        Exit;
      end;
      Dispose(pg);
      MenuList.Delete(i);
      if i < g_SaveItemList.Count then g_SaveItemList.Delete(i);
      if menuindex > MenuList.Count - 1 then menuindex := MenuList.Count - 1;
      Break;
    end;
  end;
end;

procedure TFrmDlg.DMenuCloseClick(Sender: TObject; X, Y: Integer);
begin
  DMenuDlg.Visible := False;
end;

procedure TFrmDlg.DMerchantDlgClick(Sender: TObject; X, Y: Integer);
var
  i, L, T: Integer;
  p: pTClickPoint;
begin
  if GetTickCount < LastestClickTime then Exit;
  L := DMerchantDlg.Left;
  T := DMerchantDlg.Top;
  with DMerchantDlg do
    for i := 0 to MDlgPoints.Count - 1 do begin
      p := pTClickPoint(MDlgPoints[i]);
      if (X >= SurfaceX(L + p.rc.Left)) and (X <= SurfaceX(L + p.rc.Right)) and
        (Y >= SurfaceY(T + p.rc.Top)) and (Y <= SurfaceY(T + p.rc.Bottom)) then begin
        g_SndMgr.PlaySound(s_glass_button_click);
        frmMain.SendMerchantDlgSelect(g_nCurMerchant, p.rstr);
        LastestClickTime := GetTickCount + NPC_CILCK_INVTIME;
        Break;
      end;
    end;
end;

procedure TFrmDlg.DMerchantDlgMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
  i, L, T: Integer;
  p: pTClickPoint;
begin
  if GetTickCount < LastestClickTime then Exit;
  SelectMenuStr := '';
  L := DMerchantDlg.Left;
  T := DMerchantDlg.Top;
  with DMerchantDlg do
    for i := 0 to MDlgPoints.Count - 1 do begin
      p := pTClickPoint(MDlgPoints[i]);
      if (X >= SurfaceX(L + p.rc.Left)) and (X <= SurfaceX(L + p.rc.Right)) and
        (Y >= SurfaceY(T + p.rc.Top)) and (Y <= SurfaceY(T + p.rc.Bottom)) then begin
        SelectMenuStr := p.rstr;
        Break;
      end;
    end;
end;

procedure TFrmDlg.DMerchantDlgMouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  SelectMenuStr := '';
end;

procedure TFrmDlg.DSellDlgDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
  actionname: string;
begin
  with DSellDlg do begin
    d := DMenuDlg.WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);

    with dsurface do begin
      actionname := '';
      case SpotDlgMode of
        dmSell: actionname := '出售: ';
        dmRepair: actionname := '修理: ';
        dmStorage: actionname := '   保管物品';
        dmMaketSell: actionname := '   寄售物品';
        dmItemDlg: begin
            actionname := FrmDlg.SpotDlgStr;
            g_sSellPriceStr := '';
          end;
        dmBindItem: actionname := '   绑定装备';
        dmUnBindItem: actionname := '   解除绑定装备';
        dmExchangeBook: if g_sSellPriceStr = '' then actionname := '请放上装备';
      end;
      TextOut(SurfaceX(Left + 8), SurfaceY(Top + 6), actionname + g_sSellPriceStr, clWhite);
    end;
  end;
end;

procedure TFrmDlg.DSellDlgCloseClick(Sender: TObject; X, Y: Integer);
begin
  CloseDSellDlg;
end;

procedure TFrmDlg.DSellDlgSpotClick(Sender: TObject; X, Y: Integer);
var
  temp: TClientItem;
  MsgResult, Count: Integer;
  valstr: string;
begin
  g_sSellPriceStr := '';
  if not g_boItemMoving then begin
    if g_SellDlgItem.s.Name <> '' then begin
      g_SndMgr.ItemClickSound(g_SellDlgItem.s);
      g_boItemMoving := True;
      g_MovingItem.Index := -99;
      g_MovingItem.item := g_SellDlgItem;
      g_SellDlgItem.s.Name := '';
    end;
  end else begin
    if (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) then Exit;
    if ((g_MovingItem.Index >= 0) and (g_MovingItem.Index < HERO_MIIDX_OFFSET)) or (g_MovingItem.Index = -99) then begin
      g_SndMgr.ItemClickSound(g_MovingItem.item.s);
      if g_SellDlgItem.s.Name <> '' then begin
        temp := g_SellDlgItem;
        g_SellDlgItem := g_MovingItem.item;
        g_MovingItem.Index := -99;
        g_MovingItem.item := temp
      end else if g_MovingItem.item.s.Overlap = 0 then begin
        g_SellDlgItem := g_MovingItem.item;
        g_MovingItem.item.s.Name := '';
        g_boItemMoving := False;
      end else if g_MovingItem.item.s.Overlap > 0 then begin
        g_SellDlgItem := g_MovingItem.item;
        g_boItemMoving := False;
        Total := g_MovingItem.item.Dura;
        if Total = 1 then begin
          DlgEditText := '1';
          MsgResult := mrOk;
        end else begin

          MsgResult := DMessageDlg(Format('你想放上多少 %s ？', [g_MovingItem.item.s.Name]), [mbOk, mbCancel, mbAbort], IntToStr(g_MovingItem.item.Dura));
        end;
        g_boItemMoving := True;
        GetValidStrVal(DlgEditText, valstr, [' ']);
        Count := Str_ToInt(valstr, 0);
        if Count <= 0 then begin
          Count := 0;
          AddItemBag(g_SellDlgItem);
          g_SellDlgItem.s.Name := '';
          g_SellDlgItem.Dura := 0;
          g_MovingItem.item.s.Name := '';
          CancelItemMoving;
          g_boItemMoving := False;
          Exit;
        end;
        if Count >= g_SellDlgItem.Dura then begin
          Count := g_SellDlgItem.Dura;
          g_MovingItem.item.Dura := 0;
          g_boItemMoving := False;
        end;
        if MsgResult = mrOk then begin
          g_SellDlgItem.Dura := Word(Count);
          if g_MovingItem.item.Dura > 0 then begin
            g_MovingItem.item.Dura := g_MovingItem.item.Dura - Word(Count);
          end;
          if g_MovingItem.item.Dura <= 0 then begin
            g_MovingItem.item.Dura := 0;
            g_MovingItem.item.s.Name := '';
            g_boItemMoving := False;
          end;
          CancelItemMoving;
        end;
        if MsgResult = mrCancel then begin
          AddItemBag(g_SellDlgItem);
          g_SellDlgItem.s.Name := '';
          g_SellDlgItem.Dura := 0;
          g_MovingItem.item.s.Name := '';
          CancelItemMoving;
          g_boItemMoving := False;
          Exit;
        end;
      end;
      g_boQueryPrice := True;
      g_dwQueryPriceTime := GetTickCount;
    end;
  end;

end;

procedure TFrmDlg.DSellDlgSpotDirectPaint(Sender: TObject;
  dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
begin
  if g_SellDlgItem.s.Name <> '' then begin
    //d := g_WBagItemImages.Images[g_SellDlgItem.s.looks];
    d := frmMain.GetWBagItemImg(g_SellDlgItem.s.looks);
    if d <> nil then begin
      with DSellDlgSpot do
        dsurface.Draw(SurfaceX(Left + (Width - d.Width) div 2),
          SurfaceY(Top + (Height - d.Height) div 2),
          d.ClientRect,
          d, True);
      if g_SellDlgItem.s.Overlap > 0 then begin
        with DSellDlgSpot do
          dsurface.BoldTextOut(
            SurfaceX(Left + (Width - d.Width) div 2) + 21,
            SurfaceY(Top + (Height - d.Height) div 2) + 15,
            clSilver, clBlack, IntToStr(g_SellDlgItem.Dura));
      end;
    end;
  end;
end;

procedure TFrmDlg.DSellDlgSpotMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  itemidx: Integer;
  shint: string;
  b1, b2: Boolean;
begin
  if g_Myself = nil then Exit;
  DScreen.ClearHint;
  if g_SellDlgItem.s.Name <> '' then begin
    g_MouseItem := g_SellDlgItem;
    itemidx := GetItemWhere(g_MouseItem);
    if itemidx in [0..U_FASHION] then begin
      g_ShowSuite := 1;
      g_SuiteIdx := itemidx;
    end;
    GetMouseItemInfoHint(g_MouseItem, shint);
    if shint <> '' then begin
      with Sender as TDButton do
        DScreen.ShowHint(
          SurfaceX(Left - 30),
          SurfaceY(Top - 66),
          shint,
          clWhite, False, True, True, True);
    end;
    g_MouseItem.s.Name := '';
  end;
end;

procedure TFrmDlg.DSeMag1DirectPaint(Sender: TObject;
  dsurface: TCustomCanvas);
var
  idx, icon: Integer;
  d: TCustomLockableTexture;
  pm: PTClientMagic;
begin
  with Sender as TDButton do begin
    if (g_Myself = nil) then Exit;
{$IF SERIESSKILL}
    if g_Myself.n_boState and (m_nIPStatePage = 3) then begin
      {if tag = 3 then begin
        d := g_WMainImages.Images[912];
        if d <> nil then
          dsurface.Draw(SurfaceX(Left - 2), SurfaceY(Top - 4), d.ClientRect, d, True);
      end else begin}
      case g_TempSeriesSkillArr[tag] of
        0: begin //空
            if g_MagicList2.Count > 0 then begin
              if tag = 3 then begin
                d := g_Wui.Images[1297];
                if d = nil then d := g_WMainImages.Images[903 + tag * 2 + Integer(Downed)];
              end else
                d := g_WMainImages.Images[903 + tag * 2 + Integer(Downed)]
            end else begin
              if tag = 3 then begin
                d := g_Wui.Images[1297];
                if d = nil then d := g_WMainImages.Images[903 + tag * 2 + Integer(Downed)];
              end else
                d := g_WMainImages.Images[913 + tag];
            end;
            if d <> nil then
              dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
          end;
        1: begin //随机
            d := g_WMainImages.Images[909 + Integer(Downed)];
            if d <> nil then
              dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
          end;
      else begin
          icon := GetSeriesSkillIcon(g_TempSeriesSkillArr[tag]);
          icon := icon + Integer(Downed);
          if icon > 0 then begin
            d := g_WMainImages.Images[icon];
            if d <> nil then
              dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
          end;
        end;
      end;
      //end;
    end;
{$IFEND SERIESSKILL}
  end;
end;

procedure TFrmDlg.DSeMag1MouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
var
  b: Boolean;
  i, ii: Integer;
  pm: PTClientMagic;
begin
{$IF SERIESSKILL}
  if g_MagicList2.Count = 0 then Exit;
  with Sender as TDButton do begin
    DListBoxSSkill.tag := -1;
    DListBoxSSkill.Left := Left - 2;
    DListBoxSSkill.Top := Top + Height + 1;
    DListBoxSSkill.Visible := not DListBoxSSkill.Visible;
    if DListBoxSSkill.Visible then begin
      DListBoxSSkill.tag := tag;
      g_SeriesSkillSelList.Clear;
      for i := 0 to g_MagicList2.Count - 1 do begin
        pm := PTClientMagic(g_MagicList2[i]);
        b := False;
        for ii := 0 to High(TSeriesSkillArr) do
          if pm.Def.wMagicId = g_TempSeriesSkillArr[ii] then begin
            b := True;
            Break;
          end;
        if not b then g_SeriesSkillSelList.AddObject(pm.Def.sMagicName, TObject(pm.Def.wMagicId));
      end;
      g_SeriesSkillSelList.AddObject('空', TObject(Integer(0)));
      if g_MagicList2.Count > 1 then g_SeriesSkillSelList.AddObject('随机', TObject(Integer(1)));
    end;
  end;
{$IFEND SERIESSKILL}
end;

procedure TFrmDlg.DSellDlgOkClick(Sender: TObject; X, Y: Integer);
var
  dropgold: Integer;
  valstr: string;
  MsgResult: Integer;
begin
  if (g_SellDlgItem.s.Name = '') and (g_SellDlgItemSellWait.item.s.Name = '') then Exit;
  if GetTickCount < LastestClickTime then Exit;
  case SpotDlgMode of
    dmExchangeBook: frmMain.SendExchgBook(g_nCurMerchant, g_SellDlgItem.MakeIndex, g_SellDlgItem.s.Name, g_SellDlgItem.Dura);

    dmSell: frmMain.SendSellItem(g_nCurMerchant, g_SellDlgItem.MakeIndex, g_SellDlgItem.s.Name, g_SellDlgItem.Dura);
    dmRepair: frmMain.SendRepairItem(g_nCurMerchant, g_SellDlgItem.MakeIndex, g_SellDlgItem.s.Name);
    dmStorage: frmMain.SendStorageItem(g_nCurMerchant, g_SellDlgItem.MakeIndex, g_SellDlgItem.s.Name, g_SellDlgItem.Dura);
    dmBindItem: frmMain.SendBindItem(g_nCurMerchant, g_SellDlgItem.MakeIndex, g_SellDlgItem.s.Name, 0);
    dmUnBindItem: frmMain.SendBindItem(g_nCurMerchant, g_SellDlgItem.MakeIndex, g_SellDlgItem.s.Name, 1);
    dmItemDlg: begin
        frmMain.SendSelectItem(g_nCurMerchant, g_SellDlgItem.MakeIndex, g_SellDlgItem.s.Name);
        //g_SellDlgItemSellWait := g_SellDlgItem;
        //g_SellDlgItem.S.Name := '';
        LastestClickTime := GetTickCount + NPC_CILCK_INVTIME;
        Exit;
      end;
    dmMaketSell: begin
        DMessageDlg('确认以多少金币寄售物品?', [mbOk, mbAbort]);
        GetValidStrVal(DlgEditText, valstr, [' ']);
        try
          dropgold := Str_ToInt(valstr, 0);
        except
          DMessageDlg('价格有错.', [mbOk]);
          Exit;
        end;
        if (dropgold > 0) and (dropgold <= MAX_MARKETPRICE) then begin
          MsgResult := DMessageDlg(g_SellDlgItem.s.Name + ' 以 ' + GetGoldStr(dropgold) + ' 金币开始寄售, 确认吗?', [mbOk, mbCancel]);
          if MsgResult = mrOk then
            frmMain.SendMaketSellItem(g_nCurMerchant, g_SellDlgItem.MakeIndex, valstr, g_SellDlgItem.Dura)
          else if MsgResult = mrCancel then
            Exit;
        end else begin
          DMessageDlg('[失败]: 寄售定义价格有误.最大寄售价格为 ' + GetGoldStr(MAX_MARKETPRICE) + ' 金币.', [mbOk]);
          Exit;
        end;
      end;
  end;

  g_SellDlgItemSellWait.item := g_SellDlgItem;
  g_SellDlgItem.s.Name := '';
  LastestClickTime := GetTickCount + NPC_CILCK_INVTIME;
  g_sSellPriceStr := '';
end;

procedure TFrmDlg.SetMagicKeyDlg(icon: Integer; magname: string; var curkey: Word);
begin
  MagKeyIcon := icon;
  MagKeyMagName := magname;
  MagKeyCurKey := curkey;

  DKeySelDlg.Left := (SCREENWIDTH - DKeySelDlg.Width) div 2;
  DKeySelDlg.Top := (SCREENHEIGHT - DKeySelDlg.Height) div 2;
  HideAllControls;
  DKeySelDlg.ShowModal;

  while True do begin
    if not DKeySelDlg.Visible then Break;
    //FrmMain.DXTimerTimer (self, 0);
    frmMain.ProcOnIdle;
    Application.ProcessMessages;
    if Application.Terminated then Exit;
  end;

  RestoreHideControls;
  curkey := MagKeyCurKey;
end;

procedure TFrmDlg.DKeySelDlgDirectPaint(Sender: TObject;
  dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
begin
  with DKeySelDlg do begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    //魔法快捷键
    with dsurface do begin
      TextOut(SurfaceX(Left + 95), SurfaceY(Top + 38), MagKeyMagName + '快捷键被设置为:', clSilver);
    end;
  end;
end;

procedure TFrmDlg.DKsIconDirectPaint(Sender: TObject;
  dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
begin
  with DKsIcon do begin
    if (MagKeyIcon in [248, 250, 252, 254]) or (MagKeyIcon = 256) then begin
      d := g_WMagIcon2Images.Images[(MagKeyIcon div 2 - 124) * 2 + 580];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    end else if MagKeyIcon in [240, 242, 246] then begin
      d := g_Wui.Images[(MagKeyIcon div 2 - 120) * 2 + 761];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    end else if MagKeyIcon in [230, 232, 234] then begin
      d := g_WMagIcon2Images.Images[(MagKeyIcon div 2 - 115) * 2 + 170];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    end else begin
      d := g_WMagIconImages.Images[MagKeyIcon];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    end;
  end;
end;

procedure TFrmDlg.DKsF1DirectPaint(Sender: TObject;
  dsurface: TCustomCanvas);
var
  b: TDButton;
  d: TCustomLockableTexture;
begin
  b := nil;
  case MagKeyCurKey of
    Word('1'): b := DKsF1;
    Word('2'): b := DKsF2;
    Word('3'): b := DKsF3;
    Word('4'): b := DKsF4;
    Word('5'): b := DKsF5;
    Word('6'): b := DKsF6;
    Word('7'): b := DKsF7;
    Word('8'): b := DKsF8;
    Word('E'): b := DKsConF1;
    Word('F'): b := DKsConF2;
    Word('G'): b := DKsConF3;
    Word('H'): b := DKsConF4;
    Word('I'): b := DKsConF5;
    Word('J'): b := DKsConF6;
    Word('K'): b := DKsConF7;
    Word('L'): b := DKsConF8;
  else b := DKsNone;
  end;
  if b = Sender then begin
    with b do begin
      d := WLib.Images[FaceIndex + 1];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    end;
  end;
  with Sender as TDButton do begin
    if Downed then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    end;
  end;
end;

procedure TFrmDlg.DKsOkClick(Sender: TObject; X, Y: Integer);
begin
  DKeySelDlg.Visible := False;
end;

procedure TFrmDlg.DKsF1Click(Sender: TObject; X, Y: Integer);
begin
  if Sender = DKsF1 then MagKeyCurKey := Integer('1');
  if Sender = DKsF2 then MagKeyCurKey := Integer('2');
  if Sender = DKsF3 then MagKeyCurKey := Integer('3');
  if Sender = DKsF4 then MagKeyCurKey := Integer('4');
  if Sender = DKsF5 then MagKeyCurKey := Integer('5');
  if Sender = DKsF6 then MagKeyCurKey := Integer('6');
  if Sender = DKsF7 then MagKeyCurKey := Integer('7');
  if Sender = DKsF8 then MagKeyCurKey := Integer('8');
  if Sender = DKsConF1 then MagKeyCurKey := Integer('E');
  if Sender = DKsConF2 then MagKeyCurKey := Integer('F');
  if Sender = DKsConF3 then MagKeyCurKey := Integer('G');
  if Sender = DKsConF4 then MagKeyCurKey := Integer('H');
  if Sender = DKsConF5 then MagKeyCurKey := Integer('I');
  if Sender = DKsConF6 then MagKeyCurKey := Integer('J');
  if Sender = DKsConF7 then MagKeyCurKey := Integer('K');
  if Sender = DKsConF8 then MagKeyCurKey := Integer('L');
  if Sender = DKsNone then MagKeyCurKey := 0;
end;

procedure TFrmDlg.DBotMiniMapClick(Sender: TObject; X, Y: Integer);
var
  i: Integer;
  szMapTitle: string;
  pMapDescInfo: pTMapDescInfo;
begin
  if not g_boViewMiniMap then begin
    if GetTickCount > g_dwQueryMsgTick then begin
      g_dwQueryMsgTick := GetTickCount + 3000;
      frmMain.SendWantMiniMap;
      g_nViewMinMapLv := 1;
    end;
  end else begin
    if g_nViewMinMapLv >= 2 then begin
      g_nViewMinMapLv := 0;
      g_boViewMiniMap := False;
    end else
      Inc(g_nViewMinMapLv);
  end;
  //123456
  g_xCurMapDescList.Clear;
  for i := 0 to g_xMapDescList.Count - 1 do begin
    szMapTitle := g_xMapDescList[i];
    pMapDescInfo := pTMapDescInfo(g_xMapDescList.Objects[i]);
    if (CompareText(g_xMapDescList[i], g_sMapTitle) = 0) and
      (((pMapDescInfo.nFullMap = g_nViewMinMapLv) and (pMapDescInfo.nFullMap = 1)) or
      ((g_nViewMinMapLv <> 1) and (pMapDescInfo.nFullMap = 0))) then begin
      g_xCurMapDescList.AddObject(g_xMapDescList[i], TObject(pMapDescInfo));
    end;
  end;
end;

procedure TFrmDlg.DBotTradeClick(Sender: TObject; X, Y: Integer);
begin
  if GetTickCount > g_dwQueryMsgTick then begin
    g_dwQueryMsgTick := GetTickCount + 3000;
    frmMain.SendDealTry;
  end;
end;

procedure TFrmDlg.DBP1DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d, dd: TCustomLockableTexture;
begin
  with Sender as TDButton do begin
    dd := nil;
    if tag <= g_VenationInfos[DStateWin.tag].Point then
      d := WLib.Images[FaceIndex + 1]
    else begin
      d := WLib.Images[FaceIndex];
      if tag = (g_VenationInfos[DStateWin.tag].Point + 1) then begin
        if GetTickCount - g_PointFlashTick > 600 then begin
          g_PointFlashTick := GetTickCount;
          g_boPointFlash := not g_boPointFlash;
        end;
        if g_boPointFlash then begin
          case g_VenationInfos[DStateWin.tag].Level of
            2..6: dd := WLib.Images[852 + g_VenationInfos[DStateWin.tag].Level];
          else
            dd := WLib.Images[853];
          end;
        end;
      end;
    end;
    if d <> nil then dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    if dd <> nil then dsurface.DrawBlend(SurfaceX(Left), SurfaceY(Top), dd, 1);
  end;
end;

procedure TFrmDlg.DBP1MouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  s: string;
  cl: TColor;
begin
{$IF SERIESSKILL}
  if g_Myself.n_boState and (g_Myself.m_nIPowerLvl > 0) and (m_nIPStatePage = 2) then begin
    with Sender as TDButton do begin
      if not (tag in [1..5]) then Exit;

      //DebugOutStr(Format('%d %d %d', [tag, Left, Top]));

      s := '';
      if tag <= g_VenationInfos[DStateWin.tag].Point then begin
        g_VMouseInfo2 := Format('%s穴', [g_VaInfos[DStateWin.tag].Str1[tag - 1]]);
        g_VLvHints2 := '已打通' + g_VaInfos[DStateWin.tag].Hint[tag - 1];

        DScreen.ShowHint(
          SurfaceX(Left + Width),
          SurfaceY(Top),
          Format('<%s|C=%d>\', [g_VaInfos[DStateWin.tag].Str1[tag - 1], clWhite]),
          GetRGB(103), False, False, False);
      end else begin
        g_VMouseInfo2 := g_VaInfos[DStateWin.tag].Str1[tag - 1];
        g_VLvHints2 := '通过舒经活络丸打通，\打通后' + g_VaInfos[DStateWin.tag].Hint[tag - 1];

        if tag = (g_VenationInfos[DStateWin.tag].Point + 1) then begin
          if g_Myself.m_nIPowerLvl >= g_VNeedLevels[DStateWin.tag][tag] then
            cl := $FF00
          else
            cl := clRed;
          s := Format('\<需要内功等级:%d|C=%d>', [g_VNeedLevels[DStateWin.tag][tag], cl]);

          DScreen.ShowHint(
            SurfaceX(Left + Width),
            SurfaceY(Top),
            Format('<%s穴:待打通|C=%d>', [g_VaInfos[DStateWin.tag].Str1[tag - 1], clYellow]) + s,
            GetRGB(103), False, False, False);
        end else
          DScreen.ShowHint(
            SurfaceX(Left + Width),
            SurfaceY(Top),
            Format('<%s穴:目前不可打通|C=%d>', [g_VaInfos[DStateWin.tag].Str1[tag - 1], clRed]),
            GetRGB(103), False, False, False);
      end;

    end;
  end;
{$IFEND SERIESSKILL}
end;

procedure TFrmDlg.DBP1MouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
var
  s: string;
begin
{$IF SERIESSKILL}
  with Sender as TDButton do begin
    if tag = (g_VenationInfos[DStateWin.tag].Point + 1) then begin
      if g_Myself.m_nIPowerLvl >= g_VNeedLevels[DStateWin.tag][tag] then begin
        s := '使用舒经活络丸有几率打通%s穴，%s。您是否要尝试打通\该穴位？';
        s := Format(s,
          [
          g_VaInfos[DStateWin.tag].Str1[tag - 1],
            g_VaInfos[DStateWin.tag].Hint[tag - 1]
            ]);
        if FrmDlg.DMessageDlg(s, [mbOk, mbCancel]) = mrOk then begin
          frmMain.SendClientMessage(CM_BREAKPOINT, g_Myself.m_nRecogId, DStateWin.tag, tag, 0);
        end;
      end else begin
        ShowMDlg(0, '', Format('你的内功等级不够,请努力修炼,早日打通%s的%s穴位\ \<关闭/@closewin>', [g_VaStrs[DStateWin.tag], g_VaInfos[DStateWin.tag].Str1[tag - 1]]));
      end;
    end else begin
      if tag > (g_VenationInfos[DStateWin.tag].Point + 1) then
        ShowMDlg(0, '', Format('%s的%s穴位目前不可打通\ \<关闭/@closewin>', [g_VaStrs[DStateWin.tag], g_VaInfos[DStateWin.tag].Str1[tag - 1]]));
    end;
  end;
{$IFEND SERIESSKILL}
end;

procedure TFrmDlg.DBPH1DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
//var
//  d: TDirectDrawSurface;
begin
  //94 95 93
  with Sender as TDButton do begin
    if Downed then begin
      dsurface.BoldTextOut(SurfaceX(Left + 1), SurfaceY(Top + 1), GetRGB(94), clBlack, CaptionEx)
    end else if Arrived then begin
      dsurface.BoldTextOut(SurfaceX(Left), SurfaceY(Top), GetRGB(95), clBlack, CaptionEx)
    end else
      dsurface.BoldTextOut(SurfaceX(Left), SurfaceY(Top), GetRGB(93), clBlack, CaptionEx);
  end;
end;

procedure TFrmDlg.DBotGuildClick(Sender: TObject; X, Y: Integer);
begin
  if DGuildDlg.Visible then begin
    DGuildDlg.Visible := False;
  end else
    if GetTickCount > g_dwQueryMsgTick then begin
      g_dwQueryMsgTick := GetTickCount + 3000;
      frmMain.SendGuildDlg;
    end;
end;

procedure TFrmDlg.ToggleShowGroupDlg;
begin
  DGroupDlg.Visible := not DGroupDlg.Visible;
end;

procedure TFrmDlg.DGroupDlgDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
  lx, ly, n: Integer;
begin
  try
    with DGroupDlg do begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    end;
    if g_GroupMembers.Count > 0 then begin
//      dsurface.Canvas.Font.Color := clSilver;
      lx := DGroupDlg.SurfaceX(28) + DGroupDlg.Left;
      ly := DGroupDlg.SurfaceY(80) + DGroupDlg.Top;
      dsurface.TextOut(lx, ly, g_GroupMembers[0]);
      for n := 1 to g_GroupMembers.Count - 1 do begin
        lx := DGroupDlg.SurfaceX(28) + DGroupDlg.Left + ((n - 1) mod 2) * 100;
        ly := DGroupDlg.SurfaceY(80 + 16) + DGroupDlg.Top + ((n - 1) div 2) * 16;
        dsurface.TextOut(lx, ly, g_GroupMembers[n]);
      end;
    end;
  except
  end;
end;

procedure TFrmDlg.DGrpDlgCloseClick(Sender: TObject; X, Y: Integer);
begin
  DGroupDlg.Visible := False;
end;

procedure TFrmDlg.DGrpAllowGroupDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
begin
  d := nil;
  with Sender as TDButton do begin
    if Downed then begin
      d := WLib.Images[FaceIndex - 1];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    end else begin
      if g_boAllowGroup then
        d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    end;
  end;
end;

procedure TFrmDlg.DGrpAllowGroupClick(Sender: TObject; X, Y: Integer);
begin
  if GetTickCount > g_dwChangeGroupModeTick then begin
    g_boAllowGroup := not g_boAllowGroup;
    g_dwChangeGroupModeTick := GetTickCount + 2000;
    frmMain.SendGroupMode(g_boAllowGroup);
  end;
end;

procedure TFrmDlg.DGrpCreateClick(Sender: TObject; X, Y: Integer);
var
  who: string;
begin
  if (GetTickCount > g_dwChangeGroupModeTick) and (g_GroupMembers.Count = 0) then begin
    DialogSize := 1;
    DMessageDlg('输入想加入编组人物名称：', [mbOk, mbAbort]);
    who := Trim(DlgEditText);
    if who <> '' then begin
      g_dwChangeGroupModeTick := GetTickCount + 5000; //timeout 5檬
      frmMain.SendCreateGroup(Trim(DlgEditText));
    end;
  end;
end;

procedure TFrmDlg.DGrpAddMemClick(Sender: TObject; X, Y: Integer);
var
  who: string;
begin
  if (GetTickCount > g_dwChangeGroupModeTick) and (g_GroupMembers.Count > 0) then begin
    DialogSize := 1;
    DMessageDlg('输入想加入编组人物名称：', [mbOk, mbAbort]);
    who := Trim(DlgEditText);
    if who <> '' then begin
      g_dwChangeGroupModeTick := GetTickCount + 5000; //timeout 5檬
      frmMain.SendAddGroupMember(Trim(DlgEditText));
    end;
  end;
end;

procedure TFrmDlg.DGrpDelMemClick(Sender: TObject; X, Y: Integer);
var
  who: string;
begin
  if (GetTickCount > g_dwChangeGroupModeTick) and (g_GroupMembers.Count > 0) then begin
    DialogSize := 1;
    DMessageDlg('输入想退出编组人物名称：', [mbOk, mbAbort]);
    who := Trim(DlgEditText);
    if who <> '' then begin
      g_dwChangeGroupModeTick := GetTickCount + 5000; //timeout 5檬
      frmMain.SendDelGroupMember(Trim(DlgEditText));
    end;
  end;
end;

procedure TFrmDlg.DBotLogoutClick(Sender: TObject; X, Y: Integer);
begin
  frmMain.AppLogout;
  //强行退出
  {g_dwLatestStruckTick := GetTickCount() + 10001;
  g_dwLatestMagicTick := GetTickCount() + 10001;
  g_dwLatestHitTick := GetTickCount() + 10001;
  if (GetTickCount - g_dwLatestStruckTick > 10000) and
    (GetTickCount - g_dwLatestMagicTick > 10000) and
    (GetTickCount - g_dwLatestHitTick > 10000) or
    (g_MySelf.m_boDeath) then begin
    frmMain.AppLogout;
  end else
    DScreen.AddChatBoardString('攻击状态不能退出游戏！', clYellow, clRed);}
end;

procedure TFrmDlg.DBotDareClick(Sender: TObject; X, Y: Integer);
var
  dwExit: LongWord;
begin
  DWChatRecordList.Visible := not DWChatRecordList.Visible;
end;

procedure TFrmDlg.DBotExitClick(Sender: TObject; X, Y: Integer);
begin
  frmMain.AppExit;
  //强行退出
  {g_dwLatestStruckTick := GetTickCount() + 10001;
  g_dwLatestMagicTick := GetTickCount() + 10001;
  g_dwLatestHitTick := GetTickCount() + 10001;
  if (GetTickCount - g_dwLatestStruckTick > 10000) and
    (GetTickCount - g_dwLatestMagicTick > 10000) and
    (GetTickCount - g_dwLatestHitTick > 10000) or
    (g_MySelf.m_boDeath) then begin
    frmMain.AppExit;
  end else
    DScreen.AddChatBoardString('攻击状态不能退出游戏！', clYellow, clRed);}
end;

procedure TFrmDlg.DBotPlusAbilClick(Sender: TObject; X, Y: Integer);
begin
  FrmDlg.OpenAdjustAbility;
end;

procedure TFrmDlg.OpenDealDlg;
var
  d: TCustomCanvas;
begin
  DDealRemoteDlg.Left := SCREENWIDTH - 236 - 100;
  DDealRemoteDlg.Top := 0;
  DDealDlg.Left := SCREENWIDTH - 236 - 100;
  DDealDlg.Top := DDealRemoteDlg.Height - 15;
  DItemBag.Left := 0;
  DItemBag.Top := 60;
  DItemBag.Visible := True;
  DDealDlg.Visible := True;
  DDealRemoteDlg.Visible := True;
  FillChar(g_DealItems, SizeOf(TClientItem) * 10, #0);
  FillChar(g_YbDealItems, SizeOf(TClientItem) * 10, #0);
  FillChar(g_DealRemoteItems, SizeOf(TClientItem) * 20, #0);
  g_nDealGold := 0;
  g_nDealRemoteGold := 0;
  g_boDealEnd := False;
  ArrangeItembag;
end;

procedure TFrmDlg.CloseDealDlg;
begin
  DDealDlg.Visible := False;
  DDealRemoteDlg.Visible := False;
  ArrangeItembag;
end;

procedure TFrmDlg.DDealOkClick(Sender: TObject; X, Y: Integer);
var
  mi: Integer;
begin
  if GetTickCount > g_dwDealActionTick then begin
    frmMain.SendDealEnd;
    g_dwDealActionTick := GetTickCount + 4000;
    g_boDealEnd := True;
    if g_boItemMoving then begin
      mi := g_MovingItem.Index;
      if (mi <= -20) and (mi > -30) then begin
        AddDealItem(g_MovingItem.item);
        g_boItemMoving := False;
        g_MovingItem.item.s.Name := '';
      end;
    end;
  end;
end;

procedure TFrmDlg.DDealCloseClick(Sender: TObject; X, Y: Integer);
begin
  if GetTickCount > g_dwDealActionTick then begin
    CloseDealDlg;
    frmMain.SendCancelDeal;
  end;
end;

procedure TFrmDlg.DDealRemoteDlgDirectPaint(Sender: TObject;
  dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
begin
  with DDealRemoteDlg do begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    with dsurface do begin
      TextOut(SurfaceX(Left + 64), SurfaceY(Top + 196 - 65), GetGoldStr(g_nDealRemoteGold), clWhite);
      TextOut(SurfaceX(Left + 59 + (106 - FontManager.Default.TextWidth(g_sDealWho)) div 2), SurfaceY(Top + 3) + 3, g_sDealWho, clWhite);
    end;
  end;
end;

procedure TFrmDlg.DDealDlgDirectPaint(Sender: TObject;
  dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
begin
  with DDealDlg do begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    with dsurface do begin
      Font.Color := clWhite;
      TextOut(SurfaceX(Left + 64), SurfaceY(Top + 196 - 65), GetGoldStr(g_nDealGold), clWhite);
      TextOut(SurfaceX(Left + 59 + (106 - FontManager.Default.TextWidth(frmMain.m_sCharName)) div 2), SurfaceY(Top + 3) + 3, frmMain.m_sCharName, clWhite);
    end;
  end;
end;

procedure TFrmDlg.DealItemReturnBag(mitem: TClientItem);
begin
  if not g_boDealEnd then begin
    g_DealDlgItem := mitem;
    frmMain.SendDelDealItem(g_DealDlgItem);
    g_dwDealActionTick := GetTickCount + 4000;
  end;
end;

procedure TFrmDlg.YbDealItemReturnBag();
var
  i: Integer;
begin
  for i := Low(g_YbDealItems) to High(g_YbDealItems) - 1 do
    if g_YbDealItems[i].s.Name <> '' then begin
      AddItemBag(g_YbDealItems[i]);
      g_YbDealItems[i].s.Name := '';
    end;
end;

procedure TFrmDlg.DDGridGridSelect(Sender: TObject; X, Y, ACol, ARow: Integer; Shift: TShiftState);
var
  temp: TClientItem;
  mi, idx: Integer;
  MsgResult, Count: Integer;
  valstr: string;
begin
  if not g_boDealEnd and (GetTickCount > g_dwDealActionTick) then begin
    if not g_boItemMoving then begin
      idx := ACol + ARow * DDGrid.ColCount;
      if idx in [0..9] then
        if g_DealItems[idx].s.Name <> '' then begin
          g_boItemMoving := True;
          g_MovingItem.Index := -idx - 20;
          g_MovingItem.item := g_DealItems[idx];
          g_DealItems[idx].s.Name := '';
          g_SndMgr.ItemClickSound(g_MovingItem.item.s);
        end;
    end else begin
      mi := g_MovingItem.Index;
      if (mi in [0..MAXBAGITEM - 1]) or (mi <= -20) and (mi > -30) then begin
        g_SndMgr.ItemClickSound(g_MovingItem.item.s);
        g_boItemMoving := False;
        if mi >= 0 then begin

          if g_MovingItem.item.s.Overlap > 0 then begin

            Total := g_MovingItem.item.Dura;
            if Total = 1 then begin
              DlgEditText := '1';
              MsgResult := mrOk;
            end else begin

              MsgResult := DMessageDlg(Format('你想放上多少 %s ？', [g_MovingItem.item.s.Name]),
                [mbOk, mbCancel, mbAbort], IntToStr(g_MovingItem.item.Dura));
            end;
            GetValidStrVal(DlgEditText, valstr, [' ']);
            Count := Str_ToInt(valstr, 0);
            if Count <= 0 then Count := 0;
            if Count > g_MovingItem.item.Dura then begin
              Count := g_MovingItem.item.Dura;
            end;
            g_boItemMoving := True;
            if MsgResult = mrOk then begin
              g_DealDlgItem := g_MovingItem.item;
              g_DealDlgItem.Dura := Word(Count);
              g_MovingItem.item.Dura := g_MovingItem.item.Dura - Count;
              if g_MovingItem.item.Dura = 0 then begin
                g_MovingItem.item.s.Name := '';
                g_boItemMoving := False;
              end;
              CancelItemMoving;
              frmMain.SendAddDealItem(g_DealDlgItem);
              g_dwDealActionTick := GetTickCount + 4000;
            end else if MsgResult = mrCancel then begin
              CancelItemMoving;
              g_dwDealActionTick := GetTickCount;
            end;
          end else begin
            g_DealDlgItem := g_MovingItem.item;
            frmMain.SendAddDealItem(g_DealDlgItem);
            g_dwDealActionTick := GetTickCount + 4000;
          end;
        end else
          AddDealItem(g_MovingItem.item);
        g_MovingItem.item.s.Name := '';
      end;
      if mi = -98 then DDGoldClick(Self, 0, 0);
    end;
    ArrangeItembag;
  end;
end;

procedure TFrmDlg.DDGridGridPaint(Sender: TObject; ACol, ARow: Integer;
  Rect: TRect; State: TGridDrawState; dsurface: TCustomCanvas);
var
  n, idx: Integer;
  d: TCustomLockableTexture;
begin
  idx := ACol + ARow * DDGrid.ColCount;
  if idx in [0..9] then begin
    if g_DealItems[idx].s.Name <> '' then begin
      //d := g_WBagItemImages.Images[g_DealItems[idx].s.looks];
      d := frmMain.GetWBagItemImg(g_DealItems[idx].s.looks);
      if d <> nil then begin
        with DDGrid do
          dsurface.Draw(SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
            SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
            d.ClientRect,
            d, True);
        if g_DealItems[idx].s.Overlap > 0 then begin
          dsurface.BoldTextOut(
            DDGrid.SurfaceX(Rect.Left + 33 - FontManager.Default.TextWidth(IntToStr(g_DealItems[idx].Dura))),
            DDGrid.SurfaceY(Rect.Top + 20),
            clSilver, clBlack, IntToStr(g_DealItems[idx].Dura));
        end;
        if (g_DealItems[idx].s.StdMode in [5,6,10,11,15..24, 26..30]) then begin
          if (g_DealItems[idx].s.Shape = 190) or (g_DealItems[idx].s.reserve[3] = 4) then begin
            if GetTickCount - g_DealItemsShine[idx].tick > 60 then begin
              g_DealItemsShine[idx].tick := GetTickCount;
              Inc(g_DealItemsShine[idx].idx);
              if g_DealItemsShine[idx].idx > 31 then
                g_DealItemsShine[idx].idx := 0;
            end;
            n := -1;
            d := nil;
            case g_DealItems[idx].s.StdMode of
              30: n := 6;
              19, 20, 21: n := 2;
              15: n := 3;
              24, 25, 26: n := 0;
              22, 23: n := 1;
              27: n := 5;
              28: n := 4
            end;
            if n >= 0 then
              d := g_Wui.Images[100 + n * 40 + g_DealItemsShine[idx].idx];
            //d := g_Wui.Images[100 + (g_DealItems[idx].s.looks - 2130) * 40 + g_DealItemsShine[idx].idx];
            if d <> nil then
              with DDGrid do
                dsurface.DrawBlend(
                  SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                  SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                  d, 1);
          end else if g_DealItems[idx].s.reserve[3] = 1 then begin
            n := 0;
            if g_DealItems[idx].s.StdMode in [15, 16] then
              n := 2;
            if GetTickCount - g_DealItemsShine[idx].tick > 100 then begin
              g_DealItemsShine[idx].tick := GetTickCount;
              Inc(g_DealItemsShine[idx].idx);
              if g_DealItemsShine[idx].idx > (8 + n) then
                g_DealItemsShine[idx].idx := 0;
            end;
            d := g_WMainImages.Images[(640 - n * 10) + g_DealItemsShine[idx].idx];
            if d <> nil then
              with DDGrid do
                dsurface.DrawBlend(
                  SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                  SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                  d, 1);
          end else if g_DealItems[idx].s.reserve[3] = 2 then begin
            if GetTickCount - g_DealItemsShine[idx].tick > 100 then begin
              g_DealItemsShine[idx].tick := GetTickCount;
              Inc(g_DealItemsShine[idx].idx);
              if g_DealItemsShine[idx].idx > 5 then
                g_DealItemsShine[idx].idx := 0;
            end;
            d := g_WMain2Images.Images[260 + g_DealItemsShine[idx].idx];
            if d <> nil then
              with DDGrid do
                dsurface.DrawBlend(
                  SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                  SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                  d, 1);
          end else if g_DealItems[idx].s.reserve[3] = 3 then begin
            if GetTickCount - g_DealItemsShine[idx].tick > 100 then begin
              g_DealItemsShine[idx].tick := GetTickCount;
              Inc(g_DealItemsShine[idx].idx);
              if g_DealItemsShine[idx].idx > 9 then
                g_DealItemsShine[idx].idx := 0;
            end;
            n := -1;
            d := nil;
            case g_DealItems[idx].s.StdMode of
              30: n := 6;
              19, 20, 21: n := 2;
              15: n := 5;
              24, 25, 26: n := 1;
              22, 23: n := 0;
              27: n := 4;
              28: n := 3;
            end;
            if n >= 0 then
              d := g_StateEffect.Images[530 + n * 10 + g_DealItemsShine[idx].idx];
            //d := g_StateEffect.Images[530 + (g_DealItems[idx].s.looks - 2410) * 10 + g_DealItemsShine[idx].idx];
            if d <> nil then
              with DDGrid do
                dsurface.DrawBlend(
                  SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                  SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                  d, 1);
          end else if g_DealItems[idx].s.reserve[3] = 5 then begin
            if GetTickCount - g_DealItemsShine[idx].tick > 100 then begin
              g_DealItemsShine[idx].tick := GetTickCount;
              Inc(g_DealItemsShine[idx].idx);
              if g_DealItemsShine[idx].idx > 9 then
                g_DealItemsShine[idx].idx := 0;
            end;
            d := g_WStateItemImages.Images[3910 + g_DealItemsShine[idx].idx];
            if d <> nil then
              with DDGrid do
                dsurface.DrawBlend(
                  SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                  SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                  d, 1);
          end else if g_DealItems[idx].s.reserve[3] in [6..10] then begin
            d := g_WMain3Images.Images[750 + (g_DealItems[idx].s.reserve[3] - 6) * 2];
            if d <> nil then
              with DDGrid do
                dsurface.DrawBlend(
                  SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                  SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                  d, 1);
          end else if g_DealItems[idx].s.reserve[3] in [100..249] then begin  //20200927交易自己
            if GetTickCount - g_DealItemsShine[idx].tick > 200 then begin
              g_DealItemsShine[idx].tick := GetTickCount;
              Inc(g_DealItemsShine[idx].idx);
              if g_DealItemsShine[idx].idx > 19 then
                g_DealItemsShine[idx].idx := 0;
            end;
          d := frmMain.GetWBagItemImg(20000 + (g_DealItems[idx].s.reserve[3] +1 - 100) * 20-20 + g_DealItemsShine[idx].idx);
          if d = nil then begin
           g_DealItemsShine[idx].idx := 0;
            d := frmMain.GetWBagItemImg(20000 + (g_DealItems[idx].s.reserve[3] +1 - 100) * 20-20 + g_DealItemsShine[idx].idx);
          end;
            if d <> nil then
              with DDGrid do
                dsurface.DrawBlend(
                  SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                  SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                  d, 1);
          end;

        end;

      end;
    end;
  end;
end;

procedure TFrmDlg.DDGridGridMouseMove(Sender: TObject; X, Y, ACol, ARow: Integer; Shift: TShiftState);
var
  idx, itemidx: Integer;
  temp: TClientItem;
  shint: string;
  b1, b2, useable: Boolean;
  hcolor: TColor;
begin
  idx := ACol + ARow * DDGrid.ColCount;
  if idx in [0..9] then begin
    g_MouseItem := g_DealItems[idx];
    if g_MovingItem.item.s.Name = '' then begin
      itemidx := GetItemWhere(g_MouseItem);
      if itemidx in [0..U_FASHION] then begin
        g_ShowSuite := 1;
        g_SuiteIdx := itemidx;
      end;
      GetMouseItemInfoHint(g_MouseItem, shint);
      if shint <> '' then begin
        with TDGrid(Sender) do begin
          DScreen.ShowHint(
            SurfaceX(Left + (ACol) * 36),
            SurfaceY(Top + (ARow + 1) * 34),
            shint,
            clWhite, False, False, True, True);
        end;
      end;
      g_MouseItem.s.Name := '';
    end;
  end;
end;

procedure TFrmDlg.DDRGridGridPaint(Sender: TObject; ACol, ARow: Integer;
  Rect: TRect; State: TGridDrawState; dsurface: TCustomCanvas);
var
  n, idx: Integer;
  i, k: Integer;
  d: TCustomLockableTexture;
begin
  for i := 0 to 19 do begin
    if g_DealRemoteItems[i].s.Name <> '' then begin
      for k := i + 1 to 19 do begin
        if g_DealRemoteItems[i].s.Overlap > 0 then begin
          if (g_DealRemoteItems[i].s.Name = g_DealRemoteItems[k].s.Name) then begin
            g_DealRemoteItems[i].Dura := g_DealRemoteItems[i].Dura + g_DealRemoteItems[k].Dura;
            FillChar(g_DealRemoteItems[k], SizeOf(TClientItem), #0);
          end;
        end else if (g_DealRemoteItems[i].s.Name = g_DealRemoteItems[k].s.Name) and (g_DealRemoteItems[i].MakeIndex = g_DealRemoteItems[k].MakeIndex) then begin
          FillChar(g_DealRemoteItems[k], SizeOf(TClientItem), #0);
        end;
      end;
    end;
  end;

  idx := ACol + ARow * DDRGrid.ColCount;
  if idx in [0..19] then begin
    if g_DealRemoteItems[idx].s.Name <> '' then begin
      //d := g_WBagItemImages.Images[g_DealRemoteItems[idx].s.looks];
      d := frmMain.GetWBagItemImg(g_DealRemoteItems[idx].s.looks);
      if d <> nil then begin
        with DDRGrid do
          dsurface.Draw(SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
            SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
            d.ClientRect,
            d, True);
        if g_DealRemoteItems[idx].s.Overlap > 0 then begin
          dsurface.BoldTextOut(
            DDRGrid.SurfaceX(Rect.Left + 33 - FontManager.Default.TextWidth(IntToStr(g_DealRemoteItems[idx].Dura))),
            DDRGrid.SurfaceY(Rect.Top + 20),
            clSilver, clBlack, IntToStr(g_DealRemoteItems[idx].Dura));
        end;
        if (g_DealRemoteItems[idx].s.StdMode in [5,6,10,11,15..24, 26..30]) then begin
          if (g_DealRemoteItems[idx].s.Shape = 190) or (g_DealRemoteItems[idx].s.reserve[3] = 4) then begin
            if GetTickCount - g_DealRemoteItemsShine[idx].tick > 100 then begin
              g_DealRemoteItemsShine[idx].tick := GetTickCount;
              Inc(g_DealRemoteItemsShine[idx].idx);
              if g_DealRemoteItemsShine[idx].idx > 31 then
                g_DealRemoteItemsShine[idx].idx := 0;
            end;
            n := -1;
            d := nil;
            case g_DealRemoteItems[idx].s.StdMode of
              30: n := 6;
              19, 20, 21: n := 2;
              15: n := 3;
              24, 25, 26: n := 0;
              22, 23: n := 1;
              27: n := 5;
              28: n := 4
            end;
            if n >= 0 then
              d := g_Wui.Images[100 + n * 40 + g_DealRemoteItemsShine[idx].idx];

            //d := g_Wui.Images[100 + (g_DealRemoteItems[idx].s.looks - 2130) * 40 + g_DealRemoteItemsShine[idx].idx];
            if d <> nil then
              with DDRGrid do
                dsurface.DrawBlend(
                  SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                  SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                  d, 1);
          end else if g_DealRemoteItems[idx].s.reserve[3] = 1 then begin
            n := 0;
            if g_DealRemoteItems[idx].s.StdMode in [15, 16] then
              n := 2;
            if GetTickCount - g_DealRemoteItemsShine[idx].tick > 100 then begin
              g_DealRemoteItemsShine[idx].tick := GetTickCount;
              Inc(g_DealRemoteItemsShine[idx].idx);
              if g_DealRemoteItemsShine[idx].idx > (8 + n) then
                g_DealRemoteItemsShine[idx].idx := 0;
            end;
            d := g_WMainImages.Images[(640 - n * 10) + g_DealRemoteItemsShine[idx].idx];
            if d <> nil then
              with DDRGrid do
                dsurface.DrawBlend(
                  SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                  SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                  d, 1);
          end else if g_DealRemoteItems[idx].s.reserve[3] = 2 then begin
            if GetTickCount - g_DealRemoteItemsShine[idx].tick > 100 then begin
              g_DealRemoteItemsShine[idx].tick := GetTickCount;
              Inc(g_DealRemoteItemsShine[idx].idx);
              if g_DealRemoteItemsShine[idx].idx > 5 then
                g_DealRemoteItemsShine[idx].idx := 0;
            end;
            d := g_WMain2Images.Images[260 + g_DealRemoteItemsShine[idx].idx];
            if d <> nil then
              with DDRGrid do
                dsurface.DrawBlend(
                  SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                  SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                  d, 1);
          end else if g_DealRemoteItems[idx].s.reserve[3] = 3 then begin
            if GetTickCount - g_DealRemoteItemsShine[idx].tick > 100 then begin
              g_DealRemoteItemsShine[idx].tick := GetTickCount;
              Inc(g_DealRemoteItemsShine[idx].idx);
              if g_DealRemoteItemsShine[idx].idx > 9 then
                g_DealRemoteItemsShine[idx].idx := 0;
            end;
            n := -1;
            d := nil;
            case g_DealRemoteItems[idx].s.StdMode of
              30: n := 6;
              19, 20, 21: n := 2;
              15: n := 5;
              24, 25, 26: n := 1;
              22, 23: n := 0;
              27: n := 4;
              28: n := 3;
            end;
            if n >= 0 then
              d := g_StateEffect.Images[530 + n * 10 + g_DealRemoteItemsShine[idx].idx];
            //d := g_StateEffect.Images[530 + (g_DealRemoteItems[idx].s.looks - 2410) * 10 + g_DealRemoteItemsShine[idx].idx];
            if d <> nil then
              with DDRGrid do
                dsurface.DrawBlend(
                  SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                  SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                  d, 1);
          end else if g_DealRemoteItems[idx].s.reserve[3] = 5 then begin
            if GetTickCount - g_DealRemoteItemsShine[idx].tick > 100 then begin
              g_DealRemoteItemsShine[idx].tick := GetTickCount;
              Inc(g_DealRemoteItemsShine[idx].idx);
              if g_DealRemoteItemsShine[idx].idx > 9 then
                g_DealRemoteItemsShine[idx].idx := 0;
            end;
            d := g_WStateItemImages.Images[3910 + g_DealRemoteItemsShine[idx].idx];
            if d <> nil then
              with DDRGrid do
                dsurface.DrawBlend(
                  SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                  SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                  d, 1);
          end else if g_DealRemoteItems[idx].s.reserve[3] in [6..10] then begin
            d := g_WMain3Images.Images[750 + (g_DealRemoteItems[idx].s.reserve[3] - 6) * 2];
            if d <> nil then
              with DDRGrid do
                dsurface.DrawBlend(
                  SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                  SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                  d, 1);
          end else if g_DealRemoteItems[idx].s.reserve[3] in [100..249] then begin //20200927交易别人
            if GetTickCount - g_DealRemoteItemsShine[idx].tick > 200 then begin
              g_DealRemoteItemsShine[idx].tick := GetTickCount;
              Inc(g_DealRemoteItemsShine[idx].idx);
              if g_DealRemoteItemsShine[idx].idx > 19 then
                g_DealRemoteItemsShine[idx].idx := 0;
            end;
          d := frmMain.GetWBagItemImg(20000 + (g_DealRemoteItems[idx].s.reserve[3] +1 - 100) * 20-20 + g_DealRemoteItemsShine[idx].idx);
          if d = nil then begin
           g_DealRemoteItemsShine[idx].idx := 0;
            d := frmMain.GetWBagItemImg(20000 + (g_DealRemoteItems[idx].s.reserve[3] +1 - 100) * 20-20 + g_DealRemoteItemsShine[idx].idx);
          end;
            if d <> nil then
              with DDRGrid do
                dsurface.DrawBlend(
                  SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                  SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                  d, 1);
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DDRGridGridMouseMove(Sender: TObject; X, Y, ACol, ARow: Integer; Shift: TShiftState);
var
  idx, itemidx: Integer;
  temp: TClientItem;
  shint: string;
  b1, b2, useable: Boolean;
  hcolor: TColor;
begin
  idx := ACol + ARow * DDRGrid.ColCount;
  if idx in [0..19] then begin
    g_MouseItem := g_DealRemoteItems[idx];
    if g_MovingItem.item.s.Name = '' then begin
      itemidx := GetItemWhere(g_MouseItem);
      if itemidx in [0..U_FASHION] then begin
        g_ShowSuite := 1;
        g_SuiteIdx := itemidx;
      end;
      GetMouseItemInfoHint(g_MouseItem, shint);
      if shint <> '' then begin
        with TDGrid(Sender) do begin
          DScreen.ShowHint(
            SurfaceX(Left + (ACol) * 36),
            SurfaceY(Top + (ARow + 1) * 34),
            shint,
            clWhite, False, False, True, True);
        end;
      end;
      g_MouseItem.s.Name := '';
    end;
  end;
end;

procedure TFrmDlg.DealZeroGold;
begin
  if not g_boDealEnd and (g_nDealGold > 0) then begin
    g_dwDealActionTick := GetTickCount + 4000;
    frmMain.SendChangeDealGold(0);
  end;
end;

procedure TFrmDlg.DDGoldClick(Sender: TObject; X, Y: Integer);
var
  DGold: Integer;
  valstr: string;
begin
  if g_Myself = nil then Exit;
  if not g_boDealEnd and (GetTickCount > g_dwDealActionTick) then begin
    if not g_boItemMoving then begin
      if g_nDealGold > 0 then begin
        g_SndMgr.PlaySound(s_money);
        g_boItemMoving := True;
        g_MovingItem.Index := -97;
        g_MovingItem.item.s.Name := g_sGoldName;
      end;
    end else begin
      if (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) then begin
        if (g_MovingItem.Index = -98) then begin
          if g_MovingItem.item.s.Name = g_sGoldName then begin
            DialogSize := 1;
            g_boItemMoving := False;
            g_MovingItem.item.s.Name := '';
            DMessageDlg('请输入' + g_sGoldName + '数量：', [mbOk, mbAbort]);
            GetValidStrVal(DlgEditText, valstr, [' ']);
            DGold := Str_ToInt(valstr, 0);
            if (DGold <= (g_nDealGold + g_Myself.m_nGold)) and (DGold > 0) then begin
              frmMain.SendChangeDealGold(DGold);
              g_dwDealActionTick := GetTickCount + 4000;
            end else
              DGold := 0;
          end;
        end;
        g_boItemMoving := False;
        g_MovingItem.item.s.Name := '';
      end;
    end;
  end;
end;

procedure TFrmDlg.DUserState1DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  i, L, M, pgidx, bbx, bby, idx, ax, ay, sex, hair, FontColor: Integer;
  d: TCustomLockableTexture;
  hcolor, keyimg: Integer;
  iname, d1, d2, d3, d4: string;
  useable: Boolean;
  tmpColor: TColor;
  weaponeffect: byte;
begin
  with DUserState1 do begin
{$IFDEF UI_0508}
    d := WLib.Images[FaceIndex];
    //d := ULib.Images[FaceName];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);

    sex := DRESSfeature(UserState1.Feature) mod 2;
    hair := HAIRfeature(UserState1.Feature) mod 10;
    weaponeffect := UserState1.btResver1;
    if sex = 1 then
      pgidx := 30
    else
      pgidx := 29;

    bbx := Left + 38;
    bby := Top + 52;
    d := g_WMain3Images.Images[pgidx];
    if d <> nil then
      dsurface.Draw(SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, False);

    bbx := bbx - 7;
    bby := bby + 44;
    idx := 440 + hair;
    if idx > 0 then begin
      d := g_WMainImages.GetCachedImage(idx, ax, ay);
      if d <> nil then
        dsurface.Draw(SurfaceX(bbx + ax), SurfaceY(bby + ay), d.ClientRect, d, True);
    end;
    if UserState1.UseItems[U_DRESS].s.Name <> '' then begin
      idx := UserState1.UseItems[U_DRESS].s.looks;
      if idx >= 0 then begin
        d := frmMain.GetWStateImg(idx, ax, ay);
        if d <> nil then
          dsurface.Draw(SurfaceX(bbx + ax), SurfaceY(bby + ay), d.ClientRect, d, True);

        if UserState1.UseItems[U_DRESS].s.reserve[3] = 1 then begin
          d := frmMain.GetWStateImg(2425 + sex, ax, ay);
          if d <> nil then
            dsurface.DrawBlend(
              SurfaceX(bbx + ax),
              SurfaceY(bby + ay),
              d,
              1);
        end;
        if UserState1.UseItems[U_DRESS].s.reserve[3] = 2 then begin
          d := frmMain.GetWStateImg(2541 + sex * 2, ax, ay);
          if d <> nil then
            dsurface.DrawBlend(
              SurfaceX(bbx + ax),
              SurfaceY(bby + ay),
              d,
              1);
        end;
        if UserState1.UseItems[U_DRESS].s.reserve[3] = 3 then begin

          if GetTickCount - g_uDressEffectTick > 200 then begin
            g_uDressEffectTick := GetTickCount;
            Inc(g_uDressEffectIdx);
            if g_uDressEffectIdx >= 20 then
              g_uDressEffectIdx := 0;
          end;

          d := frmMain.GetWStateImg(2600 + g_uDressEffectIdx, ax, ay);
          if d <> nil then
            dsurface.DrawBlend(
              SurfaceX(bbx + ax),
              SurfaceY(bby + ay),
              d,
              1);
        end;
        if UserState1.UseItems[U_DRESS].s.reserve[3] = 4 then begin

          if GetTickCount - g_uDressEffectTick > 200 then begin
            g_uDressEffectTick := GetTickCount;
            Inc(g_uDressEffectIdx);
            if g_uDressEffectIdx >= 10 then
              g_uDressEffectIdx := 0;
          end;

          if sex = 0 then
            d := frmMain.GetWStateImg(3550 + g_uDressEffectIdx, ax, ay)
          else
            d := frmMain.GetWStateImg(3570 + g_uDressEffectIdx, ax, ay);
          if d <> nil then
            dsurface.DrawBlend(
              SurfaceX(bbx + ax),
              SurfaceY(bby + ay),
              d,
              1);
        end;
        if UserState1.UseItems[U_DRESS].s.reserve[3] = 5 then begin

          if GetTickCount - g_uDressEffectTick > 200 then begin
            g_uDressEffectTick := GetTickCount;
            Inc(g_uDressEffectIdx);
            if g_uDressEffectIdx >= 8 then
              g_uDressEffectIdx := 0;
          end;

          if sex = 0 then
            d := frmMain.GetWStateImg(3680 + g_uDressEffectIdx, ax, ay)
          else
            d := frmMain.GetWStateImg(3690 + g_uDressEffectIdx, ax, ay);
          if d <> nil then
            dsurface.DrawBlend(
              SurfaceX(bbx + ax),
              SurfaceY(bby + ay),
              d,
              1);
        end else if UserState1.UseItems[U_DRESS].s.reserve[3] = 6 then begin
          if GetTickCount - g_hDressEffectTick > 200 then begin
            g_hDressEffectTick := GetTickCount;
            Inc(g_hDressEffectIdx);
            if g_hDressEffectIdx >= 8 then
              g_hDressEffectIdx := 0;
          end;
          d := frmMain.GetWStateImg(3800 + g_hDressEffectIdx, ax, ay);
          if d <> nil then
            dsurface.DrawBlend(
              SurfaceX(bbx + ax),
              SurfaceY(bby + ay),
              d,
              1);
        end else if UserState1.UseItems[U_DRESS].s.reserve[3] = 7 then begin
          if GetTickCount - g_hDressEffectTick > 200 then begin
            g_hDressEffectTick := GetTickCount;
            Inc(g_hDressEffectIdx);
            if g_hDressEffectIdx >= 9 then
              g_hDressEffectIdx := 0;
          end;
          if sex = 0 then
            d := frmMain.GetWStateImg(3950 + g_hDressEffectIdx, ax, ay)
          else
            d := frmMain.GetWStateImg(3959 + g_hDressEffectIdx, ax, ay);
          if d <> nil then
            dsurface.DrawBlend(
              SurfaceX(bbx + ax),
              SurfaceY(bby + ay),
              d,
              1);
        end else if UserState1.UseItems[U_DRESS].s.reserve[3] = 8 then begin
          if GetTickCount - g_hDressEffectTick > 200 then begin
            g_hDressEffectTick := GetTickCount;
            Inc(g_hDressEffectIdx);
            if g_hDressEffectIdx >= 10 then
              g_hDressEffectIdx := 0;
          end;
          if sex = 0 then
            d := frmMain.GetWStateImg(3968 + g_hDressEffectIdx, ax, ay)
          else
            d := frmMain.GetWStateImg(3978 + g_hDressEffectIdx, ax, ay);
          if d <> nil then
            dsurface.DrawBlend(
              SurfaceX(bbx + ax),
              SurfaceY(bby + ay),
              d,
              1);
        end else if UserState1.UseItems[U_DRESS].s.reserve[3]  in [100..249] then begin  //自定义特效四格  衣服 看别人
          if GetTickCount - g_hDressEffectTick > 200 then begin
            g_hDressEffectTick := GetTickCount;
            Inc(g_hDressEffectIdx);
            if g_hDressEffectIdx >= 20 then
              g_hDressEffectIdx := 0;
          end;
          d := frmMain.GetWStateImg(30000 + (UserState1.UseItems[U_DRESS].s.reserve[3]+1 - 100) * 20-20 + g_hDressEffectIdx, ax, ay);
          if d = nil then begin
            g_hDressEffectIdx := 0;
            d := frmMain.GetWStateImg(30000 + (UserState1.UseItems[U_DRESS].s.reserve[3]+1 - 100) * 20-20 + g_hDressEffectIdx, ax, ay);
          end;
          if d <> nil then begin
           dsurface.DrawBlend(SurfaceX(bbx + ax), SurfaceY(bby + ay), d, 1);
          end;

        end;
      end;
    end;
    if UserState1.UseItems[U_WEAPON].s.Name <> '' then begin
      idx := UserState1.UseItems[U_WEAPON].s.looks;
      if idx >= 0 then begin
        d := frmMain.GetWStateImg(idx, ax, ay);
        if d <> nil then
          dsurface.Draw(SurfaceX(bbx + ax), SurfaceY(bby + ay), d.ClientRect, d, True);

        if UserState1.UseItems[U_WEAPON].s.reserve[3] = 3 then begin
          d := frmMain.GetWStateImg(2427, ax, ay);
          if d <> nil then
            dsurface.DrawBlend(
              SurfaceX(bbx + ax),
              SurfaceY(bby + ay),
              d,
              1);
        end else if UserState1.UseItems[U_WEAPON].s.reserve[3] = 1 then begin
          d := frmMain.GetWStateImg(1403, ax, ay);
          if d <> nil then
            dsurface.DrawBlend(
              SurfaceX(bbx + ax),
              SurfaceY(bby + ay),
              d,
              1);
        end else if (UserState1.UseItems[U_WEAPON].s.reserve[3] = 2) {and (idx = 1880)} then begin

          if GetTickCount - g_uWeaponEffectTick > 200 then begin
            g_uWeaponEffectTick := GetTickCount;
            Inc(g_uWeaponEffectIdx);
            if g_uWeaponEffectIdx > 9 then
              g_uWeaponEffectIdx := 0;
          end;

          d := frmMain.GetWStateImg(1890 + g_uWeaponEffectIdx, ax, ay);
          if d <> nil then
            dsurface.DrawBlend(
              SurfaceX(bbx + ax),
              SurfaceY(bby + ay),
              d,
              1);

        end else if (UserState1.UseItems[U_WEAPON].s.reserve[3] = 4) then begin
          //if (idx = 2523) then begin

          if GetTickCount - g_uWeaponEffectTick > 200 then begin
            g_uWeaponEffectTick := GetTickCount;
            Inc(g_uWeaponEffectIdx);
            if g_uWeaponEffectIdx > 7 then
              g_uWeaponEffectIdx := 0;
          end;

          d := frmMain.GetWStateImg(2530 + g_uWeaponEffectIdx, ax, ay);
          if d <> nil then
            dsurface.DrawBlend(
              SurfaceX(bbx + ax),
              SurfaceY(bby + ay),
              d,
              1);

          //end;
        end else if (UserState1.UseItems[U_WEAPON].s.reserve[3] = 5) then begin
          //if (idx = 2524) then begin

          if GetTickCount - g_uWeaponEffectTick > 200 then begin
            g_uWeaponEffectTick := GetTickCount;
            Inc(g_uWeaponEffectIdx);
            if g_uWeaponEffectIdx > 9 then
              g_uWeaponEffectIdx := 0;
          end;

          d := frmMain.GetWStateImg(2550 + g_uWeaponEffectIdx, ax, ay);
          if d <> nil then
            dsurface.DrawBlend(
              SurfaceX(bbx + ax),
              SurfaceY(bby + ay),
              d,
              1);

          //end;
        end else if (UserState1.UseItems[U_WEAPON].s.reserve[3] = 6) then begin
          //if (idx = 2525) then begin

          if GetTickCount - g_uWeaponEffectTick > 200 then begin
            g_uWeaponEffectTick := GetTickCount;
            Inc(g_uWeaponEffectIdx);
            if g_uWeaponEffectIdx > 9 then
              g_uWeaponEffectIdx := 0;
          end;

          d := frmMain.GetWStateImg(2560 + g_uWeaponEffectIdx, ax, ay);
          if d <> nil then
            dsurface.DrawBlend(
              SurfaceX(bbx + ax),
              SurfaceY(bby + ay),
              d,
              1);
        end else if (UserState1.UseItems[U_WEAPON].s.reserve[3] in [7..9]) then begin
          if GetTickCount - g_uWeaponEffectTick > 200 then begin
            g_uWeaponEffectTick := GetTickCount;
            Inc(g_uWeaponEffectIdx);
            if g_uWeaponEffectIdx > 13 then
              g_uWeaponEffectIdx := 0;
          end;

          d := frmMain.GetWStateImg(3480 + (UserState1.UseItems[U_WEAPON].s.reserve[3] - 7) * 20 + g_uWeaponEffectIdx, ax, ay);
          if d <> nil then
            dsurface.DrawBlend(
              SurfaceX(bbx + ax),
              SurfaceY(bby + ay),
              d,
              1);
        end else if (UserState1.UseItems[U_WEAPON].s.reserve[3] in [10..12]) then begin
          if GetTickCount - g_uWeaponEffectTick > 200 then begin
            g_uWeaponEffectTick := GetTickCount;
            Inc(g_uWeaponEffectIdx);
            if g_uWeaponEffectIdx >= 18 then
              g_uWeaponEffectIdx := 0;
          end;

          d := frmMain.GetWStateImg(3610 + (UserState1.UseItems[U_WEAPON].s.reserve[3] - 10) * 20 + g_uWeaponEffectIdx, ax, ay);
          if d <> nil then
            dsurface.DrawBlend(
              SurfaceX(bbx + ax),
              SurfaceY(bby + ay),
              d,
              1);
        end else if (UserState1.UseItems[U_WEAPON].s.reserve[3] in [13..15]) then begin
          if GetTickCount - g_uWeaponEffectTick > 200 then begin
            g_uWeaponEffectTick := GetTickCount;
            Inc(g_uWeaponEffectIdx);
            if g_uWeaponEffectIdx >= 18 then
              g_uWeaponEffectIdx := 0;
          end;

          d := frmMain.GetWStateImg(3820 + (UserState1.UseItems[U_WEAPON].s.reserve[3] - 13) * 20 + g_uWeaponEffectIdx, ax, ay);
          if d <> nil then
            dsurface.DrawBlend(
              SurfaceX(bbx + ax),
              SurfaceY(bby + ay),
              d,
              1);
        end else if (UserState1.UseItems[U_WEAPON].s.reserve[3] in [16]) then begin
          if GetTickCount - g_uWeaponEffectTick > 200 then begin
            g_uWeaponEffectTick := GetTickCount;
            Inc(g_uWeaponEffectIdx);
            if g_uWeaponEffectIdx >= 16 then
              g_uWeaponEffectIdx := 0;
          end;

          d := frmMain.GetWStateImg(2850 + g_uWeaponEffectIdx, ax, ay);
          if d <> nil then
            dsurface.DrawBlend(
              SurfaceX(bbx + ax),
              SurfaceY(bby + ay),
              d,
              1);
        end else if (UserState1.UseItems[U_WEAPON].s.reserve[3] in [100..249]) then begin  //自定义特效四格  武器 看别人
          if GetTickCount - g_sWeaponEffectTick > 200 then begin
            g_sWeaponEffectTick := GetTickCount;
            Inc(g_sWeaponEffectIdx);
            if g_sWeaponEffectIdx >= 20 then
              g_sWeaponEffectIdx := 0;
          end;
          d := frmMain.GetWStateImg(30000 + (UserState1.UseItems[U_WEAPON].s.reserve[3]+1 - 100) * 20-20+g_sWeaponEffectIdx, ax, ay);
          if d = nil then begin
            g_sWeaponEffectIdx := 0;
            d := frmMain.GetWStateImg(30000 + (UserState1.UseItems[U_WEAPON].s.reserve[3]+1 - 100) * 20-20+g_sWeaponEffectIdx, ax, ay);
          end;
          if d <> nil then begin
          dsurface.DrawBlend(SurfaceX(bbx + ax), SurfaceY(bby + ay), d, 1);
          end;
        end;

      end;
    end;
    pgidx := 1;
    if UserState1.UseItems[U_HELMETEX].s.Name <> '' then begin
      idx := UserState1.UseItems[U_HELMETEX].s.looks;
      if idx >= 0 then begin
        if UserState1.UseItems[U_HELMETEX].s.Source <> 0 then
          pgidx := 1
        else
          pgidx := 0;
        d := frmMain.GetWStateImg(idx, ax, ay);
        if d <> nil then
          dsurface.Draw(SurfaceX(bbx + ax), SurfaceY(bby + ay), d.ClientRect, d, True);
      end;
    end;
    if (UserState1.UseItems[U_HELMET].s.Name <> '') then begin
      idx := UserState1.UseItems[U_HELMET].s.looks;
      if idx >= 0 then begin
        if (pgidx <> 0) then begin
          d := frmMain.GetWStateImg(idx, ax, ay);
          if d <> nil then
            dsurface.Draw(SurfaceX(bbx + ax), SurfaceY(bby + ay), d.ClientRect, d, True);
        end;

        if (UserState1.UseItems[U_HELMET].s.Shape = 190) or (UserState1.UseItems[U_HELMET].s.reserve[3] = 4) then begin
          if GetTickCount - UserState1Shine[U_HELMET].tick > 60 then begin
            UserState1Shine[U_HELMET].tick := GetTickCount;
            Inc(UserState1Shine[U_HELMET].idx);
            if UserState1Shine[U_HELMET].idx > 31 then
              UserState1Shine[U_HELMET].idx := 0;
          end;
          d := g_Wui.Images[220 + UserState1Shine[U_HELMET].idx];
          if d <> nil then
            dsurface.DrawBlend( SurfaceX(bbx + ax - 12), SurfaceY(bby + ay - 10), d, 1);
        end else if UserState1.UseItems[U_HELMET].s.reserve[3] = 3 then begin
          if GetTickCount - UserState1Shine[U_HELMET].tick > 100 then begin
            UserState1Shine[U_HELMET].tick := GetTickCount;
            Inc(UserState1Shine[U_HELMET].idx);
            if UserState1Shine[U_HELMET].idx >= 10 then
              UserState1Shine[U_HELMET].idx := 0;
          end;
          d := g_StateEffect.Images[580 + UserState1Shine[U_HELMET].idx];
          if d <> nil then
            dsurface.DrawBlend( SurfaceX(bbx + ax - d.Width div 4), SurfaceY(bby + ay - d.Height div 4), d, 1);
        end else if UserState1.UseItems[U_HELMET].s.reserve[3] >= 100 then begin //20200927四格头盔特效看别人
          if GetTickCount - UserState1Shine[U_HELMET].tick > 200 then begin
            UserState1Shine[U_HELMET].tick := GetTickCount;
            Inc(UserState1Shine[U_HELMET].idx);
            if UserState1Shine[U_HELMET].idx > 19 then
              UserState1Shine[U_HELMET].idx := 0;
          end;
         d := frmMain.GetWStateImg(30000 + (UserState1.UseItems[U_HELMET].s.reserve[3]+1 - 100) * 20-20+ UserState1Shine[U_HELMET].idx);
        if d = nil then begin
          UserState1Shine[U_HELMET].idx := 0;
          d := frmMain.GetWStateImg(30000 + (UserState1.UseItems[U_HELMET].s.reserve[3]+1 - 100) * 20-20+ UserState1Shine[U_HELMET].idx);
        end;
          if d <> nil then begin
          dsurface.DrawBlend( SurfaceX(bbx + ax - 4 - d.Width div 4), SurfaceY(bby + ay - d.Height div 4), d, 1);
          end;
        end;
      end;
    end;

    if UserState1.btHumAttr in [1..5] then
      with dsurface do begin
        case UserState1.btHumAttr of
          1: FontColor := GetRGB(149);
          2: FontColor := GetRGB(221);
          3: FontColor := GetRGB(147);
          4: FontColor := GetRGB(057);
          5: FontColor := GetRGB(045);
        end;
        BoldTextOut(SurfaceX(Left + 170), SurfaceY(Top + 52), g_sHumAttr[UserState1.btHumAttr], FontColor, clBlack, [], 24, '隶书');
      end;

    with dsurface do begin
      FontColor := UserState1.NameColor;
      TextOut(SurfaceX(Left + 122 - FontManager.Default.TextWidth(UserState1.UserName) div 2), SurfaceY(Top + 23), UserState1.UserName, FontColor);
      FontColor := clSilver;
      TextOut(SurfaceX(Left + 45), SurfaceY(Top + 58), UserState1.GuildName + ' ' + UserState1.GuildRankName, FontColor);
    end;
{$ELSE}
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);

    DPageUS1DirectPaint(DPageUS1, dsurface);
    case uStatePage of
      0: begin
          sex := DRESSfeature(UserState1.Feature) mod 2;
          hair := HAIRfeature(UserState1.Feature) mod 10;
          weaponeffect := UserState1.btResver1;
          if sex = 1 then
            pgidx := 3222
          else
            pgidx := 3221;

          bbx := Left + 38 - 5;
          bby := Top + 50 + 77;
          d := g_Wui.Images[pgidx];
          if d <> nil then
            dsurface.Draw(SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, False);

          bbx := bbx - 7 + 59;
          bby := bby + 44 + 34;

          if HAIRfeature(UserState1.Feature) < 10 then begin
            idx := 440 + hair;
            if idx > 0 then begin
              d := g_WMainImages.GetCachedImage(idx, ax, ay);
              if d <> nil then
                dsurface.Draw(SurfaceX(bbx + ax), SurfaceY(bby + ay), d.ClientRect, d, True);
            end;
          end;

          if UserState1.UseItems[U_DRESS].s.Name <> '' then begin
            idx := UserState1.UseItems[U_DRESS].s.looks;
            if idx >= 0 then begin
              d := frmMain.GetWStateImg(idx, ax, ay);
              if d <> nil then
                dsurface.Draw(SurfaceX(bbx + ax), SurfaceY(bby + ay), d.ClientRect, d, True);

              if UserState1.UseItems[U_DRESS].s.reserve[3] = 1 then begin
                d := frmMain.GetWStateImg(2425 + sex, ax, ay);
                if d <> nil then
                  dsurface.DrawBlend(
                    SurfaceX(bbx + ax),
                    SurfaceY(bby + ay),
                    d,
                    1);
              end else if UserState1.UseItems[U_DRESS].s.reserve[3] = 2 then begin
                d := frmMain.GetWStateImg(2541 + sex * 2, ax, ay);
                if d <> nil then
                  dsurface.DrawBlend(
                    SurfaceX(bbx + ax),
                    SurfaceY(bby + ay),
                    d,
                    1);
              end else if UserState1.UseItems[U_DRESS].s.reserve[3] = 3 then begin

                if GetTickCount - g_uDressEffectTick > 200 then begin
                  g_uDressEffectTick := GetTickCount;
                  Inc(g_uDressEffectIdx);
                  if g_uDressEffectIdx >= 20 then
                    g_uDressEffectIdx := 0;
                end;

                d := frmMain.GetWStateImg(2600 + g_uDressEffectIdx, ax, ay);
                if d <> nil then
                  dsurface.DrawBlend(
                    SurfaceX(bbx + ax),
                    SurfaceY(bby + ay),
                    d,
                    1);
              end else if UserState1.UseItems[U_DRESS].s.reserve[3] = 4 then begin

                if GetTickCount - g_uDressEffectTick > 200 then begin
                  g_uDressEffectTick := GetTickCount;
                  Inc(g_uDressEffectIdx);
                  if g_uDressEffectIdx >= 10 then
                    g_uDressEffectIdx := 0;
                end;

                if sex = 0 then
                  d := frmMain.GetWStateImg(3550 + g_uDressEffectIdx, ax, ay)
                else
                  d := frmMain.GetWStateImg(3570 + g_uDressEffectIdx, ax, ay);
                if d <> nil then
                  dsurface.DrawBlend(
                    SurfaceX(bbx + ax),
                    SurfaceY(bby + ay),
                    d,
                    1);
              end else if UserState1.UseItems[U_DRESS].s.reserve[3] = 5 then begin

                if GetTickCount - g_uDressEffectTick > 200 then begin
                  g_uDressEffectTick := GetTickCount;
                  Inc(g_uDressEffectIdx);
                  if g_uDressEffectIdx >= 8 then
                    g_uDressEffectIdx := 0;
                end;

                if sex = 0 then
                  d := frmMain.GetWStateImg(3680 + g_uDressEffectIdx, ax, ay)
                else
                  d := frmMain.GetWStateImg(3690 + g_uDressEffectIdx, ax, ay);
                if d <> nil then
                  dsurface.DrawBlend(
                    SurfaceX(bbx + ax),
                    SurfaceY(bby + ay),
                    d,
                    1);
              end else if UserState1.UseItems[U_DRESS].s.reserve[3] = 6 then begin
                if GetTickCount - g_hDressEffectTick > 200 then begin
                  g_hDressEffectTick := GetTickCount;
                  Inc(g_hDressEffectIdx);
                  if g_hDressEffectIdx >= 8 then
                    g_hDressEffectIdx := 0;
                end;
                d := frmMain.GetWStateImg(3800 + g_hDressEffectIdx, ax, ay);
                if d <> nil then
                  dsurface.DrawBlend(
                    SurfaceX(bbx + ax),
                    SurfaceY(bby + ay),
                    d,
                    1);
              end else if UserState1.UseItems[U_DRESS].s.reserve[3] = 7 then begin
                if GetTickCount - g_hDressEffectTick > 200 then begin
                  g_hDressEffectTick := GetTickCount;
                  Inc(g_hDressEffectIdx);
                  if g_hDressEffectIdx >= 9 then
                    g_hDressEffectIdx := 0;
                end;
                if sex = 0 then
                  d := frmMain.GetWStateImg(3950 + g_hDressEffectIdx, ax, ay)
                else
                  d := frmMain.GetWStateImg(3959 + g_hDressEffectIdx, ax, ay);
                if d <> nil then
                  dsurface.DrawBlend(
                    SurfaceX(bbx + ax),
                    SurfaceY(bby + ay),
                    d,
                    1);
              end else if UserState1.UseItems[U_DRESS].s.reserve[3] = 8 then begin
                if GetTickCount - g_hDressEffectTick > 200 then begin
                  g_hDressEffectTick := GetTickCount;
                  Inc(g_hDressEffectIdx);
                  if g_hDressEffectIdx >= 10 then
                    g_hDressEffectIdx := 0;
                end;
                if sex = 0 then
                  d := frmMain.GetWStateImg(3968 + g_hDressEffectIdx, ax, ay)
                else
                  d := frmMain.GetWStateImg(3978 + g_hDressEffectIdx, ax, ay);
                if d <> nil then
                  dsurface.DrawBlend(
                    SurfaceX(bbx + ax),
                    SurfaceY(bby + ay),
                    d,
                    1);
              end else if UserState1.UseItems[U_DRESS].s.reserve[3]  in [100..249] then begin  //自定义特效六格  衣服 看别人
                if GetTickCount - g_hDressEffectTick > 200 then begin
                  g_hDressEffectTick := GetTickCount;
                  Inc(g_hDressEffectIdx);
                  if g_hDressEffectIdx >= 20 then
                    g_hDressEffectIdx := 0;
                end;
                d := frmMain.GetWStateImg(30000 + (UserState1.UseItems[U_DRESS].s.reserve[3]+1 - 100) * 20-20 + g_hDressEffectIdx, ax, ay);
                if d = nil then begin
                  g_hDressEffectIdx := 0;
                  d := frmMain.GetWStateImg(30000 + (UserState1.UseItems[U_DRESS].s.reserve[3]+1 - 100) * 20-20 + g_hDressEffectIdx, ax, ay);
                end;
                if d <> nil then begin
                 dsurface.DrawBlend(SurfaceX(bbx + ax), SurfaceY(bby + ay), d, 1);
                end;

              end;
            end;
          end;
          if UserState1.UseItems[U_WEAPON].s.Name <> '' then begin
            idx := UserState1.UseItems[U_WEAPON].s.looks;
            if idx >= 0 then begin
              d := frmMain.GetWStateImg(idx, ax, ay);
              if d <> nil then
                dsurface.Draw(SurfaceX(bbx + ax), SurfaceY(bby + ay), d.ClientRect, d, True);

              if UserState1.UseItems[U_WEAPON].s.reserve[3] = 3 then begin
                d := frmMain.GetWStateImg(2427, ax, ay);
                if d <> nil then
                  dsurface.DrawBlend(
                    SurfaceX(bbx + ax),
                    SurfaceY(bby + ay),
                    d,
                    1);
              end else if UserState1.UseItems[U_WEAPON].s.reserve[3] = 1 then begin
                d := frmMain.GetWStateImg(1403, ax, ay);
                if d <> nil then
                  dsurface.DrawBlend(
                    SurfaceX(bbx + ax),
                    SurfaceY(bby + ay),
                    d,
                    1);
              end else if (UserState1.UseItems[U_WEAPON].s.reserve[3] = 2) then begin

                if GetTickCount - g_uWeaponEffectTick > 200 then begin
                  g_uWeaponEffectTick := GetTickCount;
                  Inc(g_uWeaponEffectIdx);
                  if g_uWeaponEffectIdx > 9 then
                    g_uWeaponEffectIdx := 0;
                end;

                d := frmMain.GetWStateImg(1890 + g_uWeaponEffectIdx, ax, ay);
                if d <> nil then
                  dsurface.DrawBlend(
                    SurfaceX(bbx + ax),
                    SurfaceY(bby + ay),
                    d,
                    1);

              end else if (UserState1.UseItems[U_WEAPON].s.reserve[3] = 4) then begin
                //if (idx = 2523) then begin

                if GetTickCount - g_uWeaponEffectTick > 200 then begin
                  g_uWeaponEffectTick := GetTickCount;
                  Inc(g_uWeaponEffectIdx);
                  if g_uWeaponEffectIdx > 7 then
                    g_uWeaponEffectIdx := 0;
                end;

                d := frmMain.GetWStateImg(2530 + g_uWeaponEffectIdx, ax, ay);
                if d <> nil then
                  dsurface.DrawBlend(
                    SurfaceX(bbx + ax),
                    SurfaceY(bby + ay),
                    d,
                    1);

                //end;
              end else if (UserState1.UseItems[U_WEAPON].s.reserve[3] = 5) then begin
                //if (idx = 2524) then begin

                if GetTickCount - g_uWeaponEffectTick > 200 then begin
                  g_uWeaponEffectTick := GetTickCount;
                  Inc(g_uWeaponEffectIdx);
                  if g_uWeaponEffectIdx > 9 then
                    g_uWeaponEffectIdx := 0;
                end;

                d := frmMain.GetWStateImg(2550 + g_uWeaponEffectIdx, ax, ay);
                if d <> nil then
                  dsurface.DrawBlend(
                    SurfaceX(bbx + ax),
                    SurfaceY(bby + ay),
                    d,
                    1);

                //end;
              end else if (UserState1.UseItems[U_WEAPON].s.reserve[3] = 6) then begin
                //if (idx = 2525) then begin

                if GetTickCount - g_uWeaponEffectTick > 200 then begin
                  g_uWeaponEffectTick := GetTickCount;
                  Inc(g_uWeaponEffectIdx);
                  if g_uWeaponEffectIdx > 9 then
                    g_uWeaponEffectIdx := 0;
                end;

                d := frmMain.GetWStateImg(2560 + g_uWeaponEffectIdx, ax, ay);
                if d <> nil then
                  dsurface.DrawBlend(
                    SurfaceX(bbx + ax),
                    SurfaceY(bby + ay),
                    d,
                    1);
              end else if (UserState1.UseItems[U_WEAPON].s.reserve[3] in [7..9]) then begin
                if GetTickCount - g_uWeaponEffectTick > 200 then begin
                  g_uWeaponEffectTick := GetTickCount;
                  Inc(g_uWeaponEffectIdx);
                  if g_uWeaponEffectIdx > 13 then
                    g_uWeaponEffectIdx := 0;
                end;

                d := frmMain.GetWStateImg(3480 + (UserState1.UseItems[U_WEAPON].s.reserve[3] - 7) * 20 + g_uWeaponEffectIdx, ax, ay);
                if d <> nil then
                  dsurface.DrawBlend(
                    SurfaceX(bbx + ax),
                    SurfaceY(bby + ay),
                    d,
                    1);
              end else if (UserState1.UseItems[U_WEAPON].s.reserve[3] in [10..12]) then begin
                if GetTickCount - g_uWeaponEffectTick > 200 then begin
                  g_uWeaponEffectTick := GetTickCount;
                  Inc(g_uWeaponEffectIdx);
                  if g_uWeaponEffectIdx >= 18 then
                    g_uWeaponEffectIdx := 0;
                end;

                d := frmMain.GetWStateImg(3610 + (UserState1.UseItems[U_WEAPON].s.reserve[3] - 10) * 20 + g_uWeaponEffectIdx, ax, ay);
                if d <> nil then
                  dsurface.DrawBlend(
                    SurfaceX(bbx + ax),
                    SurfaceY(bby + ay),
                    d,
                    1);
              end else if (UserState1.UseItems[U_WEAPON].s.reserve[3] in [13..15]) then begin
                if GetTickCount - g_uWeaponEffectTick > 200 then begin
                  g_uWeaponEffectTick := GetTickCount;
                  Inc(g_uWeaponEffectIdx);
                  if g_uWeaponEffectIdx >= 18 then
                    g_uWeaponEffectIdx := 0;
                end;

                d := frmMain.GetWStateImg(3820 + (UserState1.UseItems[U_WEAPON].s.reserve[3] - 13) * 20 + g_uWeaponEffectIdx, ax, ay);
                if d <> nil then
                  dsurface.DrawBlend(
                    SurfaceX(bbx + ax),
                    SurfaceY(bby + ay),
                    d,
                    1);
              end else if (UserState1.UseItems[U_WEAPON].s.reserve[3] in [16]) then begin
                if GetTickCount - g_uWeaponEffectTick > 200 then begin
                  g_uWeaponEffectTick := GetTickCount;
                  Inc(g_uWeaponEffectIdx);
                  if g_uWeaponEffectIdx >= 16 then
                    g_uWeaponEffectIdx := 0;
                end;

                d := frmMain.GetWStateImg(2850 + g_uWeaponEffectIdx, ax, ay);
                if d <> nil then
                  dsurface.DrawBlend(
                    SurfaceX(bbx + ax),
                    SurfaceY(bby + ay),
                    d,
                    1);
              end else if (UserState1.UseItems[U_WEAPON].s.reserve[3] in [100..249]) then begin  //自定义特效六格  武器 看别人
                if GetTickCount - g_sWeaponEffectTick > 200 then begin
                  g_sWeaponEffectTick := GetTickCount;
                  Inc(g_sWeaponEffectIdx);
                  if g_sWeaponEffectIdx >= 20 then
                    g_sWeaponEffectIdx := 0;
                end;
                d := frmMain.GetWStateImg(30000 + (UserState1.UseItems[U_WEAPON].s.reserve[3]+1 - 100) * 20-20+g_sWeaponEffectIdx, ax, ay);
                if d = nil then begin
                  g_sWeaponEffectIdx := 0;
                  d := frmMain.GetWStateImg(30000 + (UserState1.UseItems[U_WEAPON].s.reserve[3]+1 - 100) * 20-20+g_sWeaponEffectIdx, ax, ay);
                end;
                if d <> nil then begin
                dsurface.DrawBlend(SurfaceX(bbx + ax), SurfaceY(bby + ay), d, 1);
                end;
              end;
            end;
          end;
          pgidx := 1;
          if UserState1.UseItems[U_HELMETEX].s.Name <> '' then begin
            idx := UserState1.UseItems[U_HELMETEX].s.looks;
            if idx >= 0 then begin
              if UserState1.UseItems[U_HELMETEX].s.Source <> 0 then
                pgidx := 1
              else
                pgidx := 0;
              d := frmMain.GetWStateImg(idx, ax, ay);
              if d <> nil then
                dsurface.Draw(SurfaceX(bbx + ax), SurfaceY(bby + ay), d.ClientRect, d, True);
            end;
          end;
          if (UserState1.UseItems[U_HELMET].s.Name <> '') then begin
            idx := UserState1.UseItems[U_HELMET].s.looks;
            if idx >= 0 then begin
              if (pgidx <> 0) then begin
                d := frmMain.GetWStateImg(idx, ax, ay);
                if d <> nil then
                  dsurface.Draw(SurfaceX(bbx + ax), SurfaceY(bby + ay), d.ClientRect, d, True);
              end;

              if (UserState1.UseItems[U_HELMET].s.Shape = 190) or (UserState1.UseItems[U_HELMET].s.reserve[3] = 4) then begin
                if GetTickCount - UserState1Shine[U_HELMET].tick > 60 then begin
                  UserState1Shine[U_HELMET].tick := GetTickCount;
                  Inc(UserState1Shine[U_HELMET].idx);
                  if UserState1Shine[U_HELMET].idx > 31 then
                    UserState1Shine[U_HELMET].idx := 0;
                end;
                d := g_Wui.Images[220 + UserState1Shine[U_HELMET].idx];
                if d <> nil then
                  dsurface.DrawBlend(SurfaceX(bbx + ax - 12), SurfaceY(bby + ay - 10), d, 1);
              end else if UserState1.UseItems[U_HELMET].s.reserve[3] = 3 then begin
                if GetTickCount - UserState1Shine[U_HELMET].tick > 100 then begin
                  UserState1Shine[U_HELMET].tick := GetTickCount;
                  Inc(UserState1Shine[U_HELMET].idx);
                  if UserState1Shine[U_HELMET].idx >= 10 then
                    UserState1Shine[U_HELMET].idx := 0;
                end;
                d := g_StateEffect.Images[580 + UserState1Shine[U_HELMET].idx];
                if d <> nil then
                  dsurface.DrawBlend(SurfaceX(bbx + ax - d.Width div 4), SurfaceY(bby + ay - d.Height div 4), d, 1);
              end else if UserState1.UseItems[U_HELMET].s.reserve[3] >= 100 then begin //20200927六格头盔特效看别人
                if GetTickCount - UserState1Shine[U_HELMET].tick > 200 then begin
                  UserState1Shine[U_HELMET].tick := GetTickCount;
                  Inc(UserState1Shine[U_HELMET].idx);
                  if UserState1Shine[U_HELMET].idx > 19 then
                    UserState1Shine[U_HELMET].idx := 0;
                end;
               d := frmMain.GetWStateImg(30000 + (UserState1.UseItems[U_HELMET].s.reserve[3]+1 - 100) * 20-20+ UserState1Shine[U_HELMET].idx);
              if d = nil then begin
                UserState1Shine[U_HELMET].idx := 0;
                d := frmMain.GetWStateImg(30000 + (UserState1.UseItems[U_HELMET].s.reserve[3]+1 - 100) * 20-20+ UserState1Shine[U_HELMET].idx);
              end;
              if d <> nil then begin
              dsurface.DrawBlend(SurfaceX(bbx + ax - 4 - d.Width div 4), SurfaceY(bby + ay - d.Height div 4), d, 1);
              end;
              end;

            end;
          end;

          if UserState1.btHumAttr in [1..5] then
            with dsurface do begin
              case UserState1.btHumAttr of
                1: FontColor := GetRGB(149);
                2: FontColor := GetRGB(221);
                3: FontColor := GetRGB(147);
                4: FontColor := GetRGB(057);
                5: FontColor := GetRGB(045);
              end;
              BoldTextOut(SurfaceX(Left + 28), SurfaceY(Top + 88), g_sHumAttr[UserState1.btHumAttr], FontColor, clBlack, [], 24, '隶书');
            end;
        end;
      1: begin
          if UserState1.btGender = 1 then
            pgidx := 3284
          else
            pgidx := 3283;
          bbx := Left + 38 - 5;
          bby := Top + 50 + 77;
          d := g_Wui.Images[pgidx];
          if d <> nil then
            dsurface.Draw(SurfaceX(bbx), SurfaceY(bby), d);

          bbx := bbx - 7 + 59;
          bby := bby + 44 + 34;

          sex := DRESSfeature(UserState1.Feature) mod 2;
          idx := 442 + sex;
          d := g_WMainImages.GetCachedImage(idx, ax, ay);
          if d <> nil then
            dsurface.Draw(SurfaceX(bbx + ax), SurfaceY(bby + ay), d);
          if UserState1.UseItems[U_FASHION].s.reserve[3] = 1 then begin  //六格时装看别人特效
            d := frmMain.GetWStateImg(2425 + sex, ax, ay);
            if d <> nil then
              dsurface.DrawBlend(
                SurfaceX(bbx + ax),
                SurfaceY(bby + ay),
                d,
                1);
          end else if UserState1.UseItems[U_FASHION].s.reserve[3] = 2 then begin
            d := frmMain.GetWStateImg(2541 + sex * 2, ax, ay);
            if d <> nil then
              dsurface.DrawBlend(
                SurfaceX(bbx + ax),
                SurfaceY(bby + ay),
                d,
                1);
          end else if UserState1.UseItems[U_FASHION].s.reserve[3] = 3 then begin

            if GetTickCount - g_uDressEffectTick > 200 then begin
              g_uDressEffectTick := GetTickCount;
              Inc(g_uDressEffectIdx);
              if g_uDressEffectIdx >= 20 then
                g_uDressEffectIdx := 0;
            end;

            d := frmMain.GetWStateImg(2600 + g_uDressEffectIdx, ax, ay);
            if d <> nil then
              dsurface.DrawBlend(
                SurfaceX(bbx + ax),
                SurfaceY(bby + ay),
                d,
                1);
          end else if UserState1.UseItems[U_FASHION].s.reserve[3] = 4 then begin

            if GetTickCount - g_uDressEffectTick > 200 then begin
              g_uDressEffectTick := GetTickCount;
              Inc(g_uDressEffectIdx);
              if g_uDressEffectIdx >= 10 then
                g_uDressEffectIdx := 0;
            end;

            if sex = 0 then
              d := frmMain.GetWStateImg(3550 + g_uDressEffectIdx, ax, ay)
            else
              d := frmMain.GetWStateImg(3570 + g_uDressEffectIdx, ax, ay);
            if d <> nil then
              dsurface.DrawBlend(
                SurfaceX(bbx + ax),
                SurfaceY(bby + ay),
                d,
                1);
          end else if UserState1.UseItems[U_FASHION].s.reserve[3] = 5 then begin

            if GetTickCount - g_uDressEffectTick > 200 then begin
              g_uDressEffectTick := GetTickCount;
              Inc(g_uDressEffectIdx);
              if g_uDressEffectIdx >= 8 then
                g_uDressEffectIdx := 0;
            end;

            if sex = 0 then
              d := frmMain.GetWStateImg(3680 + g_uDressEffectIdx, ax, ay)
            else
              d := frmMain.GetWStateImg(3690 + g_uDressEffectIdx, ax, ay);
            if d <> nil then
              dsurface.DrawBlend(
                SurfaceX(bbx + ax),
                SurfaceY(bby + ay),
                d,
                1);
          end else if UserState1.UseItems[U_FASHION].s.reserve[3] = 6 then begin
            if GetTickCount - g_hDressEffectTick > 200 then begin
              g_hDressEffectTick := GetTickCount;
              Inc(g_hDressEffectIdx);
              if g_hDressEffectIdx >= 8 then
                g_hDressEffectIdx := 0;
            end;
            d := frmMain.GetWStateImg(3800 + g_hDressEffectIdx, ax, ay);
            if d <> nil then
              dsurface.DrawBlend(
                SurfaceX(bbx + ax),
                SurfaceY(bby + ay),
                d,
                1);
          end else if UserState1.UseItems[U_FASHION].s.reserve[3] = 7 then begin
            if GetTickCount - g_hDressEffectTick > 200 then begin
              g_hDressEffectTick := GetTickCount;
              Inc(g_hDressEffectIdx);
              if g_hDressEffectIdx >= 9 then
                g_hDressEffectIdx := 0;
            end;
            if sex = 0 then
              d := frmMain.GetWStateImg(3950 + g_hDressEffectIdx, ax, ay)
            else
              d := frmMain.GetWStateImg(3959 + g_hDressEffectIdx, ax, ay);
            if d <> nil then
              dsurface.DrawBlend(
                SurfaceX(bbx + ax),
                SurfaceY(bby + ay),
                d,
                1);
          end else if UserState1.UseItems[U_FASHION].s.reserve[3] = 8 then begin
            if GetTickCount - g_hDressEffectTick > 200 then begin
              g_hDressEffectTick := GetTickCount;
              Inc(g_hDressEffectIdx);
              if g_hDressEffectIdx >= 10 then
                g_hDressEffectIdx := 0;
            end;
            if sex = 0 then
              d := frmMain.GetWStateImg(3968 + g_hDressEffectIdx, ax, ay)
            else
              d := frmMain.GetWStateImg(3978 + g_hDressEffectIdx, ax, ay);
            if d <> nil then
              dsurface.DrawBlend(
                SurfaceX(bbx + ax),
                SurfaceY(bby + ay),
                d,
                1);
          end else if UserState1.UseItems[U_FASHION].s.reserve[3]  in [100..249] then begin  //自定义特效六格  时装 看别人
            if GetTickCount - g_hDressEffectTick > 200 then begin
              g_hDressEffectTick := GetTickCount;
              Inc(g_hDressEffectIdx);
              if g_hDressEffectIdx >= 20 then
                g_hDressEffectIdx := 0;
            end;
            d := frmMain.GetWStateImg(30000 + (UserState1.UseItems[U_FASHION].s.reserve[3]+1 - 100) * 20-20 + g_hDressEffectIdx, ax, ay);
            if d = nil then begin
              g_hDressEffectIdx := 0;
              d := frmMain.GetWStateImg(30000 + (UserState1.UseItems[U_FASHION].s.reserve[3]+1 - 100) * 20-20 + g_hDressEffectIdx, ax, ay);
            end;
            if d <> nil then begin
             dsurface.DrawBlend(SurfaceX(bbx + ax), SurfaceY(bby + ay), d, 1);
            end;

          end;
        end;
      2: begin
          bbx := Left + 38 - 5;
          bby := Top + 50 + 77;
          d := g_Wui.Images[3228];
          if d <> nil then begin
            dsurface.Draw(SurfaceX(bbx), SurfaceY(bby), d);
          end;
          //bby := Top + 70 + 14 * 6;
          //bbx := Left + 190;
          //mmx := bbx + 55;
        end;
    end;

    with dsurface do begin
      FontColor := UserState1.NameColor;
      TextOut(SurfaceX(Left + (Width - FontManager.Default.TextWidth(UserState1.UserName)) div 2),
        SurfaceY(Top + 62),
        UserState1.UserName, FontColor);
      if (uStatePage = 0) then begin
        FontColor := clSilver;
        TextOut(SurfaceX(Left + (Width - FontManager.Default.TextWidth(UserState1.GuildName + ' ' + UserState1.GuildRankName)) div 2),
          SurfaceY(Top + 81),
          UserState1.GuildName + ' ' + UserState1.GuildRankName, FontColor);
      end;
    end;
{$ENDIF}
  end;
end;

procedure TFrmDlg.DUserState1MouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
{$IFDEF UI_0508}
  X := DUserState1.LocalX(X) - DUserState1.Left;
  Y := DUserState1.LocalY(Y) - DUserState1.Top;
  if (X > 42) and (X < 201) and (Y > 54) and (Y < 71) then begin
    if UserState1.GuildName <> '' then begin
      FrmDlg.DEdChat.Visible := True;
      FrmDlg.DEdChat.SetFocus;
      FrmDlg.DEdChat.Text := UserState1.GuildName;
      FrmDlg.DEdChat.ChangeCurPos(AnsiTextLength(FrmDlg.DEdChat.Text), True);
      FrmDlg.DEdChat.SelLength := 0;
    end;
  end;
{$ELSE}
  if uStatePage <> 0 then
    Exit;
  X := DUserState1.LocalX(X) - DUserState1.Left;
  Y := DUserState1.LocalY(Y) - DUserState1.Top;
  if (X > 80) and (X < 270) and (Y > 80) and (Y < 96) then begin
    if UserState1.GuildName <> '' then begin
      FrmDlg.DEdChat.Visible := True;
      FrmDlg.DEdChat.SetFocus;
      FrmDlg.DEdChat.Text := UserState1.GuildName;
      FrmDlg.DEdChat.ChangeCurPos(AnsiTextLength(FrmDlg.DEdChat.Text), True);
      FrmDlg.DEdChat.SelLength := 0;
    end;
  end;
{$ENDIF}
end;

procedure TFrmDlg.DUserState1MouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
begin
  DScreen.ClearHint;
  if g_MouseUserStateItem.s.Name <> '' then
    g_MouseUserStateItem.s.Name := '';
end;

procedure TFrmDlg.DWeaponUS1MouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  HintLeft, b1, b2: Boolean;
  sel, L: Integer;
  shint: string;
begin
  sel := -1;
  L := 0;
  if Sender = DDressUS1 then begin
{$IFDEF UI_0508}
    sel := U_DRESS;
{$ELSE}
    if uStatePage = 0 then
      sel := U_DRESS
    else
      sel := U_FASHION;
{$ENDIF}
  end;
  if Sender = DWeaponUS1 then sel := U_WEAPON;
  if Sender = DHelmetUS1 then sel := U_HELMET;
  if Sender = DNecklaceUS1 then sel := U_NECKLACE;
  if Sender = DLightUS1 then sel := U_RIGHTHAND;
  if Sender = DRingLUS1 then sel := U_RINGL;
  if Sender = DRingRUS1 then sel := U_RINGR;
  if Sender = DArmringLUS1 then sel := U_ARMRINGL;
  if Sender = DArmringRUS1 then sel := U_ARMRINGR;
  if Sender = DBujukUS1 then sel := U_BUJUK;
  if Sender = DBeltUS1 then sel := U_BELT;
  if Sender = DBootsUS1 then sel := U_BOOTS;
  if Sender = DCharmUS1 then sel := U_CHARM;
{$IFNDEF UI_0508}
  if Sender = DDrumUS1 then sel := U_DRUM;
  if Sender = DHorseUS1 then sel := U_HORSE;
{$ENDIF}
  if sel >= 0 then begin
    DScreen.ClearHint;
    with DUserState1 do begin
      X := SurfaceX(Left + {$IFDEF UI_0508}243{$ELSE}372{$ENDIF});
      Y := SurfaceY(Top + 65);

      HintLeft := False;
      if X + 151 > SCREENWIDTH then
        HintLeft := True;

      if UserState1.UseItems[sel].s.Name <> '' then begin
        g_ShowSuite := 3;
        g_SuiteIdx := sel;
        g_MouseItem := UserState1.UseItems[sel];
        if HintLeft then begin
          GetMouseItemInfoHint(g_MouseItem, shint);
          if shint <> '' then begin
            L := DScreen.ShowHint(
              X - 209{$IFNDEF UI_0508} - 164{$ENDIF},
              Y,
              shint,
              clWhite, False, True, True, True);
          end;
          if (sel = U_HELMET) and (UserState1.UseItems[U_HELMETEX].s.Name <> '') then begin
            GetMouseItemInfoHint(UserState1.UseItems[U_HELMETEX], shint);
            if shint <> '' then begin
              DScreen.ShowHint(
                X - 209{$IFNDEF UI_0508} - 164{$ENDIF} + (MAXITEMBOX_WIDTH + 5),
                Y,
                shint,
                clWhite, False, True, True, True, 2);
            end;
          end;
        end else begin
          GetMouseItemInfoHint(g_MouseItem, shint);
          if shint <> '' then begin
            L := DScreen.ShowHint(
              X - 30,
              Y,
              shint,
              clWhite, False, False, True, True);
          end;
          if (sel = U_HELMET) and (UserState1.UseItems[U_HELMETEX].s.Name <> '') then begin
            GetMouseItemInfoHint(UserState1.UseItems[U_HELMETEX], shint);
            if shint <> '' then begin
              DScreen.ShowHint(
                X - 30 - (MAXITEMBOX_WIDTH + 5),
                Y,
                shint,
                clWhite, False, False, True, True, 2);
            end;
          end;
        end;
        g_MouseItem.s.Name := '';
      end else begin
        if HintLeft then begin
          if (sel = U_HELMET) and (UserState1.UseItems[U_HELMETEX].s.Name <> '') then begin
            GetMouseItemInfoHint(UserState1.UseItems[U_HELMETEX], shint);
            if shint <> '' then begin
              DScreen.ShowHint(
                X - 209{$IFNDEF UI_0508} - 164{$ENDIF},
                Y,
                shint,
                clWhite, False, True, True, True, 2);
            end;
          end;
        end else begin
          if (sel = U_HELMET) and (UserState1.UseItems[U_HELMETEX].s.Name <> '') then begin
            GetMouseItemInfoHint(UserState1.UseItems[U_HELMETEX], shint);
            if shint <> '' then begin
              DScreen.ShowHint(
                X - 30,
                Y,
                shint,
                clWhite, False, False, True, True, 2);
            end;
          end;
        end;
      end;
    end;
  end;

end;

procedure TFrmDlg.DCloseUS1Click(Sender: TObject; X, Y: Integer);
begin
  DUserState1.Visible := False;
end;

procedure TFrmDlg.DNecklaceUS1DirectPaint(Sender: TObject;
  dsurface: TCustomCanvas);
var
  X, Y, idx, sel, eft: Integer;
  d: TCustomLockableTexture;
begin
  sel := -1;
  eft := -1;
  if Sender = DNecklaceUS1 then begin
    sel := U_NECKLACE;
    eft := 1;
  end else if Sender = DLightUS1 then begin
    sel := U_RIGHTHAND;
    eft := 1;
  end else if Sender = DArmringRUS1 then begin
    sel := U_ARMRINGR;
    eft := 1;
  end else if Sender = DArmringLUS1 then begin
    sel := U_ARMRINGL;
    eft := 1;
  end else if Sender = DRingRUS1 then begin
    sel := U_RINGR;
    eft := 1;
  end else if Sender = DRingLUS1 then begin
    sel := U_RINGL;
    eft := 1;
  end else if Sender = DBeltUS1 then begin
    sel := U_BELT;
    eft := 1;
  end else if Sender = DBootsUS1 then begin
    sel := U_BOOTS;
    eft := 1;
{$IFNDEF UI_0508}
  end else if Sender = DDrumUS1 then begin
    sel := U_DRUM;
    eft := 1;
  end else if Sender = DHorseUS1 then begin
    sel := U_HORSE;
    eft := 1;
{$ENDIF}
  end else if Sender = DBujukUS1 then begin
    sel := U_BUJUK;
  end else if Sender = DCharmUS1 then begin
    sel := U_CHARM;
  end;
  if (sel in [0..U_FASHION]) and (UserState1.UseItems[sel].s.Name <> '') then begin
    idx := UserState1.UseItems[sel].s.looks;
    if idx >= 0 then begin
      d := frmMain.GetWStateImg(idx);
      with Sender as TDButton do begin
        if d <> nil then
          dsurface.Draw(SurfaceX(Left + (Width - d.Width) div 2),
            SurfaceY(Top + (Height - d.Height) div 2),
            d);

        if (UserState1.UseItems[sel].s.Shape = 190) or (UserState1.UseItems[sel].s.reserve[3] = 4) then begin
          if GetTickCount - UserState1Shine[sel].tick > 60 then begin
            UserState1Shine[sel].tick := GetTickCount;
            Inc(UserState1Shine[sel].idx);
            if UserState1Shine[sel].idx > 31 then
              UserState1Shine[sel].idx := 0;
          end;
          d := g_Wui.Images[180 + UserState1Shine[sel].idx];
          if d <> nil then
            dsurface.DrawBlend(
              SurfaceX(Left + (Width - d.Width) div 2),
              SurfaceY(Top + (Height - d.Height) div 2),
              d, 1);
        end else if UserState1.UseItems[sel].s.reserve[3] = 1 then begin
          if GetTickCount - UserState1Shine[sel].tick > 100 then begin
            UserState1Shine[sel].tick := GetTickCount;
            Inc(UserState1Shine[sel].idx);
            if UserState1Shine[sel].idx > 8 then
              UserState1Shine[sel].idx := 0;
          end;
          d := g_WMainImages.Images[640 + UserState1Shine[sel].idx];
          if d <> nil then
            dsurface.DrawBlend(
              SurfaceX(Left + (Width - d.Width) div 2),
              SurfaceY(Top + (Height - d.Height) div 2),
              d, 1);
        end else if UserState1.UseItems[sel].s.reserve[3] = 2 then begin
          if GetTickCount - UserState1Shine[sel].tick > 100 then begin
            UserState1Shine[sel].tick := GetTickCount;
            Inc(UserState1Shine[sel].idx);
            if UserState1Shine[sel].idx > 5 then
              UserState1Shine[sel].idx := 0;
          end;
          d := g_WMain2Images.Images[260 + UserState1Shine[sel].idx];
          if d <> nil then
            dsurface.DrawBlend(
              SurfaceX(Left + (Width - d.Width) div 2),
              SurfaceY(Top + (Height - d.Height) div 2),
              d, 1);
        end else if UserState1.UseItems[sel].s.reserve[3] = 3 then begin
          if GetTickCount - UserState1Shine[sel].tick > 100 then begin
            UserState1Shine[sel].tick := GetTickCount;
            Inc(UserState1Shine[sel].idx);
            if UserState1Shine[sel].idx > 9 then
              UserState1Shine[sel].idx := 0;
          end;
          d := g_StateEffect.Images[550 + UserState1Shine[sel].idx];
          if d <> nil then
            dsurface.DrawBlend(
              SurfaceX(Left + (Width - d.Width) div 2),
              SurfaceY(Top + (Height - d.Height) div 2),
              d, 1);
        end else if UserState1.UseItems[sel].s.reserve[3] = 5 then begin
          if GetTickCount - UserState1Shine[sel].tick > 100 then begin
            UserState1Shine[sel].tick := GetTickCount;
            Inc(UserState1Shine[sel].idx);
            if UserState1Shine[sel].idx > 9 then
              UserState1Shine[sel].idx := 0;
          end;
          d := g_WStateItemImages.Images[3910 + UserState1Shine[sel].idx];
          if d <> nil then
            dsurface.DrawBlend(
              SurfaceX(Left + (Width - d.Width) div 2),
              SurfaceY(Top + (Height - d.Height) div 2),
              d, 1);
        end else if UserState1.UseItems[sel].s.reserve[3] in [6..10] then begin
          d := g_WMain3Images.Images[750 + (UserState1.UseItems[sel].s.reserve[3] - 6) * 2];
          if d <> nil then
            dsurface.DrawBlend(
              SurfaceX(Left + (Width - d.Width) div 2),
              SurfaceY(Top + (Height - d.Height) div 2),
              d, 1);
        end else if UserState1.UseItems[sel].s.reserve[3] in [100..249] then begin //20200927看别人首饰
          if GetTickCount - UserState1Shine[sel].tick > 200 then begin
            UserState1Shine[sel].tick := GetTickCount;
            Inc(UserState1Shine[sel].idx);
            if UserState1Shine[sel].idx > 19 then
              UserState1Shine[sel].idx := 0;
          end;
          d := frmMain.GetWStateImg(30000 + (UserState1.UseItems[sel].s.reserve[3] +1 - 100) * 20-20 + UserState1Shine[sel].idx);
          if d = nil then begin
           UserState1Shine[sel].idx := 0;
            d := frmMain.GetWStateImg(30000 + (UserState1.UseItems[sel].s.reserve[3] +1 - 100) * 20-20 + UserState1Shine[sel].idx);
          end;
          if d <> nil then
            dsurface.DrawBlend(
              SurfaceX(Left + (Width - d.Width) div 2),
              SurfaceY(Top + (Height - d.Height) div 2),
              d, 1);
        end;

      end;
    end;
  end;
end;

procedure TFrmDlg.ShowGuildDlg;
begin
  DGuildDlg.Visible := True; //not DGuildDlg.Visible;
  DGuildDlg.Top := -3;
  DGuildDlg.Left := 0;
  if DGuildDlg.Visible then begin
    if GuildCommanderMode then begin
      DGDAddMem.Visible := True;
      DGDDelMem.Visible := True;
      DGDEditNotice.Visible := True;
      DGDEditGrade.Visible := True;
      DGDAlly.Visible := True;
      DGDBreakAlly.Visible := True;
      DGDWar.Visible := True;
      DGDCancelWar.Visible := True;
    end else begin
      DGDAddMem.Visible := False;
      DGDDelMem.Visible := False;
      DGDEditNotice.Visible := False;
      DGDEditGrade.Visible := False;
      DGDAlly.Visible := False;
      DGDBreakAlly.Visible := False;
      DGDWar.Visible := False;
      DGDCancelWar.Visible := False;
    end;

  end;
  GuildTopLine := 0;
end;

procedure TFrmDlg.ShowGuildEditNotice;
var
  d: TCustomLockableTexture;
  i: Integer;
  data: string;
begin
  with DGuildEditNotice do begin
    d := WLib.Images[FaceIndex];
    if d <> nil then begin
      Left := (SCREENWIDTH - d.Width) div 2;
      Top := (SCREENHEIGHT - d.Height) div 2;
    end;
    HideAllControls;
    DGuildEditNotice.ShowModal;

    Memo.Left := SurfaceX(Left + 16);
    Memo.Top := SurfaceY(Top + 36);
    Memo.Width := 571;
    Memo.Height := 246;
    Memo.Lines.Assign(GuildNotice);
    Memo.Visible := True;

    while True do begin
      if not DGuildEditNotice.Visible then Break;
      frmMain.ProcOnIdle;
      Application.ProcessMessages;
      if Application.Terminated then Exit;
    end;

    DGuildEditNotice.Visible := False;
    RestoreHideControls;

    if DMsgDlg.DialogResult = mrOk then begin
      data := '';
      for i := 0 to Memo.Lines.Count - 1 do begin
        if Memo.Lines[i] = '' then
          data := data + Memo.Lines[i] + ' '#13
        else data := data + Memo.Lines[i] + #13;
      end;
      if Length(data) > 14000 then begin
        data := Copy(data, 1, 14000);
        DMessageDlg('公告内容超过限制大小，公告内容将被截短！', [mbOk]);
      end;
      frmMain.SendGuildUpdateNotice(data);
    end;
  end;
end;

procedure TFrmDlg.ShowGuildEditGrade;
var
  d: TCustomLockableTexture;
  data: string;
  i: Integer;
begin
  if GuildMembers.Count <= 0 then begin
    DMessageDlg('请点击 [成员列表] 按钮以调出行会成员信息。', [mbOk]);
    Exit;
  end;

  with DGuildEditNotice do begin
    d := WLib.Images[FaceIndex];
    if d <> nil then begin
      Left := (SCREENWIDTH - d.Width) div 2;
      Top := (SCREENHEIGHT - d.Height) div 2;
    end;
    HideAllControls;
    DGuildEditNotice.ShowModal;

    Memo.Left := SurfaceX(Left + 16);
    Memo.Top := SurfaceY(Top + 36);
    Memo.Width := 571;
    Memo.Height := 246;
    Memo.Lines.Assign(GuildMembers);
    Memo.Visible := True;

    while True do begin
      if not DGuildEditNotice.Visible then Break;
      frmMain.ProcOnIdle;
      Application.ProcessMessages;
      if Application.Terminated then Exit;
    end;

    DGuildEditNotice.Visible := False;
    RestoreHideControls;

    if DMsgDlg.DialogResult = mrOk then begin
      //GuildMembers.Assign (Memo.Lines);
      data := '';
      for i := 0 to Memo.Lines.Count - 1 do
        data := data + Memo.Lines[i] + #13;
      if Length(data) > 15000 then begin
        data := Copy(data, 1, 15000);
        DMessageDlg('内容超过限制大小，内容将被截短！', [mbOk]);
      end;
      frmMain.SendGuildUpdateGrade(data);
    end;
  end;
end;

procedure TFrmDlg.ShowItemMarketDlg;
var
  i: Integer;
begin
  DSellDlg.Visible := False;
  boInRect := False;

  if not DItemBag.Visible then begin
    DItemBag.Left := 456;
    DItemBag.Top := 0;
    DItemBag.Visible := True;
  end;
  if not DItemMarketDlg.Visible then begin
    DItemMarketDlg.Left := 0; //10;
    DItemMarketDlg.Top := 176; //20;
    DItemMarketDlg.Visible := True;
  end;

  if g_Market.GetFirst = 1 then begin
    MenuTop := 0;
    menuindex := -1;
  end;

  DItemMarketDlg.Show;

  if g_Market.GetUserMode = 1 then begin
    DItemBuy.Visible := True;
    DItemSellCancel.Visible := False;
    DItemFind.Visible := True;
    DItemMarketDlg.EnableFocus := True;
    DEditItemFind.Visible := True;
    DEditItemFind.SetFocus;
    DlgEditText := DEditItemFind.Caption;
  end else if g_Market.GetUserMode = 2 then begin
    DItemBuy.Visible := False;
    DItemSellCancel.Visible := True;
    DItemFind.Visible := False;
    //DEditItemFind.Visible := False;
  end;
  DItemCancel.Visible := True;

  //SetImeMode(FrmDlg.DEdChat.Handle, g_LocalLanguage);
  if FrmDlg.DEdChat.Visible then FrmDlg.DEdChat.SetFocus;

  LastestClickTime := GetTickCount;

end;

procedure TFrmDlg.ShowAssistantItemFilter;
var
  d: TCustomLockableTexture;
  i, no: Integer;
  sfile: string;
  sn, so: string;
begin
  if g_Myself = nil then Exit;
  with DGuildEditNotice do begin
    d := WLib.Images[FaceIndex];
    if d <> nil then begin
      Left := (SCREENWIDTH - d.Width) div 2;
      Top := (SCREENHEIGHT - d.Height) div 2;
    end;
    DScreen.ClearHint;
    HideAllControls;
    DGuildEditNotice.ShowModal;

    sfile := '.\Config\' + g_sServerName + '.' + g_Myself.m_sUserName + '.ItemFilterEx.txt';
    Memo.Left := SurfaceX(Left + 16);
    Memo.Top := SurfaceY(Top + 36);
    Memo.Width := 571;
    Memo.Height := 246;
    GuildNotice.Clear;
    if FileExists(sfile) then
      GuildNotice.LoadFromFile(sfile)
    else
      GuildNotice.SaveToFile(sfile);
    Memo.Lines.Assign(GuildNotice);
    Memo.Visible := True;

    while True do begin
      if not DGuildEditNotice.Visible then Break;
      frmMain.ProcOnIdle;
      Application.ProcessMessages;
      if Application.Terminated then Exit;
    end;

    DGuildEditNotice.Visible := False;
    RestoreHideControls;

    if DMsgDlg.DialogResult = mrOk then begin
      g_APPickUpList.Clear;
      Memo.Lines.SaveToFile(sfile);
      for i := 0 to Memo.Lines.Count - 1 do begin
        if (Memo.Lines[i] = '') or (Memo.Lines[i][1] = ';') then Continue;
        so := GetValidStr3(Memo.Lines[i], sn, [',', ' ', #9]);
        no := Integer(so <> '');
        g_APPickUpList.AddObject(sn, TObject(no));
      end;
    end;
  end;
end;

procedure TFrmDlg.ShowAssistantMonFilter;
var
  d: TCustomLockableTexture;
  i: Integer;
  sfile: string;
begin
  if g_Myself = nil then Exit;
  with DGuildEditNotice do begin
    d := WLib.Images[FaceIndex];
    if d <> nil then begin
      Left := (SCREENWIDTH - d.Width) div 2;
      Top := (SCREENHEIGHT - d.Height) div 2;
    end;
    DScreen.ClearHint;
    HideAllControls;
    DGuildEditNotice.ShowModal;

    sfile := '.\Config\' + g_sServerName + '.' + g_Myself.m_sUserName + '.MonFilter.txt';
    Memo.Left := SurfaceX(Left + 16);
    Memo.Top := SurfaceY(Top + 36);
    Memo.Width := 571;
    Memo.Height := 246;
    GuildNotice.Clear;
    if FileExists(sfile) then
      GuildNotice.LoadFromFile(sfile)
    else
      GuildNotice.SaveToFile(sfile);
    Memo.Lines.Assign(GuildNotice);
    Memo.Visible := True;

    while True do begin
      if not DGuildEditNotice.Visible then Break;
      frmMain.ProcOnIdle;
      Application.ProcessMessages;
      if Application.Terminated then Exit;
    end;

    DGuildEditNotice.Visible := False;
    RestoreHideControls;

    if DMsgDlg.DialogResult = mrOk then begin
      g_APMobList.Clear;
      Memo.Lines.SaveToFile(sfile);
      for i := 0 to Memo.Lines.Count - 1 do begin
        if (Memo.Lines[i] = '') or (Memo.Lines[i][1] = ';') then Continue;
        g_APMobList.Add(Memo.Lines[i] {, nil});
      end;
    end;
  end;
end;

procedure TFrmDlg.DGuildDlgDirectPaint(Sender: TObject;
  dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
  i, n, bx, by, FontColor: Integer;
begin
  with DGuildDlg do begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);

    with dsurface do begin
      FontColor := clWhite;
      TextOut(Left + 320, Top + 13, Guild, FontColor);

      bx := Left + 24;
      by := Top + 41;
      for i := GuildTopLine to GuildStrs.Count - 1 do begin
        n := i - GuildTopLine;
        if n * 14 > 356 then Break;
        if Integer(GuildStrs.Objects[i]) <> 0 then
          FontColor := TColor(GuildStrs.Objects[i])
        else begin
          if BoGuildChat then
            FontColor := GetRGB(2)
          else
            FontColor := clSilver;
        end;
        TextOut(bx, by + n * 14, GuildStrs[i], FontColor);
      end;
    end;
  end;
end;

procedure TFrmDlg.DGDUpClick(Sender: TObject; X, Y: Integer);
begin
  if GuildTopLine > 0 then Dec(GuildTopLine, 3);
  if GuildTopLine < 0 then GuildTopLine := 0;
end;

procedure TFrmDlg.DGDDownClick(Sender: TObject; X, Y: Integer);
begin
  if GuildTopLine + 12 < GuildStrs.Count then Inc(GuildTopLine, 3);
end;

procedure TFrmDlg.DGDCloseClick(Sender: TObject; X, Y: Integer);
begin
  DGuildDlg.Visible := False;
  BoGuildChat := False;
end;

procedure TFrmDlg.DGDHomeClick(Sender: TObject; X, Y: Integer);
begin
  if GetTickCount > g_dwQueryMsgTick then begin
    g_dwQueryMsgTick := GetTickCount + 3000;
    frmMain.SendGuildHome;
    BoGuildChat := False;
  end;
end;

procedure TFrmDlg.DGDListClick(Sender: TObject; X, Y: Integer);
begin
  if GetTickCount > g_dwQueryMsgTick then begin
    g_dwQueryMsgTick := GetTickCount + 3000;
    frmMain.SendGuildMemberList;
    BoGuildChat := False;
  end;
end;

procedure TFrmDlg.DGDAddMemClick(Sender: TObject; X, Y: Integer);
begin
  DMessageDlg('请输入想加入' + Guild + '的人物名称：', [mbOk, mbAbort]);
  if DlgEditText <> '' then
    frmMain.SendGuildAddMem(DlgEditText);
end;

procedure TFrmDlg.DGDDelMemClick(Sender: TObject; X, Y: Integer);
begin
  DMessageDlg('请输入想要开除的人物名称：', [mbOk, mbAbort]);
  if DlgEditText <> '' then
    frmMain.SendGuildDelMem(DlgEditText);
end;

procedure TFrmDlg.DGDEditNoticeClick(Sender: TObject; X, Y: Integer);
begin
  GuildEditHint := '[修改行会公告内容。]';
  ShowGuildEditNotice;
end;

procedure TFrmDlg.DGDEditGradeClick(Sender: TObject; X, Y: Integer);
begin
  GuildEditHint := '[修改行会成员的等级和职位。 # 警告 : 不能增加行会成员/删除行会成员。]';
  ShowGuildEditGrade;
end;

procedure TFrmDlg.DGDAllyClick(Sender: TObject; X, Y: Integer);
begin
  if mrOk = DMessageDlg('对方结盟行会必需在 [允许结盟]状态下。\' +
    '而且二个行会的掌门必须面对面。\' +
    '是否确认行会结盟？', [mbOk, mbCancel]) then
    frmMain.SendSay('@联盟');
end;

procedure TFrmDlg.DGDBreakAllyClick(Sender: TObject; X, Y: Integer);
begin
  DMessageDlg('请输入您想取消结盟的行会的名字：', [mbOk, mbAbort]);
  if DlgEditText <> '' then
    frmMain.SendSay('@取消联盟 ' + DlgEditText);
end;

procedure TFrmDlg.DGuildEditNoticeDirectPaint(Sender: TObject;
  dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
begin
  with DGuildEditNotice do begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);

    with dsurface do begin
      BoldTextOut(SurfaceX(Left) + 18, SurfaceY(Top) + 291, clYellow, clBlack, GuildEditHint);
    end;
  end;
end;

procedure TFrmDlg.DGECloseClick(Sender: TObject; X, Y: Integer);
begin
  DGuildEditNotice.Visible := False;
  Memo.Visible := False;
  DMsgDlg.DialogResult := mrCancel;
end;

procedure TFrmDlg.DGEOkClick(Sender: TObject; X, Y: Integer);
begin
  DGECloseClick(Self, 0, 0);
  DMsgDlg.DialogResult := mrOk;
end;

procedure TFrmDlg.AddGuildChat(Str: string);
var
  i: Integer;
begin
  GuildChats.Add(Str);
  if GuildChats.Count > 500 then begin
    for i := 0 to 100 do
      GuildChats.Delete(0);
  end;
  if BoGuildChat then
    GuildStrs.Assign(GuildChats);
end;

procedure TFrmDlg.DGDChatClick(Sender: TObject; X, Y: Integer);
begin
  BoGuildChat := not BoGuildChat;
  if BoGuildChat then begin
    GuildStrs2.Assign(GuildStrs);
    GuildStrs.Assign(GuildChats);
  end else
    GuildStrs.Assign(GuildStrs2);
end;

procedure TFrmDlg.DGoldDirectPaint(Sender: TObject;
  dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
begin
  if g_Myself = nil then Exit;
  with DGold do begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
  end;
end;

{--------------------------------------------------------------}
//瓷仿摹 炼沥 芒

procedure TFrmDlg.DAdjustAbilCloseClick(Sender: TObject; X, Y: Integer);
begin
  DAdjustAbility.Visible := False;
  g_nBonusPoint := g_nSaveBonusPoint;
end;

procedure TFrmDlg.DAdjustAbilityDirectPaint(Sender: TObject; dsurface: TCustomCanvas);

  procedure AdjustAb(abil: Word; Val: Word; var lov, hiv: Word);
  var
    Lo, Hi: byte;
    i: Integer;
  begin
    Lo := Lobyte(abil);
    Hi := Hibyte(abil);
    lov := 0;
    hiv := 0;
    for i := 1 to Val do begin
      if Lo + 2 < Hi then begin
        Inc(Lo);
        Inc(lov);
      end else begin
        Inc(Hi);
        Inc(hiv);
      end;
    end;
  end;
var
  d: TCustomLockableTexture;
  L, M, adc, amc, asc, aac, amac, FontColor: Integer;
  ldc, lmc, lsc, lac, lmac, hdc, hmc, hsc, hac, hmac: Word;
begin
  if g_Myself = nil then Exit;
  with dsurface do begin
    with DAdjustAbility do begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    end;

    FontColor := clSilver;
    L := DAdjustAbility.SurfaceX(DAdjustAbility.Left) + 22;
    M := DAdjustAbility.SurfaceY(DAdjustAbility.Top) + 22;
    TextOut(L, M + 14 * 0, '你当前还有剩余部份的属性点未分配，可根据自己的', FontColor);
    TextOut(L, M + 14 * 1, '意向，调整其中属性值，分配后的属性点数，不可以', FontColor);
    TextOut(L, M + 14 * 2, '重新分配，所以请在分配属性点时务必要小心选择。', FontColor);

    FontColor := clWhite;
    L := DAdjustAbility.SurfaceX(DAdjustAbility.Left) + 100; //66;
    M := DAdjustAbility.SurfaceY(DAdjustAbility.Top) + 101;

    adc := (g_BonusAbilChg.DC) div g_BonusTick.DC;
    amc := (g_BonusAbilChg.MC) div g_BonusTick.MC;
    asc := (g_BonusAbilChg.SC) div g_BonusTick.SC;
    aac := (g_BonusAbilChg.AC) div g_BonusTick.AC;
    amac := (g_BonusAbilChg.MAC) div g_BonusTick.MAC;

    AdjustAb(g_NakedAbil.DC, adc, ldc, hdc);
    AdjustAb(g_NakedAbil.MC, amc, lmc, hmc);
    AdjustAb(g_NakedAbil.SC, asc, lsc, hsc);
    AdjustAb(g_NakedAbil.AC, aac, lac, hac);
    AdjustAb(g_NakedAbil.MAC, amac, lmac, hmac);

    TextOut(L + 0, M + 000, IntToStr(LoWord(g_Myself.m_Abil.DC) + ldc) + '-' + IntToStr(HiWord(g_Myself.m_Abil.DC) + hdc), FontColor);
    TextOut(L + 0, M + 020, IntToStr(LoWord(g_Myself.m_Abil.MC) + lmc) + '-' + IntToStr(HiWord(g_Myself.m_Abil.MC) + hmc), FontColor);
    TextOut(L + 0, M + 040, IntToStr(LoWord(g_Myself.m_Abil.SC) + lsc) + '-' + IntToStr(HiWord(g_Myself.m_Abil.SC) + hsc), FontColor);
    TextOut(L + 0, M + 060, IntToStr(LoWord(g_Myself.m_Abil.AC) + lac) + '-' + IntToStr(HiWord(g_Myself.m_Abil.AC) + hac), FontColor);
    TextOut(L + 0, M + 080, IntToStr(LoWord(g_Myself.m_Abil.MAC) + lmac) + '-' + IntToStr(HiWord(g_Myself.m_Abil.MAC) + hmac), FontColor);
    TextOut(L + 0, M + 100, IntToStr(g_Myself.m_Abil.MaxHP + ({g_BonusAbil.HP +} g_BonusAbilChg.HP) div g_BonusTick.HP), FontColor);
    TextOut(L + 0, M + 120, IntToStr(g_Myself.m_Abil.MaxMP + ({g_BonusAbil.MP +} g_BonusAbilChg.MP) div g_BonusTick.MP), FontColor);
    TextOut(L + 0, M + 140, IntToStr(g_nMyHitPoint + ({g_BonusAbil.Hit + } g_BonusAbilChg.Hit) div g_BonusTick.Hit), FontColor);
    TextOut(L + 0, M + 160, IntToStr(g_nMySpeedPoint + ({g_BonusAbil.Speed +} g_BonusAbilChg.Speed) div g_BonusTick.Speed), FontColor);

    FontColor := clYellow;
    TextOut(L + 0, M + 180, IntToStr(g_nBonusPoint), FontColor);

    FontColor := clWhite;
    L := DAdjustAbility.SurfaceX(DAdjustAbility.Left) + 155; //66;
    M := DAdjustAbility.SurfaceY(DAdjustAbility.Top) + 101;

    if g_BonusAbilChg.DC > 0 then FontColor := clWhite
    else FontColor := clSilver;
    TextOut(L + 0, M + 0, IntToStr(g_BonusAbilChg.DC {+ g_BonusAbil.DC}) + '/' + IntToStr(g_BonusTick.DC), FontColor);

    if g_BonusAbilChg.MC > 0 then FontColor := clWhite
    else FontColor := clSilver;
    TextOut(L + 0, M + 20, IntToStr(g_BonusAbilChg.MC {+ g_BonusAbil.MC}) + '/' + IntToStr(g_BonusTick.MC), FontColor);

    if g_BonusAbilChg.SC > 0 then FontColor := clWhite
    else FontColor := clSilver;
    TextOut(L + 0, M + 40, IntToStr(g_BonusAbilChg.SC {+ g_BonusAbil.SC}) + '/' + IntToStr(g_BonusTick.SC), FontColor);

    if g_BonusAbilChg.AC > 0 then FontColor := clWhite
    else FontColor := clSilver;
    TextOut(L + 0, M + 60, IntToStr(g_BonusAbilChg.AC {+ g_BonusAbil.AC}) + '/' + IntToStr(g_BonusTick.AC), FontColor);

    if g_BonusAbilChg.MAC > 0 then FontColor := clWhite
    else FontColor := clSilver;
    TextOut(L + 0, M + 80, IntToStr(g_BonusAbilChg.MAC {+ g_BonusAbil.MAC}) + '/' + IntToStr(g_BonusTick.MAC), FontColor);

    if g_BonusAbilChg.HP > 0 then FontColor := clWhite
    else FontColor := clSilver;
    TextOut(L + 0, M + 100, IntToStr(g_BonusAbilChg.HP {+ g_BonusAbil.HP}) + '/' + IntToStr(g_BonusTick.HP), FontColor);

    if g_BonusAbilChg.MP > 0 then FontColor := clWhite
    else FontColor := clSilver;
    TextOut(L + 0, M + 120, IntToStr(g_BonusAbilChg.MP {+ g_BonusAbil.MP}) + '/' + IntToStr(g_BonusTick.MP), FontColor);

    if g_BonusAbilChg.Hit > 0 then FontColor := clWhite
    else FontColor := clSilver;
    TextOut(L + 0, M + 140, IntToStr(g_BonusAbilChg.Hit {+ g_BonusAbil.Hit}) + '/' + IntToStr(g_BonusTick.Hit), FontColor);

    if g_BonusAbilChg.Speed > 0 then FontColor := clWhite
    else FontColor := clSilver;
    TextOut(L + 0, M + 160, IntToStr(g_BonusAbilChg.Speed {+ g_BonusAbil.Speed}) + '/' + IntToStr(g_BonusTick.Speed), FontColor);
  end;
end;
(*
procedure TFrmDlg.DPageUS1DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  i, L: Integer;
  T: TCustomLockableTexture;
begin
  with TDButton(Sender) do begin
    T := WLib.Images[FaceIndex + uStatePage];
    if T <> nil then begin
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), T);
//      L := dsurface.Canvas.Font.Size;
//      dsurface.Canvas.Font.Size := 10;
//      dsurface.Canvas.Font.Style := [fsBold];
      try
        for i := 0 to 2 do begin
          if uStatePage = i then begin
            dsurface.BoldTextOut(
              SurfaceX(Left + 18),
              SurfaceY(Top + 41 * i + 12),
              GetRGB(103), clBlack,
              g_DBStateStrArrUS[i]);
          end else begin
            dsurface.BoldTextOut(
              SurfaceX(Left + 19),
              SurfaceY(Top + 41 * i + 12),
              GetRGB(92), clBlack,
              g_DBStateStrArrUS[i]);
          end;
        end;
      finally
//        dsurface.Canvas.Font.Size := L;
//        dsurface.Canvas.Font.Style := [];
      end;
    end;
  end;
end;   *)

procedure TFrmDlg.DPageUS1DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  i, L: Integer;
  T: TCustomLockableTexture;
begin
   with TDButton(Sender) do begin
    T := WLib.Images[FaceIndex + uStatePage];
    if T <> nil then begin
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), T);
      for i := 0 to 2 do begin
          if uStatePage = i then begin
            dsurface.BoldTextOut(
              SurfaceX(Left + 6),
              SurfaceY(Top + 41 * i + 12),
              g_DBStateStrArrUS[i][1],
              GetRGB(103), clBlack, [fsBold],10);
            dsurface.BoldTextOut(
              SurfaceX(Left + 6),
              SurfaceY(Top + 41 * i + 12 + FontManager.Default.TextHeight('') + 1),
               g_DBStateStrArrUS[i][2],GetRGB(103),
              clBlack, [fsBold],10);
          end else begin
            dsurface.BoldTextOut(
              SurfaceX(Left + 6),
              SurfaceY(Top + 41 * i + 12),
              g_DBStateStrArrUS[i][1],
              GetRGB(92), clBlack, [fsBold],10);
            dsurface.BoldTextOut(
              SurfaceX(Left + 6),
              SurfaceY(Top + 41 * i + 12 + FontManager.Default.TextHeight('') + 1),
              g_DBStateStrArrUS[i][2], GetRGB(92),
              clBlack, [fsBold],10);
          end;
        end;
    end;
  end;
end;

procedure TFrmDlg.DPageUS1MouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
  OldPage: Integer;
begin
{$IFNDEF UI_0508}
  if (X > 27) or (X < 9) then Exit; //0605
  OldPage := uStatePage;
  if (Y >= 128) and (Y <= 162) then begin
    uStatePage := 0;
  end else if (Y >= 172) and (Y <= 202) then begin
    uStatePage := 1;
  end else if (Y >= 212) and (Y <= 242) then begin
    uStatePage := 2;
  end;
  if OldPage <> uStatePage then begin
    g_SndMgr.PlaySound(s_norm_button_click);
    USPageChanged;
  end;
{$ENDIF}
end;

procedure TFrmDlg.DPlusDCClick(Sender: TObject; X, Y: Integer);
var
  incp: Integer;
begin
  //EdDlgEdit.PasteFromClipboard;
  if g_nBonusPoint > 0 then begin
    if IsKeyPressed(VK_CONTROL) and (g_nBonusPoint > 10) then incp := 10
    else incp := 1;
    Dec(g_nBonusPoint, incp);
    if Sender = DPlusDC then Inc(g_BonusAbilChg.DC, incp);
    if Sender = DPlusMC then Inc(g_BonusAbilChg.MC, incp);
    if Sender = DPlusSC then Inc(g_BonusAbilChg.SC, incp);
    if Sender = DPlusAC then Inc(g_BonusAbilChg.AC, incp);
    if Sender = DPlusMAC then Inc(g_BonusAbilChg.MAC, incp);
    if Sender = DPlusHP then Inc(g_BonusAbilChg.HP, incp);
    if Sender = DPlusMP then Inc(g_BonusAbilChg.MP, incp);
    if Sender = DPlusHit then Inc(g_BonusAbilChg.Hit, incp);
    if Sender = DPlusSpeed then Inc(g_BonusAbilChg.Speed, incp);
  end;
end;

procedure TFrmDlg.DMinusDCClick(Sender: TObject; X, Y: Integer);
var
  decp: Integer;
begin
  if IsKeyPressed(VK_CONTROL) and (g_nBonusPoint - 10 > 0) then decp := 10
  else decp := 1;
  if Sender = DMinusDC then
    if g_BonusAbilChg.DC >= decp then begin
      Dec(g_BonusAbilChg.DC, decp);
      Inc(g_nBonusPoint, decp);
    end;
  if Sender = DMinusMC then
    if g_BonusAbilChg.MC >= decp then begin
      Dec(g_BonusAbilChg.MC, decp);
      Inc(g_nBonusPoint, decp);
    end;
  if Sender = DMinusSC then
    if g_BonusAbilChg.SC >= decp then begin
      Dec(g_BonusAbilChg.SC, decp);
      Inc(g_nBonusPoint, decp);
    end;
  if Sender = DMinusAC then
    if g_BonusAbilChg.AC >= decp then begin
      Dec(g_BonusAbilChg.AC, decp);
      Inc(g_nBonusPoint, decp);
    end;
  if Sender = DMinusMAC then
    if g_BonusAbilChg.MAC >= decp then begin
      Dec(g_BonusAbilChg.MAC, decp);
      Inc(g_nBonusPoint, decp);
    end;
  if Sender = DMinusHP then
    if g_BonusAbilChg.HP >= decp then begin
      Dec(g_BonusAbilChg.HP, decp);
      Inc(g_nBonusPoint, decp);
    end;
  if Sender = DMinusMP then
    if g_BonusAbilChg.MP >= decp then begin
      Dec(g_BonusAbilChg.MP, decp);
      Inc(g_nBonusPoint, decp);
    end;
  if Sender = DMinusHit then
    if g_BonusAbilChg.Hit >= decp then begin
      Dec(g_BonusAbilChg.Hit, decp);
      Inc(g_nBonusPoint, decp);
    end;
  if Sender = DMinusSpeed then
    if g_BonusAbilChg.Speed >= decp then begin
      Dec(g_BonusAbilChg.Speed, decp);
      Inc(g_nBonusPoint, decp);
    end;
end;

procedure TFrmDlg.DListBox_ItemsOnChangeSelect(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
  TmpSel: Integer;
begin

  with Sender as TDx9CustomListBox do begin
    if (FSelected in [0..5]) and (g_ptItems_Type <> FSelected) then begin
      g_ptItems_Type := FSelected;
      case g_ptItems_Type of
        0: DMoveButton_items.Max := _MAX(0, (g_ItemsFilter_All.Count div 8) + byte(g_ItemsFilter_All.Count mod 8 <> 0) - 1);
        1: DMoveButton_items.Max := _MAX(0, (g_ItemsFilter_Dress.Count div 8) + byte(g_ItemsFilter_Dress.Count mod 8 <> 0) - 1);
        2: DMoveButton_items.Max := _MAX(0, (g_ItemsFilter_Weapon.Count div 8) + byte(g_ItemsFilter_Weapon.Count mod 8 <> 0) - 1);
        3: DMoveButton_items.Max := _MAX(0, (g_ItemsFilter_Headgear.Count div 8) + byte(g_ItemsFilter_Headgear.Count mod 8 <> 0) - 1);
        4: DMoveButton_items.Max := _MAX(0, (g_ItemsFilter_Drug.Count div 8) + byte(g_ItemsFilter_Drug.Count mod 8 <> 0) - 1);
        5: DMoveButton_items.Max := _MAX(0, (g_ItemsFilter_Other.Count div 8) + byte(g_ItemsFilter_Other.Count mod 8 <> 0) - 1);
      end;

      DMoveButton_items.Position := 0;
      DMoveButton_items.UpdatePos(DMoveButton_items.Position, True);
      DMoveButton_itemsMouseMove(DMoveButton_items, [ssLeft], 0, 0);
    end;
  end;
end;

procedure TFrmDlg.DMoveButton_itemsMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  i, ii, idx: Integer;
  p, p2: pTCItemRule;
  bo: Boolean;
begin
  bo := DxEdit_Items.Caption <> '';
  if bo then begin
    FillChar(g_caItems2, SizeOf(g_caItems2), 0);
    //DMoveButton_items.UpdatePos(DMoveButton_items.Position, True);
    idx := (Sender as TDMoveButton).Position * 8;
    case g_ptItems_Type of
      0: begin
          for i := idx to idx + 7 do begin
            ii := i mod 8;
            if i >= g_ItemsFilter_All.Count then
              Break;
            p := pTCItemRule(g_ItemsFilter_All.GetValues(g_ItemsFilter_All.Keys[i]));
            g_caItems2[ii] := p;
          end;
        end;
      1: begin //服装
          for i := idx to idx + 7 do begin
            ii := i mod 8;
            if i >= g_ItemsFilter_Dress.Count then
              Break;
            p := pTCItemRule(g_ItemsFilter_Dress.Objects[i]);
            g_caItems2[ii] := p;
          end;
        end;
      2: begin //武器
          for i := idx to idx + 7 do begin
            ii := i mod 8;
            if i >= g_ItemsFilter_Weapon.Count then
              Break;
            p := pTCItemRule(g_ItemsFilter_Weapon.Objects[i]);
            g_caItems2[ii] := p;
          end;
        end;
      3: begin //武器
          for i := idx to idx + 7 do begin
            ii := i mod 8;
            if i >= g_ItemsFilter_Headgear.Count then
              Break;
            p := pTCItemRule(g_ItemsFilter_Headgear.Objects[i]);
            g_caItems2[ii] := p;
          end;
        end;
      4: begin //药品
          for i := idx to idx + 7 do begin
            ii := i mod 8;
            if i >= g_ItemsFilter_Drug.Count then
              Break;
            p := pTCItemRule(g_ItemsFilter_Drug.Objects[i]);
            g_caItems2[ii] := p;
          end;
        end;
      5: begin //其他
          for i := idx to idx + 7 do begin
            ii := i mod 8;
            if i >= g_ItemsFilter_Other.Count then
              Break;
            p := pTCItemRule(g_ItemsFilter_Other.Objects[i]);
            g_caItems2[ii] := p;
          end;
        end;
    end;
    Exit;
  end;
  g_ptItems_Pos := -1;
  FillChar(g_caItems, SizeOf(g_caItems), 0);
  FillChar(g_caItems2, SizeOf(g_caItems2), 0);
  //DMoveButton_items.UpdatePos(DMoveButton_items.Position, True);
  idx := (Sender as TDMoveButton).Position * 8;
  case g_ptItems_Type of
    0: begin
        for i := idx to idx + 7 do begin
          ii := i mod 8;
          if i >= g_ItemsFilter_All.Count then
            Break;
          p := pTCItemRule(g_ItemsFilter_All.GetValues(g_ItemsFilter_All.Keys[i]));
          g_caItems[ii] := p;
        end;
      end;
    1: begin //服装
        for i := idx to idx + 7 do begin
          ii := i mod 8;
          if i >= g_ItemsFilter_Dress.Count then
            Break;
          p := pTCItemRule(g_ItemsFilter_Dress.Objects[i]);
          g_caItems[ii] := p;
        end;
      end;
    2: begin //武器
        for i := idx to idx + 7 do begin
          ii := i mod 8;
          if i >= g_ItemsFilter_Weapon.Count then
            Break;
          p := pTCItemRule(g_ItemsFilter_Weapon.Objects[i]);
          g_caItems[ii] := p;
        end;
      end;
    3: begin //武器
        for i := idx to idx + 7 do begin
          ii := i mod 8;
          if i >= g_ItemsFilter_Headgear.Count then
            Break;
          p := pTCItemRule(g_ItemsFilter_Headgear.Objects[i]);
          g_caItems[ii] := p;
        end;
      end;
    4: begin //药品
        for i := idx to idx + 7 do begin
          ii := i mod 8;
          if i >= g_ItemsFilter_Drug.Count then
            Break;
          p := pTCItemRule(g_ItemsFilter_Drug.Objects[i]);
          g_caItems[ii] := p;
        end;
      end;
    5: begin //其他
        for i := idx to idx + 7 do begin
          ii := i mod 8;
          if i >= g_ItemsFilter_Other.Count then
            Break;
          p := pTCItemRule(g_ItemsFilter_Other.Objects[i]);
          g_caItems[ii] := p;
        end;
      end;
  end;
  for i := Low(g_caItems) to High(g_caItems) do
    g_caItems2[i] := g_caItems[i];
  //DScreen.AddChatBoardString(IntToStr(idx), clWhite, clRed);

end;

procedure TFrmDlg.DAdjustAbilOkClick(Sender: TObject; X, Y: Integer);
begin
  frmMain.SendAdjustBonus(g_nBonusPoint, g_BonusAbilChg);
  DAdjustAbility.Visible := False;
end;

procedure TFrmDlg.DAdjustAbilOkDirectPaint(Sender: TObject;
  dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
begin
  with Sender as TDButton do begin
    if Downed then begin
      d := WLib.Images[FaceIndex + 1];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    end else begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    end;
  end;
end;

procedure TFrmDlg.DAdjustAbilityMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  i, lx, ly: Integer;
  flag: Boolean;
begin
  with DAdjustAbility do begin
    lx := LocalX(X - Left);
    ly := LocalY(Y - Top);
    flag := False;
    if (lx >= 50) and (lx < 150) then
      for i := 0 to 8 do begin
        if (ly >= 98 + i * 20) and (ly < 98 + (i + 1) * 20) then begin
          DScreen.ShowHint(SurfaceX(Left) + lx + 10,
            SurfaceY(Top) + ly + 5,
            AdjustAbilHints[i],
            clWhite,
            False);
          flag := True;
          Break;
        end;
      end;
    if not flag then
      DScreen.ClearHint;
  end;
end;

procedure TFrmDlg.DBotMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  nLocalX, nLocalY: Integer;
  nHintX, nHintY: Integer;
  Butt: TDButton;
  sMsg: string;
  p: TPoint;
  showleft: Boolean;
begin
  showleft := False;
  DScreen.ClearHint;
  Butt := TDButton(Sender);
  sMsg := '';
  //DScreen.ShowHint(X, Y, IntToStr(X) + '/' + IntToStr(Y), clBlack, True);
  if g_Myself <> nil then begin
    p.X := DBottom.LocalX(X) - DBottom.Left;
    p.Y := DBottom.LocalY(Y) - DBottom.Top;
    if PtInRect(G_RC_LEVEL, p) then begin
      sMsg := Format('当前等级%d', [g_Myself.m_Abil.Level]);
      nHintX := G_RC_LEVEL.Top + DBottom.Top;
      nHintY := G_RC_LEVEL.Left;
    end else if PtInRect(G_RC_EXP, p) then begin
      if g_Myself.m_Abil.MaxExp > 0 then
        sMsg := '当前经验' + Format('%f', [g_Myself.m_Abil.Exp / g_Myself.m_Abil.MaxExp * 100]) + '%';
      nHintX := G_RC_EXP.Top + DBottom.Top;
      nHintY := G_RC_EXP.Left;
    end else if PtInRect(G_RC_WEIGTH, p) then begin
      if g_Myself.m_Abil.MaxWeight > 0 then
        sMsg := '包裹负重' + Format('%f', [g_Myself.m_Abil.Weight / g_Myself.m_Abil.MaxWeight * 100]) + '%';
      nHintX := G_RC_WEIGTH.Top + DBottom.Top;
      nHintY := G_RC_WEIGTH.Left;
    end;
    if sMsg <> '' then begin
      DScreen.ShowHint(nHintY, nHintX, sMsg, clBlack, True);
      Exit;
    end;
  end;

  nHintX := Butt.SurfaceY(Butt.Top - 2);
  nHintY := Butt.SurfaceX(Butt.Left);
  if Sender = DBVigour then begin
    if (g_nMaxSquHitPoint > 0) and (g_nSquHitPoint > 0) then
      sMsg := Format('龙影剑气 %d/%d', [g_nSquHitPoint, g_nMaxSquHitPoint]);
  end else if Sender = DButtonShop then begin
    sMsg := '商铺';
    //nHintX := Butt.SurfaceY(Butt.Top + 24);
    //nHintY := Butt.SurfaceX(Butt.Left - Butt.Width + 14);
  end else if Sender = DBAttackMode then begin
    sMsg := '左键切换';
    //if g_boHero then begin
    nHintX := Butt.SurfaceY(Butt.Top - 2);
    nHintY := Butt.SurfaceX(Butt.Left);
    DScreen.ShowHint(nHintY + 88, nHintX - 2, sMsg, clBlack, False);
    Exit;
    //end;
  end else if Sender = DBRefuseSay then begin
    sMsg := '接收公聊信息';
    showleft := True;
  end else if Sender = DBRefuseWhisper then begin
    sMsg := '拒绝私聊信息';
    showleft := True;
  end else if Sender = DBRefuseCry then begin
    sMsg := '拒绝喊话信息';
    showleft := True;
  end else if Sender = DBRefuseGuild then begin
    sMsg := '拒绝行会信息';
    showleft := True;
  end else if Sender = DBAotoSay then begin
    sMsg := '自动喊话开关';
    showleft := True;
  end else if Sender = DBCommand then begin
    sMsg := '游戏命令';
    showleft := True;
  end else if Sender = DBChatRange then begin
    sMsg := '改变大小';
  end else if Sender = DBHideChat then begin
    sMsg := '隐藏';
  end else if Sender = DBChatStatus then begin
    if not g_ChatStatusLarge then
      sMsg := '显示聊天栏'
    else
      sMsg := '隐藏聊天栏';
  end else if Sender = DBotMiniMap then begin
    sMsg := '小地图(TAB)';
  end else if Sender = DBotTrade then begin
    sMsg := '物品交易(T)';
  end else if Sender = DBotBelt then begin
    sMsg := '物品快捷栏(R)';
  end else if Sender = DBMissionOpen then begin
    sMsg := '任务日志(O)';
  end else if Sender = DMyState then begin
    sMsg := '状态信息(F10)';
  end else if Sender = DMyBag then begin
    sMsg := '包裹信息(F9)';
  end else if Sender = DMyMagic then begin
    sMsg := '技能信息(F11)';
  end else if Sender = DOption then begin
    sMsg := '声音开关';

  end else if Sender = DBotGuild then begin ////
    sMsg := '行会信息(G)';
  end else if Sender = DBotGroup then begin ////
    sMsg := '组队控制(右键开关)';
  end else if Sender = DBotFriend then begin ////
    sMsg := '关系系统';
  end else if Sender = DBotDare then begin ////
    sMsg := '聊天记录';
  end else if Sender = DBotLevelRank then begin ////
    sMsg := '排行榜';
  end else if Sender = DBotPlusAbil then begin ////
    sMsg := '属性调整';
  end else if Sender = DBotStore then begin ////
    sMsg := '摆摊';
  end else if Sender = DBotLogout then begin ////
    sMsg := '小退(ALT-X)';
  end else if Sender = DBotExit then begin ////
    sMsg := '退出(ALT-Q)';

  end else if Sender = DButtonRecallHero then begin
    sMsg := '召唤英雄';
  end else if Sender = DButtonHeroState then begin
    sMsg := '英雄状态(N)';
  end else if Sender = DButtonHeroBag then begin
    sMsg := '英雄包裹(B)';
  end;

  if sMsg <> '' then begin
    if showleft then
      DScreen.ShowHint(nHintY, nHintX, sMsg, clBlack, False, True)
    else
      DScreen.ShowHint(nHintY, nHintX, sMsg, clBlack, True);
  end;
end;

procedure TFrmDlg.DConfigDlgDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
begin
  with Sender as TDWindow do begin
    d := WLib.Images[204];
    if d <> nil then dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
  end;
  //
end;

procedure TFrmDlg.DConfigDlgCloseDirectPaint(Sender: TObject;
  dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
begin
  with Sender as TDButton do begin
    if TDButton(Sender).Downed then begin
      d := WLib.Images[64];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    end;
  end;
end;

procedure TFrmDlg.DConfigDlgOKDirectPaint(Sender: TObject;
  dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
begin
  with Sender as TDButton do begin
    if TDButton(Sender).Downed then begin
      d := WLib.Images[362];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    end;
  end;
end;

procedure TFrmDlg.DFrdFriendDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
begin
  with Sender as TDButton do begin
    if TDButton(Sender).tag = 1 then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    end;
  end;
end;

procedure TFrmDlg.DBotFriendClick(Sender: TObject; X, Y: Integer);
begin
  OpenFriendDlg();
end;

procedure TFrmDlg.OpenFriendDlg();
begin
  DFriendDlg.Visible := not DFriendDlg.Visible;
  if not DFriendDlg.Visible then Exit;
  m_nFriendsTop := 0;
  m_nBlockTop := 0;
  m_nFriendIndex := -1;
  m_nBlockIndex := -1;
  //m_nShopItemIndex := -1;
  //m_nShopItemIndex2 := -1;
end;

procedure TFrmDlg.DFrdCloseClick(Sender: TObject; X, Y: Integer);
begin
  OpenFriendDlg();
end;

procedure TFrmDlg.DGameShopCloseClick(Sender: TObject; X, Y: Integer);
begin
  DGameShop.Visible := False;
end;

procedure TFrmDlg.DGameShopDirectPaint(Sender: TObject;
  dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
  lx, ly, sX: Integer;
begin
  with Sender as TDWindow do begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    if (g_ShopListArr[m_nShopClass] <> nil) and (g_ShopListArr[m_nShopClass].Count > 0) then
      dsurface.BoldTextOut(
        SurfaceX(Left + 230),
        SurfaceY(Top + 351),
        clSilver, clBlack, Format('(%d/%d 页)', [m_nShopPage + 1, (g_ShopListArr[m_nShopClass].Count + 9) div 10]));
  end;
end;

procedure TFrmDlg.DButtonRecallHeroDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TDButton;
  dd: TCustomLockableTexture;
begin
  if Sender is TDButton then begin
    d := TDButton(Sender);
    if d.Downed then begin
      dd := d.WLib.Images[d.FaceIndex];
      if dd <> nil then
        dsurface.Draw(d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, True);
    end;
  end;
end;

procedure TFrmDlg.LoadMySelfConfig();
var
  s: string;
begin
  if not g_boConfigLoaded then begin
    g_boConfigLoaded := True;
    s := '.\Config\' + g_sServerName + '.' + frmMain.m_sCharName + '.Friends.txt';
    if FileExists(s) then
      m_FriendsList.LoadFromFile(s);
    s := '.\Config\' + g_sServerName + '.' + frmMain.m_sCharName + '.BlackList.txt';
    if FileExists(s) then
      m_BlockList.LoadFromFile(s);
  end;
end;

procedure TFrmDlg.DFrdFriendClick(Sender: TObject; X, Y: Integer);
begin
  if not DFriendDlg.Visible then Exit;
  if Sender = DFrdFriend then begin
    DFriendDlg.tag := 0;
    DFrdFriend.tag := 1;
    DFrdMaster.tag := 0;
    DFrdBlackList.tag := 0;
    DFrdMemo.Visible := False;
  end else if Sender = DFrdMaster then begin
    DFriendDlg.tag := 1;
    DFrdFriend.tag := 0;
    DFrdMaster.tag := 1;
    DFrdBlackList.tag := 0;
    DFrdMemo.Visible := True;
  end else if Sender = DFrdBlackList then begin
    DFriendDlg.tag := 2;
    DFrdFriend.tag := 0;
    DFrdMaster.tag := 0;
    DFrdBlackList.tag := 1;
    DFrdMemo.Visible := False;
  end;
end;

procedure TFrmDlg.DFriendDlgDirectPaint(Sender: TObject; dsurface: TCustomCanvas);

  function sX(X: Integer): Integer;
  begin
    Result := DFriendDlg.SurfaceX(DFriendDlg.Left + X);
  end;

  function sY(Y: Integer): Integer;
  begin
    Result := DFriendDlg.SurfaceY(DFriendDlg.Top + Y);
  end;
var
  i, lh, k, M, nLine, FontColor: Integer;
  d: TCustomLockableTexture;
  Str: string;
begin
  if g_Myself = nil then Exit;
  with dsurface do begin
    with DFriendDlg do begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    end;
    FontColor := clWhite;
    lh := LISTLINEHEIGHT;

    if DFriendDlg.tag = 0 then begin
      nLine := _MIN(FRIENDMAXMENU, m_FriendsList.Count - m_nFriendsTop);
      for i := m_nFriendsTop to m_nFriendsTop + nLine - 1 do begin
        M := i - m_nFriendsTop;
        if i = m_nFriendIndex then begin
          FontColor := clRed;
        end else
          FontColor := clWhite;
        TextOut(sX(40), sY(50 + M * lh), m_FriendsList[i], FontColor);
      end;
    end else if DFriendDlg.tag = 2 then begin
      nLine := _MIN(FRIENDMAXMENU, m_BlockList.Count - m_nBlockTop);
      for i := m_nBlockTop to m_nBlockTop + nLine - 1 do begin
        M := i - m_nBlockTop;
        if i = m_nBlockIndex then begin
          FontColor := clRed;
        end else
          FontColor := clWhite;
        TextOut(sX(40), sY(50 + M * lh), m_BlockList[i], FontColor);
      end;
    end;
  end;
end;

procedure TFrmDlg.DFriendDlgClick(Sender: TObject; X, Y: Integer);
var
  lx, ly, idx: Integer;
begin
  DScreen.ClearHint;
  lx := DFriendDlg.LocalX(X) - DFriendDlg.Left;
  ly := DFriendDlg.LocalY(Y) - DFriendDlg.Top;
  if (lx >= 42) and (lx <= 140) and (ly >= 50) then begin
    if DFriendDlg.tag = 0 then begin
      idx := (ly - 50) div LISTLINEHEIGHT + m_nFriendsTop;
      if idx < m_FriendsList.Count then
        m_nFriendIndex := idx;
    end else if DFriendDlg.tag = 2 then begin
      idx := (ly - 50) div LISTLINEHEIGHT + m_nBlockTop;
      if idx < m_BlockList.Count then
        m_nBlockIndex := idx;
    end;
  end;
end;

procedure TFrmDlg.DFriendDlgDblClick(Sender: TObject);
begin
  if DFriendDlg.tag = 0 then begin
    if (m_nFriendIndex >= 0) and (m_nFriendIndex < m_FriendsList.Count) then begin
      if m_FriendsList.Strings[m_nFriendIndex] <> '' then begin
        g_SndMgr.PlaySound(s_glass_button_click);
        FrmDlg.DEdChat.Visible := True;
        FrmDlg.DEdChat.SetFocus;
        //SetImeMode(FrmDlg.DEdChat.Handle, g_LocalLanguage);
        FrmDlg.DEdChat.Text := '/' + m_FriendsList.Strings[m_nFriendIndex] + ' ';
        FrmDlg.DEdChat.ChangeCurPos(AnsiTextLength(FrmDlg.DEdChat.Text), True);
        FrmDlg.DEdChat.SelLength := 0;
      end;
    end;
  end else if DFriendDlg.tag = 2 then begin
    if (m_nBlockIndex >= 0) and (m_nBlockIndex < m_BlockList.Count) then begin
      if m_BlockList.Strings[m_nBlockIndex] <> '' then begin
        g_SndMgr.PlaySound(s_glass_button_click);
        FrmDlg.DEdChat.Visible := True;
        FrmDlg.DEdChat.SetFocus;
        //SetImeMode(FrmDlg.DEdChat.Handle, g_LocalLanguage);
        FrmDlg.DEdChat.Text := '/' + m_BlockList.Strings[m_nBlockIndex] + ' ';
        FrmDlg.DEdChat.ChangeCurPos(AnsiTextLength(FrmDlg.DEdChat.Text), True);
        FrmDlg.DEdChat.SelLength := 0;
      end;
    end;
  end;
end;

procedure TFrmDlg.DFrdPgDnClick(Sender: TObject; X, Y: Integer);
begin
  if DFriendDlg.tag = 0 then begin
    if m_nFriendsTop > 0 then Dec(m_nFriendsTop, FRIENDMAXMENU - 1);
    if m_nFriendsTop < 0 then m_nFriendsTop := 0;
  end else if DFriendDlg.tag = 2 then begin
    if m_nBlockTop > 0 then Dec(m_nBlockTop, FRIENDMAXMENU - 1);
    if m_nBlockTop < 0 then m_nBlockTop := 0;
  end;
end;

procedure TFrmDlg.DFrdPgUpClick(Sender: TObject; X, Y: Integer);
begin
  if DFriendDlg.tag = 0 then begin
    if m_nFriendsTop + FRIENDMAXMENU < m_FriendsList.Count then
      Inc(m_nFriendsTop, FRIENDMAXMENU - 1);
  end else if DFriendDlg.tag = 2 then begin
    if m_nBlockTop + FRIENDMAXMENU < m_BlockList.Count then
      Inc(m_nBlockTop, FRIENDMAXMENU - 1);
  end;
end;

procedure TFrmDlg.DFrdSave();
begin
  if (FrmDlg.m_FriendsList.Text <> '') and (g_Myself <> nil) then
    FrmDlg.m_FriendsList.SaveToFile('.\Config\' + g_sServerName + '.' + g_Myself.m_sUserName + '.Friends.txt');
  if (FrmDlg.m_BlockList.Text <> '') and (g_Myself <> nil) then
    FrmDlg.m_BlockList.SaveToFile('.\Config\' + g_sServerName + '.' + g_Myself.m_sUserName + '.BlackList.txt');
end;

procedure TFrmDlg.DFrdAddClick(Sender: TObject; X, Y: Integer);
var
  sName: string[14];
begin
  if DFriendDlg.tag = 0 then begin
    FrmDlg.DMessageDlg('添加新的好友:', [mbOk, mbAbort]);
    sName := Trim(FrmDlg.DlgEditText);
    if sName <> '' then begin
      m_FriendsList.Add(sName);
      DFrdSave();
    end;
  end else if DFriendDlg.tag = 2 then begin
    FrmDlg.DMessageDlg('添加新的黑名单:', [mbOk, mbAbort]);
    sName := Trim(FrmDlg.DlgEditText);
    if sName <> '' then begin
      m_BlockList.Add(sName);
      DFrdSave();
    end;
  end;
end;

procedure TFrmDlg.DFrdDelClick(Sender: TObject; X, Y: Integer);
begin
  if DFriendDlg.tag = 0 then begin
    if (m_nFriendIndex >= 0) and (m_nFriendIndex < m_FriendsList.Count) then
      if FrmDlg.DMessageDlg(Format('是否确认删除 %s ？', [m_FriendsList[m_nFriendIndex]]), [mbOk, mbCancel]) = mrOk then begin
        m_FriendsList.Delete(m_nFriendIndex);
        DFrdSave();
      end;
  end else if DFriendDlg.tag = 2 then begin
    if (m_nBlockIndex >= 0) and (m_nBlockIndex < m_BlockList.Count) then
      if FrmDlg.DMessageDlg(Format('是否确认删除 %s ？', [m_BlockList[m_nBlockIndex]]), [mbOk, mbCancel]) = mrOk then begin
        m_BlockList.Delete(m_nBlockIndex);
        DFrdSave();
      end;
  end;
end;

procedure TFrmDlg.DButtonShopClick(Sender: TObject; X, Y: Integer);
var
  msg: TDefaultMessage;
begin
  if g_Myself = nil then Exit;
  //msg := MakeDefaultMsg(CM_MERCHANTDLGSELECT, g_nCurMerchant, 0, 0, 0);
  //frmmain.SendSocket(EncodeMessage(msg) + EncodeString(DEdChat.Text));
  //exit;

  DGameShop.Visible := not DGameShop.Visible;
  if DGameShop.Visible then begin
    if g_Myself.m_boFisrShopItem then begin
      g_Myself.m_boFisrShopItem := False;
      DButtonShop1Click(DButtonShop1, X, Y);
    end else begin
      //
    end;
  end;
end;

procedure TFrmDlg.DButtonShop1Click(Sender: TObject; X, Y: Integer);
begin
  if not DGameShop.Visible then Exit;
  g_ClickShopItem.sItemName := '';
  DButtonShop1.tag := 0;
  DButtonShop2.tag := 0;
  DButtonShop3.tag := 0;
  DButtonShop4.tag := 0;
  DButtonShop5.tag := 0;
  m_nShopPage := 0;
  m_nShopItemIndex := -1;
  if Sender = DButtonShop1 then begin
    DButtonShop1.tag := 1;
    m_nShopClass := 0;
  end else if Sender = DButtonShop2 then begin
    DButtonShop2.tag := 1;
    m_nShopClass := 1;
  end else if Sender = DButtonShop3 then begin
    DButtonShop3.tag := 1;
    m_nShopClass := 2;
  end else if Sender = DButtonShop4 then begin
    DButtonShop4.tag := 1;
    m_nShopClass := 3;
  end else if Sender = DButtonShop5 then begin
    DButtonShop5.tag := 1;
    m_nShopClass := 4;
  end;
  if g_Myself <> nil then begin
    frmMain.SendClientMessage(CM_GETSHOPITEM, 0, 0, 0, 0);
    frmMain.SendClientMessage(CM_GETSHOPITEM, m_nShopClass, 0, 0, 0);
  end;
end;

procedure TFrmDlg.DButtonShop6Click(Sender: TObject; X, Y: Integer);
begin
  if (g_ClickShopItem.sItemName <> '') then begin
    if FrmDlg.DMessageDlg(Format('是否确认购买 %s ？', [g_ClickShopItem.sItemName]), [mbOk, mbCancel]) = mrOk then
      frmMain.SendShoping(g_ClickShopItem.sItemName);
  end;
end;

procedure TFrmDlg.DButtonShop7Click(Sender: TObject; X, Y: Integer);
var
  sWho: string;
begin
  if (g_ClickShopItem.sItemName <> '') and (g_Myself <> nil) then begin
    DMessageDlg('请输入赠送人的名称:', [mbOk, mbAbort]);
    sWho := Trim(DlgEditText);
    if (sWho = '') then Exit;
    if (Length(sWho) > 14) or (sWho = g_Myself.m_sUserName) then begin
      DMessageDlg('赠送人名称输入有误！', [mbOk]);
      Exit;
    end;
    if FrmDlg.DMessageDlg(Format('是否确认购买 %s 赠送给 %s ？', [g_ClickShopItem.sItemName, sWho]), [mbOk, mbCancel]) = mrOk then
      frmMain.SendPresend(sWho, g_ClickShopItem.sItemName);
  end;
end;

procedure TFrmDlg.DButtonShop8Click(Sender: TObject; X, Y: Integer);
begin
  DGameShop.Visible := False;
end;

procedure TFrmDlg.DGridShop1GridPaint(Sender: TObject; ACol, ARow: Integer; Rect: TRect; State: TGridDrawState; dsurface: TCustomCanvas);
var
  idx, FontColor: Integer;
  sDesc, s, ss: string;
  pShopItem: pTShopItem;
  d: TCustomLockableTexture;
begin
  if not DGameShop.Visible then Exit;
  if g_ShopListArr[m_nShopClass].Count <= 0 then Exit;
  idx := ACol + ARow * DGridShop1.ColCount + m_nShopPage * 10;
  if (idx >= 0) and (idx < g_ShopListArr[m_nShopClass].Count) then begin
    pShopItem := pTShopItem(g_ShopListArr[m_nShopClass].Items[idx]);
    //d := g_WBagItemImages.Images[pShopItem.wLooks];
    d := frmMain.GetWBagItemImg(pShopItem.wLooks);
    if d <> nil then
      with DGridShop1 do begin
        dsurface.Draw(SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1 - 62), SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1), d.ClientRect, d, True);
        ss := GetValidStr3(pShopItem.sExplain, s, ['|']);
        if m_nShopItemIndex = idx then begin
          FontColor := clWhite;
          idx := 0;
          while True do begin
            if ss = '' then
              Break;
            ss := GetValidStr3(ss, sDesc, ['|']);
            if sDesc <> '' then
              dsurface.TextOut(SurfaceX(Left - 156), SurfaceY(Top + 198) + 15 * idx, sDesc, FontColor)
            else
              Break;
            Inc(idx);
          end;
          FontColor := clRed;
        end else
          FontColor := clWhite;
        dsurface.TextOut(SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 + 44 - 62), SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 - 6), pShopItem.sItemName, FontColor);
        dsurface.TextOut(SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 + 44 - 62), SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 - 6) + 15 * 1, s, FontColor);
        if g_btSellType = 0 then
          dsurface.TextOut(SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 + 44 - 62), SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 - 6) + 15 * 2, IntToStr(pShopItem.wPrice) + '元宝', FontColor)
        else
          dsurface.TextOut(SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 + 44 - 62), SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 - 6) + 15 * 2, IntToStr(pShopItem.wPrice) + '金币', FontColor);
      end;
  end;
end;

procedure TFrmDlg.DGridShop1GridSelect(Sender: TObject; X, Y, ACol,
  ARow: Integer; Shift: TShiftState);
var
  idx: Integer;
  s: string;
  d: TCustomCanvas;
begin
  g_ClickShopItem.sItemName := '';
  if g_ShopListArr[m_nShopClass].Count <= 0 then Exit;
  idx := ACol + ARow * DGridShop1.ColCount + m_nShopPage * 10;
  if (idx >= 0) and (idx < g_ShopListArr[m_nShopClass].Count) then begin
    g_ClickShopItem := pTShopItem(g_ShopListArr[m_nShopClass].Items[idx])^;
    m_nShopItemIndex := idx;
    m_nShopItemIndex2 := -1;

    m_dwShopEffectTick := GetTickCount + 200;
    m_nShopShowMaxFrame := g_ClickShopItem.wShape2;
    m_nShopShowEffectFrame := g_ClickShopItem.wShape1;
    m_nShopShowCurrentFrame := g_ClickShopItem.wShape1;

    g_SndMgr.PlaySound(s_glass_button_click);
  end;
end;

procedure TFrmDlg.DButtonShop9Click(Sender: TObject; X, Y: Integer);
begin
  if m_nShopPage > 0 then begin
    Dec(m_nShopPage);
    g_ClickShopItem.sItemName := '';
  end;
end;

procedure TFrmDlg.DButtonShop10Click(Sender: TObject; X, Y: Integer);
begin
  if m_nShopPage < (g_ShopListArr[m_nShopClass].Count + 9) div 10 - 1 then begin
    Inc(m_nShopPage);
    g_ClickShopItem.sItemName := '';
  end;
end;

procedure TFrmDlg.DGridShop2GridPaint(Sender: TObject; ACol, ARow: Integer; Rect: TRect; State: TGridDrawState; dsurface: TCustomCanvas);
var
  idx, FontColor: Integer;
  sDesc, s, ss: string;
  pShopItem: pTShopItem;
  d: TCustomLockableTexture;
begin
  if not DGameShop.Visible then Exit;
  if g_ShopListArr[5].Count <= 0 then Exit;
  idx := ACol + ARow * DGridShop2.ColCount;
  if (idx >= 0) and (idx < g_ShopListArr[5].Count) then begin
    pShopItem := pTShopItem(g_ShopListArr[5].Items[idx]);
    //d := g_WBagItemImages.Images[pShopItem.wLooks];
    d := frmMain.GetWBagItemImg(pShopItem.wLooks);
    if d <> nil then
      with DGridShop2 do begin
        dsurface.Draw(SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 + 12), SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 - 16), d.ClientRect, d, True);
        ss := GetValidStr3(pShopItem.sExplain, s, ['|']);
        if m_nShopItemIndex2 = idx then begin
          FontColor := clWhite;
          idx := 0;
          while True do begin
            if ss = '' then
              Break;
            ss := GetValidStr3(ss, sDesc, ['|']);
            if sDesc <> '' then
              dsurface.TextOut(DGridShop1.SurfaceX(DGridShop1.Left - 156), DGridShop1.SurfaceY(DGridShop1.Top + 198) + 15 * idx, sDesc, FontColor)
            else
              Break;
            Inc(idx);
          end;
          FontColor := clRed;
        end else
          FontColor := clWhite;
        dsurface.TextOut(SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 + 44 - 65), SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 17), pShopItem.sItemName, FontColor);
        if g_btSellType = 0 then
          dsurface.TextOut(SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 + 44 - 65), SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 17) + 12 * 1, IntToStr(pShopItem.wPrice) + '元宝', FontColor)
        else
          dsurface.TextOut(SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 + 44 - 65), SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 17) + 12 * 1, IntToStr(pShopItem.wPrice) + '金币', FontColor);
      end;
  end;
end;

procedure TFrmDlg.DGridShop2GridSelect(Sender: TObject; X, Y, ACol, ARow: Integer; Shift: TShiftState);
var
  idx: Integer;
  s: string;
  d: TCustomCanvas;
begin
  g_ClickShopItem.sItemName := '';
  if g_ShopListArr[5].Count <= 0 then Exit;
  idx := ACol + ARow * DGridShop2.ColCount;
  if (idx >= 0) and (idx < g_ShopListArr[5].Count) then begin
    g_ClickShopItem := pTShopItem(g_ShopListArr[5].Items[idx])^;
    m_nShopItemIndex := -1;
    m_nShopItemIndex2 := idx;

    m_dwShopEffectTick := GetTickCount + 200;
    m_nShopShowMaxFrame := g_ClickShopItem.wShape2;
    m_nShopShowEffectFrame := g_ClickShopItem.wShape1;
    m_nShopShowCurrentFrame := g_ClickShopItem.wShape1;

    g_SndMgr.PlaySound(s_glass_button_click);
  end;
end;

procedure TFrmDlg.DGridStoreGridMouseMove(Sender: TObject; X, Y, ACol, ARow: Integer; Shift: TShiftState);
var
  idx, itemidx: Integer;
  temp: TClientItem;
  shint: string;
  useable: Boolean;
  hcolor: TColor;
begin
  if not DWHeroStore.Visible then Exit;
  DScreen.ClearHint;
  idx := ACol + ARow * TDGrid(Sender).ColCount;
  if idx in [0..10 - 1] then begin
    g_MouseItem := g_Myself.m_StallMgr.mBlock.Items[idx];
    if g_MovingItem.item.s.Name = '' then begin
      itemidx := GetItemWhere(g_MouseItem);
      if itemidx in [0..U_FASHION] then begin
        g_ShowSuite := 1;
        g_SuiteIdx := itemidx;
      end;
      GetMouseItemInfoHint(g_MouseItem, shint);
      //if not useable then Font.Color := clRed;
      if shint <> '' then begin
        with TDGrid(Sender) do begin
          if g_MouseItem.s.NeedIdentify = 4 then
            shint := shint + '\<售价: ' + GetGoldStr(g_MouseItem.s.Price) + '金币|c=$FF00>'
          else if g_MouseItem.s.NeedIdentify = 5 then
            shint := shint + '\<售价: ' + GetGoldStr(g_MouseItem.s.Price) + '元宝|C=clYellow>';
          DScreen.ShowHint(
            SurfaceX(Left + (ACol) * 38),
            SurfaceY(Top + (ARow + 1) * 36),
            shint,
            clWhite, False, False, True, True);
        end;
      end;
      g_MouseItem.s.Name := '';
    end;
  end;
end;

procedure TFrmDlg.DGridStoreGridPaint(Sender: TObject; ACol, ARow: Integer; Rect: TRect; State: TGridDrawState; dsurface: TCustomCanvas);
var
  n, idx: Integer;
  d: TCustomLockableTexture;
begin
  if not DWHeroStore.Visible then Exit;
  idx := ACol + ARow * DGridStore.ColCount;
  if idx in [0..10 - 1] then begin
    if g_Myself.m_StallMgr.mBlock.Items[idx].s.Name <> '' then begin
      if (g_Myself.m_StallMgr.mBlock.Items[idx].s.Overlap < 1) or ((g_Myself.m_StallMgr.mBlock.Items[idx].s.Overlap > 0) and (g_Myself.m_StallMgr.mBlock.Items[idx].Dura > 0)) then begin

        d := frmMain.GetWBagItemImg(g_Myself.m_StallMgr.mBlock.Items[idx].s.looks);
        if d <> nil then
          with DGridStore do
            dsurface.Draw(SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
              SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
              d.ClientRect,
              d, True);
        if g_Myself.m_StallMgr.mBlock.Items[idx].s.Overlap > 0 then begin
          dsurface.BoldTextOut(
            DGridStore.SurfaceX(Rect.Left + 33 - FontManager.Default.TextWidth(IntToStr(g_Myself.m_StallMgr.mBlock.Items[idx].Dura))),
            DGridStore.SurfaceY(Rect.Top + 20),
            clWhite, clBlack, IntToStr(g_Myself.m_StallMgr.mBlock.Items[idx].Dura));
        end;
      end;
      if (g_Myself.m_StallMgr.mBlock.Items[idx].s.StdMode in [5,6,10,11,15..24, 26..30]) then begin
        if (g_Myself.m_StallMgr.mBlock.Items[idx].s.Shape = 190) or (g_Myself.m_StallMgr.mBlock.Items[idx].s.reserve[3] = 4) then begin
          if GetTickCount - g_StallItemArrShine[idx].tick > 60 then begin
            g_StallItemArrShine[idx].tick := GetTickCount;
            Inc(g_StallItemArrShine[idx].idx);
            if g_StallItemArrShine[idx].idx > 31 then
              g_StallItemArrShine[idx].idx := 0;
          end;
          n := -1;
          d := nil;
          case g_Myself.m_StallMgr.mBlock.Items[idx].s.StdMode of
            30: n := 6;
            19, 20, 21: n := 2;
            15: n := 3;
            24, 25, 26: n := 0;
            22, 23: n := 1;
            27: n := 5;
            28: n := 4
          end;
          if n >= 0 then
            d := g_Wui.Images[100 + n * 40 + g_StallItemArrShine[idx].idx];

          //d := g_Wui.Images[100 + (g_Myself.m_StallMgr.mBlock.Items[idx].s.looks - 2130) * 40 + g_StallItemArrShine[idx].idx];
          if d <> nil then
            with DGridStore do
              dsurface.DrawBlend(
                SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                d, 1);
        end else if g_Myself.m_StallMgr.mBlock.Items[idx].s.reserve[3] = 1 then begin
          n := 0;
          if g_Myself.m_StallMgr.mBlock.Items[idx].s.StdMode in [15, 16] then
            n := 2;
          if GetTickCount - g_StallItemArrShine[idx].tick > 100 then begin
            g_StallItemArrShine[idx].tick := GetTickCount;
            Inc(g_StallItemArrShine[idx].idx);
            if g_StallItemArrShine[idx].idx > (8 + n) then
              g_StallItemArrShine[idx].idx := 0;
          end;
          d := g_WMainImages.Images[(640 - n * 10) + g_StallItemArrShine[idx].idx];
          if d <> nil then
            with DGridStore do
              dsurface.DrawBlend(
                SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                d, 1);
        end else if g_Myself.m_StallMgr.mBlock.Items[idx].s.reserve[3] = 2 then begin
          if GetTickCount - g_StallItemArrShine[idx].tick > 100 then begin
            g_StallItemArrShine[idx].tick := GetTickCount;
            Inc(g_StallItemArrShine[idx].idx);
            if g_StallItemArrShine[idx].idx > 5 then
              g_StallItemArrShine[idx].idx := 0;
          end;
          d := g_WMain2Images.Images[260 + g_StallItemArrShine[idx].idx];
          if d <> nil then
            with DGridStore do
              dsurface.DrawBlend(
                SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                d, 1);
        end else if g_Myself.m_StallMgr.mBlock.Items[idx].s.reserve[3] = 3 then begin
          if GetTickCount - g_StallItemArrShine[idx].tick > 100 then begin
            g_StallItemArrShine[idx].tick := GetTickCount;
            Inc(g_StallItemArrShine[idx].idx);
            if g_StallItemArrShine[idx].idx > 9 then
              g_StallItemArrShine[idx].idx := 0;
          end;
          n := -1;
          d := nil;
          case g_Myself.m_StallMgr.mBlock.Items[idx].s.StdMode of
            30: n := 6;
            19, 20, 21: n := 2;
            15: n := 5;
            24, 25, 26: n := 1;
            22, 23: n := 0;
            27: n := 4;
            28: n := 3;
          end;
          if n >= 0 then
            d := g_StateEffect.Images[530 + n * 10 + g_StallItemArrShine[idx].idx];
          //d := g_StateEffect.Images[530 + (g_Myself.m_StallMgr.mBlock.Items[idx].s.looks - 2410) * 10 + g_StallItemArrShine[idx].idx];
          if d <> nil then
            with DGridStore do
              dsurface.DrawBlend(
                SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                d, 1);
        end else if g_Myself.m_StallMgr.mBlock.Items[idx].s.reserve[3] = 5 then begin
          if GetTickCount - g_StallItemArrShine[idx].tick > 100 then begin
            g_StallItemArrShine[idx].tick := GetTickCount;
            Inc(g_StallItemArrShine[idx].idx);
            if g_StallItemArrShine[idx].idx > 9 then
              g_StallItemArrShine[idx].idx := 0;
          end;
          d := g_WStateItemImages.Images[3910 + g_StallItemArrShine[idx].idx];
          if d <> nil then
            with DGridStore do
             dsurface.DrawBlend(
                SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                d, 1);
        end else if g_Myself.m_StallMgr.mBlock.Items[idx].s.reserve[3] in [6..10] then begin
          d := g_WMain3Images.Images[750 + (g_Myself.m_StallMgr.mBlock.Items[idx].s.reserve[3] - 6) * 2];
          if d <> nil then
            with DGridStore do
              dsurface.DrawBlend(
                SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                d, 1);
        end else if g_Myself.m_StallMgr.mBlock.Items[idx].s.reserve[3] in [100..249] then begin  //20200927看自己摆摊
          if GetTickCount - g_StallItemArrShine[idx].tick > 100 then begin
            g_StallItemArrShine[idx].tick := GetTickCount;
            Inc(g_StallItemArrShine[idx].idx);
            if g_StallItemArrShine[idx].idx > 19 then
              g_StallItemArrShine[idx].idx := 0;
          end;
            d := frmMain.GetWBagItemImg(20000 + (g_Myself.m_StallMgr.mBlock.Items[idx].s.reserve[3] +1 - 100) * 20-20 + g_StallItemArrShine[idx].idx);
            if d = nil then begin
             g_StallItemArrShine[idx].idx := 0;
              d := frmMain.GetWBagItemImg(20000 + (g_Myself.m_StallMgr.mBlock.Items[idx].s.reserve[3] +1 - 100) * 20-20 + g_StallItemArrShine[idx].idx);
            end;
          if d <> nil then
            with DGridStore do
             dsurface.DrawBlend(
                SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                d, 1);
        end;

      end;
    end;
  end;
end;

procedure TFrmDlg.DGridStoreGridSelect(Sender: TObject; X, Y, ACol, ARow: Integer; Shift: TShiftState);
var
  idx, mi: Integer;
  temp: TClientItem;
  MsgResult, Count: Integer;
  valstr: string;
  keyvalue: TKeyBoardState;
begin
  if DGridStore.OnButton = mbLeft then begin
    FillChar(keyvalue, SizeOf(TKeyBoardState), #0);
    GetKeyboardState(keyvalue);
    idx := ACol + ARow * DGridStore.ColCount;
    if idx in [0..10 - 1] then begin
      if not g_boItemMoving then begin
        if g_Myself.m_StallMgr.mBlock.Items[idx].s.Name <> '' then begin
          g_boItemMoving := True;
          g_MovingItem.Index := idx + STALL_MIIDX_OFFSET;
          g_MovingItem.item := g_Myself.m_StallMgr.mBlock.Items[idx];
          g_Myself.m_StallMgr.mBlock.Items[idx].s.Name := '';
          g_SndMgr.ItemClickSound(g_Myself.m_StallMgr.mBlock.Items[idx].s);
        end;
      end else begin //temMoving
        mi := g_MovingItem.Index;
        //DScreen.AddChatBoardString(IntToStr(mi) + ' - ' + g_MovingItem.item.s.Name, clWhite, clRed);
        if g_MovingItem.item.s.Name <> '' then begin
          if mi in [6..MAXBAGITEM - 1] then begin
            if CanAddStallItem() then begin
              //if not g_Myself.m_StallMgr.OnSale or (g_WaitingStallItem.item.s.Name = '') then begin
              g_WaitingStallItem := g_MovingItem;
              CancelItemMoving;
              DxEditStoreItemPrice.Text := '';
              DWStoreItemPrice.Visible := True;
              DxEditStoreItemPrice.SetFocus;
              //end;
            end else begin
              DMessageDlg('摊位已满，无法继续添加物品！', [mbOk, mbCancel]);
            end;
          end else if IsStallItem(mi) then begin
            AddStallItem(g_MovingItem.item);
            g_boItemMoving := False;
            g_MovingItem.item.s.Name := '';
          end;
        end;
      end;
    end;
    //ArrangeItembag;
  end;
end;

procedure TFrmDlg.DGridUserStallGridMouseMove(Sender: TObject; X, Y, ACol, ARow: Integer; Shift: TShiftState);
var
  idx, itemidx: Integer;
  temp: TClientItem;
  shint: string;
  useable: Boolean;
  hcolor: TColor;
begin
  if not DWUserStall.Visible then Exit;
  DScreen.ClearHint;
  if not g_Myself.m_StallMgr.DoShop then Exit;
  idx := ACol + ARow * TDGrid(Sender).ColCount;
  if idx in [0..10 - 1] then begin
    g_MouseItem := g_Myself.m_StallMgr.uBlock.Items[idx];
    if g_MovingItem.item.s.Name = '' then begin
      itemidx := GetItemWhere(g_MouseItem);
      if itemidx in [0..U_FASHION] then begin
        g_ShowSuite := 1;
        g_SuiteIdx := itemidx;
      end;
      GetMouseItemInfoHint(g_MouseItem, shint);
      //if not useable then Font.Color := clRed;
      if shint <> '' then begin
        with TDGrid(Sender) do begin
          if g_MouseItem.s.NeedIdentify = 4 then
            shint := shint + '\<售价: ' + GetGoldStr(g_MouseItem.s.Price) + '金币|c=$FF00>'
          else if g_MouseItem.s.NeedIdentify = 5 then
            shint := shint + '\<售价: ' + GetGoldStr(g_MouseItem.s.Price) + '元宝|c=clYellow>';
          DScreen.ShowHint(
            SurfaceX(Left + (ACol) * 38),
            SurfaceY(Top + (ARow + 1) * 36),
            shint,
            clWhite, False, False, True, True);
        end;
      end;
      g_MouseItem.s.Name := '';
    end;
  end;
end;

procedure TFrmDlg.DGridUserStallGridPaint(Sender: TObject; ACol, ARow: Integer; Rect: TRect; State: TGridDrawState; dsurface: TCustomCanvas);
var
  n, idx: Integer;
  d: TCustomLockableTexture;
begin
  if not DWUserStall.Visible then Exit;
  if not g_Myself.m_StallMgr.DoShop then Exit;
  idx := ACol + ARow * DGridUserStall.ColCount;
  if idx in [0..10 - 1] then begin
    if g_Myself.m_StallMgr.uBlock.Items[idx].s.Name <> '' then begin
      if (g_Myself.m_StallMgr.uBlock.Items[idx].s.Overlap < 1) or ((g_Myself.m_StallMgr.uBlock.Items[idx].s.Overlap > 0) and (g_Myself.m_StallMgr.uBlock.Items[idx].Dura > 0)) then begin

        d := frmMain.GetWBagItemImg(g_Myself.m_StallMgr.uBlock.Items[idx].s.looks);
        if d <> nil then
          with DGridUserStall do
            dsurface.Draw(SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
              SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
              d.ClientRect,
              d, True);
        if g_Myself.m_StallMgr.uBlock.Items[idx].s.Overlap > 0 then begin
          dsurface.BoldTextOut(
            DGridUserStall.SurfaceX(Rect.Left + 33 - FontManager.Default.TextWidth(IntToStr(g_Myself.m_StallMgr.uBlock.Items[idx].Dura))),
            DGridUserStall.SurfaceY(Rect.Top + 20),
            clWhite, clBlack, IntToStr(g_Myself.m_StallMgr.uBlock.Items[idx].Dura));
        end;
      end;
      if (g_Myself.m_StallMgr.uBlock.Items[idx].s.StdMode in [5,6,10,11,15..24, 26..30]) then begin
        if (g_Myself.m_StallMgr.uBlock.Items[idx].s.Shape = 190) or (g_Myself.m_StallMgr.uBlock.Items[idx].s.reserve[3] = 4) then begin
          if GetTickCount - g_uStallItemArrShine[idx].tick > 60 then begin
            g_uStallItemArrShine[idx].tick := GetTickCount;
            Inc(g_uStallItemArrShine[idx].idx);
            if g_uStallItemArrShine[idx].idx > 31 then
              g_uStallItemArrShine[idx].idx := 0;
          end;
          n := -1;
          d := nil;
          case g_Myself.m_StallMgr.uBlock.Items[idx].s.StdMode of
            30: n := 6;
            19, 20, 21: n := 2;
            15: n := 3;
            24, 25, 26: n := 0;
            22, 23: n := 1;
            27: n := 5;
            28: n := 4
          end;
          if n >= 0 then
            d := g_Wui.Images[100 + n * 40 + g_uStallItemArrShine[idx].idx];
          //d := g_Wui.Images[100 + (g_Myself.m_StallMgr.uBlock.Items[idx].s.looks - 2130) * 40 + g_uStallItemArrShine[idx].idx];
          if d <> nil then
            with DGridUserStall do
              dsurface.DrawBlend(
                SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                d, 1);
        end else if g_Myself.m_StallMgr.uBlock.Items[idx].s.reserve[3] = 1 then begin
          n := 0;
          if g_Myself.m_StallMgr.uBlock.Items[idx].s.StdMode in [15, 16] then
            n := 2;
          if GetTickCount - g_uStallItemArrShine[idx].tick > 100 then begin
            g_uStallItemArrShine[idx].tick := GetTickCount;
            Inc(g_uStallItemArrShine[idx].idx);
            if g_uStallItemArrShine[idx].idx > (8 + n) then
              g_uStallItemArrShine[idx].idx := 0;
          end;
          d := g_WMainImages.Images[(640 - n * 10) + g_uStallItemArrShine[idx].idx];
          if d <> nil then
            with DGridUserStall do
              dsurface.DrawBlend(
                SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                d, 1);
        end else if g_Myself.m_StallMgr.uBlock.Items[idx].s.reserve[3] = 2 then begin
          if GetTickCount - g_uStallItemArrShine[idx].tick > 100 then begin
            g_uStallItemArrShine[idx].tick := GetTickCount;
            Inc(g_uStallItemArrShine[idx].idx);
            if g_uStallItemArrShine[idx].idx > 8 then
              g_uStallItemArrShine[idx].idx := 0;
          end;
          d := g_WMain2Images.Images[260 + g_uStallItemArrShine[idx].idx];
          if d <> nil then
            with DGridUserStall do
              dsurface.DrawBlend(
                SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                d, 1);
        end else if g_Myself.m_StallMgr.uBlock.Items[idx].s.reserve[3] = 3 then begin
          if GetTickCount - g_uStallItemArrShine[idx].tick > 100 then begin
            g_uStallItemArrShine[idx].tick := GetTickCount;
            Inc(g_uStallItemArrShine[idx].idx);
            if g_uStallItemArrShine[idx].idx > 9 then
              g_uStallItemArrShine[idx].idx := 0;
          end;
          n := -1;
          d := nil;
          case g_Myself.m_StallMgr.uBlock.Items[idx].s.StdMode of
            30: n := 6;
            19, 20, 21: n := 2;
            15: n := 5;
            24, 25, 26: n := 1;
            22, 23: n := 0;
            27: n := 4;
            28: n := 3;
          end;
          if n >= 0 then
            d := g_StateEffect.Images[530 + n * 10 + g_uStallItemArrShine[idx].idx];
          //d := g_StateEffect.Images[530 + (g_Myself.m_StallMgr.uBlock.Items[idx].s.looks - 2410) * 10 + g_uStallItemArrShine[idx].idx];
          if d <> nil then
            with DGridUserStall do
              dsurface.DrawBlend(
                SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                d, 1);
        end else if g_Myself.m_StallMgr.uBlock.Items[idx].s.reserve[3] = 5 then begin
          if GetTickCount - g_uStallItemArrShine[idx].tick > 100 then begin
            g_uStallItemArrShine[idx].tick := GetTickCount;
            Inc(g_uStallItemArrShine[idx].idx);
            if g_uStallItemArrShine[idx].idx > 9 then
              g_uStallItemArrShine[idx].idx := 0;
          end;
          d := g_WStateItemImages.Images[3910 + g_uStallItemArrShine[idx].idx];
          if d <> nil then
            with DGridUserStall do
              dsurface.DrawBlend(
                SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                d, 1);
        end else if g_Myself.m_StallMgr.uBlock.Items[idx].s.reserve[3] in [6..10] then begin
          d := g_WMain3Images.Images[750 + (g_Myself.m_StallMgr.uBlock.Items[idx].s.reserve[3] - 6) * 2];
          if d <> nil then
            with DGridUserStall do
              dsurface.DrawBlend(
                SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                d, 1);
        end else if g_Myself.m_StallMgr.uBlock.Items[idx].s.reserve[3] in [100..249] then begin  //20200927看别人摆摊
          if GetTickCount - g_uStallItemArrShine[idx].tick > 100 then begin
            g_uStallItemArrShine[idx].tick := GetTickCount;
            Inc(g_uStallItemArrShine[idx].idx);
            if g_uStallItemArrShine[idx].idx > 19 then
              g_uStallItemArrShine[idx].idx := 0;
          end;
          d := frmMain.GetWBagItemImg(20000 + (g_Myself.m_StallMgr.uBlock.Items[idx].s.reserve[3] +1 - 100) * 20-20 + g_uStallItemArrShine[idx].idx);
          if d = nil then begin
             g_uStallItemArrShine[idx].idx := 0;
            d := frmMain.GetWBagItemImg(20000 + (g_Myself.m_StallMgr.uBlock.Items[idx].s.reserve[3] +1 - 100) * 20-20 + g_uStallItemArrShine[idx].idx);
          end;
          if d <> nil then
            with DGridUserStall do
              dsurface.DrawBlend(
                SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                d, 1);
        end;


      end;
      if idx = g_Myself.m_StallMgr.uSelIdx then begin
        d := g_WMain3Images.Images[616];
        with DGridUserStall do
          dsurface.DrawBlend(
            SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
            SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
            d, 1);
         //g_HintSurface_Olive.FillRect(g_HintSurface_Olive.ClientRect, GetRGB(2));

      end;
//      if idx = g_Myself.m_StallMgr.uSelIdx then begin
//        d := g_HintSurface_Olive;
//        with DGridUserStall do
//          DrawBlend_Mix(dsurface,
//            SurfaceX(Rect.Left + (ColWidth - 38) div 2 - 1),
//            SurfaceY(Rect.Top + (RowHeight - 36) div 2 + 1),
//            d, 0, 0,
//            36,
//            34, 0);
//      end;
    end;
  end;
end;

procedure TFrmDlg.DGridUserStallGridSelect(Sender: TObject; X, Y, ACol, ARow: Integer; Shift: TShiftState);
var
  idx, mi: Integer;
  temp: TClientItem;
  MsgResult, Count: Integer;
  valstr: string;
  keyvalue: TKeyBoardState;
begin
  if not DWUserStall.Visible then Exit;
  if DGridUserStall.OnButton = mbLeft then begin
    idx := ACol + ARow * DGridUserStall.ColCount;
    if idx in [0..10 - 1] then begin
      if g_Myself.m_StallMgr.uBlock.Items[idx].s.Name <> '' then begin
        if g_Myself.m_StallMgr.uSelIdx = idx then
          g_Myself.m_StallMgr.uSelIdx := -1
        else
          g_Myself.m_StallMgr.uSelIdx := idx;
      end;
    end;
  end;
end;

procedure TFrmDlg.DButtonShopEffectDirectPaint(Sender: TObject;
  dsurface: TCustomCanvas);
var
  d: TDButton;
  dd: TCustomLockableTexture;
begin
  if Sender is TDButton then begin
    d := TDButton(Sender);
    if (g_ClickShopItem.sItemName = '') or (m_nShopShowEffectFrame = 0) or (m_nShopShowMaxFrame <= 1) then begin
      dd := g_WEffectImg.Images[380];
      if dd <> nil then
        with DButtonShopEffect do dsurface.Draw(d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, True);
      Exit;
    end;
    if GetTickCount - m_dwShopEffectTick > 300 then begin
      m_dwShopEffectTick := GetTickCount;
      Inc(m_nShopShowCurrentFrame);
      if m_nShopShowCurrentFrame - m_nShopShowEffectFrame >= m_nShopShowMaxFrame then
        m_nShopShowCurrentFrame := m_nShopShowEffectFrame;
    end;
    dd := g_WEffectImg.Images[m_nShopShowCurrentFrame];
    if dd <> nil then
      with DButtonShopEffect do dsurface.Draw(d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, True);
    //g_WEffectImg.ClearCache;
  end;
end;

procedure TFrmDlg.DBV1Click(Sender: TObject; X, Y: Integer);

  procedure FillComponentTag();
  begin
    DBV1.PageActive := False;
    DBV2.PageActive := False;
    DBV3.PageActive := False;
    DBV4.PageActive := False;
    TDButton(Sender).PageActive := True;
  end;

begin
{$IF SERIESSKILL}
  FillComponentTag();
  DStateWin.tag := TDButton(Sender).tag;

  DBTrainVenation.Caption := Format('修炼%s', [TDButton(Sender).Caption]);

  DBP1.SetImgIndex(g_WMainImages, 850);
  DBP1.Left := g_VaInfos[DStateWin.tag].pt1[0].Left;
  DBP1.Top := g_VaInfos[DStateWin.tag].pt1[0].Top;
  //DBPh1.FFloating := True;

  DBP2.SetImgIndex(g_WMainImages, 850);
  DBP2.Left := g_VaInfos[DStateWin.tag].pt1[1].Left;
  DBP2.Top := g_VaInfos[DStateWin.tag].pt1[1].Top;
  //DBPh2.FFloating := True;

  DBP3.SetImgIndex(g_WMainImages, 850);
  DBP3.Left := g_VaInfos[DStateWin.tag].pt1[2].Left;
  DBP3.Top := g_VaInfos[DStateWin.tag].pt1[2].Top;
  //DBPh3.FFloating := True;

  DBP4.SetImgIndex(g_WMainImages, 850);
  DBP4.Left := g_VaInfos[DStateWin.tag].pt1[3].Left;
  DBP4.Top := g_VaInfos[DStateWin.tag].pt1[3].Top;
  //DBPh4.FFloating := True;

  DBP5.SetImgIndex(g_WMainImages, 850);
  DBP5.Left := g_VaInfos[DStateWin.tag].pt1[4].Left;
  DBP5.Top := g_VaInfos[DStateWin.tag].pt1[4].Top;
  //DBPh5.FFloating := True;

  //////////////
  DBPH1.CaptionEx := g_VaInfos[DStateWin.tag].Str1[0];
  DBPH1.Left := g_VaInfos[DStateWin.tag].pt2[0].Left;
  DBPH1.Top := g_VaInfos[DStateWin.tag].pt2[0].Top;
  DBPH1.Width := 28;
  DBPH1.Height := 12;

  DBPH2.CaptionEx := g_VaInfos[DStateWin.tag].Str1[1];
  DBPH2.Left := g_VaInfos[DStateWin.tag].pt2[1].Left;
  DBPH2.Top := g_VaInfos[DStateWin.tag].pt2[1].Top;
  DBPH2.Width := 24;
  DBPH2.Height := 12;

  DBPH3.CaptionEx := g_VaInfos[DStateWin.tag].Str1[2];
  DBPH3.Left := g_VaInfos[DStateWin.tag].pt2[2].Left;
  DBPH3.Top := g_VaInfos[DStateWin.tag].pt2[2].Top;
  DBPH3.Width := 24;
  DBPH3.Height := 12;

  DBPH4.CaptionEx := g_VaInfos[DStateWin.tag].Str1[3];
  DBPH4.Left := g_VaInfos[DStateWin.tag].pt2[3].Left;
  DBPH4.Top := g_VaInfos[DStateWin.tag].pt2[3].Top;
  DBPH4.Width := 24;
  DBPH4.Height := 12;

  DBPH5.CaptionEx := g_VaInfos[DStateWin.tag].Str1[4];
  DBPH5.Left := g_VaInfos[DStateWin.tag].pt2[4].Left;
  DBPH5.Top := g_VaInfos[DStateWin.tag].pt2[4].Top;
  DBPH5.Width := 24;
  DBPH5.Height := 12;
  g_VLastSender := Sender;
{$IFEND SERIESSKILL}
end;

procedure TFrmDlg.DBV1DirectPaint(Sender: TObject;
  dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
begin
  with Sender as TDButton do begin
    if not PageActive then begin
      d := WLib.Images[FaceIndex + 1];
      if d <> nil then dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
      if not Downed then begin
        dsurface.BoldTextOut( SurfaceX(Left + (Width - FontManager.Default.TextWidth(Caption)) div 2 + 1), SurfaceY(Top + (Height - FontManager.Default.TextHeight(Caption)) div 2 + 1), GetRGB(92), clBlack, Caption)
      end else begin
        dsurface.BoldTextOut( SurfaceX(Left + (Width - FontManager.Default.TextWidth(Caption)) div 2 + 2), SurfaceY(Top + (Height - FontManager.Default.TextHeight(Caption)) div 2 + 2), GetRGB(92), clBlack, Caption);
      end;
    end else begin
      d := WLib.Images[FaceIndex];
      if d <> nil then dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
      if not Downed then begin
        if Arrived then
          dsurface.BoldTextOut( SurfaceX(Left + (Width - FontManager.Default.TextWidth(Caption)) div 2 + 1), SurfaceY(Top + (Height - FontManager.Default.TextHeight(Caption)) div 2 + 1), GetRGB(95), clBlack, Caption)
        else
          dsurface.BoldTextOut( SurfaceX(Left + (Width - FontManager.Default.TextWidth(Caption)) div 2 + 1), SurfaceY(Top + (Height - FontManager.Default.TextHeight(Caption)) div 2 + 1), GetRGB(93), clBlack, Caption)
      end else begin
        dsurface.BoldTextOut( SurfaceX(Left + (Width - FontManager.Default.TextWidth(Caption)) div 2 + 2), SurfaceY(Top + (Height - FontManager.Default.TextHeight(Caption)) div 2 + 2), GetRGB(94), clBlack, Caption);
      end;
    end;
  end;
end;

procedure TFrmDlg.DBV1MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
{$IF SERIESSKILL}
  with Sender as TDButton do begin
    g_VMouseInfo := Caption;
    g_VMouseInfoTag := tag;
  end;
{$IFEND SERIESSKILL}
end;

procedure TFrmDlg.DWHeroStatusDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  n: Integer;
  useable: Boolean;
  d: TCustomLockableTexture;
  rc: TIntRect;
  btop, sX, sY, i, fcolor, bcolor: Integer;
  r: Real;
  Str: string;
begin
  if (g_Myself = nil) or (g_Myself.m_HeroObject = nil) then Exit;
  if not g_Myself.m_HeroObject.m_boDeath then begin
    with DWHeroStatus do begin
      if Left <> 0 then Left := 0;
      if Top <> 0 then Top := 0;
      if DMerchantDlg.Visible then
        Left := DMerchantDlg.Width;

      d := g_opui.Images[g_sHeroStatusWindow];
      if d <> nil then dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);

      d := g_WMain3Images.Images[365 + g_Myself.m_HeroObject.m_btJob + (g_Myself.m_HeroObject.m_btSex * 3)]; //Hero Job
      if d <> nil then dsurface.Draw(SurfaceX(Left + 18), SurfaceY(Top + 18), d.ClientRect, d, True);

      dsurface.TextOut(SurfaceX(Left + 7), SurfaceY(Top + 61), IntToStr(g_Myself.m_HeroObject.m_Abil.Level), clWhite); //Hero Level
      if g_Myself.m_HeroObject.m_sLoyaly <> '' then
        dsurface.TextOut(SurfaceX(Left + 102), SurfaceY(Top + 63), g_Myself.m_HeroObject.m_sLoyaly, clWhite);
      if g_Myself.m_HeroObject.m_sUserName <> '' then begin //Hero Name
//        dsurface.Font.Color := clSkyBlue; //g_MySelf.m_HeroObject.m_nNameColor;
        dsurface.TextOut(SurfaceX(Left + 80), SurfaceY(Top + 6), g_Myself.m_HeroObject.m_sUserName, clSkyBlue);
      end;

      d := g_WMain3Images.Images[386];
      if d <> nil then begin
        rc := d.ClientRect;
        if g_Myself.m_HeroObject.m_Abil.MaxHP > 0 then
          rc.Right := Round((rc.Right - rc.Left) / g_Myself.m_HeroObject.m_Abil.MaxHP * g_Myself.m_HeroObject.m_Abil.HP);
        dsurface.Draw(SurfaceX(Left + 76), SurfaceY(Top + 24), rc, d, False);
      end;
      d := g_WMain3Images.Images[387];
      if d <> nil then begin
        rc := d.ClientRect;
        if g_Myself.m_HeroObject.m_Abil.MaxMP > 0 then
          rc.Right := Round((rc.Right - rc.Left) / g_Myself.m_HeroObject.m_Abil.MaxMP * g_Myself.m_HeroObject.m_Abil.MP);
        dsurface.Draw(SurfaceX(Left + 81), SurfaceY(Top + 24 + 13 * 1), rc, d, False);
      end;
      d := g_WMain3Images.Images[388];
      if d <> nil then begin
        rc := d.ClientRect;
        if g_Myself.m_HeroObject.m_Abil.MaxExp > 0 then
          rc.Right := Round((rc.Right - rc.Left) / g_Myself.m_HeroObject.m_Abil.MaxExp * g_Myself.m_HeroObject.m_Abil.Exp);
        dsurface.Draw(SurfaceX(Left + 80), SurfaceY(Top + 24 + 13 * 2), rc, d, False);
      end;
    end;
  end else with DWHeroStatus do begin
      if Left <> 0 then Left := 0;
      if Top <> 0 then Top := 0;

      if DMerchantDlg.Visible then
        Left := DMerchantDlg.Width;

      d := g_opui.Images[g_sHeroStatusWindow];
      if d <> nil then begin
//        g_ImgMixSurface.Draw(0, 0, d.ClientRect, d, False);
//        DrawEffect(0, 0, d.Width, d.Height, g_ImgMixSurface, ceDark);
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
        DrawEffect(0, 0, dsurface, d, ceBlack, True);
      end;
      d := g_WMain3Images.Images[365 + g_Myself.m_HeroObject.m_btJob + (g_Myself.m_HeroObject.m_btSex * 3)]; //Hero Job
      if d <> nil then begin
//        g_ImgMixSurface.Draw(0, 0, d.ClientRect, d, False);
//        DrawEffect(0, 0, d.Width, d.Height, g_ImgMixSurface, ceDark);
        dsurface.Draw(SurfaceX(Left + 18), SurfaceY(Top + 18), d.ClientRect, d, True);
        DrawEffect(SurfaceX(Left + 18), SurfaceY(Top + 18), dsurface, d, ceBlack, True);
      end;

      dsurface.TextOut(SurfaceX(Left + 7), SurfaceY(Top + 61), IntToStr(g_Myself.m_HeroObject.m_Abil.Level), clSilver); //Hero Level
      if g_Myself.m_HeroObject.m_sLoyaly <> '' then
        dsurface.TextOut(SurfaceX(Left + 102), SurfaceY(Top + 63), g_Myself.m_HeroObject.m_sLoyaly, clSilver);
      if g_Myself.m_HeroObject.m_sUserName <> '' then //Hero Name
        dsurface.TextOut(SurfaceX(Left + 80), SurfaceY(Top + 6), g_Myself.m_HeroObject.m_sUserName, clSilver);
    end;
end;

{
procedure TfrmMain.SendSocket(sendstr: string);
begin
  if CSocket.Socket.Connected then begin
    CSocket.Socket.SendText(Format('#1%s!', [sendstr]));
  end;
end;

procedure TfrmMain.SendClientMessage(msg, Recog, param, tag, series: Integer);
var
  dMsg                      : TDefaultMessage;
begin
  dMsg := MakeDefaultMsg(msg, Recog, param, tag, series);
  SendSocket(EncodeMessage(dMsg));
end;
}

procedure TFrmDlg.ClientCallHero();
var
  test: string;

  X, Y: Integer;
  A: byte;
  Key, sSendBuf: string;
  p: PChar;
  len: Integer;

  wr: Word;

  msg: TDefaultMessage;
begin
  if not frmMain.CSocket.Socket.Connected or not g_boHero then Exit;
  test := 'clBlue';
  if g_pbRecallHero^ then begin
    g_pbRecallHero^ := False;
    if GetTickCount - m_dwRecallHeroTick > 500 then begin
      m_dwRecallHeroTick := GetTickCount;
      if g_Myself <> nil then begin
        if g_Myself.m_HeroObject = nil then begin
          wr := Random(High(Word));
          msg := MakeDefaultMsg(CM_RECALLHERO, g_Myself.m_nRecogId, wr, 0, 0);
          sSendBuf := EncodeMessage(msg);
          Key := IntToStr(g_Myself.m_nRecogId) + '+' + g_Myself.m_sUserName + IntToStr(Lobyte(wr));
          len := Length(sSendBuf);
          Y := 1;
          p := @sSendBuf[1];
          for X := 0 to len - 1 do begin
            A := (Ord(p[X]) and $0F) xor (Ord(Key[Y]) and $0F);
            p[X] := Char((Ord(p[X]) and $F0) + A);
            Inc(Y);
            if Y >= Length(Key) then Y := 1;
          end;
          frmMain.CSocket.Socket.SendText(Format('#1%s!', [EncodeMessage(msg) + EncodeString(sSendBuf)]));
        end else begin
          wr := Random(High(Word));
          msg := MakeDefaultMsg(CM_UNRECALLHERO, g_Myself.m_nRecogId, 0, 0, wr);
          sSendBuf := EncodeMessage(msg);
          Key := IntToStr(g_Myself.m_nRecogId) + '-' + g_Myself.m_sUserName + IntToStr(Hibyte(wr));
          len := Length(sSendBuf);
          Y := 1;
          p := @sSendBuf[1];
          for X := 0 to len - 1 do begin
            A := (Ord(p[X]) and $0F) xor (Ord(Key[Y]) and $0F);
            p[X] := Char((Ord(p[X]) and $F0) + A);
            Inc(Y);
            if Y >= Length(Key) then Y := 1;
          end;
          frmMain.CSocket.Socket.SendText(Format('#1%s!', [EncodeMessage(msg) + EncodeString(sSendBuf)]));
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.ClientHeroState();
begin
  if (g_Myself = nil) or (g_Myself.m_HeroObject = nil) or not g_boHero then Exit;
  OpenHeroStatus();
end;

procedure TFrmDlg.ClientHeroBag();
begin
  if (g_Myself = nil) or (g_Myself.m_HeroObject = nil) or not g_boHero then Exit;
  OpenHeroItemBag();
end;

procedure TFrmDlg.DButtonRecallHeroClick(Sender: TObject; X, Y: Integer);
begin
  g_pbRecallHero^ := True;
  ClientCallHero();
end;

procedure TFrmDlg.DHeroItemBagDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d0, d1, d2, d3, d4: string;
  n, L: Integer;
  useable: Boolean;
  d: TCustomLockableTexture;
begin
  if (g_Myself = nil) or (g_Myself.m_HeroObject = nil) then Exit;
  with DHeroItemBag do begin
    d := WLib.Images[FaceIndex];
    //d := ULib.Images[FaceName];
    if d <> nil then begin
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);

      {GetMouseItemInfo(g_HeroMouseItem, d0, d1, d2, d3, d4, useable, True);
      if d0 <> '' then begin
        with dsurface.Canvas do begin
          Font.Color := clWhite;
          n := TextWidth(d0, False);
          Font.Color := clYellow;
          TextOutA(SurfaceX(Left + 13), SurfaceY(Top + d.Height - 82), d0);
          Font.Color := clWhite;
          TextOutA(SurfaceX(Left + 13) + n, SurfaceY(Top + d.Height - 82), d1);
          TextOutA(SurfaceX(Left + 13), SurfaceY(Top + d.Height - 82 + 14), d2);
          if not useable then Font.Color := clRed;
          TextOutA(SurfaceX(Left + 13), SurfaceY(Top + d.Height - 82 + 14 * 2), d3);
          if d4 <> '' then begin
            L := 1;
            Font.Color := clLime;
            while True do begin
              if d4 = '' then Break;
              d4 := GetValidStr3(d4, d0, ['\']);
              if d0 <> '' then TextOutA(SurfaceX(Left + 13), SurfaceY(Top + d.Height - 82 + 14 * (2 + L)), d0);
              Inc(L);
              if L > 2 then Break;
            end;
          end;
//          Release;
        end;
      end else begin}
      with dsurface do begin
        TextOut(SurfaceX(Left + 13), SurfaceY(Top + d.Height - 54), 'ALT+B 刷新英雄包裹', clWhite);
      end;
      //end;
    end;
  end;
end;

procedure TFrmDlg.DHeroItemGridGridMouseMove(Sender: TObject; X, Y, ACol, ARow: Integer; Shift: TShiftState);
var
  XX, YY, idx, L, M, itemidx0, itemidx, itemidx2: Integer;
  temp: TClientItem;
  iname, d1, d2, d3, shint: string;
  HintLeft, HintDown: Boolean;
  hcolor: TColor;
  b1, b2: Boolean;
label
  labNext;
begin
  DScreen.ClearHint;
  idx := ACol + ARow * DHeroItemGrid.ColCount;
  if idx in [0..g_nHeroBagSize - 1] then begin
    g_HeroMouseItem := g_HeroItemArr[idx];
    if g_HeroMouseItem.s.Name <> '' then begin
      itemidx0 := -1;
      itemidx := -1;
      itemidx2 := -1;

      //if g_gcGeneral[14] then begin
      case g_HeroMouseItem.s.StdMode of
        10, 11: begin
            itemidx0 := U_DRESS;
            if g_HeroUseItems[U_DRESS].s.Name <> '' then
              if g_gcGeneral[14] then itemidx := U_DRESS;
          end;
        5, 6: begin
            itemidx0 := U_WEAPON;
            if g_HeroUseItems[U_WEAPON].s.Name <> '' then
              if g_gcGeneral[14] then itemidx := U_WEAPON;
          end;
        30: begin
            itemidx0 := U_RIGHTHAND;
            if g_HeroUseItems[U_RIGHTHAND].s.Name <> '' then
              if g_gcGeneral[14] then itemidx := U_RIGHTHAND;
          end;
        19, 20, 21: begin
            itemidx0 := U_NECKLACE;
            if g_HeroUseItems[U_NECKLACE].s.Name <> '' then
              if g_gcGeneral[14] then itemidx := U_NECKLACE;
          end;
        15: begin
            itemidx0 := U_HELMET;
            if g_HeroUseItems[U_HELMET].s.Name <> '' then
              if g_gcGeneral[14] then itemidx := U_HELMET;
          end;
        16: begin
            if g_HeroUseItems[U_HELMETEX].s.Name <> '' then
              if g_gcGeneral[14] then itemidx := U_HELMETEX;
          end;
        24, 26: begin
            itemidx0 := U_ARMRINGL;
            if g_HeroUseItems[U_ARMRINGL].s.Name <> '' then
              if g_gcGeneral[14] then itemidx := U_ARMRINGL;
            if g_HeroUseItems[U_ARMRINGR].s.Name <> '' then begin
              itemidx0 := U_ARMRINGR;
              if g_gcGeneral[14] then begin
                if itemidx < 0 then
                  itemidx := U_ARMRINGR
                else
                  itemidx2 := U_ARMRINGR;
              end;
            end;
          end;
        22, 23: begin
            itemidx0 := U_RINGL;
            if g_HeroUseItems[U_RINGL].s.Name <> '' then
              if g_gcGeneral[14] then itemidx := U_RINGL;
            if g_HeroUseItems[U_RINGR].s.Name <> '' then begin
              itemidx0 := U_RINGR;
              if g_gcGeneral[14] then begin
                if itemidx < 0 then
                  itemidx := U_RINGR
                else
                  itemidx2 := U_RINGR;
              end;
            end;
          end;
        25: begin
            itemidx0 := U_BUJUK;
            if g_HeroUseItems[U_BUJUK].s.Name <> '' then
              if g_gcGeneral[14] then itemidx := U_BUJUK;
          end;
        27: begin
            itemidx0 := U_BELT;
            if g_HeroUseItems[U_BELT].s.Name <> '' then
              if g_gcGeneral[14] then itemidx := U_BELT;
          end;
        28: begin
            itemidx0 := U_BOOTS;
            if g_HeroUseItems[U_BOOTS].s.Name <> '' then
              if g_gcGeneral[14] then itemidx := U_BOOTS;
          end;
        7, 29: begin
            itemidx0 := U_CHARM;
            if g_HeroUseItems[U_CHARM].s.Name <> '' then
              if g_gcGeneral[14] then itemidx := U_CHARM;
          end;
      end;
      //end;
      with TDGrid(Sender) do begin
        XX := SurfaceX(Left + (ACol + 1) * 36);
        YY := SurfaceY(Top + (ARow) * 32 + 2);
        if itemidx in [0..U_FASHION] then begin

          HintLeft := False;
          if XX + (MAXITEMBOX_WIDTH + 5) * (2 + byte(itemidx2 > -1)) > SCREENWIDTH then begin
            HintLeft := True;
          end;

          if HintLeft then begin
            if (itemidx in [0..U_FASHION]) and (itemidx2 > -1) then begin
              XX := SCREENWIDTH - ((MAXITEMBOX_WIDTH + 5) * (2 + byte(itemidx2 > -1))) + 2;
              goto labNext;
            end;
            if itemidx0 in [0..12] then begin
              g_ShowSuite := 2;
              g_SuiteIdx := itemidx0;
            end;
            g_ItemWear := byte((itemidx in [0..U_FASHION]) or (itemidx2 > -1));
            GetMouseItemInfoHint(g_HeroMouseItem, shint, True);
            if shint <> '' then begin
              DScreen.ShowHint(
                XX - 36 - 3,
                YY,
                shint,
                clWhite, False, True, True, True);
            end;

            //2
            if itemidx in [0..U_FASHION] then begin
              g_ShowSuite := 2;
              g_SuiteIdx := itemidx;
            end;
            g_HeroMouseItem := g_HeroUseItems[itemidx];
            if itemidx in [U_ARMRINGL, U_RINGL] then
              g_ItemWear := 3
            else if itemidx in [U_ARMRINGR, U_RINGR] then
              g_ItemWear := 4
            else if itemidx in [0..U_FASHION] then
              g_ItemWear := 2;
            GetMouseItemInfoHint(g_HeroMouseItem, shint, True);
            if shint <> '' then begin
              L := DScreen.ShowHint(
                XX - 36 - (MAXITEMBOX_WIDTH + 5) - 3,
                YY,
                shint,
                clWhite, False, True, True, True, 2, True);
            end;
          end else begin
            labNext:
            if itemidx0 in [0..12] then begin
              g_ShowSuite := 2;
              g_SuiteIdx := itemidx0;
            end;
            g_ItemWear := byte((itemidx in [0..U_FASHION]) or (itemidx2 > -1));
            GetMouseItemInfoHint(g_HeroMouseItem, shint, True);
            if shint <> '' then begin
              DScreen.ShowHint(
                XX,
                YY,
                shint,
                clWhite, False, False, True, True);
            end;

            //2
            if itemidx in [0..U_FASHION] then begin
              g_ShowSuite := 2;
              g_SuiteIdx := itemidx;
            end;
            g_HeroMouseItem := g_HeroUseItems[itemidx];
            if itemidx in [U_ARMRINGL, U_RINGL] then
              g_ItemWear := 3
            else if itemidx in [U_ARMRINGR, U_RINGR] then
              g_ItemWear := 4
            else if itemidx in [0..U_FASHION] then
              g_ItemWear := 2;
            GetMouseItemInfoHint(g_HeroMouseItem, shint, True);
            if shint <> '' then begin
              DScreen.ShowHint(
                XX + (MAXITEMBOX_WIDTH + 5),
                YY,
                shint,
                clWhite, False, False, True, True, 2, True);
            end;

            //3
            if itemidx2 > -1 then begin
              if itemidx2 in [0..U_FASHION] then begin
                g_ShowSuite := 2;
                g_SuiteIdx := itemidx2;
              end;
              g_HeroMouseItem := g_HeroUseItems[itemidx2];
              g_ItemWear := 4;
              GetMouseItemInfoHint(g_HeroMouseItem, shint, True);
              if shint <> '' then begin
                DScreen.ShowHint(
                  XX + (MAXITEMBOX_WIDTH + 5) * 2,
                  YY,
                  shint,
                  clWhite, False, False, True, True, 3, True);
              end;
            end;
          end;
        end else begin
          if itemidx0 in [0..12] then begin
            g_ShowSuite := 2;
            g_SuiteIdx := itemidx0;
          end;
          GetMouseItemInfoHint(g_HeroMouseItem, shint, True);
          if shint <> '' then begin
            DScreen.ShowHint(
              XX,
              YY,
              shint,
              clWhite, False, False, True, True);
          end;
        end;
      end;

      g_HeroMouseItem.s.Name := '';
    end;

  end;
end;

procedure TFrmDlg.DHeroItemGridGridSelect(Sender: TObject; X, Y, ACol, ARow: Integer; Shift: TShiftState);
var
  idx, mi: Integer;
  temp: TClientItem;
  MsgResult, Count: Integer;
  valstr: string;
begin
  //if (g_WaitingUseItem.Item.S.Name <> '') then Exit;
  if (g_Myself = nil) or (g_Myself.m_HeroObject = nil) or (g_Myself.m_HeroObject.m_boDeath) then Exit;
  if DHeroItemGrid.OnButton = mbLeft then begin
    idx := ACol + ARow * DHeroItemGrid.ColCount;
    if idx in [0..g_nHeroBagSize - 1 {MAXBAGITEM - 1 - 6}] then begin
      if not g_boItemMoving then begin
        if g_HeroItemArr[idx].s.Name <> '' then begin
          if (g_HeroItemArr[idx].s.Overlap > 0) and (g_HeroItemArr[idx].Dura > 1) and (Shift = [{ssCtrl,} ssShift]) then begin
            MsgResult := DMessageDlg(Format('(英雄) 你拆分多少 %s (0~%d)？', [g_HeroItemArr[idx].s.Name, g_HeroItemArr[idx].Dura - 1]), [mbOk, mbCancel, mbAbort]);

            GetValidStrVal(DlgEditText, valstr, [' ']);
            Count := Str_ToInt(valstr, 0);

            if Count >= g_HeroItemArr[idx].Dura then Count := g_HeroItemArr[idx].Dura - 1;
            if (MsgResult = mrCancel) or (Count <= 0) then begin
              Count := 0;
              Exit;
            end;
            frmMain.SendDismantleItem(g_HeroItemArr[idx].s.Name, g_HeroItemArr[idx].MakeIndex, Count, 1);

          end else begin
            g_boItemMoving := True;
            g_MovingItem.Index := idx + HERO_MIIDX_OFFSET;
            g_MovingItem.item := g_HeroItemArr[idx];
            g_HeroItemArr[idx].s.Name := '';
            g_SndMgr.ItemClickSound(g_HeroItemArr[idx].s);
          end;
        end;
      end else begin
        mi := g_MovingItem.Index;
        if IsDetectItem(mi) then Exit;
        if IsStallItem(mi) then Exit;
        if (mi = -97) or (mi = -98) then Exit;
        if (mi < 0) and (mi >= -(U_FASHION + 1)) then Exit;
        if (mi <= -20) and (mi > -39) then Exit;
        if (mi < (0 - HERO_MIIDX_OFFSET)) and (mi >= -((U_FASHION + 1) + HERO_MIIDX_OFFSET)) then begin
          g_WaitingUseItem := g_MovingItem;
          frmMain.HeroSendTakeOffItem(-(g_MovingItem.Index + 1 + HERO_MIIDX_OFFSET), g_MovingItem.item.MakeIndex, g_MovingItem.item.s.Name);
          g_MovingItem.item.s.Name := '';
          g_boItemMoving := False;
          g_SndMgr.ItemClickSound(g_MovingItem.item.s);
        end else begin
          //if (mi <= -20) and (mi > -30) then DealItemReturnBag(g_MovingItem.Item);
          if mi >= HERO_MIIDX_OFFSET then begin
            if g_HeroItemArr[idx].s.Name <> '' then begin
              if (g_HeroItemArr[idx].s.Overlap > 0) and (g_HeroItemArr[idx].s.Name = g_MovingItem.item.s.Name) then begin

                frmMain.SendItemSumCount(g_HeroItemArr[idx].MakeIndex, g_MovingItem.item.MakeIndex, 1, g_HeroItemArr[idx].s.Name, g_MovingItem.item.s.Name);

                //if (mi > 0) and (mi < 100) then
                g_WaitingUseItem := g_MovingItem;
                //CancelItemMoving;
                //else begin
                g_MovingItem.item.s.Name := '';
                g_boItemMoving := False;
                //end;
              end else begin
                temp := g_HeroItemArr[idx];
                g_HeroItemArr[idx] := g_MovingItem.item;
                g_MovingItem.Index := idx + HERO_MIIDX_OFFSET;
                g_MovingItem.item := temp;
                g_SndMgr.ItemClickSound(g_MovingItem.item.s);
              end;
            end else begin
              g_HeroItemArr[idx] := g_MovingItem.item;
              g_MovingItem.item.s.Name := '';
              g_boItemMoving := False;
              g_SndMgr.ItemClickSound(g_MovingItem.item.s);
            end;
          end else begin
            g_WaitingUseItem := g_MovingItem;
            frmMain.SendMasterItemToHeroBag(g_MovingItem.item.MakeIndex, g_MovingItem.item.s.Name);
            g_MovingItem.item.s.Name := '';
            g_boItemMoving := False;
            g_SndMgr.ItemClickSound(g_MovingItem.item.s);
          end;
        end;
      end;
    end;
    ArrangeHeroItembag;
  end else begin
    if g_WaitingUseItem.item.s.Name <> '' then Exit;
    idx := ACol + ARow * DHeroItemGrid.ColCount;
    if idx in [0..g_nHeroBagSize - 1 {MAXBAGITEM - 1 - 6}] then begin
      idx := idx + HERO_MIIDX_OFFSET;
      if (idx = -97) or (idx = -98) then Exit;
      if (idx < (0 - HERO_MIIDX_OFFSET)) and (idx >= -((U_FASHION + 1) + HERO_MIIDX_OFFSET)) then Exit;
      if not g_boItemMoving then begin
        if idx >= HERO_MIIDX_OFFSET then begin
          g_WaitingUseItem.Index := idx;
          g_WaitingUseItem.item := g_HeroItemArr[idx - HERO_MIIDX_OFFSET];
          frmMain.SendHeroItemToMasterBag(g_WaitingUseItem.item.MakeIndex, g_WaitingUseItem.item.s.Name);
          g_HeroItemArr[idx - HERO_MIIDX_OFFSET].s.Name := '';
          g_SndMgr.ItemClickSound(g_WaitingUseItem.item.s);
        end;
      end;
      ArrangeItembag;
    end;
  end;
end;

procedure TFrmDlg.DHeroItemGridGridPaint(Sender: TObject; ACol, ARow: Integer; Rect: TRect; State: TGridDrawState; dsurface: TCustomCanvas);
var
  n, idx: Integer;
  d: TCustomLockableTexture;
begin
  if not DHeroItemGrid.Visible then Exit;
  idx := ACol + ARow * DHeroItemGrid.ColCount;
  if idx in [0..g_nHeroBagSize - 1 {MAXBAGITEM - 1 - 6}] then begin
    if g_HeroItemArr[idx].s.Name <> '' then begin

      if (g_ItemArr[idx].s.Overlap < 1) or ((g_ItemArr[idx].s.Overlap > 0) and (g_ItemArr[idx].Dura > 0)) then begin

        //d := g_WBagItemImages.Images[g_HeroItemArr[idx].s.looks];
        d := frmMain.GetWBagItemImg(g_HeroItemArr[idx].s.looks);
        if d <> nil then
          with DHeroItemGrid do
            dsurface.Draw(SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
              SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
              d.ClientRect,
              d, True);

        if g_HeroItemArr[idx].s.Overlap > 0 then begin
          dsurface.BoldTextOut(
            DHeroItemGrid.SurfaceX(Rect.Left + 33 - FontManager.Default.TextWidth(IntToStr(g_HeroItemArr[idx].Dura))),
            DHeroItemGrid.SurfaceY(Rect.Top + 20),
            clSilver, clBlack, IntToStr(g_HeroItemArr[idx].Dura));
        end;
      end;
      if (g_HeroItemArr[idx].s.StdMode in [5,6,10,11,15..24, 26..30]) then begin
        if (g_HeroItemArr[idx].s.Shape = 190) or (g_HeroItemArr[idx].s.reserve[3] = 4) then begin
          if GetTickCount - g_HeroItemArrShine[idx].tick > 60 then begin
            g_HeroItemArrShine[idx].tick := GetTickCount;
            Inc(g_HeroItemArrShine[idx].idx);
            if g_HeroItemArrShine[idx].idx > 31 then
              g_HeroItemArrShine[idx].idx := 0;
          end;
          n := -1;
          d := nil;
          case g_HeroItemArr[idx].s.StdMode of
            30: n := 6;
            19, 20, 21: n := 2;
            15: n := 3;
            24, 25, 26: n := 0;
            22, 23: n := 1;
            27: n := 5;
            28: n := 4
          end;
          if n >= 0 then
            d := g_Wui.Images[100 + n * 40 + g_HeroItemArrShine[idx].idx];
          //d := g_Wui.Images[100 + (g_HeroItemArr[idx].s.looks - 2130) * 40 + g_HeroItemArrShine[idx].idx];
          if d <> nil then
            with DHeroItemGrid do
              dsurface.DrawBlend(
                SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                d, 1);
        end else if g_HeroItemArr[idx].s.reserve[3] = 1 then begin
          n := 0;
          if g_HeroItemArr[idx].s.StdMode in [15, 16] then
            n := 2;
          if GetTickCount - g_HeroItemArrShine[idx].tick > 100 then begin
            g_HeroItemArrShine[idx].tick := GetTickCount;
            Inc(g_HeroItemArrShine[idx].idx);
            if g_HeroItemArrShine[idx].idx > (8 + n) then
              g_HeroItemArrShine[idx].idx := 0;
          end;
          d := g_WMainImages.Images[(640 - n * 10) + g_HeroItemArrShine[idx].idx];
          if d <> nil then
            with DHeroItemGrid do
              dsurface.DrawBlend(
                SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                d, 1);
        end else if g_HeroItemArr[idx].s.reserve[3] = 2 then begin
          if GetTickCount - g_HeroItemArrShine[idx].tick > 100 then begin
            g_HeroItemArrShine[idx].tick := GetTickCount;
            Inc(g_HeroItemArrShine[idx].idx);
            if g_HeroItemArrShine[idx].idx > 5 then
              g_HeroItemArrShine[idx].idx := 0;
          end;
          d := g_WMain2Images.Images[260 + g_HeroItemArrShine[idx].idx];
          if d <> nil then
            with DHeroItemGrid do
              dsurface.DrawBlend(
                SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                d, 1);
        end else if g_HeroItemArr[idx].s.reserve[3] = 3 then begin
          if GetTickCount - g_HeroItemArrShine[idx].tick > 100 then begin
            g_HeroItemArrShine[idx].tick := GetTickCount;
            Inc(g_HeroItemArrShine[idx].idx);
            if g_HeroItemArrShine[idx].idx > 9 then
              g_HeroItemArrShine[idx].idx := 0;
          end;
          n := -1;
          d := nil;
          case g_HeroItemArr[idx].s.StdMode of
            30: n := 6;
            19, 20, 21: n := 2;
            15: n := 5;
            24, 25, 26: n := 1;
            22, 23: n := 0;
            27: n := 4;
            28: n := 3;
          end;
          if n >= 0 then
            d := g_StateEffect.Images[530 + n * 10 + g_HeroItemArrShine[idx].idx];
          //d := g_StateEffect.Images[530 + (g_HeroItemArr[idx].s.looks - 2410) * 10 + g_HeroItemArrShine[idx].idx];
          if d <> nil then
            with DHeroItemGrid do
              dsurface.DrawBlend(
                SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                d, 1);
        end else if g_HeroItemArr[idx].s.reserve[3] = 5 then begin
          if GetTickCount - g_HeroItemArrShine[idx].tick > 100 then begin
            g_HeroItemArrShine[idx].tick := GetTickCount;
            Inc(g_HeroItemArrShine[idx].idx);
            if g_HeroItemArrShine[idx].idx > 9 then
              g_HeroItemArrShine[idx].idx := 0;
          end;
          d := g_WStateItemImages.Images[3910 + g_HeroItemArrShine[idx].idx];
          if d <> nil then
            with DHeroItemGrid do
              dsurface.DrawBlend(
                SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                d, 1);
        end else if g_HeroItemArr[idx].s.reserve[3] in [6..10] then begin
          d := g_WMain3Images.Images[750 + (g_HeroItemArr[idx].s.reserve[3] - 6) * 2];
          if d <> nil then
            with DHeroItemGrid do
              dsurface.DrawBlend(
                SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                d, 1);
        end else if g_HeroItemArr[idx].s.reserve[3] in [100..249] then begin//20200927背包特效6  英雄背包
          if GetTickCount - g_HeroItemArrShine[idx].tick > 200 then begin
            g_HeroItemArrShine[idx].tick := GetTickCount;
            Inc(g_HeroItemArrShine[idx].idx);
            if g_HeroItemArrShine[idx].idx > 19 then
              g_HeroItemArrShine[idx].idx := 0;
          end;
            d := frmMain.GetWBagItemImg(20000 + (g_HeroItemArr[idx].s.reserve[3] +1 - 100) * 20-20 + g_HeroItemArrShine[idx].idx);
            if d = nil then begin
             g_HeroItemArrShine[idx].idx := 0;
              d := frmMain.GetWBagItemImg(20000 + (g_HeroItemArr[idx].s.reserve[3] +1 - 100) * 20-20 + g_HeroItemArrShine[idx].idx);
            end;
          if d <> nil then
            with DHeroItemGrid do
              dsurface.DrawBlend(
                SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                d, 1);
        end;


      end;
    end;
  end;
end;

procedure TFrmDlg.DHeroItemGridDblClick(Sender: TObject);
var
  idx, n: Integer;
  keyvalue: TKeyBoardState;
  cu: TClientItem;
begin
  if (g_Myself = nil) or (g_Myself.m_HeroObject = nil) then Exit;
  idx := DHeroItemGrid.Col + DHeroItemGrid.Row * DHeroItemGrid.ColCount;
  if idx in [0..g_nHeroBagSize - 1 {MAXBAGITEM - 1 - 6}] then begin
    if g_HeroItemArr[idx].s.Name <> '' then begin
      FillChar(keyvalue, SizeOf(TKeyBoardState), #0);
      GetKeyboardState(keyvalue);
      if keyvalue[VK_CONTROL] = $80 then begin
        cu := g_HeroItemArr[idx];
        g_HeroItemArr[idx].s.Name := '';
        HeroAddItemBag(cu);
      end else {if (g_HeroItemArr[idx].S.StdMode <= 4) or (g_HeroItemArr[idx].S.StdMode = 31) then}  begin
        if (g_HeroItemArr[idx].s.StdMode = 3) and (g_HeroItemArr[idx].s.Shape in [1..3, 5, 11]) then Exit;
        if (g_HeroItemArr[idx].s.StdMode = 31) and not (g_HeroItemArr[idx].s.AniCount in [0..3]) then Exit;
        frmMain.HeroEatItem(idx);
      end;
    end else if g_boItemMoving and (g_MovingItem.item.s.Name <> '') then begin
      n := -(g_MovingItem.Index + 1);
      if n in [0..U_FASHION] then Exit;
      FillChar(keyvalue, SizeOf(TKeyBoardState), #0);
      GetKeyboardState(keyvalue);
      frmMain.m_nEatRetIdx := idx;
      if keyvalue[VK_CONTROL] = $80 then begin
        cu := g_MovingItem.item;
        g_MovingItem.item.s.Name := '';
        g_boItemMoving := False;
        HeroAddItemBag(cu);
      end else if (g_MovingItem.Index = (idx + HERO_MIIDX_OFFSET)) {and (g_MovingItem.Item.S.StdMode <= 4) or (g_HeroItemArr[idx].S.StdMode = 31)} then begin
        if (g_HeroItemArr[idx].s.StdMode = 3) and (g_HeroItemArr[idx].s.Shape in [1..3, 5, 11]) then Exit;
        if (g_HeroItemArr[idx].s.StdMode = 31) and not (g_HeroItemArr[idx].s.AniCount in [0..3]) then Exit;
        frmMain.HeroEatItem(-1);
      end;
    end;
  end;
end;

procedure TFrmDlg.DButtonHeroStateClick(Sender: TObject; X, Y: Integer);
begin
  ClientHeroState();
end;

procedure TFrmDlg.DCloseHeroBagClick(Sender: TObject; X, Y: Integer);
begin
  DHeroItemBag.Visible := False;
end;

procedure TFrmDlg.CloseHeroWindows();
begin
  DWHeroStatus.Visible := False;
  DHeroItemBag.Visible := False;
  DHStateWin.Visible := False;
end;

procedure TFrmDlg.DButtonHeroBagClick(Sender: TObject; X, Y: Integer);
begin
  ClientHeroBag();
end;

procedure TFrmDlg.DHeroItemBagMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
begin
  DScreen.ClearHint;
  if g_HeroMouseItem.s.Name <> '' then
    g_HeroMouseItem.s.Name := '';
end;

procedure TFrmDlg.DItemBagMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
begin
  DScreen.ClearHint;
  if g_MouseItem.s.Name <> '' then
    g_MouseItem.s.Name := '';
  g_showgamegoldinfo := False;
end;

procedure TFrmDlg.DHCloseStateClick(Sender: TObject; X, Y: Integer);
begin
  DHStateWin.Visible := False;
end;

procedure TFrmDlg.DHStateWinMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
begin
  DScreen.ClearHint;
  if g_HeroMouseStateItem.s.Name <> '' then
    g_HeroMouseStateItem.s.Name := '';
{$IF SERIESSKILL}
  if g_hVMouseInfo <> '' then
    g_hVMouseInfo := '';
  if g_hVMouseInfo2 <> '' then
    g_hVMouseInfo2 := '';
{$IFEND SERIESSKILL}
end;

procedure TFrmDlg.DHStateWinMouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  if (g_Myself = nil) or (g_Myself.m_HeroObject = nil) then Exit;
  if g_Myself.m_HeroObject.m_nIPowerLvl <= 0 then Exit;
  X := DHStateWin.LocalX(X) - DHStateWin.Left;
  Y := DHStateWin.LocalY(Y) - DHStateWin.Top;
  if (X >= 64) and (X <= 121) and (Y >= 32) and (Y <= 52) then begin
    if g_Myself.m_HeroObject.n_boState then begin
      g_Myself.m_HeroObject.n_boState := False;
      HeroPageChanged;
      g_SndMgr.PlaySound(s_norm_button_click);
    end;
  end else if (X >= 130) and (X <= 186) and (Y >= 32) and (Y <= 52) then begin
    if not g_Myself.m_HeroObject.n_boState then begin
      g_Myself.m_HeroObject.n_boState := True;
      HeroPageChanged;
      g_SndMgr.PlaySound(s_norm_button_click);
    end;
  end;
end;

procedure TFrmDlg.DHSeMag1DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  idx, icon: Integer;
  d: TCustomLockableTexture;
  pm: PTClientMagic;
begin
  with Sender as TDButton do begin
    if (g_Myself = nil) or (g_Myself.m_HeroObject = nil) then Exit;
{$IF SERIESSKILL}
    if g_Myself.m_HeroObject.n_boState and (m_nHeroIPStatePage = 3) then begin
      {if tag = 3 then begin
        d := g_WMainImages.Images[912];
        if d <> nil then
          dsurface.Draw(SurfaceX(Left - 2), SurfaceY(Top - 4), d.ClientRect, d, True);
      end else begin}
      case g_hTempSeriesSkillArr[tag] of
        0: begin //空
            if g_hMagicList2.Count > 0 then begin
              if tag = 3 then begin
                d := g_Wui.Images[1297];
                if d = nil then d := g_WMainImages.Images[903 + tag * 2 + Integer(Downed)];
              end else
                d := g_WMainImages.Images[903 + tag * 2 + Integer(Downed)];
            end else begin
              if tag = 3 then begin
                d := g_Wui.Images[1297];
                if d = nil then d := g_WMainImages.Images[903 + tag * 2 + Integer(Downed)];
              end else
                d := g_WMainImages.Images[913 + tag];
            end;
            if d <> nil then
              dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
          end;
        1: begin //随机
            d := g_WMainImages.Images[909 + Integer(Downed)];
            if d <> nil then
              dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
          end;
      else begin
          icon := GetSeriesSkillIcon(g_hTempSeriesSkillArr[tag]);
          icon := icon + Integer(Downed);
          if icon > 0 then begin
            d := g_WMainImages.Images[icon];
            if d <> nil then
              dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
          end;
        end;
      end;
      //end;
    end;
{$IFEND SERIESSKILL}
  end;
end;

procedure TFrmDlg.DHSeMag1MouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
  b: Boolean;
  i, ii: Integer;
  pm: PTClientMagic;
begin
{$IF SERIESSKILL}
  if g_hMagicList2.Count = 0 then Exit;
  with Sender as TDButton do begin
    DHListBoxSSkill.tag := -1;
    DHListBoxSSkill.Left := Left - 2;
    DHListBoxSSkill.Top := Top + Height + 1;
    DHListBoxSSkill.Visible := not DHListBoxSSkill.Visible;
    if DHListBoxSSkill.Visible then begin
      DHListBoxSSkill.tag := tag;
      g_hSeriesSkillSelList.Clear;
      for i := 0 to g_hMagicList2.Count - 1 do begin
        pm := PTClientMagic(g_hMagicList2[i]);
        b := False;
        for ii := 0 to 3 do
          if pm.Def.wMagicId = g_hTempSeriesSkillArr[ii] then begin
            b := True;
            Break;
          end;
        if not b then g_hSeriesSkillSelList.AddObject(pm.Def.sMagicName, TObject(pm.Def.wMagicId));
      end;
      g_hSeriesSkillSelList.AddObject('空', TObject(Integer(0)));
      if g_hMagicList2.Count > 1 then g_hSeriesSkillSelList.AddObject('随机', TObject(Integer(1)));
    end;
  end;
{$IFEND SERIESSKILL}
end;

procedure TFrmDlg.DHStateWinDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  i, L, M, pgidx, magline, bbx, bby, mmx, idx, ax, ay, trainlv, FontColor: Integer;
  pm: PTClientMagic;
  d: TCustomLockableTexture;
  hcolor, old, keyimg: Integer;
  iname, d1, d2, d3, d4: string;
  useable: Boolean;
  rc: TIntRect;
begin
  if (g_Myself = nil) or (g_Myself.m_HeroObject = nil) then
    Exit;

  with DHStateWin do begin
{$IFDEF UI_0508}
    d := WLib.Images[FaceIndex];
    if d <> nil then dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);

    DBHStateDirectPaint(DBHState, dsurface);

    if g_Myself.m_HeroObject.m_nIPowerLvl > 0 then begin
      d := g_WMain2Images.Images[746 + Integer(g_Myself.m_HeroObject.n_boState)];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left + 36), SurfaceY(Top + 31), d.ClientRect, d, True);
    end;

    if not g_Myself.m_HeroObject.n_boState then begin
      case m_nHeroStatePage of
        0: begin
            if g_Myself.m_HeroObject.m_btSex = 1 then
              pgidx := 381
            else
              pgidx := 380;
            bbx := Left + 38;
            bby := Top + 52;
            d := g_WMain3Images.Images[pgidx];
            if d <> nil then
              dsurface.Draw(SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, False);
            bbx := bbx - 7;
            bby := bby + 44;

            if g_Myself.m_HeroObject.m_btHairEx <= 0 then begin
              idx := 440 + g_Myself.m_HeroObject.m_btHair div 2 + g_Myself.m_HeroObject.m_btSex;
              //idx := 440 + g_MySelf.m_btHair div 2 + g_MySelf.m_btSex;
              //idx := 440 + g_MySelf.m_HeroObject.m_btHair;
              if idx > 0 then begin
                d := g_WMainImages.GetCachedImage(idx, ax, ay);
                if d <> nil then
                  dsurface.Draw(SurfaceX(bbx + ax), SurfaceY(bby + ay), d.ClientRect, d, True);
              end;
            end;

            if g_HeroUseItems[U_DRESS].s.Name <> '' then begin
              idx := g_HeroUseItems[U_DRESS].s.looks;
              if idx >= 0 then begin
                d := frmMain.GetWStateImg(idx, ax, ay);
                if d <> nil then
                  dsurface.Draw(SurfaceX(bbx + ax), SurfaceY(bby + ay), d.ClientRect, d, True);

                if g_HeroUseItems[U_DRESS].s.reserve[3] = 1 then begin
                  d := frmMain.GetWStateImg(2425 + g_Myself.m_HeroObject.m_btSex, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end;
                if g_HeroUseItems[U_DRESS].s.reserve[3] = 2 then begin
                  d := frmMain.GetWStateImg(2541 + g_Myself.m_HeroObject.m_btSex * 2, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end;
                if g_HeroUseItems[U_DRESS].s.reserve[3] = 3 then begin

                  if GetTickCount - g_hDressEffectTick > 200 then begin
                    g_hDressEffectTick := GetTickCount;
                    Inc(g_hDressEffectIdx);
                    if g_hDressEffectIdx >= 20 then
                      g_hDressEffectIdx := 0;
                  end;

                  d := frmMain.GetWStateImg(2600 + g_hDressEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end;
                if g_HeroUseItems[U_DRESS].s.reserve[3] = 4 then begin

                  if GetTickCount - g_hDressEffectTick > 200 then begin
                    g_hDressEffectTick := GetTickCount;
                    Inc(g_hDressEffectIdx);
                    if g_hDressEffectIdx >= 10 then
                      g_hDressEffectIdx := 0;
                  end;

                  if g_Myself.m_HeroObject.m_btSex = 0 then
                    d := frmMain.GetWStateImg(3550 + g_hDressEffectIdx, ax, ay)
                  else
                    d := frmMain.GetWStateImg(3570 + g_hDressEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end;
                if g_HeroUseItems[U_DRESS].s.reserve[3] = 5 then begin

                  if GetTickCount - g_hDressEffectTick > 200 then begin
                    g_hDressEffectTick := GetTickCount;
                    Inc(g_hDressEffectIdx);
                    if g_hDressEffectIdx >= 8 then
                      g_hDressEffectIdx := 0;
                  end;

                  if g_Myself.m_HeroObject.m_btSex = 0 then
                    d := frmMain.GetWStateImg(3680 + g_hDressEffectIdx, ax, ay)
                  else
                    d := frmMain.GetWStateImg(3690 + g_hDressEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if g_HeroUseItems[U_DRESS].s.reserve[3] = 6 then begin
                  if GetTickCount - g_hDressEffectTick > 200 then begin
                    g_hDressEffectTick := GetTickCount;
                    Inc(g_hDressEffectIdx);
                    if g_hDressEffectIdx >= 8 then
                      g_hDressEffectIdx := 0;
                  end;
                  d := frmMain.GetWStateImg(3800 + g_hDressEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if g_HeroUseItems[U_DRESS].s.reserve[3] = 7 then begin
                  if GetTickCount - g_hDressEffectTick > 200 then begin
                    g_hDressEffectTick := GetTickCount;
                    Inc(g_hDressEffectIdx);
                    if g_hDressEffectIdx >= 9 then
                      g_hDressEffectIdx := 0;
                  end;
                  if g_Myself.m_HeroObject.m_btSex = 0 then
                    d := frmMain.GetWStateImg(3950 + g_hDressEffectIdx, ax, ay)
                  else
                    d := frmMain.GetWStateImg(3959 + g_hDressEffectIdx, ax, ay);
                  if d <> nil then
                   dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if g_HeroUseItems[U_DRESS].s.reserve[3] = 8 then begin
                  if GetTickCount - g_hDressEffectTick > 200 then begin
                    g_hDressEffectTick := GetTickCount;
                    Inc(g_hDressEffectIdx);
                    if g_hDressEffectIdx >= 10 then
                      g_hDressEffectIdx := 0;
                  end;
                  if g_Myself.m_HeroObject.m_btSex = 0 then
                    d := frmMain.GetWStateImg(3968 + g_hDressEffectIdx, ax, ay)
                  else
                    d := frmMain.GetWStateImg(3978 + g_hDressEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if g_HeroUseItems[U_DRESS].s.reserve[3]  in [100..249] then begin  //自定义特效四格  衣服 看英雄
                  if GetTickCount - g_hDressEffectTick > 200 then begin
                    g_hDressEffectTick := GetTickCount;
                    Inc(g_hDressEffectIdx);
                    if g_hDressEffectIdx >= 20 then
                      g_hDressEffectIdx := 0;
                  end;
                  d := frmMain.GetWStateImg(30000 + (g_HeroUseItems[U_DRESS].s.reserve[3]+1 - 100) * 20-20 + g_hDressEffectIdx, ax, ay);
                  if d = nil then begin
                    g_hDressEffectIdx := 0;
                    d := frmMain.GetWStateImg(30000 + (g_HeroUseItems[U_DRESS].s.reserve[3]+1 - 100) * 20-20 + g_hDressEffectIdx, ax, ay);
                  end;
                  if d <> nil then begin
                      dsurface.DrawBlend(SurfaceX(bbx + ax), SurfaceY(bby + ay), d, 1);
                  end;
                end;
              end;
            end;
            if g_HeroUseItems[U_WEAPON].s.Name <> '' then begin
              idx := g_HeroUseItems[U_WEAPON].s.looks;
              if idx >= 0 then begin
                d := frmMain.GetWStateImg(idx, ax, ay);
                if d <> nil then
                  dsurface.Draw(SurfaceX(bbx + ax), SurfaceY(bby + ay), d.ClientRect, d, True);
                if g_HeroUseItems[U_WEAPON].s.reserve[3] = 1 then begin
                  d := frmMain.GetWStateImg(1403, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if g_HeroUseItems[U_WEAPON].s.reserve[3] = 3 then begin
                  d := frmMain.GetWStateImg(2427, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if (g_HeroUseItems[U_WEAPON].s.reserve[3] = 2) {and (idx = 1880)} then begin
                  if GetTickCount - g_hWeaponEffectTick > 200 then begin
                    g_hWeaponEffectTick := GetTickCount;
                    Inc(g_hWeaponEffectIdx);
                    if g_hWeaponEffectIdx > 9 then
                      g_hWeaponEffectIdx := 0;
                  end;

                  d := frmMain.GetWStateImg(1890 + g_hWeaponEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if (g_HeroUseItems[U_WEAPON].s.reserve[3] = 4) then begin
                  //if (idx = 2523) then begin
                  if GetTickCount - g_hWeaponEffectTick > 200 then begin
                    g_hWeaponEffectTick := GetTickCount;
                    Inc(g_hWeaponEffectIdx);
                    if g_hWeaponEffectIdx > 7 then
                      g_hWeaponEffectIdx := 0;
                  end;

                  d := frmMain.GetWStateImg(2530 + g_hWeaponEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                  //end;
                end else if (g_HeroUseItems[U_WEAPON].s.reserve[3] = 5) then begin
                  //if (idx = 2524) then begin
                  if GetTickCount - g_hWeaponEffectTick > 200 then begin
                    g_hWeaponEffectTick := GetTickCount;
                    Inc(g_hWeaponEffectIdx);
                    if g_hWeaponEffectIdx > 9 then
                      g_hWeaponEffectIdx := 0;
                  end;

                  d := frmMain.GetWStateImg(2550 + g_hWeaponEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                  //end;
                end else if (g_HeroUseItems[U_WEAPON].s.reserve[3] = 6) then begin
                  //if (idx = 2525) then begin
                  if GetTickCount - g_hWeaponEffectTick > 200 then begin
                    g_hWeaponEffectTick := GetTickCount;
                    Inc(g_hWeaponEffectIdx);
                    if g_hWeaponEffectIdx > 9 then
                      g_hWeaponEffectIdx := 0;
                  end;

                  d := frmMain.GetWStateImg(2560 + g_hWeaponEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                  //end;
                end else if (g_HeroUseItems[U_WEAPON].s.reserve[3] in [7..9]) then begin
                  if GetTickCount - g_hWeaponEffectTick > 200 then begin
                    g_hWeaponEffectTick := GetTickCount;
                    Inc(g_hWeaponEffectIdx);
                    if g_hWeaponEffectIdx > 13 then
                      g_hWeaponEffectIdx := 0;
                  end;

                  d := frmMain.GetWStateImg(3480 + (g_HeroUseItems[U_WEAPON].s.reserve[3] - 7) * 20 + g_hWeaponEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if (g_HeroUseItems[U_WEAPON].s.reserve[3] in [10..12]) then begin
                  if GetTickCount - g_hWeaponEffectTick > 200 then begin
                    g_hWeaponEffectTick := GetTickCount;
                    Inc(g_hWeaponEffectIdx);
                    if g_hWeaponEffectIdx >= 18 then
                      g_hWeaponEffectIdx := 0;
                  end;

                  d := frmMain.GetWStateImg(3610 + (g_HeroUseItems[U_WEAPON].s.reserve[3] - 10) * 20 + g_hWeaponEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if (g_HeroUseItems[U_WEAPON].s.reserve[3] in [13..15]) then begin
                  if GetTickCount - g_sWeaponEffectTick > 200 then begin
                    g_sWeaponEffectTick := GetTickCount;
                    Inc(g_sWeaponEffectIdx);
                    if g_sWeaponEffectIdx >= 18 then
                      g_sWeaponEffectIdx := 0;
                  end;

                  d := frmMain.GetWStateImg(3820 + (g_HeroUseItems[U_WEAPON].s.reserve[3] - 13) * 20 + g_sWeaponEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if (g_HeroUseItems[U_WEAPON].s.reserve[3] in [16]) then begin
                  if GetTickCount - g_sWeaponEffectTick > 200 then begin
                    g_sWeaponEffectTick := GetTickCount;
                    Inc(g_sWeaponEffectIdx);
                    if g_sWeaponEffectIdx >= 16 then
                      g_sWeaponEffectIdx := 0;
                  end;

                  d := frmMain.GetWStateImg(2850 + g_sWeaponEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if (g_HeroUseItems[U_WEAPON].s.reserve[3] in [100..249]) then begin //自定义特效四格  武器 看英雄
                  if GetTickCount - g_sWeaponEffectTick > 200 then begin
                    g_sWeaponEffectTick := GetTickCount;
                    Inc(g_sWeaponEffectIdx);
                    if g_sWeaponEffectIdx >= 20 then
                      g_sWeaponEffectIdx := 0;
                  end;

                  d := frmMain.GetWStateImg(30000 + (g_HeroUseItems[U_WEAPON].s.reserve[3]+1 - 100) * 20-20+g_sWeaponEffectIdx, ax, ay);
                  if d = nil then begin
                    g_sWeaponEffectIdx := 0;
                    d := frmMain.GetWStateImg(30000 + (g_HeroUseItems[U_WEAPON].s.reserve[3]+1 - 100) * 20-20+g_sWeaponEffectIdx, ax, ay);
                  end;
                  if d <> nil then begin
                  dsurface.DrawBlend(SurfaceX(bbx + ax), SurfaceY(bby + ay), d, 1);
                  end;
                end;

              end;
            end;
            pgidx := 1;
            if g_HeroUseItems[U_HELMETEX].s.Name <> '' then begin
              idx := g_HeroUseItems[U_HELMETEX].s.looks;
              if idx >= 0 then begin
                if g_HeroUseItems[U_HELMETEX].s.Source <> 0 then
                  pgidx := 1
                else
                  pgidx := 0;
                d := frmMain.GetWStateImg(idx, ax, ay);
                if d <> nil then
                  dsurface.Draw(SurfaceX(bbx + ax), SurfaceY(bby + ay), d.ClientRect, d, True);
              end;
            end;
            if (g_HeroUseItems[U_HELMET].s.Name <> '') then begin
              idx := g_HeroUseItems[U_HELMET].s.looks;
              if idx >= 0 then begin
                if (pgidx <> 0) then begin
                  d := frmMain.GetWStateImg(idx, ax, ay);
                  if d <> nil then
                    dsurface.Draw(SurfaceX(bbx + ax), SurfaceY(bby + ay), d.ClientRect, d, True);
                end;

                if (g_HeroUseItems[U_HELMET].s.Shape = 190) or (g_HeroUseItems[U_HELMET].s.reserve[3] = 4) then begin
                  if GetTickCount - g_HeroUseItemsShine[U_HELMET].tick > 60 then begin
                    g_HeroUseItemsShine[U_HELMET].tick := GetTickCount;
                    Inc(g_HeroUseItemsShine[U_HELMET].idx);
                    if g_HeroUseItemsShine[U_HELMET].idx > 31 then
                      g_HeroUseItemsShine[U_HELMET].idx := 0;
                  end;
                  d := g_Wui.Images[220 + g_HeroUseItemsShine[U_HELMET].idx];
                  if d <> nil then
                    dsurface.DrawBlend( SurfaceX(bbx + ax - 12), SurfaceY(bby + ay - 10), d, 1);
                end else if g_HeroUseItems[U_HELMET].s.reserve[3] = 3 then begin
                  if GetTickCount - g_HeroUseItemsShine[U_HELMET].tick > 100 then begin
                    g_HeroUseItemsShine[U_HELMET].tick := GetTickCount;
                    Inc(g_HeroUseItemsShine[U_HELMET].idx);
                    if g_HeroUseItemsShine[U_HELMET].idx >= 10 then
                      g_HeroUseItemsShine[U_HELMET].idx := 0;
                  end;
                  d := g_StateEffect.Images[580 + g_HeroUseItemsShine[U_HELMET].idx];
                  if d <> nil then
                    dsurface.DrawBlend( SurfaceX(bbx + ax - d.Width div 4), SurfaceY(bby + ay - d.Height div 4), d, 1);
                end else if g_HeroUseItems[U_HELMET].s.reserve[3] >= 100 then begin   //20200927四格头盔特效英雄
                  if GetTickCount - g_HeroUseItemsShine[U_HELMET].tick > 200 then begin
                    g_HeroUseItemsShine[U_HELMET].tick := GetTickCount;
                    Inc(g_HeroUseItemsShine[U_HELMET].idx);
                    if g_HeroUseItemsShine[U_HELMET].idx > 19 then
                      g_HeroUseItemsShine[U_HELMET].idx := 0;
                  end;
                  d := frmMain.GetWStateImg(30000 + (g_HeroUseItems[U_HELMET].s.reserve[3]+1 - 100) * 20-20+ g_HeroUseItemsShine[U_HELMET].idx);
                  if d = nil then begin
                    g_HeroUseItemsShine[U_HELMET].idx := 0;
                    d := frmMain.GetWStateImg(30000 + (g_HeroUseItems[U_HELMET].s.reserve[3]+1 - 100) * 20-20+ g_HeroUseItemsShine[U_HELMET].idx);
                  end;
                  if d <> nil then begin
                  dsurface.DrawBlend( SurfaceX(bbx + ax - 4 - d.Width div 4), SurfaceY(bby + ay - d.Height div 4), d, 1);
                  end;
                end;
              end;
            end;

            //检测是否有斗笠
            with dsurface do begin
              FontColor := g_Myself.m_HeroObject.m_nNameColor;
              TextOut(SurfaceX(Left + 122 - FontManager.Default.TextWidth(frmMain.m_sHeroCharName) div 2), SurfaceY(Top + 53), g_Myself.m_HeroObject.m_sUserName, FontColor);
            end;
          end;
        1: begin
            bbx := Left + 38 + 1;
            bby := Top + 52 - 1;
            d := g_opui.Images[g_sStateWindowHero];
            if d <> nil then dsurface.Draw(SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, False);
            L := Left + 110;
            M := Top + 98;
            with dsurface do begin
              FontColor := clWhite;
              TextOut(SurfaceX(L + 0), SurfaceY(M + 0), IntToStr(LoWord(g_Myself.m_HeroObject.m_Abil.AC)) + '-' + IntToStr(HiWord(g_Myself.m_HeroObject.m_Abil.AC)), FontColor);
              TextOut(SurfaceX(L + 0), SurfaceY(M + 20), IntToStr(LoWord(g_Myself.m_HeroObject.m_Abil.MAC)) + '-' + IntToStr(HiWord(g_Myself.m_HeroObject.m_Abil.MAC)), FontColor);
              TextOut(SurfaceX(L + 0), SurfaceY(M + 40), IntToStr(LoWord(g_Myself.m_HeroObject.m_Abil.DC)) + '-' + IntToStr(HiWord(g_Myself.m_HeroObject.m_Abil.DC)), FontColor);
              TextOut(SurfaceX(L + 0), SurfaceY(M + 60), IntToStr(LoWord(g_Myself.m_HeroObject.m_Abil.MC)) + '-' + IntToStr(HiWord(g_Myself.m_HeroObject.m_Abil.MC)), FontColor);
              TextOut(SurfaceX(L + 0), SurfaceY(M + 80), IntToStr(LoWord(g_Myself.m_HeroObject.m_Abil.SC)) + '-' + IntToStr(HiWord(g_Myself.m_HeroObject.m_Abil.SC)), FontColor);
              TextOut(SurfaceX(L + 0), SurfaceY(M + 100), IntToStr(g_Myself.m_HeroObject.m_Abil.HP) + '/' + IntToStr(g_Myself.m_HeroObject.m_Abil.MaxHP), FontColor);
              TextOut(SurfaceX(L + 0), SurfaceY(M + 120), IntToStr(g_Myself.m_HeroObject.m_Abil.MP) + '/' + IntToStr(g_Myself.m_HeroObject.m_Abil.MaxMP), FontColor);
            end;
          end;
        2: begin
            bbx := Left + 38 + 20;
            bby := Top + 52 + 10;
            with dsurface do begin
              mmx := bbx + 75;
              FontColor := clSilver;
              TextOut(bbx, bby, '当前经验', FontColor);
              TextOut(mmx, bby, IntToStr(g_Myself.m_HeroObject.m_Abil.Exp), FontColor);
              TextOut(bbx, bby + 14 * 1, '升级经验', FontColor);
              TextOut(mmx, bby + 14 * 1, IntToStr(g_Myself.m_HeroObject.m_Abil.MaxExp), FontColor);
              TextOut(bbx, bby + 14 * 2, '背包重量', FontColor);
              if g_Myself.m_HeroObject.m_Abil.Weight > g_Myself.m_HeroObject.m_Abil.MaxWeight then FontColor := clRed;
              TextOut(mmx, bby + 14 * 2, IntToStr(g_Myself.m_HeroObject.m_Abil.Weight) + '/' + IntToStr(g_Myself.m_HeroObject.m_Abil.MaxWeight), FontColor);
              FontColor := clSilver;
              TextOut(bbx, bby + 14 * 3, '穿戴重量', FontColor);
              if g_Myself.m_HeroObject.m_Abil.WearWeight > g_Myself.m_HeroObject.m_Abil.MaxWearWeight then FontColor := clRed;
              TextOut(mmx, bby + 14 * 3, IntToStr(g_Myself.m_HeroObject.m_Abil.WearWeight) + '/' + IntToStr(g_Myself.m_HeroObject.m_Abil.MaxWearWeight), FontColor);
              FontColor := clSilver;
              TextOut(bbx, bby + 14 * 4, '腕力', FontColor);
              if g_Myself.m_HeroObject.m_Abil.HandWeight > g_Myself.m_HeroObject.m_Abil.MaxHandWeight then FontColor := clRed;
              TextOut(mmx, bby + 14 * 4, IntToStr(g_Myself.m_HeroObject.m_Abil.HandWeight) + '/' + IntToStr(g_Myself.m_HeroObject.m_Abil.MaxHandWeight), FontColor);
              FontColor := clSilver;
              TextOut(bbx, bby + 14 * 5, '准确度', FontColor);
              TextOut(mmx, bby + 14 * 5, IntToStr(g_nHeroHitPoint), FontColor);
              TextOut(bbx, bby + 14 * 6, '敏捷度', FontColor);
              TextOut(mmx, bby + 14 * 6, IntToStr(g_nHeroSpeedPoint), FontColor);
              TextOut(bbx, bby + 14 * 7, '魔法躲避', FontColor);
              TextOut(mmx, bby + 14 * 7, '+' + IntToStr(g_nHeroAntiMagic * 10) + '%', FontColor);
              TextOut(bbx, bby + 14 * 8, '毒物躲避', FontColor);
              TextOut(mmx, bby + 14 * 8, '+' + IntToStr(g_nHeroAntiPoison * 10) + '%', FontColor);
              TextOut(bbx, bby + 14 * 9, '中毒恢复', FontColor);
              TextOut(mmx, bby + 14 * 9, '+' + IntToStr(g_nHeroPoisonRecover * 10) + '%', FontColor);
              TextOut(bbx, bby + 14 * 10, '体力恢复', FontColor);
              TextOut(mmx, bby + 14 * 10, '+' + IntToStr(g_nHeroHealthRecover * 10) + '%', FontColor);
              TextOut(bbx, bby + 14 * 11, '魔法恢复', FontColor);
              TextOut(mmx, bby + 14 * 11, '+' + IntToStr(g_nHeroSpellRecover * 10) + '%', FontColor);

              //TextOutA(bbx, bby + 14 * 12, '内力恢复');
              //TextOutA(mmx, bby + 14 * 12, IntToStr(g_nHeroIPowerRecover));
            end;
          end;
        3: begin
            bbx := Left + 39;
            bby := Top + 51;
            d := g_WMain2Images.Images[751]; // _WMain3Images.Images[382];
            if d <> nil then begin
              rc := d.ClientRect;
//              Dec(rc.Right, 3);
//              Dec(rc.Bottom, 3);
              dsurface.Draw(SurfaceX(bbx), SurfaceY(bby), rc, d, False);
            end;
            m_nHMagTop := m_nHeroMagicPage * 6;
            magline := _MIN(m_nHeroMagicPage * 6 + 6, g_HeroMagicList.Count);
            for i := m_nHMagTop to magline - 1 do begin
              M := i - m_nHMagTop;
              d := g_WMainImages.Images[112]; //Lv
              if d <> nil then
                dsurface.Draw(bbx + 48, bby + 8 + 15 + M * 37, d.ClientRect, d, True);
              d := g_WMainImages.Images[111]; //exp
              if d <> nil then
                dsurface.Draw(bbx + 48 + 26, bby + 8 + 15 + M * 37, d.ClientRect, d, True);
            end;

            with dsurface do begin
              for i := m_nHMagTop to magline - 1 do begin
                pm := PTClientMagic(g_HeroMagicList[i]);
                if pm.Key = #0 then begin
                  iname := '';
                  FontColor := clSilver;
                end else begin
                  iname := '[关]';
                  FontColor := clGray;
                end;
                M := i - m_nHMagTop;

                TextOut(bbx + 48, bby + 8 + M * 37, pm.Def.sMagicName + iname, FontColor);
                trainlv := _MIN(14, pm.Level);
                TextOut(bbx + 48 + 16, bby + 8 + 15 + M * 37, IntToStr(pm.Level), FontColor);
                if pm.Def.MaxTrain[trainlv] > 0 then begin
                  if trainlv < pm.Def.btTrainLv then
                    TextOut(bbx + 48 + 46, bby + 8 + 15 + M * 37, IntToStr(pm.CurTrain) + '/' + IntToStr(pm.Def.MaxTrain[trainlv]), FontColor)
                  else
                    TextOut(bbx + 48 + 46, bby + 8 + 15 + M * 37, IntToStr(trainlv), FontColor);
                end;
              end;
            end;
          end;
      end;
    end else if g_Myself.m_HeroObject.m_nIPowerLvl > 0 then begin
      case m_nHeroIPStatePage of
        0: begin
            bbx := Left + 38;
            bby := Top + 52;
            d := g_WMain2Images.Images[749];
            if d <> nil then begin
              rc := d.ClientRect;
//              Dec(rc.Right, 3);
//              Dec(rc.Bottom, 4);
              dsurface.Draw(SurfaceX(bbx), SurfaceY(bby), rc, d, False);
            end;
            d := g_WMain2Images.Images[752];
            if d <> nil then begin
              dsurface.Draw(SurfaceX(bbx + 87), SurfaceY(bby + 50 + 27 * 0), rc, d, False);
              dsurface.Draw(SurfaceX(bbx + 87), SurfaceY(bby + 50 + 27 * 1), rc, d, False);
              dsurface.Draw(SurfaceX(bbx + 87), SurfaceY(bby + 50 + 27 * 2), rc, d, False);
              dsurface.Draw(SurfaceX(bbx + 87), SurfaceY(bby + 50 + 27 * 3), rc, d, False);
              dsurface.Draw(SurfaceX(bbx + 87), SurfaceY(bby + 50 + 27 * 4), rc, d, False);
              dsurface.Draw(SurfaceX(bbx + 87), SurfaceY(bby + 50 + 27 * 5), rc, d, False);
              dsurface.Draw(SurfaceX(bbx + 87), SurfaceY(bby + 50 + 27 * 6), rc, d, False);
            end;
            L := Left + 48;
            M := Top + 105;
            dsurface.BoldTextOut(SurfaceX(L + 00), SurfaceY(M + 27 * 0), clSilver, clBlack, '当前内功等级');
            dsurface.BoldTextOut(SurfaceX(L + 00), SurfaceY(M + 27 * 1), clSilver, clBlack, '当前内功经验');
            dsurface.BoldTextOut(SurfaceX(L + 00), SurfaceY(M + 27 * 2), clSilver, clBlack, '升级所需经验');
            dsurface.BoldTextOut(SurfaceX(L + 00), SurfaceY(M + 27 * 3), clSilver, clBlack, '内   力   值');

            dsurface.BoldTextOut(SurfaceX(L + 00), SurfaceY(M + 27 * 4), clSilver, clBlack, '内功恢复速度');
            dsurface.BoldTextOut(SurfaceX(L + 00), SurfaceY(M + 27 * 5), clSilver, clBlack, '内功增加伤害');
            dsurface.BoldTextOut(SurfaceX(L + 00), SurfaceY(M + 27 * 6), clSilver, clBlack, '内功减免伤害');

            with dsurface do begin
              FontColor := clSilver;
              TextOut(SurfaceX(L + 83), SurfaceY(M + 27 * 0 - 1), IntToStr(g_Myself.m_HeroObject.m_nIPowerLvl), FontColor);
              TextOut(SurfaceX(L + 83), SurfaceY(M + 27 * 1 - 1), IntToStr(g_Myself.m_HeroObject.m_nIPowerExp), FontColor);
              TextOut(SurfaceX(L + 83), SurfaceY(M + 27 * 2 - 1), IntToStr(g_dwIPNeedInfo[g_Myself.m_HeroObject.m_nIPowerLvl].dwHExp), FontColor);
              TextOut(SurfaceX(L + 83), SurfaceY(M + 27 * 3 - 1), Format('%d/%d', [g_Myself.m_HeroObject.m_nIPower, g_dwIPNeedInfo[g_Myself.m_HeroObject.m_nIPowerLvl].nPower]), FontColor);
              TextOut(SurfaceX(L + 83), SurfaceY(M + 27 * 4 - 1), IntToStr(g_nHeroIPowerRecover), FontColor);
              TextOut(SurfaceX(L + 83), SurfaceY(M + 27 * 5 - 1), IntToStr(g_nHeroAddDamage), FontColor);
              TextOut(SurfaceX(L + 83), SurfaceY(M + 27 * 6 - 1), IntToStr(g_nHeroDecDamage), FontColor);
            end;
          end;
        1: begin
            bbx := Left + 38;
            bby := Top + 52;
            d := g_WMain2Images.Images[751]; //g_WMain3Images.Images[33];
            if d <> nil then begin
              rc := d.ClientRect;
//              Dec(rc.Right, 3);
//              Dec(rc.Bottom, 4);
              dsurface.Draw(SurfaceX(bbx + 1), SurfaceY(bby - 1), rc, d, False);
            end;
            m_nMagTop := m_nHeroIPMagicPage * 6;
            magline := _MIN(m_nHeroIPMagicPage * 6 + 6, g_HeroIPMagicList.Count);
            for i := m_nMagTop to magline - 1 do begin
              pm := PTClientMagic(g_HeroIPMagicList[i]);
              M := i - m_nMagTop;
              d := g_WMainImages.Images[112]; //Level
              if d <> nil then
                dsurface.Draw(bbx + 48, bby + 8 + 15 + M * 37, d.ClientRect, d, True);
              d := g_WMainImages.Images[111]; //exp
              if d <> nil then
                dsurface.Draw(bbx + 48 + 26, bby + 8 + 15 + M * 37, d.ClientRect, d, True);
            end;

            with dsurface do begin
              FontColor := clSilver;
              for i := m_nMagTop to magline - 1 do begin
                pm := PTClientMagic(g_HeroIPMagicList[i]);
                M := i - m_nMagTop;
                TextOut(bbx + 48, bby + 8 + M * 37, pm.Def.sMagicName, FontColor);
                trainlv := _MIN(14, pm.Level);
                TextOut(bbx + 48 + 16, bby + 8 + 15 + M * 37, IntToStr(pm.Level), FontColor);
                if pm.Def.MaxTrain[trainlv] > 0 then begin
                  if trainlv < pm.Def.btTrainLv then
                    TextOut(bbx + 48 + 46, bby + 8 + 15 + M * 37, IntToStr(pm.CurTrain) + '/' + IntToStr(pm.Def.MaxTrain[trainlv]), FontColor)
                  else
                    TextOut(bbx + 48 + 46, bby + 8 + 15 + M * 37, IntToStr(trainlv), FontColor);
                end;
              end;
            end;
          end;
        2: begin
            bbx := Left + 38;
            bby := Top + 50;
            if DHStateWin.tag in [0] then
              d := g_WMainImages.Images[821 + Integer(g_Myself.m_HeroObject.m_btSex) * 2]
            else if DHStateWin.tag in [1..3] then
              d := g_WMainImages.Images[820 + Integer(g_Myself.m_HeroObject.m_btSex) * 2];
            if d <> nil then
              dsurface.Draw(SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, False);

            d := g_WMainImages.Images[830 + DHStateWin.tag];
            if d <> nil then
              dsurface.Draw(bbx + 96, bby + 5, d.ClientRect, d, True);

            //0 未通 1通 2一重
            d := g_WMainImages.Images[860 + DHStateWin.tag * 10 + g_hVenationInfos[DHStateWin.tag].Level];
            if d <> nil then
              dsurface.DrawBlend( bbx, bby, d, 1);

            dsurface.BoldTextOut(
              SurfaceX(bbx + 122),
              SurfaceY(bby + 143),
              GetRGB(93),
              clBlack,
              g_VenationLvStrArr[g_hVenationInfos[DHStateWin.tag].Level]);

            d := g_WMainImages.Images[840 + DHStateWin.tag];
            if d <> nil then
              dsurface.Draw(bbx, bby, d.ClientRect, d, True);
          end;
        3: begin
            bbx := Left + 38;
            bby := Top + 50;
            d := g_WMainImages.Images[900];
            if d <> nil then begin
              rc := d.ClientRect;
              //Dec(rc.Right, 3);
              //Dec(rc.Bottom, 4);
              dsurface.Draw(SurfaceX(bbx), SurfaceY(bby), rc, d, False);
            end;

            for i := 0 to g_hMagicList2.Count - 1 do begin
              pm := PTClientMagic(g_hMagicList2[i]);
              M := i + 2;
              d := g_WMainImages.Images[112]; //Level
              if d <> nil then
                dsurface.Draw(bbx + 48, bby + 30 + M * 37, d.ClientRect, d, True);
              d := g_WMainImages.Images[111]; //exp
              if d <> nil then
                dsurface.Draw(bbx + 48 + 26, bby + 30 + M * 37, d.ClientRect, d, True);
            end;

            with dsurface do begin
              FontColor := clSilver;
              for i := 0 to g_hMagicList2.Count - 1 do begin
                if i >= 4 then Break;
                pm := PTClientMagic(g_hMagicList2[i]);
                M := i + 2;
                trainlv := _MIN(14, pm.Level);
                trainlv := g_VLvDamageExRate[trainlv] + g_VPoDamageExRate[i];
                TextOut(bbx + 48, bby + 15 + M * 37, pm.Def.sMagicName + ' +' + Format('%d', [trainlv]) + '%暴击', FontColor);
                trainlv := _MIN(14, pm.Level);
                TextOut(bbx + 48 + 16, bby + 30 + M * 37, IntToStr(pm.Level), FontColor);
                if pm.Def.MaxTrain[trainlv] > 0 then begin
                  if trainlv < pm.Def.btTrainLv then
                    TextOut(bbx + 48 + 46, bby + 30 + M * 37, IntToStr(pm.CurTrain) + '/' + IntToStr(pm.Def.MaxTrain[trainlv]), FontColor)
                  else
                    TextOut(bbx + 48 + 46, bby + 30 + M * 37, '-', FontColor);
                end;
              end;
            end;
          end;
      end;
    end;

    if (g_hVMouseInfo <> '') and (g_hVMouseInfoTag in [0..3]) then begin
      with dsurface do begin
        FontColor := clYellow;
        TextOut(SurfaceX(Left + 37), SurfaceY(Top + 272 + 37), g_hVMouseInfo, FontColor);
        FontColor := clWhite;
        trainlv := FontManager.Default.TextWidth(g_hVMouseInfo) + 5;
        d4 := g_VLvHints[g_hVenationInfos[g_hVMouseInfoTag].Level];
        //g_JobofSeriesSkill
        case g_hVenationInfos[g_hVMouseInfoTag].Level of
          1: d4 := Format(d4, [g_JobofSeriesSkill[g_Myself.m_HeroObject.m_btJob][g_hVMouseInfoTag]]);
          2: d4 := Format(d4, [g_JobofSeriesSkill[g_Myself.m_HeroObject.m_btJob][g_hVMouseInfoTag], g_JobofSeriesSkill[g_Myself.m_HeroObject.m_btJob][g_hVMouseInfoTag], g_VLvDamageExRate[g_hVenationInfos[g_hVMouseInfoTag].Level - 1], '%', 1.5]);
          3: d4 := Format(d4, [g_JobofSeriesSkill[g_Myself.m_HeroObject.m_btJob][g_hVMouseInfoTag], g_VLvDamageExRate[g_hVenationInfos[g_hVMouseInfoTag].Level - 1], '%', 1.5]);
          4: d4 := Format(d4, [g_JobofSeriesSkill[g_Myself.m_HeroObject.m_btJob][g_hVMouseInfoTag], g_VLvDamageExRate[g_hVenationInfos[g_hVMouseInfoTag].Level - 1], '%', 1.5]);
          5: d4 := Format(d4, [g_JobofSeriesSkill[g_Myself.m_HeroObject.m_btJob][g_hVMouseInfoTag], g_VLvDamageExRate[g_hVenationInfos[g_hVMouseInfoTag].Level - 1], '%', 1.5]);
          6: d4 := Format(d4, [g_JobofSeriesSkill[g_Myself.m_HeroObject.m_btJob][g_hVMouseInfoTag], g_VLvDamageExRate[g_hVenationInfos[g_hVMouseInfoTag].Level - 1], '%', 1.5]);
        end;
        if d4 <> '' then begin
          L := 0;
          while True do begin
            if d4 = '' then Break;
            d4 := GetValidStr3(d4, d3, ['\']);
            if d3 <> '' then begin
              if L = 0 then
                TextOut(SurfaceX(Left + 37 + trainlv), SurfaceY(Top + 272 + 37 + (FontManager.Default.TextHeight('A') + 2) * (L)), d3, FontColor)
              else
                TextOut(SurfaceX(Left + 37), SurfaceY(Top + 272 + 37 + (FontManager.Default.TextHeight('A') + 2) * (L)), d3, FontColor);
            end;
            Inc(L);
            if L > 2 then Break;
          end;
        end;
      end;
    end;

    if g_hVMouseInfo2 <> '' then begin
      with dsurface do begin
        FontColor := clYellow;
        TextOut(SurfaceX(Left + 37), SurfaceY(Top + 272 + 37), g_hVMouseInfo2, FontColor);
        FontColor := clWhite;
        trainlv := FontManager.Default.TextWidth(g_hVMouseInfo2) + 5;
        d4 := g_hVLvHints2;
        if d4 <> '' then begin
          L := 0;
          while True do begin
            if d4 = '' then Break;
            d4 := GetValidStr3(d4, d3, ['\']);
            if d3 <> '' then begin
              if L = 0 then
                TextOut(SurfaceX(Left + 37 + trainlv), SurfaceY(Top + 272 + 37 + (FontManager.Default.TextHeight('A') + 2) * (L)), d3, FontColor)
              else
                TextOut(SurfaceX(Left + 37), SurfaceY(Top + 272 + 37 + (FontManager.Default.TextHeight('A') + 2) * (L)), d3, FontColor);
            end;
            Inc(L);
            if L > 2 then Break;
          end;
        end;
      end;
    end;
{$ELSE}
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);

    DBHStateDirectPaint(DBHState, dsurface);

    if g_Myself.m_HeroObject.m_nIPowerLvl > 0 then begin
      with DBHState2 do begin
        d := WLib.Images[FaceIndex - byte(g_Myself.m_HeroObject.n_boState)];
        if d <> nil then
          dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);

        try
          if not g_Myself.m_HeroObject.n_boState then begin
            dsurface.BoldTextOut(
              SurfaceX(Left + 60),
              SurfaceY(Top + 4), '基础',
              GetRGB(103),
              clBlack,
              [fsBold], 10);
            dsurface.BoldTextOut(
              SurfaceX(Left + 140),
              SurfaceY(Top + 4), '内功',
              GetRGB(92),
              clBlack,
              [fsBold], 10);
          end else begin
            dsurface.BoldTextOut(
              SurfaceX(Left + 60),
              SurfaceY(Top + 4), '基础',
              GetRGB(92),
              clBlack,
              [fsBold], 10);
            dsurface.BoldTextOut(
              SurfaceX(Left + 140),
              SurfaceY(Top + 4), '内功',
              GetRGB(103),
              clBlack,
              [fsBold], 10);
          end;
        finally
        end;
      end;
    end;

    if not g_Myself.m_HeroObject.n_boState then begin
      case m_nHeroStatePage of
        0: begin
            if g_Myself.m_HeroObject.m_btSex = 1 then
              pgidx := 3222
            else
              pgidx := 3221;
            bbx := Left + 38 - 5;
            bby := Top + 50 + 77;
            d := g_Wui.Images[pgidx];
            if d <> nil then
              dsurface.Draw(SurfaceX(bbx), SurfaceY(bby), d);

            bbx := bbx - 7 + 59;
            bby := bby + 44 + 34;

            if g_Myself.m_HeroObject.m_btHairEx <= 0 then begin
              idx := 440 + g_Myself.m_HeroObject.m_btHair div 2 + g_Myself.m_HeroObject.m_btSex;
              if idx > 0 then begin
                d := g_WMainImages.GetCachedImage(idx, ax, ay);
                if d <> nil then
                  dsurface.Draw(SurfaceX(bbx + ax), SurfaceY(bby + ay), d.ClientRect, d, True);
              end;
            end;

            if g_HeroUseItems[U_DRESS].s.Name <> '' then begin
              idx := g_HeroUseItems[U_DRESS].s.looks;
              if idx >= 0 then begin
                d := frmMain.GetWStateImg(idx, ax, ay);
                if d <> nil then
                  dsurface.Draw(SurfaceX(bbx + ax), SurfaceY(bby + ay), d.ClientRect, d, True);

                if g_HeroUseItems[U_DRESS].s.reserve[3] = 1 then begin
                  d := frmMain.GetWStateImg(2425 + g_Myself.m_HeroObject.m_btSex, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if g_HeroUseItems[U_DRESS].s.reserve[3] = 2 then begin
                  d := frmMain.GetWStateImg(2541 + g_Myself.m_HeroObject.m_btSex * 2, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if g_HeroUseItems[U_DRESS].s.reserve[3] = 3 then begin

                  if GetTickCount - g_sDressEffectTick > 200 then begin
                    g_sDressEffectTick := GetTickCount;
                    Inc(g_sDressEffectIdx);
                    if g_sDressEffectIdx >= 20 then
                      g_sDressEffectIdx := 0;
                  end;

                  d := frmMain.GetWStateImg(2600 + g_sDressEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if g_HeroUseItems[U_DRESS].s.reserve[3] = 4 then begin

                  if GetTickCount - g_sDressEffectTick > 200 then begin
                    g_sDressEffectTick := GetTickCount;
                    Inc(g_sDressEffectIdx);
                    if g_sDressEffectIdx >= 10 then
                      g_sDressEffectIdx := 0;
                  end;

                  if g_Myself.m_HeroObject.m_btSex = 0 then
                    d := frmMain.GetWStateImg(3550 + g_sDressEffectIdx, ax, ay)
                  else
                    d := frmMain.GetWStateImg(3570 + g_sDressEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if g_HeroUseItems[U_DRESS].s.reserve[3] = 5 then begin

                  if GetTickCount - g_sDressEffectTick > 200 then begin
                    g_sDressEffectTick := GetTickCount;
                    Inc(g_sDressEffectIdx);
                    if g_sDressEffectIdx >= 8 then
                      g_sDressEffectIdx := 0;
                  end;

                  if g_Myself.m_HeroObject.m_btSex = 0 then
                    d := frmMain.GetWStateImg(3680 + g_sDressEffectIdx, ax, ay)
                  else
                    d := frmMain.GetWStateImg(3690 + g_sDressEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if g_HeroUseItems[U_DRESS].s.reserve[3] = 6 then begin
                  if GetTickCount - g_hDressEffectTick > 200 then begin
                    g_hDressEffectTick := GetTickCount;
                    Inc(g_hDressEffectIdx);
                    if g_hDressEffectIdx >= 8 then
                      g_hDressEffectIdx := 0;
                  end;
                  d := frmMain.GetWStateImg(3800 + g_hDressEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if g_HeroUseItems[U_DRESS].s.reserve[3] = 7 then begin
                  if GetTickCount - g_hDressEffectTick > 200 then begin
                    g_hDressEffectTick := GetTickCount;
                    Inc(g_hDressEffectIdx);
                    if g_hDressEffectIdx >= 9 then
                      g_hDressEffectIdx := 0;
                  end;
                  if g_Myself.m_HeroObject.m_btSex = 0 then
                    d := frmMain.GetWStateImg(3950 + g_hDressEffectIdx, ax, ay)
                  else
                    d := frmMain.GetWStateImg(3959 + g_hDressEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if g_HeroUseItems[U_DRESS].s.reserve[3] = 8 then begin
                  if GetTickCount - g_hDressEffectTick > 200 then begin
                    g_hDressEffectTick := GetTickCount;
                    Inc(g_hDressEffectIdx);
                    if g_hDressEffectIdx >= 10 then
                      g_hDressEffectIdx := 0;
                  end;
                  if g_Myself.m_HeroObject.m_btSex = 0 then
                    d := frmMain.GetWStateImg(3968 + g_hDressEffectIdx, ax, ay)
                  else
                    d := frmMain.GetWStateImg(3978 + g_hDressEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if g_HeroUseItems[U_DRESS].s.reserve[3]  in [100..249] then begin  //自定义特效六格  衣服 看英雄
                  if GetTickCount - g_hDressEffectTick > 200 then begin
                    g_hDressEffectTick := GetTickCount;
                    Inc(g_hDressEffectIdx);
                    if g_hDressEffectIdx >= 20 then
                      g_hDressEffectIdx := 0;
                  end;
                  d := frmMain.GetWStateImg(30000 + (g_HeroUseItems[U_DRESS].s.reserve[3]+1 - 100) * 20-20 + g_hDressEffectIdx, ax, ay);
                  if d = nil then begin
                    g_hDressEffectIdx := 0;
                    d := frmMain.GetWStateImg(30000 + (g_HeroUseItems[U_DRESS].s.reserve[3]+1 - 100) * 20-20 + g_hDressEffectIdx, ax, ay);
                  end;
                  if d <> nil then begin
                      dsurface.DrawBlend(SurfaceX(bbx + ax), SurfaceY(bby + ay), d, 1);
                  end;
                end;
              end;
            end;
            if g_HeroUseItems[U_WEAPON].s.Name <> '' then begin
              idx := g_HeroUseItems[U_WEAPON].s.looks;
              if idx >= 0 then begin
                d := frmMain.GetWStateImg(idx, ax, ay);
                if d <> nil then
                  dsurface.Draw(SurfaceX(bbx + ax), SurfaceY(bby + ay), d.ClientRect, d, True);

                if g_HeroUseItems[U_WEAPON].s.reserve[3] = 3 then begin
                  d := frmMain.GetWStateImg(2427, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if g_HeroUseItems[U_WEAPON].s.reserve[3] = 1 then begin
                  d := frmMain.GetWStateImg(1403, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if (g_HeroUseItems[U_WEAPON].s.reserve[3] = 2) {and (idx = 1880)} then begin
                  if GetTickCount - g_sWeaponEffectTick > 200 then begin
                    g_sWeaponEffectTick := GetTickCount;
                    Inc(g_sWeaponEffectIdx);
                    if g_sWeaponEffectIdx > 9 then
                      g_sWeaponEffectIdx := 0;
                  end;

                  d := frmMain.GetWStateImg(1890 + g_sWeaponEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if (g_HeroUseItems[U_WEAPON].s.reserve[3] = 4) then begin
                  //if (idx = 2523) then begin
                  if GetTickCount - g_sWeaponEffectTick > 200 then begin
                    g_sWeaponEffectTick := GetTickCount;
                    Inc(g_sWeaponEffectIdx);
                    if g_sWeaponEffectIdx > 7 then
                      g_sWeaponEffectIdx := 0;
                  end;

                  d := frmMain.GetWStateImg(2530 + g_sWeaponEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                  //end;
                end else if (g_HeroUseItems[U_WEAPON].s.reserve[3] = 5) then begin
                  //if (idx = 2524) then begin
                  if GetTickCount - g_sWeaponEffectTick > 200 then begin
                    g_sWeaponEffectTick := GetTickCount;
                    Inc(g_sWeaponEffectIdx);
                    if g_sWeaponEffectIdx > 9 then
                      g_sWeaponEffectIdx := 0;
                  end;

                  d := frmMain.GetWStateImg(2550 + g_sWeaponEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                  //end;
                end else if (g_HeroUseItems[U_WEAPON].s.reserve[3] = 6) then begin
                  //if (idx = 2525) then begin
                  if GetTickCount - g_sWeaponEffectTick > 200 then begin
                    g_sWeaponEffectTick := GetTickCount;
                    Inc(g_sWeaponEffectIdx);
                    if g_sWeaponEffectIdx > 9 then
                      g_sWeaponEffectIdx := 0;
                  end;

                  d := frmMain.GetWStateImg(2560 + g_sWeaponEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                  //end;
                end else if (g_HeroUseItems[U_WEAPON].s.reserve[3] in [7..9]) then begin
                  if GetTickCount - g_sWeaponEffectTick > 200 then begin
                    g_sWeaponEffectTick := GetTickCount;
                    Inc(g_sWeaponEffectIdx);
                    if g_sWeaponEffectIdx > 13 then
                      g_sWeaponEffectIdx := 0;
                  end;

                  d := frmMain.GetWStateImg(3480 + (g_HeroUseItems[U_WEAPON].s.reserve[3] - 7) * 20 + g_sWeaponEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if (g_HeroUseItems[U_WEAPON].s.reserve[3] in [10..12]) then begin
                  if GetTickCount - g_sWeaponEffectTick > 200 then begin
                    g_sWeaponEffectTick := GetTickCount;
                    Inc(g_sWeaponEffectIdx);
                    if g_sWeaponEffectIdx >= 18 then
                      g_sWeaponEffectIdx := 0;
                  end;

                  d := frmMain.GetWStateImg(3610 + (g_HeroUseItems[U_WEAPON].s.reserve[3] - 10) * 20 + g_sWeaponEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if (g_HeroUseItems[U_WEAPON].s.reserve[3] in [13..15]) then begin
                  if GetTickCount - g_sWeaponEffectTick > 200 then begin
                    g_sWeaponEffectTick := GetTickCount;
                    Inc(g_sWeaponEffectIdx);
                    if g_sWeaponEffectIdx >= 18 then
                      g_sWeaponEffectIdx := 0;
                  end;

                  d := frmMain.GetWStateImg(3820 + (g_HeroUseItems[U_WEAPON].s.reserve[3] - 13) * 20 + g_sWeaponEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if (g_HeroUseItems[U_WEAPON].s.reserve[3] in [16]) then begin
                  if GetTickCount - g_sWeaponEffectTick > 200 then begin
                    g_sWeaponEffectTick := GetTickCount;
                    Inc(g_sWeaponEffectIdx);
                    if g_sWeaponEffectIdx >= 16 then
                      g_sWeaponEffectIdx := 0;
                  end;

                  d := frmMain.GetWStateImg(2850 + g_sWeaponEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if (g_HeroUseItems[U_WEAPON].s.reserve[3] in [100..249]) then begin //自定义特效六格  武器 看英雄
                  if GetTickCount - g_sWeaponEffectTick > 200 then begin
                    g_sWeaponEffectTick := GetTickCount;
                    Inc(g_sWeaponEffectIdx);
                    if g_sWeaponEffectIdx >= 20 then
                      g_sWeaponEffectIdx := 0;
                  end;

                  d := frmMain.GetWStateImg(30000 + (g_HeroUseItems[U_WEAPON].s.reserve[3]+1 - 100) * 20-20+g_sWeaponEffectIdx, ax, ay);
                  if d = nil then begin
                    g_sWeaponEffectIdx := 0;
                    d := frmMain.GetWStateImg(30000 + (g_HeroUseItems[U_WEAPON].s.reserve[3]+1 - 100) * 20-20+g_sWeaponEffectIdx, ax, ay);
                  end;
                  if d <> nil then begin
                  dsurface.DrawBlend(SurfaceX(bbx + ax), SurfaceY(bby + ay), d, 1);
                  end;
                end;

              end;
            end;

            trainlv := 1;
            if g_HeroUseItems[U_HELMETEX].s.Name <> '' then begin
              idx := g_HeroUseItems[U_HELMETEX].s.looks;
              if idx >= 0 then begin
                if g_HeroUseItems[U_HELMETEX].s.Source <> 0 then
                  trainlv := 1
                else
                  trainlv := 0;
                d := frmMain.GetWStateImg(idx, ax, ay);
                if d <> nil then
                  dsurface.Draw(SurfaceX(bbx + ax), SurfaceY(bby + ay), d.ClientRect, d, True);
              end;
            end;
            if (g_HeroUseItems[U_HELMET].s.Name <> '') then begin
              idx := g_HeroUseItems[U_HELMET].s.looks;
              if idx >= 0 then begin
                if (trainlv <> 0) then begin
                  d := frmMain.GetWStateImg(idx, ax, ay);
                  if d <> nil then
                    dsurface.Draw(SurfaceX(bbx + ax), SurfaceY(bby + ay), d.ClientRect, d, True);
                end;
                if (g_HeroUseItems[U_HELMET].s.Shape = 190) or (g_HeroUseItems[U_HELMET].s.reserve[3] = 4) then begin
                  if GetTickCount - g_HeroUseItemsShine[U_HELMET].tick > 60 then begin
                    g_HeroUseItemsShine[U_HELMET].tick := GetTickCount;
                    Inc(g_HeroUseItemsShine[U_HELMET].idx);
                    if g_HeroUseItemsShine[U_HELMET].idx > 31 then
                      g_HeroUseItemsShine[U_HELMET].idx := 0;
                  end;
                  d := g_Wui.Images[220 + g_HeroUseItemsShine[U_HELMET].idx];
                  if d <> nil then
                    dsurface.DrawBlend(SurfaceX(bbx + ax - 12), SurfaceY(bby + ay - 10), d, 1);
                end else if g_HeroUseItems[U_HELMET].s.reserve[3] = 3 then begin
                  if GetTickCount - g_HeroUseItemsShine[U_HELMET].tick > 100 then begin
                    g_HeroUseItemsShine[U_HELMET].tick := GetTickCount;
                    Inc(g_HeroUseItemsShine[U_HELMET].idx);
                    if g_HeroUseItemsShine[U_HELMET].idx >= 10 then
                      g_HeroUseItemsShine[U_HELMET].idx := 0;
                  end;
                  d := g_StateEffect.Images[580 + g_HeroUseItemsShine[U_HELMET].idx];
                  if d <> nil then
                    dsurface.DrawBlend(SurfaceX(bbx + ax - d.Width div 4), SurfaceY(bby + ay - d.Height div 4), d, 1);
                end else if g_HeroUseItems[U_HELMET].s.reserve[3] >= 100 then begin   //20200927六格头盔特效英雄
                  if GetTickCount - g_HeroUseItemsShine[U_HELMET].tick > 200 then begin
                    g_HeroUseItemsShine[U_HELMET].tick := GetTickCount;
                    Inc(g_HeroUseItemsShine[U_HELMET].idx);
                    if g_HeroUseItemsShine[U_HELMET].idx > 19 then
                      g_HeroUseItemsShine[U_HELMET].idx := 0;
                  end;
                  d := frmMain.GetWStateImg(30000 + (g_HeroUseItems[U_HELMET].s.reserve[3]+1 - 100) * 20-20+ g_HeroUseItemsShine[U_HELMET].idx);
                  if d = nil then begin
                    g_HeroUseItemsShine[U_HELMET].idx := 0;
                    d := frmMain.GetWStateImg(30000 + (g_HeroUseItems[U_HELMET].s.reserve[3]+1 - 100) * 20-20+ g_HeroUseItemsShine[U_HELMET].idx);
                  end;
                  if d <> nil then begin
                  dsurface.DrawBlend(SurfaceX(bbx + ax - 4 - d.Width div 4), SurfaceY(bby + ay - d.Height div 4), d, 1);
                  end;
                end;

              end;
            end;
          end;
        1: begin
            if g_Myself.m_HeroObject.m_btSex = 1 then
              pgidx := 3284
            else
              pgidx := 3283;
            bbx := Left + 38 - 5;
            bby := Top + 50 + 77;
            d := g_Wui.Images[pgidx];
            if d <> nil then
              dsurface.Draw(SurfaceX(bbx), SurfaceY(bby), d);

            bbx := bbx - 7 + 59;
            bby := bby + 44 + 34;

            idx := 442 + g_Myself.m_HeroObject.m_btSex;
            d := g_WMainImages.GetCachedImage(idx, ax, ay);
            if d <> nil then
              dsurface.Draw(SurfaceX(bbx + ax), SurfaceY(bby + ay), d);
            if g_HeroUseItems[U_FASHION].s.Name <> '' then begin  //看时装特效英雄 六格
              idx := g_HeroUseItems[U_FASHION].s.looks;
              if idx >= 0 then begin
                d := frmMain.GetWStateImg(idx, ax, ay);
                if d <> nil then
                  dsurface.Draw(SurfaceX(bbx + ax), SurfaceY(bby + ay), d.ClientRect, d, True);

                if g_HeroUseItems[U_FASHION].s.reserve[3] = 1 then begin
                  d := frmMain.GetWStateImg(2425 + g_Myself.m_HeroObject.m_btSex, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if g_HeroUseItems[U_FASHION].s.reserve[3] = 2 then begin
                  d := frmMain.GetWStateImg(2541 + g_Myself.m_HeroObject.m_btSex * 2, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if g_HeroUseItems[U_FASHION].s.reserve[3] = 3 then begin

                  if GetTickCount - g_sDressEffectTick > 200 then begin
                    g_sDressEffectTick := GetTickCount;
                    Inc(g_sDressEffectIdx);
                    if g_sDressEffectIdx >= 20 then
                      g_sDressEffectIdx := 0;
                  end;

                  d := frmMain.GetWStateImg(2600 + g_sDressEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if g_HeroUseItems[U_FASHION].s.reserve[3] = 4 then begin

                  if GetTickCount - g_sDressEffectTick > 200 then begin
                    g_sDressEffectTick := GetTickCount;
                    Inc(g_sDressEffectIdx);
                    if g_sDressEffectIdx >= 10 then
                      g_sDressEffectIdx := 0;
                  end;

                  if g_Myself.m_HeroObject.m_btSex = 0 then
                    d := frmMain.GetWStateImg(3550 + g_sDressEffectIdx, ax, ay)
                  else
                    d := frmMain.GetWStateImg(3570 + g_sDressEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if g_HeroUseItems[U_FASHION].s.reserve[3] = 5 then begin

                  if GetTickCount - g_sDressEffectTick > 200 then begin
                    g_sDressEffectTick := GetTickCount;
                    Inc(g_sDressEffectIdx);
                    if g_sDressEffectIdx >= 8 then
                      g_sDressEffectIdx := 0;
                  end;

                  if g_Myself.m_HeroObject.m_btSex = 0 then
                    d := frmMain.GetWStateImg(3680 + g_sDressEffectIdx, ax, ay)
                  else
                    d := frmMain.GetWStateImg(3690 + g_sDressEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if g_HeroUseItems[U_FASHION].s.reserve[3] = 6 then begin
                  if GetTickCount - g_hDressEffectTick > 200 then begin
                    g_hDressEffectTick := GetTickCount;
                    Inc(g_hDressEffectIdx);
                    if g_hDressEffectIdx >= 8 then
                      g_hDressEffectIdx := 0;
                  end;
                  d := frmMain.GetWStateImg(3800 + g_hDressEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if g_HeroUseItems[U_FASHION].s.reserve[3] = 7 then begin
                  if GetTickCount - g_hDressEffectTick > 200 then begin
                    g_hDressEffectTick := GetTickCount;
                    Inc(g_hDressEffectIdx);
                    if g_hDressEffectIdx >= 9 then
                      g_hDressEffectIdx := 0;
                  end;
                  if g_Myself.m_HeroObject.m_btSex = 0 then
                    d := frmMain.GetWStateImg(3950 + g_hDressEffectIdx, ax, ay)
                  else
                    d := frmMain.GetWStateImg(3959 + g_hDressEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if g_HeroUseItems[U_FASHION].s.reserve[3] = 8 then begin
                  if GetTickCount - g_hDressEffectTick > 200 then begin
                    g_hDressEffectTick := GetTickCount;
                    Inc(g_hDressEffectIdx);
                    if g_hDressEffectIdx >= 10 then
                      g_hDressEffectIdx := 0;
                  end;
                  if g_Myself.m_HeroObject.m_btSex = 0 then
                    d := frmMain.GetWStateImg(3968 + g_hDressEffectIdx, ax, ay)
                  else
                    d := frmMain.GetWStateImg(3978 + g_hDressEffectIdx, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(
                      SurfaceX(bbx + ax),
                      SurfaceY(bby + ay),
                      d,
                      1);
                end else if g_HeroUseItems[U_FASHION].s.reserve[3]  in [100..249] then begin  //自定义特效六格  时装  看英雄
                  if GetTickCount - g_hDressEffectTick > 200 then begin
                    g_hDressEffectTick := GetTickCount;
                    Inc(g_hDressEffectIdx);
                    if g_hDressEffectIdx >= 20 then
                      g_hDressEffectIdx := 0;
                  end;
                  d := frmMain.GetWStateImg(30000 + (g_HeroUseItems[U_FASHION].s.reserve[3]+1 - 100) * 20-20 + g_hDressEffectIdx, ax, ay);
                  if d = nil then begin
                    g_hDressEffectIdx := 0;
                    d := frmMain.GetWStateImg(30000 + (g_HeroUseItems[U_FASHION].s.reserve[3]+1 - 100) * 20-20 + g_hDressEffectIdx, ax, ay);
                  end;
                  if d <> nil then begin
                      dsurface.DrawBlend(SurfaceX(bbx + ax), SurfaceY(bby + ay), d, 1);
                  end;
                end;
              end;
          end;
        end;
        2: begin
            bbx := Left + 100;
            bby := Top + 70;
            mmx := bbx + 70;
            with dsurface do begin
              try
                FontColor := clSilver;
                TextOut(bbx, bby + 14 * 6, '职业', FontColor);
                TextOut(mmx, bby + 14 * 6, Format('：%s', [IntToJob(g_Myself.m_HeroObject.m_btJob)]), FontColor);
                TextOut(bbx, bby + 14 * 7, '等级', FontColor);
                TextOut(mmx, bby + 14 * 7, Format('：%d', [g_Myself.m_HeroObject.m_Abil.Level]), FontColor);
                TextOut(bbx, bby + 14 * 8, '当前经验', FontColor);
                TextOut(mmx, bby + 14 * 8, Format('：%s', [IntToStr(g_Myself.m_HeroObject.m_Abil.Exp)]), FontColor);
                TextOut(bbx, bby + 14 * 9, '升级经验', FontColor);
                TextOut(mmx, bby + 14 * 9, Format('：%s', [IntToStr(g_Myself.m_HeroObject.m_Abil.MaxExp)]), FontColor);
                TextOut(bbx, bby + 14 * 10, '体力值', FontColor);
                TextOut(mmx, bby + 14 * 10, Format('：%d/%d', [g_Myself.m_HeroObject.m_Abil.HP, g_Myself.m_HeroObject.m_Abil.MaxHP]), FontColor);
                TextOut(bbx, bby + 14 * 11, '魔法值', FontColor);
                TextOut(mmx, bby + 14 * 11, Format('：%d/%d', [g_Myself.m_HeroObject.m_Abil.MP, g_Myself.m_HeroObject.m_Abil.MaxMP]), FontColor);

                TextOut(bbx, bby + 14 * 12, '金刚石数', FontColor);
                TextOut(mmx, bby + 14 * 12, '：' + IntToStr(g_Myself.m_HeroObject.m_nGameDiamd), FontColor);

                TextOut(bbx, bby + 14 * 13, '灵符数量', FontColor);
                TextOut(mmx, bby + 14 * 13, '：' + IntToStr(g_Myself.m_HeroObject.m_nGameGird), FontColor);

                //FontColor := clYellow;
                //TextOut(bbx, bby + 14 * 14, g_sGameGoldName + '数量', FontColor);
                //TextOut(mmx, bby + 14 * 14, '：' + IntToStr(g_Myself.m_HeroObject.m_nGameGold), FontColor);
              finally

              end;
            end;

          end;
        3: begin
            bbx := Left + 38 - 5;
            bby := Top + 50 + 77;
            d := g_Wui.Images[3226];
            if d <> nil then begin
              dsurface.Draw(SurfaceX(bbx), SurfaceY(bby), d);
            end;
            bbx := Left + 70;
            bby := Top + 70 + 14 * 6;
            mmx := bbx + 45;

            with dsurface do begin
              try
                FontColor := clSilver;
                TextOut(bbx, bby + 14 * 1, '防御', FontColor);
                TextOut(mmx, bby + 14 * 1, Format('%d-%d', [LoWord(g_Myself.m_HeroObject.m_Abil.AC), HiWord(g_Myself.m_HeroObject.m_Abil.AC)]), FontColor);
                TextOut(bbx, bby + 14 * 2, '魔防', FontColor);
                TextOut(mmx, bby + 14 * 2, Format('%d-%d', [LoWord(g_Myself.m_HeroObject.m_Abil.MAC), HiWord(g_Myself.m_HeroObject.m_Abil.MAC)]), FontColor);
                TextOut(bbx, bby + 14 * 3, '攻击', FontColor);
                TextOut(mmx, bby + 14 * 3, Format('%d-%d', [LoWord(g_Myself.m_HeroObject.m_Abil.DC), HiWord(g_Myself.m_HeroObject.m_Abil.DC)]), FontColor);
                TextOut(bbx, bby + 14 * 4, '魔法', FontColor);
                TextOut(mmx, bby + 14 * 4, Format('%d-%d', [LoWord(g_Myself.m_HeroObject.m_Abil.MC), HiWord(g_Myself.m_HeroObject.m_Abil.MC)]), FontColor);
                TextOut(bbx, bby + 14 * 5, '道术', FontColor);
                TextOut(mmx, bby + 14 * 5, Format('%d-%d', [LoWord(g_Myself.m_HeroObject.m_Abil.SC), HiWord(g_Myself.m_HeroObject.m_Abil.SC)]), FontColor);
                TextOut(bbx, bby + 14 * 6, '准确度', FontColor);
                TextOut(mmx, bby + 14 * 6, Format('%d', [g_nHeroHitPoint]), FontColor);
                TextOut(bbx, bby + 14 * 7, '敏捷度', FontColor);
                TextOut(mmx, bby + 14 * 7, Format('%d', [g_nHeroSpeedPoint]), FontColor);

                bbx := Left + 190;
                mmx := bbx + 55;
                TextOut(bbx, bby + 14 * 1, '背包重量', FontColor);
                hcolor := clSilver;
                if g_Myself.m_HeroObject.m_Abil.Weight > g_Myself.m_HeroObject.m_Abil.MaxWeight then
                  hcolor := clRed;
                FontColor := hcolor;
                TextOut(mmx, bby + 14 * 1, Format('%d/%d', [g_Myself.m_HeroObject.m_Abil.Weight, g_Myself.m_HeroObject.m_Abil.MaxWeight]), FontColor);

                TextOut(bbx, bby + 14 * 2, '穿戴重量', FontColor);
                hcolor := clSilver;
                if g_Myself.m_HeroObject.m_Abil.WearWeight > g_Myself.m_HeroObject.m_Abil.MaxWearWeight then
                  hcolor := clRed;
                FontColor := hcolor;
                TextOut(mmx, bby + 14 * 2, Format('%d/%d', [g_Myself.m_HeroObject.m_Abil.WearWeight, g_Myself.m_HeroObject.m_Abil.MaxWearWeight]), FontColor);

                TextOut(bbx, bby + 14 * 3, '腕力', FontColor);
                hcolor := clSilver;
                if g_Myself.m_HeroObject.m_Abil.HandWeight > g_Myself.m_HeroObject.m_Abil.MaxHandWeight then
                  hcolor := clRed;
                FontColor := hcolor;
                TextOut(mmx, bby + 14 * 3, Format('%d/%d', [g_Myself.m_HeroObject.m_Abil.HandWeight, g_Myself.m_HeroObject.m_Abil.MaxHandWeight]), FontColor);

                FontColor := clSilver;
                TextOut(bbx, bby + 14 * 4, '魔法躲避', FontColor);
                TextOut(mmx, bby + 14 * 4, '+' + IntToStr(g_nHeroAntiMagic * 10) + '%', FontColor);

                TextOut(bbx, bby + 14 * 5, '毒物躲避', FontColor);
                TextOut(mmx, bby + 14 * 5, '+' + IntToStr(g_nHeroAntiPoison * 10) + '%', FontColor);

                TextOut(bbx, bby + 14 * 6, '中毒恢复', FontColor);
                TextOut(mmx, bby + 14 * 6, '+' + IntToStr(g_nHeroPoisonRecover * 10) + '%', FontColor);

                TextOut(bbx, bby + 14 * 7, '体力恢复', FontColor);
                TextOut(mmx, bby + 14 * 7, '+' + IntToStr(g_nHeroHealthRecover * 10) + '%', FontColor);

                TextOut(bbx, bby + 14 * 8, '魔法恢复', FontColor);
                TextOut(mmx, bby + 14 * 8, '+' + IntToStr(g_nHeroSpellRecover * 10) + '%', FontColor);

                TextOut(bbx, bby + 14 * 9, '内力恢复', FontColor);
                TextOut(mmx, bby + 14 * 9, IntToStr(g_nHeroIPowerRecover), FontColor);

                TextOut(bbx, bby + 14 * 10, '内伤增加', FontColor);
                TextOut(mmx, bby + 14 * 10, IntToStr(g_nHeroAddDamage), FontColor);

                TextOut(bbx, bby + 14 * 11, '内伤减免', FontColor);
                TextOut(mmx, bby + 14 * 11, IntToStr(g_nHeroDecDamage), FontColor);
              finally

              end;
            end;

          end;
        4: begin
            bbx := Left + 38 - 5;
            bby := Top + 50 + 77;
            d := g_Wui.Images[3228];
            if d <> nil then begin
              dsurface.Draw(SurfaceX(bbx), SurfaceY(bby), d);
            end;
            //bby := Top + 70 + 14 * 6;
            //bbx := Left + 190;
            //mmx := bbx + 55;

            //g_GE.Font.Print(bbx, bby + 14 * 4, clSilver, '魔法躲避');
            //g_GE.Font.Print(mmx, bby + 14 * 4, clSilver, '+' + IntToStr(g_nMyAntiMagic * 10) + '%');

          end;
        5: begin //魔法
            bbx := Left + 38 - 5;
            bby := Top + 50 + 77;
            d := g_Wui.Images[3227];
            if d <> nil then begin
              dsurface.Draw(SurfaceX(bbx), SurfaceY(bby), d);
            end;
            bbx := bbx + 10;
            bby := bby + 8;

            m_nHMagTop := m_nHeroMagicPage * 6;
            magline := _MIN(m_nHeroMagicPage * 6 + 6, g_HeroMagicList.Count);
            for i := m_nHMagTop to magline - 1 do begin
              pm := PTClientMagic(g_HeroMagicList[i]);
              M := i - m_nHMagTop;
              keyimg := 0;
              case byte(pm.Key) of
                byte('E'): keyimg := 148;
                byte('F'): keyimg := 149;
                byte('G'): keyimg := 150;
                byte('H'): keyimg := 151;
                byte('I'): keyimg := 152;
                byte('J'): keyimg := 153;
                byte('K'): keyimg := 154;
                byte('L'): keyimg := 155;
                byte('1'): keyimg := 156;
                byte('2'): keyimg := 157;
                byte('3'): keyimg := 158;
                byte('4'): keyimg := 159;
                byte('5'): keyimg := 160;
                byte('6'): keyimg := 161;
                byte('7'): keyimg := 162;
                byte('8'): keyimg := 163;
              end;
              if keyimg > 0 then begin
                d := g_WMain3Images.Images[keyimg];
                if d <> nil then
                  dsurface.Draw(bbx + 168, bby + 8 + M * 46, d);
              end;
              d := g_WMainImages.Images[112]; //Level
              if d <> nil then
                dsurface.Draw(bbx + 48, bby + 8 + 15 + M * 46, d);
              d := g_WMainImages.Images[111]; //exp
              if d <> nil then
                dsurface.Draw(bbx + 48 + 26, bby + 8 + 15 + M * 46, d);
            end;

            for i := m_nHMagTop to magline - 1 do begin
              pm := PTClientMagic(g_HeroMagicList[i]);
              M := i - m_nHMagTop;
              dsurface.BoldTextOut(bbx + 48, bby + 8 + M * 46, clSilver, clBlack, pm.Def.sMagicName);
              trainlv := _MIN(14, pm.Level);
              dsurface.BoldTextOut(bbx + 48 + 16, bby + 8 + 15 + M * 46, clSilver, clBlack, IntToStr(pm.Level));
              if pm.Def.MaxTrain[trainlv] > 0 then begin
                if trainlv < pm.Def.btTrainLv then
                  dsurface.BoldTextOut(bbx + 48 + 46, bby + 8 + 15 + M * 46, clSilver, clBlack, IntToStr(pm.CurTrain) + '/' + IntToStr(pm.Def.MaxTrain[trainlv]))
                else
                  dsurface.BoldTextOut(bbx + 48 + 46, bby + 8 + 15 + M * 46, clSilver, clBlack, '-');
              end;
            end;

            dsurface.BoldTextOut(bbx + 210, bby + 273,
              GetRGB(93), clBlack,
              Format('%d/%d', [m_nHeroMagicPage + 1, (g_HeroMagicList.Count + 5) div 6]));

          end;
      end;
    end else if g_Myself.m_HeroObject.m_nIPowerLvl > 0 then begin
      case m_nHeroIPStatePage of
        0: begin
            bbx := Left + 38 - 5;
            bby := Top + 50 + 77;
            d := g_Wui.Images[3260];
            if d <> nil then begin
              dsurface.Draw(SurfaceX(bbx), SurfaceY(bby), d);
            end;

            L := Left + 48 + 55;
            M := Top + 105 + 80;
            with dsurface do begin
              BoldTextOut(SurfaceX(L + 00), SurfaceY(M + 23 * 0), clSilver, clBlack, '当前内功等级');
              BoldTextOut(SurfaceX(L + 00), SurfaceY(M + 23 * 1), clSilver, clBlack, '当前内功经验');
              BoldTextOut(SurfaceX(L + 00), SurfaceY(M + 23 * 2), clSilver, clBlack, '升级所需经验');
              BoldTextOut(SurfaceX(L + 00), SurfaceY(M + 23 * 3), clSilver, clBlack, '内   力   值');
              BoldTextOut(SurfaceX(L + 00), SurfaceY(M + 23 * 4), clSilver, clBlack, '内功恢复速度');
              BoldTextOut(SurfaceX(L + 00), SurfaceY(M + 23 * 5), clSilver, clBlack, '内功增加伤害');
              BoldTextOut(SurfaceX(L + 00), SurfaceY(M + 23 * 6), clSilver, clBlack, '内功减免伤害');

              BoldTextOut(SurfaceX(L + 83), SurfaceY(M + 23 * 0 - 1), clSilver, clBlack, IntToStr(g_Myself.m_HeroObject.m_nIPowerLvl));
              BoldTextOut(SurfaceX(L + 83), SurfaceY(M + 23 * 1 - 1), clSilver, clBlack, IntToStr(g_Myself.m_HeroObject.m_nIPowerExp));
              BoldTextOut(SurfaceX(L + 83), SurfaceY(M + 23 * 2 - 1), clSilver, clBlack, IntToStr(g_dwIPNeedInfo[g_Myself.m_HeroObject.m_nIPowerLvl].dwPExp));
              BoldTextOut(SurfaceX(L + 83), SurfaceY(M + 23 * 3 - 1), clSilver, clBlack, Format('%d/%d', [g_Myself.m_HeroObject.m_nIPower, g_dwIPNeedInfo[g_Myself.m_HeroObject.m_nIPowerLvl].nPower]));
              BoldTextOut(SurfaceX(L + 83), SurfaceY(M + 23 * 4 - 1), clSilver, clBlack, IntToStr(g_nMyIPowerRecover));
              BoldTextOut(SurfaceX(L + 83), SurfaceY(M + 23 * 5 - 1), clSilver, clBlack, IntToStr(g_nMyAddDamage));
              BoldTextOut(SurfaceX(L + 83), SurfaceY(M + 23 * 6 - 1), clSilver, clBlack, IntToStr(g_nMyDecDamage));
            end;
          end;
        1: begin
            bbx := Left + 38 - 5;
            bby := Top + 50 + 77;
            d := g_Wui.Images[3227];
            if d <> nil then begin
              dsurface.Draw(SurfaceX(bbx), SurfaceY(bby), d);
            end;

            bbx := bbx + 10;
            bby := bby + 8;

            m_nHMagTop := m_nHeroIPMagicPage * 6;
            magline := _MIN(m_nHeroIPMagicPage * 6 + 6, g_HeroIPMagicList.Count);
            for i := m_nHMagTop to magline - 1 do begin
              pm := PTClientMagic(g_HeroIPMagicList[i]);
              M := i - m_nHMagTop;
              d := g_WMainImages.Images[112]; //Level
              if d <> nil then
                dsurface.Draw(bbx + 48, bby + 8 + 15 + M * 46, d);
              d := g_WMainImages.Images[111]; //exp
              if d <> nil then
                dsurface.Draw(bbx + 48 + 26, bby + 8 + 15 + M * 46, d);
            end;

            for i := m_nHMagTop to magline - 1 do begin
              pm := PTClientMagic(g_HeroIPMagicList[i]);
              M := i - m_nHMagTop;
              dsurface.BoldTextOut(bbx + 48, bby + 8 + M * 46, clSilver, clBlack, pm.Def.sMagicName);
              trainlv := _MIN(14, pm.Level);
              dsurface.BoldTextOut(bbx + 48 + 16, bby + 8 + 15 + M * 46, clSilver, clBlack, IntToStr(pm.Level));
              if pm.Def.MaxTrain[trainlv] > 0 then begin
                if trainlv < pm.Def.btTrainLv then
                  dsurface.BoldTextOut(bbx + 48 + 46, bby + 8 + 15 + M * 46, clSilver, clBlack, IntToStr(pm.CurTrain) + '/' + IntToStr(pm.Def.MaxTrain[trainlv]))
                else
                  dsurface.BoldTextOut(bbx + 48 + 46, bby + 8 + 15 + M * 46, clSilver, clBlack, '-');
              end;
            end;
            dsurface.BoldTextOut(bbx + 210, bby + 273,
              GetRGB(93), clBlack,
              Format('%d/%d', [m_nHeroIPMagicPage + 1, (g_HeroIPMagicList.Count + 5) div 6]));
          end;
        2: begin
            bbx := Left + 38 - 5;
            bby := Top + 50 + 77;
            if DBHState.tag in [0] then
              d := g_Wui.Images[3253 - Integer(g_Myself.m_HeroObject.m_btSex) * 3]
            else if DBHState.tag in [1..3] then
              d := g_Wui.Images[3252 - Integer(g_Myself.m_HeroObject.m_btSex) * 1];
            if d <> nil then
              dsurface.Draw(SurfaceX(bbx), SurfaceY(bby), d);

            bbx := bbx + 70;
            bby := bby + 30;

            d := g_WMainImages.Images[830 + DBHState.tag];
            if d <> nil then
              dsurface.Draw(bbx + 96, bby + 5, d);

            bbx := bbx - 14;
            bby := bby + 7;
            //0 未通 1通 2一重
            d := g_WMainImages.Images[860 + DBHState.tag * 10 + g_VenationInfos[DBHState.tag].Level];
            if d <> nil then
              dsurface.DrawBlend(bbx, bby, d, 1);

            dsurface.BoldTextOut(
              SurfaceX(bbx + 122),
              SurfaceY(bby + 142),
              GetRGB(93),
              clBlack,
              g_VenationLvStrArr[g_VenationInfos[DBHState.tag].Level]);

            d := g_WMainImages.Images[840 + DBHState.tag];
            if d <> nil then
              dsurface.Draw(bbx, bby, d);
          end;
        3: begin
            bbx := Left + 38 - 5;
            bby := Top + 50 + 77;
            d := g_Wui.Images[3261];
            if d <> nil then begin
              dsurface.Draw(SurfaceX(bbx), SurfaceY(bby), d);
            end;

            bbx := bbx + 10;
            bby := bby + 0;

            for i := 0 to g_hMagicList2.Count - 1 do begin
              pm := PTClientMagic(g_hMagicList2[i]);
              M := i + 2;
              d := g_WMainImages.Images[112]; //Level
              if d <> nil then
                dsurface.Draw(bbx + 48, bby + 30 + M * 46, d);
              d := g_WMainImages.Images[111]; //exp
              if d <> nil then
                dsurface.Draw(bbx + 48 + 26, bby + 30 + M * 46, d);
            end;

            for i := 0 to g_hMagicList2.Count - 1 do begin
              if i >= 4 then Break;
              pm := PTClientMagic(g_hMagicList2[i]);
              M := i + 2;
              trainlv := _MIN(14, pm.Level);
              trainlv := g_VLvDamageExRate[trainlv] + g_VPoDamageExRate[i];
              dsurface.BoldTextOut(bbx + 48, bby + 15 + M * 46, clSilver, clBlack, pm.Def.sMagicName + ' +' + Format('%d', [trainlv]) + '%暴击');
              trainlv := _MIN(14, pm.Level);
              dsurface.BoldTextOut(bbx + 48 + 16, bby + 30 + M * 46, clSilver, clBlack, IntToStr(pm.Level));
              if pm.Def.MaxTrain[trainlv] > 0 then begin
                if trainlv < pm.Def.btTrainLv then
                  dsurface.BoldTextOut(bbx + 48 + 46, bby + 30 + M * 46, clSilver, clBlack, IntToStr(pm.CurTrain) + '/' + IntToStr(pm.Def.MaxTrain[trainlv]))
                else
                  dsurface.BoldTextOut(bbx + 48 + 46, bby + 30 + M * 46, clSilver, clBlack, '-');
              end;
            end;
          end;
      end;
    end;

    if (g_VMouseInfo <> '') and (g_VMouseInfoTag in [0..3]) then begin
      with dsurface do begin
        FontColor := clYellow;
        TextOut(SurfaceX(Left + 60), SurfaceY(Top + 390), g_VMouseInfo, FontColor);
        FontColor := clWhite;
        trainlv := FontManager.Default.TextWidth(g_VMouseInfo) + 5;
        d4 := g_VLvHints[g_VenationInfos[g_VMouseInfoTag].Level];
        //g_JobofSeriesSkill
        case g_VenationInfos[g_VMouseInfoTag].Level of
          1: d4 := Format(d4, [g_JobofSeriesSkill[g_Myself.m_HeroObject.m_btJob][g_VMouseInfoTag]]);
          2: d4 := Format(d4, [g_JobofSeriesSkill[g_Myself.m_HeroObject.m_btJob][g_VMouseInfoTag], g_JobofSeriesSkill[g_Myself.m_HeroObject.m_btJob][g_VMouseInfoTag], g_VLvDamageExRate[g_VenationInfos[g_VMouseInfoTag].Level - 1], '%', 1.5]);
          3: d4 := Format(d4, [g_JobofSeriesSkill[g_Myself.m_HeroObject.m_btJob][g_VMouseInfoTag], g_VLvDamageExRate[g_VenationInfos[g_VMouseInfoTag].Level - 1], '%', 1.5]);
          4: d4 := Format(d4, [g_JobofSeriesSkill[g_Myself.m_HeroObject.m_btJob][g_VMouseInfoTag], g_VLvDamageExRate[g_VenationInfos[g_VMouseInfoTag].Level - 1], '%', 1.5]);
          5: d4 := Format(d4, [g_JobofSeriesSkill[g_Myself.m_HeroObject.m_btJob][g_VMouseInfoTag], g_VLvDamageExRate[g_VenationInfos[g_VMouseInfoTag].Level - 1], '%', 1.5]);
          6: d4 := Format(d4, [g_JobofSeriesSkill[g_Myself.m_HeroObject.m_btJob][g_VMouseInfoTag], g_VLvDamageExRate[g_VenationInfos[g_VMouseInfoTag].Level - 1], '%', 1.5]);
        end;
        if d4 <> '' then begin
          L := 0;
          while True do begin
            if d4 = '' then Break;
            d4 := GetValidStr3(d4, d3, ['\']);
            if d3 <> '' then begin
              if L = 0 then
                TextOut(SurfaceX(Left + 60 + trainlv), SurfaceY(Top + 390 + (FontManager.Default.TextHeight('A') + 2) * (L)), d3, FontColor)
              else
                TextOut(SurfaceX(Left + 60), SurfaceY(Top + 390 + (FontManager.Default.TextHeight('A') + 2) * (L)), d3, FontColor);
            end;
            Inc(L);
            if L > 2 then Break;
          end;
        end;
      end;
    end;

    if g_VMouseInfo2 <> '' then begin
      with dsurface do begin
        FontColor := clYellow;
        TextOut(SurfaceX(Left + 60), SurfaceY(Top + 390), g_VMouseInfo2, FontColor);
        FontColor := clWhite;
        trainlv := FontManager.Default.TextWidth(g_VMouseInfo2) + 5;
        d4 := g_VLvHints2;
        if d4 <> '' then begin
          L := 0;
          while True do begin
            if d4 = '' then Break;
            d4 := GetValidStr3(d4, d3, ['\']);
            if d3 <> '' then begin
              if L = 0 then
                TextOut(SurfaceX(Left + 60 + trainlv), SurfaceY(Top + 390 + (FontManager.Default.TextHeight('A') + 2) * (L)), d3, FontColor)
              else
                TextOut(SurfaceX(Left + 60), SurfaceY(Top + 390 + (FontManager.Default.TextHeight('A') + 2) * (L)), d3, FontColor);
            end;
            Inc(L);
            if L > 2 then Break;
          end;
        end;
      end;
    end;

    with dsurface do begin
      FontColor := g_Myself.m_HeroObject.m_nNameColor;
      TextOut(
        SurfaceX(Left + (Width - FontManager.Default.TextWidth(frmMain.m_sHeroCharName)) div 2),
        SurfaceY(Top + 62 + 6),
        frmMain.m_sHeroCharName, FontColor);
    end;
{$ENDIF}
  end;
end;

procedure TFrmDlg.DHStPageUpDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
begin
  with Sender as TDButton do begin
    if not Downed then
      d := WLib.Images[FaceIndex]
    else
      d := WLib.Images[FaceIndex + 1];
    if d <> nil then dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
  end;
end;

procedure TFrmDlg.DHStPageUpClick(Sender: TObject; X, Y: Integer);
begin
  if (g_Myself = nil) or (g_Myself.m_HeroObject = nil) then Exit;
  if not g_Myself.m_HeroObject.n_boState then begin
    if Sender = DHStPageUp then begin
      if m_nHeroMagicPage > 0 then
        Dec(m_nHeroMagicPage);
    end else begin
      if m_nHeroMagicPage < (g_HeroMagicList.Count + 5) div 6 - 1 then
        Inc(m_nHeroMagicPage);
    end;
  end else begin
    if Sender = DHStPageUp then begin
      if m_nHeroIPMagicPage > 0 then
        Dec(m_nHeroIPMagicPage);
    end else begin
      if m_nHeroIPMagicPage < (g_HeroIPMagicList.Count + 5) div 6 - 1 then
        Inc(m_nHeroIPMagicPage);
    end;
  end;
end;

procedure TFrmDlg.DHSWArmRingRDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  X, Y, idx, sel, eft: Integer;
  d: TCustomLockableTexture;
begin
  if (g_Myself = nil) or (g_Myself.m_HeroObject = nil) then Exit;
  if (m_nHeroStatePage = 0) and not g_Myself.m_HeroObject.n_boState then begin
    sel := -1;
    eft := -1;
    if Sender = DHSWNecklace then begin
      sel := U_NECKLACE;
      eft := 1;
    end else if Sender = DHSWLight then begin
      sel := U_RIGHTHAND;
      eft := 1;
    end else if Sender = DHSWArmRingR then begin
      sel := U_ARMRINGR;
      eft := 1;
    end else if Sender = DHSWArmRingL then begin
      sel := U_ARMRINGL;
      eft := 1;
    end else if Sender = DHSWRingR then begin
      sel := U_RINGR;
      eft := 1;
    end else if Sender = DHSWRingL then begin
      sel := U_RINGL;
      eft := 1;
    end else if Sender = DHSWBelt then begin
      sel := U_BELT;
      eft := 1;
    end else if Sender = DHSWBoots then begin
      sel := U_BOOTS;
      eft := 1;
{$IFNDEF UI_0508}
    end else if Sender = DHSWDrum then begin
      sel := U_DRUM;
      eft := 1;
    end else if Sender = DHSWHorse then begin
      sel := U_HORSE;
      eft := 1;
{$ENDIF}
    end else if Sender = DHSWBujuk then begin
      sel := U_BUJUK;
    end else if Sender = DHSWCharm then begin
      sel := U_CHARM;
    end;
    if (sel in [0..U_FASHION]) and (g_HeroUseItems[sel].s.Name <> '') then begin
      idx := g_HeroUseItems[sel].s.looks;
      if idx >= 0 then begin
        with Sender as TDButton do begin
          d := frmMain.GetWStateImg(idx);
          if d <> nil then
            dsurface.Draw(SurfaceX(Left + (Width - d.Width) div 2),
              SurfaceY(Top + (Height - d.Height) div 2),
              d);

          if eft > 0 then begin
            if (g_HeroUseItems[sel].s.Shape = 190) or (g_HeroUseItems[sel].s.reserve[3] = 4) then begin
              if GetTickCount - g_HeroUseItemsShine[sel].tick > 60 then begin
                g_HeroUseItemsShine[sel].tick := GetTickCount;
                Inc(g_HeroUseItemsShine[sel].idx);
                if g_HeroUseItemsShine[sel].idx > 31 then
                  g_HeroUseItemsShine[sel].idx := 0;
              end;
              d := g_Wui.Images[180 + g_HeroUseItemsShine[sel].idx];
              if d <> nil then
                dsurface.DrawBlend(
                  SurfaceX(Left + (Width - d.Width) div 2),
                  SurfaceY(Top + (Height - d.Height) div 2),
                  d, 1);
            end else if g_HeroUseItems[sel].s.reserve[3] = 1 then begin
              if GetTickCount - g_HeroUseItemsShine[sel].tick > 100 then begin
                g_HeroUseItemsShine[sel].tick := GetTickCount;
                Inc(g_HeroUseItemsShine[sel].idx);
                if g_HeroUseItemsShine[sel].idx > 8 then
                  g_HeroUseItemsShine[sel].idx := 0;
              end;
              d := g_WMainImages.Images[640 + g_HeroUseItemsShine[sel].idx];
              if d <> nil then
                dsurface.DrawBlend(
                  SurfaceX(Left + (Width - d.Width) div 2),
                  SurfaceY(Top + (Height - d.Height) div 2),
                  d, 1);
            end else if g_HeroUseItems[sel].s.reserve[3] = 2 then begin
              if GetTickCount - g_HeroUseItemsShine[sel].tick > 100 then begin
                g_HeroUseItemsShine[sel].tick := GetTickCount;
                Inc(g_HeroUseItemsShine[sel].idx);
                if g_HeroUseItemsShine[sel].idx > 5 then
                  g_HeroUseItemsShine[sel].idx := 0;
              end;
              d := g_WMain2Images.Images[260 + g_HeroUseItemsShine[sel].idx];
              if d <> nil then
                dsurface.DrawBlend(
                  SurfaceX(Left + (Width - d.Width) div 2),
                  SurfaceY(Top + (Height - d.Height) div 2),
                  d, 1);
            end else if g_HeroUseItems[sel].s.reserve[3] = 3 then begin
              if GetTickCount - g_HeroUseItemsShine[sel].tick > 100 then begin
                g_HeroUseItemsShine[sel].tick := GetTickCount;
                Inc(g_HeroUseItemsShine[sel].idx);
                if g_HeroUseItemsShine[sel].idx > 9 then
                  g_HeroUseItemsShine[sel].idx := 0;
              end;
              d := g_StateEffect.Images[550 + g_HeroUseItemsShine[sel].idx];
              if d <> nil then
                dsurface.DrawBlend(
                  SurfaceX(Left + (Width - d.Width) div 2),
                  SurfaceY(Top + (Height - d.Height) div 2),
                  d, 1);
            end else if g_HeroUseItems[sel].s.reserve[3] = 5 then begin
              if GetTickCount - g_HeroUseItemsShine[sel].tick > 100 then begin
                g_HeroUseItemsShine[sel].tick := GetTickCount;
                Inc(g_HeroUseItemsShine[sel].idx);
                if g_HeroUseItemsShine[sel].idx > 9 then
                  g_HeroUseItemsShine[sel].idx := 0;
              end;
              d := g_WStateItemImages.Images[3910 + g_HeroUseItemsShine[sel].idx];
              if d <> nil then
                dsurface.DrawBlend(
                  SurfaceX(Left + (Width - d.Width) div 2),
                  SurfaceY(Top + (Height - d.Height) div 2),
                  d, 1);
            end else if g_HeroUseItems[sel].s.reserve[3] in [6..10] then begin
              d := g_WMain3Images.Images[750 + (g_HeroUseItems[sel].s.reserve[3] - 6) * 2];
              if d <> nil then
                dsurface.DrawBlend(
                  SurfaceX(Left + (Width - d.Width) div 2),
                  SurfaceY(Top + (Height - d.Height) div 2),
                  d, 1);
            end else if g_HeroUseItems[sel].s.reserve[3] in [100..249] then begin //20200927首饰英雄穿戴
              if GetTickCount - g_HeroUseItemsShine[sel].tick > 200 then begin
                g_HeroUseItemsShine[sel].tick := GetTickCount;
                Inc(g_HeroUseItemsShine[sel].idx);
                if g_HeroUseItemsShine[sel].idx > 19 then
                  g_HeroUseItemsShine[sel].idx := 0;
              end;
              d := frmMain.GetWStateImg(30000 + (g_HeroUseItems[sel].s.reserve[3] +1 - 100) * 20-20 + g_HeroUseItemsShine[sel].idx);
              if d = nil then begin
               g_HeroUseItemsShine[sel].idx := 0;
                d := frmMain.GetWStateImg(30000 + (g_HeroUseItems[sel].s.reserve[3] +1 - 100) * 20-20 + g_HeroUseItemsShine[sel].idx);
              end;
              if d <> nil then
                dsurface.DrawBlend(
                  SurfaceX(Left + (Width - d.Width) div 2),
                  SurfaceY(Top + (Height - d.Height) div 2),
                  d, 1);
            end;
            end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DHSWWeaponClick(Sender: TObject; X, Y: Integer);
var
  where, n, sel: Integer;
  flag, MovCancel: Boolean;
begin
  if (g_Myself = nil) or (g_Myself.m_HeroObject = nil) then Exit;
  if not DHStateWin.Visible then Exit;
  if not (m_nHeroStatePage in [0, 1]) then Exit;
  if not g_Myself.m_HeroObject.n_boState then begin
    if g_boItemMoving then begin
      flag := False;
      MovCancel := False;
      if IsDetectItem(g_MovingItem.Index) then Exit;
      if IsStallItem(g_MovingItem.Index) then Exit;
      if (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) then Exit;
      if (g_MovingItem.item.s.Name = '') or (g_WaitingUseItem.item.s.Name <> '') then Exit;
      where := GetTakeOnPosition(g_MovingItem.item.s, g_HeroUseItems);
      if g_MovingItem.Index >= HERO_MIIDX_OFFSET then begin
        case where of
{$IFNDEF UI_0508}
          U_DRUM: begin
              if Sender = DHSWDrum then flag := True;
            end;
          U_HORSE: begin
              if Sender = DHSWHorse then flag := True;
            end;
          U_FASHION: if (Sender = DHSWDress) and (m_nHeroStatePage = 1) then begin
              if g_Myself.m_HeroObject.m_btSex = 0 then
                if g_MovingItem.item.s.StdMode <> 12 then
                  Exit;
              if g_Myself.m_HeroObject.m_btSex = 1 then
                if g_MovingItem.item.s.StdMode <> 13 then
                  Exit;
              flag := True;
            end;
{$ENDIF}
          U_DRESS: if Sender = DHSWDress then begin
              if g_Myself.m_HeroObject.m_btSex = 0 then
                if g_MovingItem.item.s.StdMode <> 10 then
                  Exit;
              if g_Myself.m_HeroObject.m_btSex = 1 then
                if g_MovingItem.item.s.StdMode <> 11 then
                  Exit;
              flag := True;
            end;
          U_WEAPON: if Sender = DHSWWeapon then flag := True;
          U_NECKLACE: if Sender = DHSWNecklace then flag := True;
          U_RIGHTHAND: if Sender = DHSWLight then flag := True;
          U_HELMET, U_HELMETEX: if Sender = DHSWHelmet then flag := True;
          U_RINGR, U_RINGL: begin
              if Sender = DHSWRingL then begin
                where := U_RINGL;
                flag := True;
              end;
              if Sender = DHSWRingR then begin
                where := U_RINGR;
                flag := True;
              end;
            end;
          U_ARMRINGR: begin
              if Sender = DHSWArmRingL then begin
                where := U_ARMRINGL;
                flag := True;
              end;
              if Sender = DHSWArmRingR then begin
                where := U_ARMRINGR;
                flag := True;
              end;
            end;
          U_ARMRINGL: begin
              if Sender = DHSWArmRingL then begin
                where := U_ARMRINGL;
                flag := True;
              end;
            end;
          U_BUJUK: begin
              if Sender = DHSWBujuk then begin
                where := U_BUJUK;
                flag := True;
              end;
              if g_MovingItem.item.s.StdMode <> 42 then begin
                if Sender = DHSWArmRingL then begin
                  where := U_ARMRINGL;
                  flag := True;
                end;
              end;
            end;
          U_BELT: begin
              if Sender = DHSWBelt then begin
                where := U_BELT;
                flag := True;
              end;
            end;
          U_BOOTS: begin
              if Sender = DHSWBoots then begin
                where := U_BOOTS;
                flag := True;
              end;
            end;
          U_CHARM: begin
              if Sender = DHSWCharm then begin
                where := U_CHARM;
                flag := True;
              end;
            end;
        end;
      end else begin
        n := -(g_MovingItem.Index + 1 + HERO_MIIDX_OFFSET);
        if n in [0..U_FASHION] then begin
          g_SndMgr.ItemClickSound(g_MovingItem.item.s);
          g_HeroUseItems[n] := g_MovingItem.item;
          g_MovingItem.item.s.Name := '';
          g_boItemMoving := False;
        end;
      end;
      if flag then begin
        if g_MovingItem.item.s.StdMode = 42 then begin
          //食人树叶
          //DScreen.AddSysMsg(IntToStr(g_MovingItem.Index - HERO_MIIDX_OFFSET));
          //frmMain.MoveItemIdx := idx;
          frmMain.HeroEatItem(-1);
        end else begin
          g_SndMgr.ItemClickSound(g_MovingItem.item.s);
          g_WaitingUseItem := g_MovingItem;
          g_WaitingUseItem.Index := where;
          frmMain.HeroSendTakeOnItem(where, g_MovingItem.item.MakeIndex, g_MovingItem.item.s.Name);
          g_MovingItem.item.s.Name := '';
          g_boItemMoving := False;
        end;
      end;
    end else begin
      flag := False;
      if (g_MovingItem.item.s.Name <> '') or (g_WaitingUseItem.item.s.Name <> '') then Exit;
      sel := -1;
      if Sender = DHSWDress then begin
{$IFDEF UI_0508}
        sel := U_DRESS;
{$ELSE}
        if m_nHeroStatePage = 0 then
          sel := U_DRESS
        else
          sel := U_FASHION;
{$ENDIF}
      end;
      if Sender = DHSWWeapon then sel := U_WEAPON;
      if Sender = DHSWHelmet then begin
        if g_HeroUseItems[U_HELMETEX].s.Name <> '' then
          sel := U_HELMETEX
        else
          sel := U_HELMET;
      end;
      if Sender = DHSWNecklace then sel := U_NECKLACE;
      if Sender = DHSWLight then sel := U_RIGHTHAND;
      if Sender = DHSWRingL then sel := U_RINGL;
      if Sender = DHSWRingR then sel := U_RINGR;
      if Sender = DHSWArmRingL then sel := U_ARMRINGL;
      if Sender = DHSWArmRingR then sel := U_ARMRINGR;

      if Sender = DHSWBujuk then sel := U_BUJUK;
      if Sender = DHSWBelt then sel := U_BELT;
      if Sender = DHSWBoots then sel := U_BOOTS;
      if Sender = DHSWCharm then sel := U_CHARM;
{$IFNDEF UI_0508}
      if Sender = DHSWDrum then sel := U_DRUM;
      if Sender = DHSWHorse then sel := U_HORSE;
{$ENDIF}
      if sel >= 0 then
        if g_HeroUseItems[sel].s.Name <> '' then begin
          g_SndMgr.ItemClickSound(g_HeroUseItems[sel].s);
          g_MovingItem.Index := -(sel + 1 + HERO_MIIDX_OFFSET);
          g_MovingItem.item := g_HeroUseItems[sel];
          g_HeroUseItems[sel].s.Name := '';
          g_boItemMoving := True;
        end;
    end;
  end;
end;

procedure TFrmDlg.DHSWWeaponMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  HintLeft, b1, b2: Boolean;
  sel, L: Integer;
  shint: string;
begin
  if (g_Myself = nil) or (g_Myself.m_HeroObject = nil) then Exit;
  if not g_Myself.m_HeroObject.n_boState then begin
    if not (m_nHeroStatePage in [0, 1]) then Exit;

    sel := -1;
    if Sender = DHSWDress then begin
{$IFDEF UI_0508}
      sel := U_DRESS;
{$ELSE}
      if m_nHeroStatePage = 0 then
        sel := U_DRESS
      else
        sel := U_FASHION;
{$ENDIF}
    end else if Sender = DHSWWeapon then sel := U_WEAPON
    else if Sender = DHSWHelmet then begin
      sel := U_HELMET;
    end else if Sender = DHSWNecklace then sel := U_NECKLACE
    else if Sender = DHSWLight then sel := U_RIGHTHAND
    else if Sender = DHSWRingL then sel := U_RINGL
    else if Sender = DHSWRingR then sel := U_RINGR
    else if Sender = DHSWArmRingL then sel := U_ARMRINGL
    else if Sender = DHSWArmRingR then sel := U_ARMRINGR
    else if Sender = DHSWBujuk then sel := U_BUJUK
    else if Sender = DHSWBelt then sel := U_BELT
    else if Sender = DHSWBoots then sel := U_BOOTS
{$IFDEF UI_0508}
    else if Sender = DHSWCharm then sel := U_CHARM;
{$ELSE}
    else if Sender = DHSWCharm then sel := U_CHARM
    else if Sender = DHSWDrum then sel := U_DRUM
    else if Sender = DHSWHorse then sel := U_HORSE;
{$ENDIF}
    if sel >= 0 then begin
      DScreen.ClearHint;
      with DHStateWin do begin
        X := SurfaceX(Left + {$IFDEF UI_0508}243{$ELSE}372{$ENDIF});
        Y := SurfaceY(Top + 65);

        HintLeft := False;
        if X + 151 > SCREENWIDTH then
          HintLeft := True;

        if g_HeroUseItems[sel].s.Name <> '' then begin
          g_ShowSuite := 2;
          g_SuiteIdx := sel;
          g_MouseItem := g_HeroUseItems[sel];
          if HintLeft then begin
            GetMouseItemInfoHint(g_MouseItem, shint, True);
            if shint <> '' then begin
              L := DScreen.ShowHint(
                X - 209{$IFNDEF UI_0508} - 164{$ENDIF},
                Y,
                shint,
                clWhite, False, True, True, True);
            end;
            if (sel = U_HELMET) and (g_HeroUseItems[U_HELMETEX].s.Name <> '') then begin
              GetMouseItemInfoHint(g_HeroUseItems[U_HELMETEX], shint, True);
              if shint <> '' then begin
                DScreen.ShowHint(
                  X - 209{$IFNDEF UI_0508} - 164{$ENDIF} + (MAXITEMBOX_WIDTH + 5),
                  Y,
                  shint,
                  clWhite, False, True, True, True, 2);
              end;
            end;
          end else begin
            GetMouseItemInfoHint(g_MouseItem, shint, True);
            if shint <> '' then begin
              L := DScreen.ShowHint(
                X - 30,
                Y,
                shint,
                clWhite, False, False, True, True);
            end;
            if (sel = U_HELMET) and (g_HeroUseItems[U_HELMETEX].s.Name <> '') then begin
              GetMouseItemInfoHint(g_HeroUseItems[U_HELMETEX], shint, True);
              if shint <> '' then begin
                DScreen.ShowHint(
                  X - 30 - (MAXITEMBOX_WIDTH + 5),
                  Y,
                  shint,
                  clWhite, False, False, True, True, 2);
              end;
            end;
          end;
          g_MouseItem.s.Name := '';
        end else begin
          if HintLeft then begin
            if (sel = U_HELMET) and (g_HeroUseItems[U_HELMETEX].s.Name <> '') then begin
              GetMouseItemInfoHint(g_HeroUseItems[U_HELMETEX], shint, True);
              if shint <> '' then begin
                DScreen.ShowHint(
                  X - 209{$IFNDEF UI_0508} - 164{$ENDIF},
                  Y,
                  shint,
                  clWhite, False, True, True, True, 2);
              end;
            end;
          end else begin
            if (sel = U_HELMET) and (g_HeroUseItems[U_HELMETEX].s.Name <> '') then begin
              GetMouseItemInfoHint(g_HeroUseItems[U_HELMETEX], shint, True);
              if shint <> '' then begin
                DScreen.ShowHint(
                  X - 30,
                  Y,
                  shint,
                  clWhite, False, False, True, True, 2);
              end;
            end;
          end;
        end;
      end;
    end;

  end;
end;

procedure TFrmDlg.DWHeroStatusClick(Sender: TObject; X, Y: Integer);
var
  mi: Integer;
begin
  if not g_boItemMoving then Exit;
  //if (g_WaitingUseItem.Item.S.Name <> '') then Exit;
  if (g_Myself = nil) or (g_Myself.m_HeroObject = nil) then Exit;
  mi := g_MovingItem.Index;
  if (mi = -97) or (mi = -98) then Exit;
  if (mi < 0) and (mi >= -(U_FASHION + 1)) then Exit;
  if (mi <= -20) and (mi > -39) then Exit;
  if mi < HERO_MIIDX_OFFSET then begin
    g_WaitingUseItem := g_MovingItem;
    frmMain.SendMasterItemToHeroBag(g_MovingItem.item.MakeIndex, g_MovingItem.item.s.Name);
    g_MovingItem.item.s.Name := '';
    g_boItemMoving := False;
    g_SndMgr.ItemClickSound(g_MovingItem.item.s);
  end;
  ArrangeHeroItembag;
end;

procedure TFrmDlg.DBDelCharListDirectPaint(Sender: TObject; dsurface: TCustomCanvas);

  function sX(X: Integer): Integer;
  begin
    Result := DBDelCharList.SurfaceX(DBDelCharList.Left + X);
  end;

  function sY(Y: Integer): Integer;
  begin
    Result := DBDelCharList.SurfaceY(DBDelCharList.Top + Y);
  end;
var
  i, k, M, MenuLine, FontColor: Integer;
  d: TCustomLockableTexture;
  pg: pTDelChar;
  Str: string;
begin
  if not DBDelCharList.Visible then Exit;
  with dsurface do begin
    with DBDelCharList do begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    end;

    FontColor := clWhite;
    m_nDelCharTopLine := _MIN(MAXMENU + 5, m_DelCharList.Count - MenuTop);
    for i := m_nDelCharTop to m_nDelCharTop + m_nDelCharTopLine - 1 do begin
      pg := pTDelChar(m_DelCharList[i]);
      if pg.sCharName = '' then Continue;
      M := i - m_nDelCharTop;
      if i = m_nDelCharIndex then begin
        FontColor := clRed;
        TextOut(sX(24), sY(125 + M * LISTLINEHEIGHT), '√', FontColor);
      end else
        FontColor := clWhite;
      TextOut(sX(35), sY(125 + M * LISTLINEHEIGHT), pg.sCharName, FontColor);
      TextOut(sX(120), sY(125 + M * LISTLINEHEIGHT), IntToStr(pg.nLevel), FontColor);
      TextOut(sX(164), sY(125 + M * LISTLINEHEIGHT), IntToJob(pg.btJob), FontColor);
      TextOut(sX(208), sY(125 + M * LISTLINEHEIGHT), IntToSex(pg.btSex), FontColor);
    end;
  end;
end;

procedure TFrmDlg.DBDetectBoxClick(Sender: TObject; X, Y: Integer);
var
  mi: Integer;
  DefMsg: TDefaultMessage;
begin
   if not g_Button_DetectBox then Exit;    //灵媒
  //mi := GetRGB(242);
 // FrmDlg.DMessageDlg(inttostr(mi), [mbOk]);
  if not g_boItemMoving then begin
    if g_DetectItem.s.Name <> '' then begin
      g_SndMgr.ItemClickSound(g_DetectItem.s);
      g_boItemMoving := True;
      g_MovingItem.Index := DETECT_MIIDX_OFFSET;
      g_MovingItem.item := g_DetectItem;
      g_DetectItem.s.Name := '';
    end;
  end else begin
    mi := g_MovingItem.Index;
    if IsDetectItem(mi) then begin
      g_DetectItem := g_MovingItem.item;
      g_MovingItem.item.s.Name := '';
      g_boItemMoving := False;
    end;
    if IsBagItem(mi) then begin
      if g_MovingItem.item.s.Eva.SpiritMax = 0 then begin
        FrmDlg.DMessageDlg('[失败] 必须放入灵媒才有效！', [mbOk]);
        Exit;
      end;
      g_WaitingDetectItem := g_MovingItem;
      g_boItemMoving := False;
      g_MovingItem.Index := 0;
      g_MovingItem.item.s.Name := '';
      DefMsg := EDcode.MakeDefaultMsg(CM_MoveDetectItem, g_WaitingDetectItem.item.MakeIndex, 0, 0, 1);
      frmMain.SendSocket(EncodeMessage(DefMsg));
    end;
  end;
end;

var
  m_dwDetectItemTick: LongWord;

procedure TFrmDlg.DBDetectBoxDblClick(Sender: TObject);
var
  mi: Integer;
  DefMsg: TDefaultMessage;
begin
  if not g_Button_DetectBox then Exit;  //灵媒

  if g_DetectItem.s.Name = '' then begin
    DScreen.AddChatBoardString('[请将灵媒装备在探索位]', clWhite, GetRGB($FC));
    Exit;
  end;

  if GetTickCount - m_dwDetectItemTick < 500 then
    Exit;
  m_dwDetectItemTick := GetTickCount;
  DefMsg := EDcode.MakeDefaultMsg(CM_DetectItem, g_DetectItem.MakeIndex, 0, 0, 0);
  frmMain.SendSocket(EncodeMessage(DefMsg));
  g_detectItemShine.idx := 5;
  g_detectItemShine.tick := GetTickCount;
end;

procedure TFrmDlg.DBDetectBoxDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
begin
  if not g_Button_DetectBox then Exit;   //灵媒

  with Sender as TDButton do begin
    if g_DetectItem.s.Name <> '' then begin
      d := frmMain.GetWBagItemImg(g_DetectItem.s.looks);
      if d <> nil then begin
        dsurface.Draw(SurfaceX(Left + (Width - d.Width) div 2), SurfaceY(Top + (Height - d.Height) div 2), d.ClientRect, d, True);
      end;

      if g_detectItemShine.idx > 0 then begin
        if GetTickCount - g_detectItemShine.tick > 120 then begin
          g_detectItemShine.tick := GetTickCount;
          Dec(g_detectItemShine.idx);
          //if g_detectItemShine.idx = 5 then
          //  g_detectItemShine.idx := 0;
        end;
        d := g_WMain2Images.Images[260 + g_detectItemShine.idx];
        if d <> nil then
          dsurface.DrawBlend(
            SurfaceX(Left + (Width - d.Width) div 2),
            SurfaceY(Top + (Height - d.Height) div 2),
            d, 1);
      end;

    end;

//    if g_boItemMoving and (g_MovingItem.item.s.Name <> '') and IsBagItem(g_MovingItem.Index) then begin
//      if g_MovingItem.item.s.Eva.SpiritMax > 0 then begin
//        DrawBlend_Mix(dsurface,
//          SurfaceX(Left),
//          SurfaceY(Top),
//          g_HintSurface_Olive, 0, 0,
//          33,
//          30, 0);
//      end else begin
//        DrawBlend_Mix(dsurface,
//          SurfaceX(Left),
//          SurfaceY(Top),
//          g_HintSurface_Red, 0, 0,
//          33,
//          30, 0);
//      end;
//    end;
  end;
end;

procedure TFrmDlg.DBDetectBoxMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  itemidx: Integer;
  shint: string;
begin
  if (not g_Button_DetectBox) or (g_Myself = nil) then Exit;     //灵媒
  DScreen.ClearHint;
  if g_DetectItem.s.Name <> '' then begin
    g_MouseItem := g_DetectItem;
    itemidx := GetItemWhere(g_MouseItem);
    if itemidx in [0..U_FASHION] then begin
      g_ShowSuite := 1;
      g_SuiteIdx := itemidx;
    end;
    GetMouseItemInfoHint(g_MouseItem, shint);
    if shint <> '' then begin
      with Sender as TDButton do
        DScreen.ShowHint(
          SurfaceX(Left + Width) + 3,
          SurfaceY(Top) - 5,
          shint,
          clWhite, False, False, True, True);
    end;
    g_MouseItem.s.Name := '';
  end else begin
    with Sender as TDButton do
      DScreen.ShowHint(
        SurfaceX(Left + Width) + 3,
        SurfaceY(Top),
        '<可以放入灵媒物品，使用|c=clYellow>\<灵媒快捷键为：|c=clYellow><Ctrl+X|c=clred>',
        clYellow, False);
  end;
end;

procedure TFrmDlg.DBGetDelCharCloseClick(Sender: TObject; X, Y: Integer);
var
  i: Integer;
begin
  DBDelCharList.Visible := False;
  for i := 0 to m_DelCharList.Count - 1 do
    Dispose(pTDelChar(m_DelCharList[i]));
  m_DelCharList.Clear;
end;

procedure TFrmDlg.DBHideChatClick(Sender: TObject; X, Y: Integer);
begin
  DBChat.Visible := not DBChat.Visible;
end;

procedure TFrmDlg.DBHint1CloseClick(Sender: TObject; X, Y: Integer);
begin
  DWHint1.Visible := False;
end;

procedure TFrmDlg.DBHP1DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d, dd: TCustomLockableTexture;
begin
  with Sender as TDButton do begin
    dd := nil;
    if tag <= g_hVenationInfos[DHStateWin.tag].Point then
      d := WLib.Images[FaceIndex + 1]
    else begin
      d := WLib.Images[FaceIndex];
      if tag = (g_hVenationInfos[DHStateWin.tag].Point + 1) then begin
        if GetTickCount - g_hPointFlashTick > 600 then begin
          g_hPointFlashTick := GetTickCount;
          g_bohPointFlash := not g_bohPointFlash;
        end;
        if g_bohPointFlash then begin
          case g_hVenationInfos[DHStateWin.tag].Level of
            2..6: dd := WLib.Images[852 + g_hVenationInfos[DHStateWin.tag].Level];
          else
            dd := WLib.Images[853];
          end;
        end;
      end;
    end;
    if d <> nil then dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    if dd <> nil then dsurface.DrawBlend( SurfaceX(Left), SurfaceY(Top), dd, 1);
  end;
end;

procedure TFrmDlg.DBHP1MouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  s: string;
  cl: TColor;
begin
{$IF SERIESSKILL}
  if (g_Myself.m_HeroObject <> nil) and g_Myself.m_HeroObject.n_boState and (g_Myself.m_HeroObject.m_nIPowerLvl > 0) and (m_nHeroIPStatePage = 2) then begin
    with Sender as TDButton do begin
      if not (tag in [1..5]) then Exit;

      //DebugOutStr(Format('%d %d %d', [tag, Left, Top]));

      s := '';
      if tag <= g_hVenationInfos[DHStateWin.tag].Point then begin
        g_hVMouseInfo2 := Format('%s穴', [g_VaInfos[DHStateWin.tag].Str1[tag - 1]]);
        g_hVLvHints2 := '已打通' + g_VaInfos[DHStateWin.tag].Hint[tag - 1];

        DScreen.ShowHint(
          SurfaceX(Left + Width),
          SurfaceY(Top),
          Format('<%s穴:已打通|C=%d>', [g_VaInfos[DHStateWin.tag].Str1[tag - 1], clWhite]),
          GetRGB(103), False, False, False);
      end else begin
        g_hVMouseInfo2 := g_VaInfos[DHStateWin.tag].Str1[tag - 1];
        g_hVLvHints2 := '通过舒经活络丸打通，\打通后' + g_VaInfos[DHStateWin.tag].Hint[tag - 1];

        if tag = (g_hVenationInfos[DHStateWin.tag].Point + 1) then begin
          if g_Myself.m_HeroObject.m_nIPowerLvl >= g_VNeedLevels[DHStateWin.tag][tag] then
            cl := $FF00
          else
            cl := clRed;
          s := Format('\<需要内功等级:%d|C=%d>', [g_VNeedLevels[DHStateWin.tag][tag], cl]);

          DScreen.ShowHint(
            SurfaceX(Left + Width),
            SurfaceY(Top),
            Format('<%s穴:待打通|C=%d>', [g_VaInfos[DHStateWin.tag].Str1[tag - 1], clYellow]) + s,
            GetRGB(103), False, False, False);
        end else
          DScreen.ShowHint(
            SurfaceX(Left + Width),
            SurfaceY(Top),
            Format('<%s穴:目前不可打通|C=%d>', [g_VaInfos[DHStateWin.tag].Str1[tag - 1], clRed]),
            GetRGB(103), False, False, False);
      end;

    end;
  end;
{$IFEND SERIESSKILL}
end;

procedure TFrmDlg.DBHP1MouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
  s: string;
begin
{$IF SERIESSKILL}
  with Sender as TDButton do begin
    if tag = (g_hVenationInfos[DHStateWin.tag].Point + 1) then begin
      if g_Myself.m_HeroObject.m_nIPowerLvl >= g_VNeedLevels[DHStateWin.tag][tag] then begin
        s := '(英雄) 使用舒经活络丸有几率打通%s穴，%s。您是否要\尝试打通该穴位？';
        s := Format(s,
          [
          g_VaInfos[DHStateWin.tag].Str1[tag - 1],
            g_VaInfos[DHStateWin.tag].Hint[tag - 1]
            ]);
        if FrmDlg.DMessageDlg(s, [mbOk, mbCancel]) = mrOk then begin
          frmMain.SendClientMessage(CM_BREAKPOINT, g_Myself.m_HeroObject.m_nRecogId, DHStateWin.tag, tag, 1);
        end;
      end else begin
        ShowMDlg(0, '', Format('(英雄) 你的内功等级不够,请努力修炼,早日打通%s的\%s穴位\ \<关闭/@closewin>', [g_VaStrs[DHStateWin.tag], g_VaInfos[DHStateWin.tag].Str1[tag - 1]]));
      end;
    end else begin
      if tag > (g_hVenationInfos[DHStateWin.tag].Point + 1) then
        ShowMDlg(0, '', Format('(英雄) %s的%s穴位目前不可打通\ \<关闭/@closewin>', [g_VaStrs[DHStateWin.tag], g_VaInfos[DHStateWin.tag].Str1[tag - 1]]));
    end;
  end;
{$IFEND SERIESSKILL}
end;

procedure TFrmDlg.DBHState2MouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  if (g_Myself = nil) or (g_Myself.m_HeroObject = nil) or (g_Myself.m_HeroObject.m_nIPowerLvl <= 0) then Exit;

  with TDButton(Sender) do begin
{$IFDEF UI_0508}
    X := DHStateWin.LocalX(X - Left);
    if (X >= 27) and (X <= 82) then begin
      if g_Myself.m_HeroObject.n_boState then begin
        g_Myself.m_HeroObject.n_boState := False;
        HeroPageChanged;
        g_SndMgr.PlaySound(s_norm_button_click);
      end;
    end else if (X >= 94) and (X <= 148) then begin
      if not g_Myself.m_HeroObject.n_boState then begin
        g_Myself.m_HeroObject.n_boState := True;
        HeroPageChanged;
        g_SndMgr.PlaySound(s_norm_button_click);
      end;
    end;
{$ELSE}
    X := DHStateWin.LocalX(X - Left);
    if (X >= 45) and (X <= 110) then begin
      if g_Myself.m_HeroObject.n_boState then begin
        DBHState.SetImgIndex(g_Wui, 3235, 7, 123);
        g_Myself.m_HeroObject.n_boState := False;
        HeroPageChanged;
        g_SndMgr.PlaySound(s_norm_button_click);
      end;
    end else if (X >= 125) and (X <= 190) then begin
      if not g_Myself.m_HeroObject.n_boState then begin
        DBHState.SetImgIndex(g_Wui, 3235, 7, 123);
        g_Myself.m_HeroObject.n_boState := True;
        HeroPageChanged;
        g_SndMgr.PlaySound(s_norm_button_click);
      end;
    end;
{$ENDIF}
  end;
end;

procedure TFrmDlg.DBHStateDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  i, L: Integer;
  d: TCustomLockableTexture;
begin
  if (g_Myself = nil) or (g_Myself.m_HeroObject = nil) then
    Exit;
  with TDButton(Sender) do begin
{$IFDEF UI_0508}
    if not g_Myself.m_HeroObject.n_boState then begin
      d := WLib.Images[FaceIndex + m_nHeroStatePage];
      if d <> nil then begin
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
//        L := dsurface.Canvas.Font.Size;
//        dsurface.Canvas.Font.Size := 10;
//        dsurface.Canvas.Font.Style := [fsBold];
        for i := 0 to 3 do begin
          if m_nHeroStatePage = i then begin
            dsurface.BoldTextOut(
              SurfaceX(Left + 6),
              SurfaceY(Top + 47 * i + 12),
              g_DBStateStrArr[i][1],
              GetRGB(103), clBlack, [fsBold],10);
            dsurface.BoldTextOut(
              SurfaceX(Left + 6),
              SurfaceY(Top + 47 * i + 12 + FontManager.Default.TextHeight('') + 1),
               g_DBStateStrArr[i][2],GetRGB(103),
              clBlack, [fsBold],10);
          end else begin
            dsurface.BoldTextOut(
              SurfaceX(Left + 6),
              SurfaceY(Top + 47 * i + 12),
              g_DBStateStrArr[i][1],
              GetRGB(92), clBlack, [fsBold],10);
            dsurface.BoldTextOut(
              SurfaceX(Left + 6),
              SurfaceY(Top + 47 * i + 12 + FontManager.Default.TextHeight('') + 1),
              g_DBStateStrArr[i][2], GetRGB(92),
              clBlack, [fsBold],10);
          end;
        end;
//        dsurface.Canvas.Font.Size := L;
//        dsurface.Canvas.Font.Style := [];
      end;
    end else begin
      d := WLib.Images[FaceIndex + m_nHeroIPStatePage];
      if d <> nil then begin
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
//        L := dsurface.Canvas.Font.Size;
//        dsurface.Canvas.Font.Size := 10;
        for i := 0 to 3 do begin
          if m_nHeroIPStatePage = i then begin
            dsurface.BoldTextOut(
              SurfaceX(Left + 6),
              SurfaceY(Top + 47 * i + 12),
              g_DBStateStrArr2[i][1],
              GetRGB(103), clBlack, [fsBold],10);
            dsurface.BoldTextOut(
              SurfaceX(Left + 6),
              SurfaceY(Top + 47 * i + 12 + FontManager.Default.TextHeight('') + 1),
               g_DBStateStrArr2[i][2],GetRGB(103),
              clBlack, [fsBold],10);
          end else begin
            dsurface.BoldTextOut(
              SurfaceX(Left + 6),
              SurfaceY(Top + 47 * i + 12),
              g_DBStateStrArr2[i][1],
              GetRGB(92), clBlack, [fsBold],10);
            dsurface.BoldTextOut(
              SurfaceX(Left + 6),
              SurfaceY(Top + 47 * i + 12 + FontManager.Default.TextHeight('') + 1),
              g_DBStateStrArr2[i][2], GetRGB(92),
              clBlack, [fsBold],10);
          end;
        end;
//        dsurface.Canvas.Font.Size := L;
      end;
    end;
{$ELSE}
    if not g_Myself.m_HeroObject.n_boState then begin
      d := WLib.Images[FaceIndex + m_nHeroStatePage];
      if d <> nil then begin
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);

        for i := 0 to 6 do begin
          if m_nHeroStatePage = i then begin
            dsurface.BoldTextOut(
              SurfaceX(Left + 6),
              SurfaceY(Top + 41 * i + 12),
              g_DBStateStrArr[i][1],
              GetRGB(103), clBlack, [fsBold],10);
            dsurface.BoldTextOut(
              SurfaceX(Left + 6),
              SurfaceY(Top + 41 * i + 12 + FontManager.Default.TextHeight('') + 1),
               g_DBStateStrArr[i][2],GetRGB(103),
              clBlack, [fsBold],10);
          end else begin
            dsurface.BoldTextOut(
              SurfaceX(Left + 6),
              SurfaceY(Top + 41 * i + 12),
              g_DBStateStrArr[i][1],
              GetRGB(92), clBlack, [fsBold],10);
            dsurface.BoldTextOut(
              SurfaceX(Left + 6),
              SurfaceY(Top + 41 * i + 12 + FontManager.Default.TextHeight('') + 1),
              g_DBStateStrArr[i][2], GetRGB(92),
              clBlack, [fsBold], 10);
          end;
        end;
      end;
    end else begin
      d := WLib.Images[FaceIndex + m_nHeroIPStatePage];
      if d <> nil then begin
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
        for i := 0 to {$IF SERIESSKILL}4{$ELSE}1{$IFEND SERIESSKILL} do begin
      if m_nHeroIPStatePage = i then begin
        dsurface.BoldTextOut(
          SurfaceX(Left + 6),
          SurfaceY(Top + 41 * i + 12),
          g_DBStateStrArr2[i][1],
          GetRGB(103), clBlack, [fsBold],10);
        dsurface.BoldTextOut(
          SurfaceX(Left + 6),
          SurfaceY(Top + 41 * i + 12 + FontManager.Default.TextHeight('') + 1),
           g_DBStateStrArr2[i][2],GetRGB(103),
          clBlack, [fsBold],10);
      end else begin
        dsurface.BoldTextOut(
          SurfaceX(Left + 6),
          SurfaceY(Top + 41 * i + 12),
          g_DBStateStrArr2[i][1],
          GetRGB(92), clBlack, [fsBold],10);
        dsurface.BoldTextOut(
          SurfaceX(Left + 6),
          SurfaceY(Top + 41 * i + 12 + FontManager.Default.TextHeight('') + 1),
          g_DBStateStrArr2[i][2], GetRGB(92),
          clBlack, [fsBold], 10);
      end;
    end;
  end;
end;
{$ENDIF}
end;
end;

procedure TFrmDlg.DBHStateMouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
  oStatePage: Integer;
begin
  if (g_Myself = nil) or (g_Myself.m_HeroObject = nil) then Exit;
{$IFDEF UI_0508}
  if (X > 24) or (X < 2) then Exit;
  if not g_Myself.m_HeroObject.n_boState then begin
    oStatePage := m_nHeroStatePage;
    if (Y >= 70) and (Y <= 102) then begin
      m_nHeroStatePage := 0;
    end else if (Y >= 116) and (Y <= 152) then begin
      m_nHeroStatePage := 1;
    end else if (Y >= 162) and (Y <= 198) then begin
      m_nHeroStatePage := 2;
    end else if (Y >= 208) and (Y <= 244) then begin
      m_nHeroStatePage := 3;
    end;
    if oStatePage <> m_nHeroStatePage then begin
      g_SndMgr.PlaySound(s_norm_button_click);
      HeroPageChanged;
    end;
  end else begin
    oStatePage := m_nHeroIPStatePage;
    if (Y >= 70) and (Y <= 102) then begin
      m_nHeroIPStatePage := 0;
    end else if (Y >= 116) and (Y <= 152) then begin
      m_nHeroIPStatePage := 1;
    end else if (Y >= 162) and (Y <= 198) then begin
      m_nHeroIPStatePage := 2;
    end else if (Y >= 208) and (Y <= 244) then begin
      m_nHeroIPStatePage := 3;
    end;
    if oStatePage <> m_nHeroIPStatePage then begin
      g_SndMgr.PlaySound(s_norm_button_click);
      HeroPageChanged;
    end;
  end;
{$ELSE}
  if (X > 27) or (X < 9) then Exit;
  if not g_Myself.m_HeroObject.n_boState then begin
    oStatePage := m_nHeroStatePage;
    if (Y >= 128) and (Y <= 162) then begin
      m_nHeroStatePage := 0;
    end else if (Y >= 172) and (Y <= 202) then begin
      m_nHeroStatePage := 1;
    end else if (Y >= 212) and (Y <= 242) then begin
      m_nHeroStatePage := 2;
    end else if (Y >= 252) and (Y <= 282) then begin
      m_nHeroStatePage := 3;
    end else if (Y >= 295) and (Y <= 328) then begin
      m_nHeroStatePage := 4;
    end else if (Y >= 335) and (Y <= 365) then begin
      m_nHeroStatePage := 5;
    end else if (Y >= 376) and (Y <= 406) then begin
      m_nHeroStatePage := 6;
    end;
    if oStatePage <> m_nHeroStatePage then begin
      g_SndMgr.PlaySound(s_norm_button_click);
      HeroPageChanged;
    end;
  end else begin
    oStatePage := m_nHeroIPStatePage;
    if (Y >= 128) and (Y <= 162) then begin
      m_nHeroIPStatePage := 0;
    end else if (Y >= 172) and (Y <= 202) then begin
      m_nHeroIPStatePage := 1;
    end else if (Y >= 212) and (Y <= 242) then begin
      m_nHeroIPStatePage := 2;
    end else if (Y >= 252) and (Y <= 282) then begin
      m_nHeroIPStatePage := 3;
    end else if (Y >= 295) and (Y <= 328) then begin
      m_nHeroIPStatePage := 4;
    end;
    if oStatePage <> m_nHeroIPStatePage then begin
      g_SndMgr.PlaySound(s_norm_button_click);
      HeroPageChanged;
    end;
  end;
{$ENDIF}
end;

procedure TFrmDlg.DBHTrainVenationMouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
  s, ss: string;
begin
{$IF SERIESSKILL}
  if g_Myself.m_HeroObject = nil then Exit;
  with Sender as TDButton do begin
    if g_hVenationInfos[DHStateWin.tag].Level in [1..5] then begin
      if g_hVenationInfos[DHStateWin.tag].Level = 1 then begin
        ss := '(英雄) 修炼%s到%s重，需要%s级金针%d枚。修炼后\能够获得连击技招式-%s'
      end else begin
        ss := '(英雄) 修炼%s到%s重，需要%s级金针%d枚。修炼后\提升%s的暴击率和暴击威力';
      end;

      s := Format(ss,
        [
        g_VaStrs[DHStateWin.tag], //脉络
          g_VLevelStr[g_hVenationInfos[DHStateWin.tag].Level], //level
          g_VLevelStr[g_hVenationInfos[DHStateWin.tag].Level], //level
          g_VLvNeesAcus[DHStateWin.tag][g_hVenationInfos[DHStateWin.tag].Level], //Acus
          g_JobofSeriesSkill[g_Myself.m_HeroObject.m_btJob][DHStateWin.tag]
          ]);

      if FrmDlg.DMessageDlg(s, [mbOk, mbCancel]) = mrOk then begin
        frmMain.SendClientMessage(CM_TRAINVENATION, g_Myself.m_HeroObject.m_nRecogId, DHStateWin.tag, 0, 1);
      end;
    end else begin
      if g_hVenationInfos[DHStateWin.tag].Level = 0 then
        ShowMDlg(0, '', Format('(英雄) %s的目前未打通，不可修炼经络\ \<关闭/@closewin>', [g_VaStrs[DHStateWin.tag]]))
      else if g_hVenationInfos[DHStateWin.tag].Level > 5 then
        ShowMDlg(0, '', Format('(英雄) %s已修炼到最高级了\ \<关闭/@closewin>', [g_VaStrs[DHStateWin.tag]]));
    end;
  end;
{$IFEND SERIESSKILL}
end;

procedure TFrmDlg.DBHV1Click(Sender: TObject; X, Y: Integer);

  procedure FillComponentTag();
  begin
    DBHV1.PageActive := False;
    DBHV2.PageActive := False;
    DBHV3.PageActive := False;
    DBHV4.PageActive := False;
    TDButton(Sender).PageActive := True;
  end;

begin
{$IF SERIESSKILL}
  FillComponentTag();
  DHStateWin.tag := TDButton(Sender).tag;

  DBHTrainVenation.Caption := Format('修炼%s', [TDButton(Sender).Caption]);

  DBHP1.SetImgIndex(g_WMainImages, 850);
  DBHP1.Left := g_VaInfos[DHStateWin.tag].pt1[0].Left;
  DBHP1.Top := g_VaInfos[DHStateWin.tag].pt1[0].Top;
  //DBPh1.FFloating := True;

  DBHP2.SetImgIndex(g_WMainImages, 850);
  DBHP2.Left := g_VaInfos[DHStateWin.tag].pt1[1].Left;
  DBHP2.Top := g_VaInfos[DHStateWin.tag].pt1[1].Top;
  //DBPh2.FFloating := True;

  DBHP3.SetImgIndex(g_WMainImages, 850);
  DBHP3.Left := g_VaInfos[DHStateWin.tag].pt1[2].Left;
  DBHP3.Top := g_VaInfos[DHStateWin.tag].pt1[2].Top;
  //DBPh3.FFloating := True;

  DBHP4.SetImgIndex(g_WMainImages, 850);
  DBHP4.Left := g_VaInfos[DHStateWin.tag].pt1[3].Left;
  DBHP4.Top := g_VaInfos[DHStateWin.tag].pt1[3].Top;
  //DBPh4.FFloating := True;

  DBHP5.SetImgIndex(g_WMainImages, 850);
  DBHP5.Left := g_VaInfos[DHStateWin.tag].pt1[4].Left;
  DBHP5.Top := g_VaInfos[DHStateWin.tag].pt1[4].Top;
  //DBPh5.FFloating := True;

  //////////////
  DBHPH1.CaptionEx := g_VaInfos[DHStateWin.tag].Str1[0];
  DBHPH1.Left := g_VaInfos[DHStateWin.tag].pt2[0].Left;
  DBHPH1.Top := g_VaInfos[DHStateWin.tag].pt2[0].Top;
  DBHPH1.Width := 28;
  DBHPH1.Height := 12;

  DBHPH2.CaptionEx := g_VaInfos[DHStateWin.tag].Str1[1];
  DBHPH2.Left := g_VaInfos[DHStateWin.tag].pt2[1].Left;
  DBHPH2.Top := g_VaInfos[DHStateWin.tag].pt2[1].Top;
  DBHPH2.Width := 24;
  DBHPH2.Height := 12;

  DBHPH3.CaptionEx := g_VaInfos[DHStateWin.tag].Str1[2];
  DBHPH3.Left := g_VaInfos[DHStateWin.tag].pt2[2].Left;
  DBHPH3.Top := g_VaInfos[DHStateWin.tag].pt2[2].Top;
  DBHPH3.Width := 24;
  DBHPH3.Height := 12;

  DBHPH4.CaptionEx := g_VaInfos[DHStateWin.tag].Str1[3];
  DBHPH4.Left := g_VaInfos[DHStateWin.tag].pt2[3].Left;
  DBHPH4.Top := g_VaInfos[DHStateWin.tag].pt2[3].Top;
  DBHPH4.Width := 24;
  DBHPH4.Height := 12;

  DBHPH5.CaptionEx := g_VaInfos[DHStateWin.tag].Str1[4];
  DBHPH5.Left := g_VaInfos[DHStateWin.tag].pt2[4].Left;
  DBHPH5.Top := g_VaInfos[DHStateWin.tag].pt2[4].Top;
  DBHPH5.Width := 24;
  DBHPH5.Height := 12;
  g_hVLastSender := Sender;
{$IFEND SERIESSKILL}
end;

procedure TFrmDlg.DBHV1MouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
begin
{$IF SERIESSKILL}
  with Sender as TDButton do begin
    g_hVMouseInfo := Caption;
    g_hVMouseInfoTag := tag;
  end;
{$IFEND SERIESSKILL}
end;

procedure TFrmDlg.DBIDownClick(Sender: TObject; X, Y: Integer);
begin
  if DMoveButton_items.Position < DMoveButton_items.Max then begin
    Inc(DMoveButton_items.Position);
    DMoveButton_items.UpdatePos(DMoveButton_items.Position, True);
    DMoveButton_itemsMouseMove(DMoveButton_items, [ssLeft], 0, 0);
  end;
end;

procedure TFrmDlg.DBIUPClick(Sender: TObject; X, Y: Integer);
begin
  if DMoveButton_items.Position > 0 then begin
    Dec(DMoveButton_items.Position);
    DMoveButton_items.UpdatePos(DMoveButton_items.Position, True);
    DMoveButton_itemsMouseMove(DMoveButton_items, [ssLeft], 0, 0);
  end;
end;

procedure TFrmDlg.DBIUPDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TDButton;
  dd: TCustomLockableTexture;
begin
  if Sender is TDButton then begin
    d := TDButton(Sender);
    if d.Downed then begin
      dd := d.WLib.Images[d.FaceIndex + 1];
    end else begin
      dd := d.WLib.Images[d.FaceIndex];
    end;
    if dd <> nil then
      dsurface.Draw(d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, True);
  end;
end;

procedure TFrmDlg.DscCreditsClick(Sender: TObject; X, Y: Integer);
begin
{$IF Var_UI = Var_185}
  if GetTickCount - m_dwSendMessageTick > 3000 then begin
    m_dwSendMessageTick := GetTickCount;
    frmMain.SendClientMessage(CM_QUERYDELCHR, 0, 0, 0, 0);
  end;
{$IFEND}
end;

procedure TFrmDlg.DBDBChatRecordScrollMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
begin
  if m_xChatRecordList.Count > 1 then begin
    m_nChatRecordListTop := Round((m_xChatRecordList.Count - 1) / DBDBChatRecordScroll.Max * DBDBChatRecordScroll.Position);
  end;
end;

procedure TFrmDlg.DBDBChatScrollMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
begin
  if DScreen.ChatStrs.Count > 1 then begin
    DScreen.ChatBoardTop := Round((DScreen.ChatStrs.Count - 1) / DBDBChatScroll.Max * DBDBChatScroll.Position);
    //Position属性：该属性用于设置或返回滚动条当前的值。
  end;
end;

procedure TFrmDlg.DBDelCharListClick(Sender: TObject; X, Y: Integer);
var
  lx, ly, idx: Integer;
  iname, d1, d2, d3: string;
  useable: Boolean;
begin
  DScreen.ClearHint;
  lx := DBDelCharList.LocalX(X) - DBDelCharList.Left;
  ly := DBDelCharList.LocalY(Y) - DBDelCharList.Top;
  if (lx >= 35) and (lx <= 218) and (ly >= 125) then begin
    idx := (ly - 125) div LISTLINEHEIGHT + m_nDelCharTop;
    if idx < m_DelCharList.Count then begin
      g_SndMgr.PlaySound(s_glass_button_click);
      m_nDelCharIndex := idx;
    end;
  end;
end;

procedure TFrmDlg.DBGetBackDelCharClick(Sender: TObject; X, Y: Integer);
var
  pg: pTDelChar;
begin
  if (m_nDelCharIndex >= 0) and (m_nDelCharIndex < m_DelCharList.Count) then begin
    pg := pTDelChar(m_DelCharList[m_nDelCharIndex]);
    if pg <> nil then begin
      frmMain.SendGetbackDelCharName(pg.sCharName);
      DBGetDelCharCloseClick(Sender, X, Y);
    end;
  end;
end;

procedure TFrmDlg.DRefineItemClick(Sender: TObject; X, Y: Integer);
begin
  DWRefine.Visible := not DWRefine.Visible;
  if not DWRefine.Visible then
    DBRefineCloseClick(Sender, X, Y);
end;

procedure TFrmDlg.DRefurbishItemClick(Sender: TObject; X, Y: Integer);
begin
  if GetTickCount - m_dwSendMessageTick > 3000 then begin
    m_dwSendMessageTick := GetTickCount;
    frmMain.SendClientMessage(CM_QUERYBAGITEMS, 0, 0, 0, 0);
  end;
end;

procedure TFrmDlg.DBRefineItem1DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  idx: Integer;
  d: TCustomLockableTexture;
  tidx: Integer;
begin
  if Sender = DBRefineItem1 then begin
    if g_RefineItems[0].item.s.Name <> '' then begin
      idx := g_RefineItems[0].item.s.looks;
      if idx >= 0 then begin
        //d := g_WBagItemImages.Images[idx];
        d := frmMain.GetWBagItemImg(idx);
        if d <> nil then
          with DBRefineItem1 do
            dsurface.Draw(SurfaceX(Left + (Width - d.Width) div 2), SurfaceY(Top + (Height - d.Height) div 2), d.ClientRect, d, True);
      end;
    end;
  end;
  if Sender = DBRefineItem2 then begin
    if g_RefineItems[1].item.s.Name <> '' then begin
      idx := g_RefineItems[1].item.s.looks;
      if idx >= 0 then begin
        //d := g_WBagItemImages.Images[idx];
        d := frmMain.GetWBagItemImg(idx);
        if d <> nil then
          with DBRefineItem2 do
            dsurface.Draw(SurfaceX(Left + (Width - d.Width) div 2), SurfaceY(Top + (Height - d.Height) div 2), d.ClientRect, d, True);
      end;
    end;
  end;
  if Sender = DBRefineItem3 then begin
    if g_RefineItems[2].item.s.Name <> '' then begin
      idx := g_RefineItems[2].item.s.looks;
      if idx >= 0 then begin
        //d := g_WBagItemImages.Images[idx];
        d := frmMain.GetWBagItemImg(idx);
        if d <> nil then
          with DBRefineItem3 do
            dsurface.Draw(SurfaceX(Left + (Width - d.Width) div 2), SurfaceY(Top + (Height - d.Height) div 2), d.ClientRect, d, True);
      end;
    end;
  end;
end;

procedure TFrmDlg.DWRefineDirectPaint(Sender: TObject;
  dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
begin
  with Sender as TDWindow do begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
  end;
end;

procedure TFrmDlg.DBRefineCloseClick(Sender: TObject; X, Y: Integer);
var
  i: Integer;
begin
  DWRefine.Visible := False;
  for i := Low(g_RefineItems) to High(g_RefineItems) do begin
    if g_RefineItems[i].item.s.Name <> '' then begin
      AddItemBag(g_RefineItems[i].item);
      g_RefineItems[i].item.s.Name := '';
    end;
  end;
end;

procedure TFrmDlg.DBRefineItem1Click(Sender: TObject; X, Y: Integer);
var
  idx: Integer;
  cuTemp: TMovingItem;
begin
  //if (g_WaitingUseItem.Item.S.Name <> '') then Exit;
  if g_Myself = nil then Exit;
  g_RIWhere := 0;
  idx := TDButton(Sender).tag;
  if g_boItemMoving and (g_MovingItem.item.s.Name <> '') then begin
    if (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) then Exit;
    if (g_MovingItem.item.s.Name = '') or (g_WaitingUseItem.item.s.Name <> '') then Exit;
    if (g_MovingItem.Index >= 0) and (g_MovingItem.Index < HERO_MIIDX_OFFSET) then begin
      g_SndMgr.ItemClickSound(g_MovingItem.item.s);
      if g_RefineItems[idx].item.s.Name <> '' then begin
        cuTemp := g_RefineItems[idx];
        g_RefineItems[idx] := g_MovingItem;
        g_boItemMoving := True;
        g_MovingItem := cuTemp;
      end else begin
        g_RefineItems[idx] := g_MovingItem;
        g_MovingItem.item.s.Name := '';
        g_boItemMoving := False;
      end;
    end else if (g_MovingItem.Index < 0) and (g_MovingItem.Index >= -(U_FASHION + 1)) then begin
      g_SndMgr.ItemClickSound(g_MovingItem.item.s);
      g_WaitingUseItem := g_MovingItem;
      g_RIWhere := idx + 1;
      frmMain.SendTakeOffItem(-(g_MovingItem.Index + 1), g_MovingItem.item.MakeIndex, g_MovingItem.item.s.Name);
      g_MovingItem.item.s.Name := '';
      g_boItemMoving := False;
    end;
  end else if g_RefineItems[idx].item.s.Name <> '' then begin
    g_SndMgr.ItemClickSound(g_RefineItems[idx].item.s);
    g_MovingItem := g_RefineItems[idx];
    g_RefineItems[idx].item.s.Name := '';
    g_boItemMoving := True;
  end;
end;

procedure TFrmDlg.DWRefineMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
begin
  DScreen.ClearHint;
  if g_MouseItem.s.Name <> '' then
    g_MouseItem.s.Name := '';
end;

procedure TFrmDlg.DWStoreItemPriceDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d0: string;
  n, L: Integer;
  useable: Boolean;
  d: TCustomLockableTexture;
  DestRect, SrcRect: TRect;
begin
  if g_Myself = nil then Exit;
  if g_WaitingStallItem.item.s.Name = '' then Exit;
  with DWStoreItemPrice do begin
//    d := WLib.Images[FaceIndex];
    d := WLib.Images[g_WStallPrice];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    if tag = 4 then begin
      with dsurface do begin
        BoldTextOut(
          SurfaceX(Left + 36),
          SurfaceY(Top + 60),
          $FF00, clBlack, g_WaitingStallItem.item.s.Name);
        BoldTextOut(
          SurfaceX(Left + 126),
          SurfaceY(Top + 60),
          GetRGB(95), clBlack, '金额范围 150,000,000 金币');
      end;
    end else if tag = 5 then begin
      with dsurface do begin
        BoldTextOut(
          SurfaceX(Left + 36),
          SurfaceY(Top + 60),
          $FF00, clBlack, g_WaitingStallItem.item.s.Name);
        BoldTextOut(
          SurfaceX(Left + 126),
          SurfaceY(Top + 60),
          GetRGB(95), clBlack, '金额范围 8,000,000 元宝');
      end;
    end;
    with dsurface do begin
      BoldTextOut(
        SurfaceX(Left + 36),
        SurfaceY(Top + 80),
        GetRGB(95), clBlack, '输入物品价格：');
    end;
  end;
end;

procedure TFrmDlg.DWTIDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
begin
  with Sender as TDWindow do begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);

    //if tag in [3, 4] then begin
    with dsurface do begin
      if g_tiHintStr1 <> '' then
        BoldTextOutZ(SurfaceX(Left + 133), SurfaceY(Top + 50), 220, clWhite, clBlack, g_tiHintStr1);

      if g_tiHintStr2 <> '' then begin
        BoldTextOutZ(SurfaceX(Left + 133), SurfaceY(Top + 120), 300, clWhite, clBlack, g_tiHintStr2);
      end;
    end;
    //end;

    {//fail
    if g_tiFailShow.idx > 0 then begin
      if GetTickCount - g_tiFailShow.tick > 80 then begin
        g_tiFailShow.tick := GetTickCount;
        Dec(g_tiFailShow.idx);
      end;
      if g_tiFailShow.idx > 0 then begin
        d := g_Wui.Images[970 + 22 - g_tiFailShow.idx];
        if d <> nil then
          DrawBlend(dsurface, SurfaceX(Left), SurfaceY(Top), d, 1);
      end;
    end;}

  end;
end;

procedure TFrmDlg.DWTIDirectPaint2(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
begin
  with Sender as TDWindow do begin
    //fail

    if g_tiFailShow.idx > 0 then begin
      if GetTickCount - g_tiFailShow.tick > 80 then begin
        g_tiFailShow.tick := GetTickCount;
        Dec(g_tiFailShow.idx);
        if g_tiFailShow.idx = 14 then
          g_SndMgr.PlaySound('Wav\UnionHitShield.wav');
      end;
      if g_tiFailShow.idx > 0 then begin
        d := g_Wui.Images[970 + 22 - g_tiFailShow.idx];
        if d <> nil then
         dsurface.DrawBlend(SurfaceX(Left), SurfaceY(Top), d, 1);
      end;
    end;
    if g_tiOKShow.idx > 0 then begin
      if GetTickCount - g_tiOKShow.tick > 80 then begin
        g_tiOKShow.tick := GetTickCount;
        Dec(g_tiOKShow.idx);
        if g_tiOKShow.idx = 14 then
          g_SndMgr.PlaySound('Wav\warpower-up.wav');
      end;
      if g_tiOKShow.idx > 0 then begin
        d := g_Wui.Images[940 + 22 - g_tiOKShow.idx];
        if d <> nil then
          dsurface.DrawBlend( SurfaceX(Left), SurfaceY(Top), d, 1);
      end;
    end;

    if g_tiFailShow2.idx > 0 then begin
      if GetTickCount - g_tiFailShow2.tick > 80 then begin
        g_tiFailShow2.tick := GetTickCount;
        Dec(g_tiFailShow2.idx);
        if g_tiFailShow2.idx = 14 then
          g_SndMgr.PlaySound('Wav\UnionHitShield.wav');
      end;
      if g_tiFailShow2.idx > 0 then begin
        d := g_Wui.Images[1030 + 22 - g_tiFailShow2.idx];
        if d <> nil then
          dsurface.DrawBlend( SurfaceX(Left), SurfaceY(Top), d, 1);
      end;
    end;
    if g_tiOKShow2.idx > 0 then begin
      if GetTickCount - g_tiOKShow2.tick > 80 then begin
        g_tiOKShow2.tick := GetTickCount;
        Dec(g_tiOKShow2.idx);
        if g_tiOKShow2.idx = 14 then
          g_SndMgr.PlaySound('Wav\warpower-up.wav');
      end;
      if g_tiOKShow2.idx > 0 then begin
        d := g_Wui.Images[1000 + 22 - g_tiOKShow2.idx];
        if d <> nil then
          dsurface.DrawBlend( SurfaceX(Left), SurfaceY(Top), d, 1);
      end;
    end;
  end;
end;

procedure TFrmDlg.DWSPDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
begin
  with Sender as TDWindow do begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);

    d := g_Wui.Images[893];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left + 118), SurfaceY(Top + 14), d.ClientRect, d, True);

    with dsurface do begin
      if g_spHintStr1 <> '' then
        BoldTextOutZ( SurfaceX(Left + 133), SurfaceY(Top + 50), 220, clWhite, clBlack, g_spHintStr1);

      if g_spHintStr2 <> '' then begin
        BoldTextOutZ( SurfaceX(Left + 130), SurfaceY(Top + 50), 630, clWhite, clBlack, g_spHintStr2);
      end;
    end;

  end;
end;

procedure TFrmDlg.DWSPDirectPaint2(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
begin
  with Sender as TDWindow do begin
    if g_spFailShow2.idx > 0 then begin
      if GetTickCount - g_spFailShow2.tick > 80 then begin
        g_spFailShow2.tick := GetTickCount;
        Dec(g_spFailShow2.idx);
        if g_spFailShow2.idx = 14 then
          g_SndMgr.PlaySound('Wav\UnionHitShield.wav');
      end;
      if g_spFailShow2.idx > 0 then begin
        d := g_Wui.Images[1030 + 22 - g_spFailShow2.idx];
        if d <> nil then
          dsurface.DrawBlend( SurfaceX(Left), SurfaceY(Top), d, 1);
      end;
    end;
    if g_spOKShow2.idx > 0 then begin
      if GetTickCount - g_spOKShow2.tick > 80 then begin
        g_spOKShow2.tick := GetTickCount;
        Dec(g_spOKShow2.idx);
        if g_spOKShow2.idx = 14 then
          g_SndMgr.PlaySound('Wav\warpower-up.wav');
      end;
      if g_spOKShow2.idx > 0 then begin
        d := g_Wui.Images[1000 + 22 - g_spOKShow2.idx];
        if d <> nil then
          dsurface.DrawBlend( SurfaceX(Left), SurfaceY(Top), d, 1);
      end;
    end;
  end;
end;

procedure TFrmDlg.DWTIMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
begin
  DScreen.ClearHint;
end;

procedure TFrmDlg.DWUserStallDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
begin
  //if g_Myself = nil then Exit;
  with DWUserStall do begin
//    d := WLib.Images[FaceIndex];
    d := WLib.Images[FaceIndex];
    if d <> nil then dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);

    if g_Myself.m_StallMgr.uBlock.StallName <> '' then
      with dsurface do begin
        BoldTextOut(
          SurfaceX(Left + 30),
          SurfaceY(Top + 36),
          clSilver, clBlack, g_Myself.m_StallMgr.uBlock.StallName);
      end;
  end;
end;

procedure TFrmDlg.DBRefineOKClick(Sender: TObject; X, Y: Integer);
var
  i, n: Integer;
  cr: TClientRefineItems;
begin
  //if g_boItemMoving and (g_MovingItem.Item.S.Name <> '') then Exit;
  if GetTickCount - m_dwSendMessageTick > 800 then begin
    m_dwSendMessageTick := GetTickCount;
    n := 0;
    for i := Low(g_RefineItems) to High(g_RefineItems) do
      if g_RefineItems[i].item.s.Name <> '' then
        Inc(n);
    if n > 2 then begin
      for i := Low(g_RefineItems) to High(g_RefineItems) do begin
        cr[i].nMakeIndex := g_RefineItems[i].item.MakeIndex;
        cr[i].sItemName := g_RefineItems[i].item.s.Name;
        g_RefineItems[i].item.s.Name := '';
      end;
      frmMain.SendRefineItems(cr);
    end;
  end;
end;

procedure TFrmDlg.DBRefineItem1MouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  sel, itemidx: Integer;
  sMsg: string;
begin
  sel := -1;
  if Sender = DBRefineItem1 then sel := 0;
  if Sender = DBRefineItem2 then sel := 1;
  if Sender = DBRefineItem3 then sel := 2;
  if (sel >= 0) and (g_RefineItems[sel].item.s.Name <> '') then begin
    DScreen.ClearHint;
    with Sender as TDButton do begin
      itemidx := GetItemWhere(g_RefineItems[sel].item);
      if itemidx in [0..U_FASHION] then begin
        g_ShowSuite := 1;
        g_SuiteIdx := itemidx;
      end;
      GetMouseItemInfoHint(g_RefineItems[sel].item, sMsg);
      if sMsg <> '' then
        DScreen.ShowHint(SurfaceX(Left + 38), SurfaceY(Top), sMsg, clWhite, False, False, True, True);
      //g_MouseItem := g_RefineItems[sel].item;
    end;
  end;
end;

procedure TFrmDlg.DBGCCloseClick(Sender: TObject; X, Y: Integer);
begin
  SaveGameConfig();
  //DWGameConfig.Visible := False;
end;

procedure TFrmDlg.DBGCCloseDirectPaint(Sender: TObject;
  dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
begin
  with Sender as TDButton do begin
    if not Downed then
      d := WLib.Images[g_sGameConfigClose1]
    else
      d := WLib.Images[g_sGameConfigClose2];
    if d <> nil then dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
  end;
end;

procedure TFrmDlg.DBGameGoldMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
begin
  if g_Myself = nil then Exit;
  g_showgamegoldinfo := True;
end;

procedure TFrmDlg.DBGCActivePage1Click(Sender: TObject; X, Y: Integer);

  procedure FillComponentTag();
  begin
    DBGCActivePage1.PageActive := False;
    DBGCActivePage2.PageActive := False;
    DBGCActivePage3.PageActive := False;
    DBGCActivePage4.PageActive := False;
    DBGCActivePage5.PageActive := False;
    DBGCActivePage6.PageActive := False;
    DBGCActivePage7.PageActive := False;
    TDButton(Sender).PageActive := True;
  end;
var
  i: Integer;
begin
  DBMiniMap.Visible := False;
  FillComponentTag();
  DWGameConfig.tag := TDButton(Sender).tag;
  with DWGameConfig do begin

    for i := DControls.Count - 1 downto 0 do begin
      if (TDControl(DControls.Items[i]) is TDCustomControl) then begin
        if not (TDControl(DControls.Items[i]) is TDListBox) then
          TDControl(DControls.Items[i]).Visible := False;
      end;
    end;
    for i := DControls.Count - 1 downto 0 do begin
      if (TDControl(DControls.Items[i]) is TDCustomControl) then begin
        if (TDControl(DControls.Items[i]) is TDListBox) then begin
          if (TDListBox(DControls.Items[i]).ParentComboBox <> nil) and not TDListBox(DControls.Items[i]).ParentComboBox.Visible then
            TDControl(DControls.Items[i]).Visible := False;
        end;
      end;
    end;

    DMBVolume.Visible := False;
    DMBHitSpeed.Visible := False;
    DMBMagSpeed.Visible := False;
    DMBMoveSpeed.Visible := False;

    DBIUP.Visible := False;
    DBIDown.Visible := False;
    DMoveButton_items.Visible := False;

    case tag of
      1: begin
          if g_gcGeneral[3] then DxEditExpFilter.Visible := True;
          DMBVolume.Visible := True;
          if g_boSpeedRate and g_boSpeedRateShow then begin
            DMBHitSpeed.Visible := True;
            DMBMagSpeed.Visible := True;
            DMBMoveSpeed.Visible := True;
            DxEditHitSpeed.Visible := True;
            DxEditMagSpeed.Visible := True;
            DxEditMoveSpeed.Visible := True;
          end;
        end;
      2: begin
          DxEditRenewHPPercent.Visible := True;
          DxEditRenewHPTime.Visible := True;
          DxEditRenewMPPercent.Visible := True;
          DxEditRenewMPTime.Visible := True;
          DxEditRenewSpecialPercent.Visible := True;
          DxEditRenewSpecialTime.Visible := True;
          DxEditRenewBookPercent.Visible := True;
          DxEditRenewBookTime.Visible := True;
          DCBRenewBookNowBook.Visible := True;
          if g_boHero then begin
            DxEditRenewHPPercentHero.Visible := True;
            DxEditRenewHPTimeHero.Visible := True;
            DxEditRenewMPPercentHero.Visible := True;
            DxEditRenewMPTimeHero.Visible := True;
            DxEditRenewSpecialPercentHero.Visible := True;
            DxEditRenewSpecialTimeHero.Visible := True;
            DxEditPerHeroSidestep.Visible := True;
          end;
        end;
      3: begin
          DCBPractice.Visible := True;
          DxEditPractice.Visible := True;
        end;
      4: begin
          DESwitchAttackModePre.Visible := True;
          DESwitchAttackMode.Visible := True;
          DESwitchMiniMapPre.Visible := True;
          DESwitchMiniMap.Visible := True;
{$IF SERIESSKILL}
          DxEditSSkillPre.Visible := True;
          DxEditSSkill.Visible := True;
{$IFEND SERIESSKILL}
          if g_boHero then begin
            DEHeroCallHeroPre.Visible := True;
            DEHeroCallHero.Visible := True;
            DEHeroSetTargetPre.Visible := True;
            DEHeroSetTarget.Visible := True;
            DEHeroUnionHitPre.Visible := True;
            DEHeroUnionHit.Visible := True;
            DEHeroSetAttackStatePre.Visible := True;
            DEHeroSetAttackState.Visible := True;
            DEHeroSetGuardPre.Visible := True;
            DEHeroSetGuard.Visible := True;
          end;
        end;
      5: begin
          DBMiniMap.Visible := True;
          g_nApMiniMap := True;
          frmMain.SendWantMiniMap;
        end;
      6: begin
          if g_boMutiHero then
            DComboBox_Hero.Visible := True;
        end;
      7: begin
          DComboBox_Items.Visible := True;
          DxEdit_Items.Visible := True;
          DBIDown.Visible := True;
          DBIUP.Visible := True;
          DMoveButton_items.Visible := True;

          //g_ptItems_Type := 0;          //all
          case g_ptItems_Type of
            0: DMoveButton_items.Max := _MAX(0, (g_ItemsFilter_All.Count div 8) + byte(g_ItemsFilter_All.Count mod 8 <> 0) - 1);
            1: DMoveButton_items.Max := _MAX(0, (g_ItemsFilter_Dress.Count div 8) + byte(g_ItemsFilter_Dress.Count mod 8 <> 0) - 1);
            2: DMoveButton_items.Max := _MAX(0, (g_ItemsFilter_Weapon.Count div 8) + byte(g_ItemsFilter_Weapon.Count mod 8 <> 0) - 1);
            3: DMoveButton_items.Max := _MAX(0, (g_ItemsFilter_Headgear.Count div 8) + byte(g_ItemsFilter_Headgear.Count mod 8 <> 0) - 1);
            4: DMoveButton_items.Max := _MAX(0, (g_ItemsFilter_Drug.Count div 8) + byte(g_ItemsFilter_Drug.Count mod 8 <> 0) - 1);
            5: DMoveButton_items.Max := _MAX(0, (g_ItemsFilter_Other.Count div 8) + byte(g_ItemsFilter_Other.Count mod 8 <> 0) - 1);
          end;
          DMoveButton_items.Position := 0;
          DMoveButton_items.UpdatePos(DMoveButton_items.Position, True);
          DMoveButton_itemsMouseMove(DMoveButton_items, [ssLeft], 0, 0);

        end;
    end;
  end;
end;

procedure TFrmDlg.DBGCActivePage1DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
  i, itTop: Integer;
begin
  with TDButton(Sender) do begin
    itTop := Top;
    if not PageActive then
      //d := WLib.Images[FaceIndex]
      d := WLib.Images[g_sGameConfigPage1]
    else begin
      //d := WLib.Images[FaceIndex + 1]
      d := WLib.Images[g_sGameConfigPage2];
      itTop := Top - 2;
    end;
    if d <> nil then begin
      dsurface.Draw(SurfaceX(Left), SurfaceY(itTop), d.ClientRect, d, True);
      with dsurface do begin
        BoldTextOut(
          SurfaceX(10 + (d.Width - FontManager.Default.TextWidth(Caption)) div 2 + (TDButton(Sender).tag - 1) * 48),
          SurfaceY(itTop + (d.Height - FontManager.Default.TextHeight(Caption)) div 2),
          clCream, clBlack, Caption);
      end;
    end;
  end;
end;

procedure TFrmDlg.DBGCShowNameClick(Sender: TObject; X, Y: Integer);
begin
  //
end;

procedure TFrmDlg.DHStMag1DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  idx, icon: Integer;
  d: TCustomLockableTexture;
  pm: PTClientMagic;
  p: pTClientStdItem;
begin
  with Sender as TDButton do begin
    if (g_Myself = nil) or (g_Myself.m_HeroObject = nil) then Exit;
    if not g_Myself.m_HeroObject.n_boState then begin
      if m_nHeroStatePage = {$IFDEF UI_0508}3{$ELSE}5{$ENDIF} then begin
        idx := _MAX(tag + m_nHeroMagicPage * 6, 0);
        if idx < g_HeroMagicList.Count then begin
          pm := PTClientMagic(g_HeroMagicList[idx]);
          if pm.Def.btEffect in [124..128] then begin
            d := g_WMagIcon2Images.Images[(pm.Def.btEffect - 124) * 2 + 580 + byte(Downed)];
            if d <> nil then
              dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
          end else if pm.Def.btEffect in [120..123] then begin
            d := g_Wui.Images[(pm.Def.btEffect - 120) * 2 + 761 + byte(Downed)];
            if d <> nil then
              dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
          end else if pm.Def.btEffect in [115..117] then begin
            if pm.Key = #0 then begin
              d := g_WMagIcon2Images.Images[(pm.Def.btEffect - 115) * 2 + 170];
              if d <> nil then begin
                dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
              end;
            end else begin
              d := g_WMagIcon2Images.Images[(pm.Def.btEffect - 115) * 2 + 170 + 1];
              if d <> nil then begin
//                g_ImgMixSurface.Fill(0);
//                g_ImgMixSurface.Draw(0, 0, d.ClientRect, d, True);
                dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
                DrawEffect(SurfaceX(Left), SurfaceY(Top), dsurface, d, ceBlack, True);
//                DrawEffect(0, 0, d.Width, d.Height, g_ImgMixSurface, ceDark);
//                DrawBlend_Mix(dsurface, SurfaceX(Left), SurfaceY(Top), g_ImgMixSurface, 0, 0, g_ImgMixSurface.Width, g_ImgMixSurface.Height, 0);
              end;
            end;
          end else if pm.Def.btEffect in [118] then begin
            if pm.Key = #0 then begin
              d := g_WMagIcon2Images.Images[620 + 170];
              if d <> nil then begin
                dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
              end;
            end else begin
              d := g_WMagIcon2Images.Images[620 + 1];
              if d <> nil then begin
                dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
                DrawEffect(SurfaceX(Left), SurfaceY(Top), dsurface, d, ceBlack, True);
              end;
            end;
          end else begin
            icon := pm.Def.btEffect * 2;
            if icon >= 0 then begin
              if pm.Key = #0 then begin
                d := g_WMagIconImages.Images[icon];
                if d <> nil then begin
                  dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
                end;
              end else begin
                d := g_WMagIconImages.Images[icon + 1];
                if d <> nil then begin
                  dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
                  DrawEffect(SurfaceX(Left), SurfaceY(Top), dsurface, d, ceBlack, True);
//                  DrawBlend_Mix(dsurface, SurfaceX(Left), SurfaceY(Top), g_ImgMixSurface, 0, 0, g_ImgMixSurface.Width, g_ImgMixSurface.Height, 0);
                end;
              end;
            end;
          end;
        end;
      end else if m_nHeroStatePage = 4 then begin
{$IFNDEF UI_0508}
        if tag = 6 then begin
          p := GetTitle(g_Myself.m_HeroObject.m_btTitleIndex);
          if p <> nil then begin
            d := g_Wui.Images[670 + byte(Downed) * 2];
            if d <> nil then
              dsurface.Draw(SurfaceX(Left) + 1, SurfaceY(Top) + 1, d);

            d := g_Wui.Images[p.looks + 3 + byte(Downed)];
            if d <> nil then
              dsurface.Draw(SurfaceX(Left) + 1, SurfaceY(Top) + 1, d);

            dsurface.BoldTextOut(
              SurfaceX(Left + Width) + 10,
              SurfaceY(Top) + 8,
              GetLevelColor(p.Source), clBlack, p.Name);
          end;
        end else if tag in [0..5] then begin
          p := GetTitle(g_hTitles[tag].Index);
          if p <> nil then begin
            d := g_Wui.Images[675 + byte(Downed) * 2];
            if d <> nil then
              dsurface.Draw(SurfaceX(Left) + 2, SurfaceY(Top) + 2, d);
            d := g_Wui.Images[p.looks + 1 + byte(Downed)];
            if d <> nil then
              dsurface.Draw(SurfaceX(Left) + 2, SurfaceY(Top) + 2, d);
            dsurface.BoldTextOut(
              SurfaceX(Left + Width) + 10,
              SurfaceY(Top) + 8,
              GetLevelColor(p.Source), clBlack, p.Name);
            if g_Myself.m_HeroObject.m_btTitleIndex = g_hTitles[tag].Index then begin
              d := g_WMain3Images.Images[756];
              if d <> nil then
                dsurface.DrawBlend(
                  (SurfaceX(Left) + (Width - d.Width) div 2),
                  (SurfaceY(Top) + (Height - d.Height) div 2),
                  d, 1);
            end;
          end;
        end;
{$ENDIF}
      end;
    end else begin
      case m_nHeroIPStatePage of
        1: begin
            idx := _MAX(tag + m_nHeroIPMagicPage * 6, 0);
            if idx < g_HeroIPMagicList.Count then begin
              pm := PTClientMagic(g_HeroIPMagicList[idx]);
              icon := pm.Def.btEffect * 2;
              if icon >= 0 then begin
                d := g_WMagIconImages.Images[icon];
                if d <> nil then begin
                  dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
                end;
              end;
            end;
          end;
        3: begin
            idx := tag - 2;
            if idx < g_hMagicList2.Count then begin
              pm := PTClientMagic(g_hMagicList2[idx]);
              icon := GetSeriesSkillIcon(pm.Def.btEffect);
              if icon >= 0 then begin
                d := g_WMainImages.Images[icon];
                if d <> nil then
                  dsurface.Draw(SurfaceX(Left - 1), SurfaceY(Top + 7), d.ClientRect, d, True);
              end;
            end;
          end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DHStMag1MouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  iname, ss, s, ostr: string;
  i, idx, trainlv: Integer;
  selkey: Word;
  keych: Char;
  pm: PTClientMagic;
  p: pTClientStdItem;
begin
  if (g_Myself = nil) or (g_Myself.m_HeroObject = nil) then Exit;
  if not g_Myself.m_HeroObject.n_boState then begin
    if (m_nHeroStatePage = {$IFDEF UI_0508}3{$ELSE}5{$ENDIF}) then begin
      with Sender as TDButton do begin
        idx := tag + m_nHMagTop;
        if (idx >= 0) and (idx < g_HeroMagicList.Count) then begin
          pm := PTClientMagic(g_HeroMagicList[idx]);
          trainlv := _MIN(14, pm.Level);
          if pm.Level >= pm.Def.btTrainLv then begin
            iname := '';
            if pm.Def.wMagicId = 4 then
              iname := '\关闭精神力战法\英雄将不进行近身攻击';
            DScreen.ShowHint(SurfaceX(Left - 2), SurfaceY(Top),
              Format('<%s|C=%d>\', [pm.Def.sMagicName, GetRGB(95)]) +
              sFullLevel +
              Format('<%s>\', [g_asSkillDesc[pm.Def.wMagicId] + iname, GetRGB(103)]) +
              '<(点击图标设置技能开关)|C=clWhite>',
              GetRGB(103), False, True, True);

          end else begin
            ss := '';
            if pm.Def.wMagicId = 4 then
              ss := '\关闭精神战法\英雄将不近身攻击';
            DScreen.ShowHint(SurfaceX(Left - 2), SurfaceY(Top),
              Format('<%s|C=%d>\', [pm.Def.sMagicName, GetRGB(95)]) +
              Format(sNextLevel, [pm.Def.TrainLevel[trainlv]]) +
              Format('<%s>\', [g_asSkillDesc[pm.Def.wMagicId] + ss, GetRGB(103)]) +
              '<(点击图标设置技能开关)|C=clWhite>',
              GetRGB(103), False, True, True);

          end;
        end;
      end;
    end else if (m_nHeroStatePage = 4) then begin
{$IFNDEF UI_0508}
      with TDButton(Sender) do begin
        if tag = 6 then
          p := GetTitle(g_Myself.m_HeroObject.m_btTitleIndex)
        else
          p := GetTitle(g_hTitles[tag].Index);
        if p <> nil then begin
          g_MouseItem.s := p^;
          GetMouseItemInfoHint(g_MouseItem, s);
          if s <> '' then begin
            idx := -1;
            if tag = 6 then begin
              if g_Myself.m_HeroObject.m_btTitleIndex > 0 then begin
                for i := Low(g_hTitles) to High(g_hTitles) do begin
                  if g_Myself.m_HeroObject.m_btTitleIndex = g_hTitles[i].Index then begin
                    idx := i;
                    Break;
                  end;
                end;
              end;
            end else begin
              idx := tag;
            end;
            if idx in [0..5] then begin
              if g_hTitles[idx].Time >= 24 then
                ostr := Format('<使用时间: |C=clWhite><%d|C=clYellow>< 天|C=clWhite>\', [g_hTitles[idx].Time div 24])
              else if g_hTitles[idx].Time = -14 then
                ostr := '<使用状态: |C=clWhite><未开启|C=clYellow>\'
              else if g_hTitles[idx].Time = -15 then
                ostr := '<使用时间: |C=clWhite><无限|C=clYellow>\'
              else
                ostr := Format('<使用时间: |C=clWhite><%d|C=clYellow>< 小时|C=clWhite>\', [g_hTitles[idx].Time]);
            end;
            if ostr <> '' then begin
              if (ostr[Length(ostr)] <> '\') then
                ostr := ostr + '\';
              s := s + '-\' + ostr;
            end;
            DScreen.ShowHint(
              SurfaceX(Left + 102), SurfaceY(Top),
              s,
              clWhite, False, False, True, True);
          end;
        end;
      end;
{$ENDIF}
    end;
  end else begin
    if (m_nHeroIPStatePage = 3) then begin
      with TDButton(Sender) do begin
        idx := tag - 2;
        if (idx >= 0) and (idx < g_hMagicList2.Count) then begin
          pm := PTClientMagic(g_hMagicList2[idx]);
          trainlv := _MIN(14, pm.Level);
          if pm.Level >= pm.Def.btTrainLv then begin
            DScreen.ShowHint(SurfaceX(Left - 2), SurfaceY(Top),
              Format('<%s|C=%d>\', [pm.Def.sMagicName, GetRGB(95)]) +
              sFullLevel +
              Format('<%s>\', [g_asSkillDesc[pm.Def.wMagicId], GetRGB(103)]),
              GetRGB(103), False, True, True);

          end else begin
            DScreen.ShowHint(SurfaceX(Left - 2), SurfaceY(Top),
              Format('<%s|C=%d>\', [pm.Def.sMagicName, GetRGB(95)]) +
              Format(sNextLevel2, [pm.Def.TrainLevel[trainlv]]) +
              Format('<%s>\', [g_asSkillDesc[pm.Def.wMagicId], GetRGB(103)]),
              GetRGB(103), False, True, True);
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DHStMag1Click(Sender: TObject; X, Y: Integer);
var
  i, idx: Integer;
  selkey: Word;
  keych: Char;
  pm: PTClientMagic;
  p, p2: pTClientStdItem;
  DefMsg: TDefaultMessage;
begin
  if (g_Myself = nil) or (g_Myself.m_HeroObject = nil) then Exit;
  if not g_Myself.m_HeroObject.n_boState then begin
    if m_nHeroStatePage = {$IFDEF UI_0508}3{$ELSE}5{$ENDIF} then begin
      with Sender as TDButton do begin
        idx := tag + m_nHMagTop;
        if (idx >= 0) and (idx < g_HeroMagicList.Count) then begin
          pm := PTClientMagic(g_HeroMagicList[idx]);
          if not (pm.Def.wMagicId in [3 {, 4}]) then begin
            if pm.Key = #0 then
              pm.Key := #1
            else
              pm.Key := #0;
            frmMain.SendHeroMagicKeyChange(pm.Def.wMagicId, pm.Key);
          end;
        end;
      end;
    end else if (m_nHeroStatePage = 4) then begin
{$IFNDEF UI_0508}
      if TDButton(Sender).tag = 6 then begin
        p := GetTitle(g_Myself.m_HeroObject.m_btTitleIndex);
        if p <> nil then begin
          if DMessageDlg('(英雄) 是否确认关闭当前称号？', [mbOk, mbCancel]) = mrOk then begin
            //开关
            DefMsg := EDcode.MakeDefaultMsg(CM_CHANGETITLE, 1, 0, 0, 0);
            frmMain.SendSocket(EncodeMessage(DefMsg));
          end;
        end;
      end else if TDButton(Sender).tag in [0..5] then begin
        p := GetTitle(g_hTitles[TDButton(Sender).tag].Index);
        if p <> nil then begin
          if g_Myself.m_HeroObject.m_btTitleIndex = g_hTitles[TDButton(Sender).tag].Index then
            Exit;
          if DMessageDlg(Format('(英雄) 激活[%s]称号？', [p.Name]), [mbOk, mbCancel]) = mrOk then begin
            //请求切换
            DefMsg := EDcode.MakeDefaultMsg(CM_CHANGETITLE, 1, 0, 0, g_hTitles[TDButton(Sender).tag].Index);
            frmMain.SendSocket(EncodeMessage(DefMsg));
          end;
        end;
      end;
{$ENDIF}
    end;
  end;
end;

procedure TFrmDlg.DBLRHunamDirectPaint(Sender: TObject;
  dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
begin
  with TDButton(Sender) do begin
    if PageActive then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    end;
  end;
end;

procedure TFrmDlg.DBLRHunamClick(Sender: TObject; X, Y: Integer);

  procedure FillComponentTag();
  begin
    DBLRHunam.PageActive := False;
    DBLRHero.PageActive := False;
    DBLRMaster.PageActive := False;
    TDButton(Sender).PageActive := True;
  end;
begin
  m_nLevelRankPage := 0;
  m_nLevelRankIndex := -1;
  m_nLevelRankMoveIndex := -1;
  m_nLastLevelRankPage := -1;

  DBLRFirst.Visible := False;
  DBLRPrior.Visible := False;
  DBLRNext.Visible := False;
  DBLRLast.Visible := False;
  DBLRMyRank.Visible := False;
  g_boDrawLevelRank := False;

  FillComponentTag();
  DWRank.tag := TDButton(Sender).tag;
  case DWRank.tag of
    1: begin
        DBLRAll.Visible := True;
        DBLRWarr.Visible := True;
        DBLRWizard.Visible := True;
        DBLRTaos.Visible := True;
        DBLRAll.SetImgIndex(g_WMain3Images, 427);
        DBLRWarr.SetImgIndex(g_WMain3Images, 431);
        DBLRWizard.SetImgIndex(g_WMain3Images, 433);
        DBLRTaos.SetImgIndex(g_WMain3Images, 435);
      end;
    2: begin
        DBLRAll.Visible := True;
        DBLRWarr.Visible := True;
        DBLRWizard.Visible := True;
        DBLRTaos.Visible := True;
        DBLRAll.SetImgIndex(g_WMain3Images, 430);
        DBLRWarr.SetImgIndex(g_WMain3Images, 437);
        DBLRWizard.SetImgIndex(g_WMain3Images, 439);
        DBLRTaos.SetImgIndex(g_WMain3Images, 441);
      end;
    3: begin
        DBLRAll.Visible := False;
        DBLRWarr.Visible := False;
        DBLRWizard.Visible := False;
        DBLRTaos.Visible := False;
      end;
  end;
end;

procedure TFrmDlg.DBLRCloseClick(Sender: TObject; X, Y: Integer);
begin
  DBotLevelRankClick(Sender, X, Y);
end;

procedure TFrmDlg.DBotLevelRankClick(Sender: TObject; X, Y: Integer);
begin
  FillChar(g_HumanLevelRanks, SizeOf(THumanLevelRanks), #0);
  FillChar(g_HeroLevelRanks, SizeOf(THeroLevelRanks), #0);
  DWRank.Visible := not DWRank.Visible;
  if DWRank.Visible then begin
    DBLRHunamClick(DBLRHunam, X, Y);
  end;
end;

procedure TFrmDlg.DBLRAllClick(Sender: TObject; X, Y: Integer);
begin
  DBLRAll.Visible := False;
  DBLRWarr.Visible := False;
  DBLRWizard.Visible := False;
  DBLRTaos.Visible := False;
  DBLRFirst.Visible := False;
  DBLRPrior.Visible := False;
  DBLRNext.Visible := False;
  DBLRLast.Visible := False;
  DBLRMyRank.Visible := False;
  m_nLevelRankPage := 0;
  m_nLevelRankType := TDButton(Sender).tag + (DWRank.tag - 1) * 4;
  frmMain.SendQueryLevelRank(m_nLevelRankPage, m_nLevelRankType);
end;

procedure TFrmDlg.DWRankDirectPaint(Sender: TObject; dsurface: TCustomCanvas);

  function sX(X: Integer): Integer;
  begin
    Result := DWRank.SurfaceX(DWRank.Left + X);
  end;

  function sY(Y: Integer): Integer;
  begin
    Result := DWRank.SurfaceY(DWRank.Top + Y);
  end;
var
  i, FontColor: Integer;
  d: TCustomLockableTexture;
begin
  with dsurface do begin
    with DWRank do begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
      if not DBLRAll.Visible then begin
        case tag of
          1: d := g_WMain3Images.Images[423];
          2: d := g_WMain3Images.Images[424];
          3: d := g_WMain3Images.Images[425];
        end;
        if d <> nil then begin
          dsurface.Draw(SurfaceX(Left + 25), SurfaceY(Top + 91), d.ClientRect, d, True);
        end;
      end;
    end;
    if g_boDrawLevelRank then begin
      case m_nLevelRankType of
        0..3: begin
            FontColor := clWhite;
            for i := Low(g_HumanLevelRanks) to High(g_HumanLevelRanks) do begin
              if g_HumanLevelRanks[i].sCharName <> '' then begin
                if i = m_nLevelRankIndex then
                  FontColor := clRed
                else if i = m_nLevelRankMoveIndex then
                  FontColor := $FF00
                else
                  FontColor := clWhite;
                TextOut(sX(046), sY(120 + i * 22), IntToStr(g_HumanLevelRanks[i].nIndex), FontColor);
                TextOut(sX(118), sY(120 + i * 22), g_HumanLevelRanks[i].sCharName, FontColor);
                TextOut(sX(255), sY(120 + i * 22), IntToStr(g_HumanLevelRanks[i].nLevel), FontColor);
              end;
            end;
          end;
        4..7: begin
            FontColor := clWhite;
            for i := Low(g_HeroLevelRanks) to High(g_HeroLevelRanks) do begin
              if g_HeroLevelRanks[i].sMasterName <> '' then begin
                if i = m_nLevelRankIndex then
                  FontColor := clRed
                else if i = m_nLevelRankMoveIndex then
                  FontColor := $FF00
                else
                  FontColor := clWhite;
                TextOut(sX(030), sY(120 + i * 22), IntToStr(g_HeroLevelRanks[i].nIndex), FontColor);
                TextOut(sX(065), sY(120 + i * 22), g_HeroLevelRanks[i].sHeroName, FontColor);
                TextOut(sX(160), sY(120 + i * 22), g_HeroLevelRanks[i].sMasterName, FontColor);
                TextOut(sX(260), sY(120 + i * 22), IntToStr(g_HeroLevelRanks[i].nLevel), FontColor);
              end;
            end;
          end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DBLRFirstClick(Sender: TObject; X, Y: Integer);
begin
  m_nLevelRankIndex := -1;
  m_nLevelRankMoveIndex := -1;
  m_nLevelRankPage := 0;
  frmMain.SendQueryLevelRank(m_nLevelRankPage, m_nLevelRankType);
end;

procedure TFrmDlg.DBLRLastClick(Sender: TObject; X, Y: Integer);
begin
  m_nLevelRankIndex := -1;
  m_nLevelRankMoveIndex := -1;
  m_nLevelRankPage := 199;
  frmMain.SendQueryLevelRank(m_nLevelRankPage, m_nLevelRankType);
end;

procedure TFrmDlg.DBLRMyRankClick(Sender: TObject; X, Y: Integer);
begin
  m_nLevelRankIndex := -1;
  m_nLevelRankMoveIndex := -1;
  m_nLevelRankPage := High(Word);
  frmMain.SendQueryLevelRank(m_nLevelRankPage, m_nLevelRankType);
end;

procedure TFrmDlg.DBLRPriorClick(Sender: TObject; X, Y: Integer);
begin
  m_nLevelRankIndex := -1;
  m_nLevelRankMoveIndex := -1;
  m_nLevelRankPage := _MAX(0, m_nLevelRankPage - 1);
  frmMain.SendQueryLevelRank(m_nLevelRankPage, m_nLevelRankType);
end;

procedure TFrmDlg.DBMiniMapDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
const
  MiniMapRect: TRect = (Left: 0; Top: 0; Right: 200; Bottom: 200);
var
  d: TCustomLockableTexture;
  r: TIntRect;
  sX, sY: Integer;
  i, mx, my, nX, nY: Integer;
  rx, ry, rrx, rry: Real;
  s: string;
  tMapPath: array of TPoint;
begin
  if not g_boOpenAutoPlay then Exit;
  if g_nMiniMapIndex < 0 then begin
    with DBMiniMap do begin
      dsurface.BoldTextOut(SurfaceX(Left + 20), SurfaceY(Top + 45), $FF00, clBlack, '没有小地图...');
    end;
    Exit;
  end;
  if g_nMiniMapIndex >= 300 then begin
    d := g_opui.Images[g_nMiniMapIndex + 1];
  end else
    d := g_WMMapImages.Images[g_nMiniMapIndex];
  if d <> nil then begin
    with DBMiniMap do begin
      sX := SurfaceX(Left);
      sY := SurfaceY(Top);
      r := IntRectBDS(sX, sY, SurfaceX(Left + 200), SurfaceY(Top + 200));
        dsurface.StretchDraw(r, d);

      if GetTickCount > g_dwBlinkTime + 300 then begin
        g_dwBlinkTime := GetTickCount;
        g_boViewBlink := not g_boViewBlink;
      end;
      rx := d.Width / (200 * 1.5);
      ry := d.Height / 200;
      nX := Round(12 / rx);
      nY := Round(12 / ry);
      if g_boViewBlink then begin
        mx := Round(g_Myself.m_nCurrX / rx);
        my := Round(g_Myself.m_nCurrY / ry);
        dsurface.FillRect(IntRectBDS(sX + mx - 1, sY + my - 1, 3, 3), 249);
      end;

      if (g_APMapPath <> nil) then begin
        SetLength(tMapPath, High(g_APMapPath) + 1);
        for i := 0 to High(g_APMapPath) do begin
          mx := Round(g_APMapPath[i].X / rx);
          my := Round(g_APMapPath[i].Y / ry);
          tMapPath[i] := Point(sX + mx, sY + my);

          dsurface.FillRect(IntRectBDS(sX + mx - 1, sY + my - 1, 3, 3), 249);
          with dsurface do begin
//            if i = g_APStep then
////              Pen.Color := clRed
//            else
//              Pen.Color := $FF00;
            //Pen.Style := psDash;
            Brush.Color := clBlack;
            Brush.Style := bsClear;
            //Rectangle((sX + mx + nX), (sY + my + nY), (sX + mx - nX), (sY + my - nY));
//            RoundRect((sX + mx + nX), (sY + my + nY), (sX + mx - nX), (sY + my - nY), nX * 2, nY * 2);
          end;
        end;

        with dsurface do begin
//          Pen.Color := GetRGB(151);
          Brush.Color := clBlack;
          Brush.Style := bsClear;
//          Polygon(tMapPath);
        end;

      end;

      rrx := (g_nMouseX - sX);
      rry := (g_nMouseY - sY);

//      with dsurface do begin
//        Brush.Color := clBlack;
//        Brush.Style := bsClear;
//        Pen.Color := GetRGB(130);
        //Pen.Style := psDash;
//        Rectangle((sX - 1), (sY - 1), (sX + 202), (sY + 202));
        //Pen.Style := psSolid;
//      end;

      if (rrx >= 0) and (rrx <= 200) and (rry >= 0) and (rry <= 200) then begin
        mx := Round(rrx * (Map.m_MapHeader.wWidth / 200));
        my := Round(rry * (Map.m_MapHeader.wHeight / 200));

        s := Format('(鼠标左键设路点,右键清除)%d:%d', [mx, my]);

        with dsurface do begin
          BoldTextOut( sX - FontManager.Default.TextWidth(s) + 198, sY + 168 + 18, clWhite, clBlack, s);
//          Pen.Color := clSilver;
//          Brush.Color := clBlack;
//          Brush.Style := bsClear;
          //Rectangle((g_nMouseX + nX), (g_nMouseY + nY), (g_nMouseX - nX), (g_nMouseY - nY));
//          RoundRect((g_nMouseX + nX), (g_nMouseY + nY), (g_nMouseX - nX), (g_nMouseY - nY), nX * 2, nY * 2);
        end;
      end;

    end;
  end;
end;

procedure TFrmDlg.DBMiniMapMouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
var
  d: TCustomLockableTexture;
  r: TRect;
  sX, sY: Integer;
  i, mx, my, nX, nY: Integer;
  rx, ry, rrx, rry: Real;
  s: string;
  tMapPath: array of TPoint;
begin
  if not g_boOpenAutoPlay then Exit;
  if g_nMiniMapIndex < 0 then Exit;
  if g_nMiniMapIndex >= 300 then begin
    d := g_opui.Images[g_nMiniMapIndex + 1];
  end else
    d := g_WMMapImages.Images[g_nMiniMapIndex];
  if d = nil then Exit;

  if Button = mbLeft then begin
    if frmMain.TimerAutoPlay.Enabled then begin
      DScreen.AddChatBoardString('[挂机] 请先停止挂机,再设置挂机路线', clWhite, clRed);
      Exit;
    end;
    with DBMiniMap do begin
      sX := SurfaceX(Left);
      sY := SurfaceY(Top);

      rrx := (g_nMouseX - sX);
      rry := (g_nMouseY - sY);

      if (rrx >= 0) and (rrx <= 200) and (rry >= 0) and (rry <= 200) then begin
        mx := Round(rrx * (Map.m_MapHeader.wWidth / 200));
        my := Round(rry * (Map.m_MapHeader.wHeight / 200));

        Map.LoadMapData();
        if Map.m_MapData[mx, my].TerrainType then begin
          DScreen.AddChatBoardString('[挂机] 目标坐标点不可到达', clWhite, clRed);
          Exit;
        end;

        if g_APMapPath = nil then begin
          if (abs(mx - g_Myself.m_nCurrX) >= 60) or (abs(my - g_Myself.m_nCurrY) >= 50) then begin
            DScreen.AddChatBoardString('[挂机] 坐标起点距离过远,请重新设置!!!', clWhite, clRed);
            Exit;
          end;
          SetLength(g_APMapPath, 1);
        end else begin
          if (abs(g_APMapPath[High(g_APMapPath)].X - mx) >= 24) or (abs(g_APMapPath[High(g_APMapPath)].Y - my) >= 24) then begin
            DScreen.AddChatBoardString('[挂机] 目标坐标距离过远,请重新设置较近的坐标点!!!', clWhite, clRed);
            Exit;
          end;
          if (abs(g_APMapPath[High(g_APMapPath)].X - mx) <= 5) and (abs(g_APMapPath[High(g_APMapPath)].Y - my) <= 5) then begin
            DScreen.AddChatBoardString('[挂机] 目标坐标距离过近,请重新设置较远的坐标点!!!', clWhite, clRed);
            Exit;
          end;
          SetLength(g_APMapPath, High(g_APMapPath) + 1 + 1);
        end;

        g_APMapPath[High(g_APMapPath)].X := mx;
        g_APMapPath[High(g_APMapPath)].Y := my;

      end;
    end;
  end else if Button = mbRight then begin
    frmMain.TimerAutoPlay.Enabled := False;
    g_gcAss[0] := False;
    SetLength(g_APMapPath, 0);
    SetLength(g_APMapPath2, 0);
    g_APStep := -1;
    g_APLastPoint.X := -1;
  end;
end;

procedure TFrmDlg.DBMissionOpenClick(Sender: TObject; X, Y: Integer);
begin
  g_boNewMission := False;
  if DWMissions.Visible then
    CloseMissionDlg
  else
    ShowMissionDlg(1);
end;

procedure TFrmDlg.DBMissionOpenDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  b: Boolean;
  d: TDButton;
  dd: TCustomLockableTexture;
begin
  if Sender is TDButton then begin
    d := TDButton(Sender);
    dd := nil;
    if d.Downed then
      dd := d.WLib.Images[d.FaceIndex + 2]
    else begin
      if g_boNewMission then begin
        if GetTickCount - g_dwNewMission > 500 then begin
          g_dwNewMission := GetTickCount;
          g_boFlashMission := not g_boFlashMission;
        end;
        dd := d.WLib.Images[d.FaceIndex + Integer(g_boFlashMission)];
      end else
        dd := d.WLib.Images[d.FaceIndex];
    end;
    if dd <> nil then
      dsurface.Draw(d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, True);
  end;
end;

procedure TFrmDlg.DBMissionsCloseClick(Sender: TObject; X, Y: Integer);
begin
  CloseMissionDlg;
end;

procedure TFrmDlg.DBMS1Click(Sender: TObject; X, Y: Integer);

  procedure FillComponentTag();
  begin
    DBMS1.PageActive := False;
    DBMS2.PageActive := False;
    DBMS3.PageActive := False;
    DBMS4.PageActive := False;
    TDButton(Sender).PageActive := True;
  end;
var
  i: Integer;
  List: TGList;
begin
  if DWMissions.tag <> TDButton(Sender).tag then begin
    FillComponentTag();
    DWMissions.tag := TDButton(Sender).tag;
    m_MissionIdxTitle := 0;
    m_MissionIdxDesc := 0;
    for i := 0 to m_MissionPoints.Count - 1 do
      Dispose(pTClickPoint(m_MissionPoints[i]));
    m_MissionPoints.Clear;
    m_MissionRequireAddPoints := True;
    LastestClickTime := GetTickCount;
    List := m_MissionList[DWMissions.tag];
    if List.Count = 1 then
      m_MissionSelectIndexStr := '1'
    else
      m_MissionSelectIndexStr := 'blue';
  end;
end;

procedure TFrmDlg.DBMS1DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
  i, itTop: Integer;
  cl: TColor;
begin
  if g_Myself = nil then Exit;
  with TDButton(Sender) do begin
    itTop := Top;
    if not PageActive then
      d := WLib.Images[FaceIndex]
    else begin
      d := WLib.Images[FaceIndex + 1];
    end;
    if d <> nil then begin
      dsurface.Draw(SurfaceX(Left), SurfaceY(itTop), d.ClientRect, d, True);
      with dsurface do begin
        cl := clCream;
        if PageActive then cl := clYellow;
        BoldTextOut(
          SurfaceX(20 + (d.Width - FontManager.Default.TextWidth(Caption)) div 2 + (TDButton(Sender).tag - 1) * 56),
          SurfaceY(itTop + (d.Height - FontManager.Default.TextHeight(Caption)) div 2 + Integer(PageActive)),
          cl, clBlack, Caption);
      end;
    end;
  end;
end;

procedure TFrmDlg.DBMUP1Click(Sender: TObject; X, Y: Integer);
var
  ii: Integer;
begin
  if m_MissionIdxTitle > 0 then begin
    for ii := 0 to m_MissionPoints.Count - 1 do
      Dispose(pTClickPoint(m_MissionPoints[ii]));
    m_MissionPoints.Clear;
    m_MissionRequireAddPoints := True;
    Dec(m_MissionIdxTitle);
  end;
end;

procedure TFrmDlg.DBMUP2Click(Sender: TObject; X, Y: Integer);
var
  ii: Integer;
begin
  if m_MissionIdxDesc > 0 then begin
    for ii := 0 to m_MissionPoints.Count - 1 do
      Dispose(pTClickPoint(m_MissionPoints[ii]));
    m_MissionPoints.Clear;
    m_MissionRequireAddPoints := True;
    Dec(m_MissionIdxDesc);
  end;
end;

procedure TFrmDlg.DBMDown1Click(Sender: TObject; X, Y: Integer);
var
  n, ii: Integer;
  List: TGList;
begin
  if DWMissions.Visible and (DWMissions.tag in [1..4]) then begin
    List := m_MissionList[DWMissions.tag];
    if List <> nil then begin
      List.Lock;
      try
        n := List.Count;
      finally
        List.UnLock;
      end;
      if m_MissionIdxTitle + n > 7 then begin
        for ii := 0 to m_MissionPoints.Count - 1 do
          Dispose(pTClickPoint(m_MissionPoints[ii]));
        m_MissionPoints.Clear;
        m_MissionRequireAddPoints := True;
        Inc(m_MissionIdxTitle);
      end;
    end;
  end;
end;

procedure TFrmDlg.DBMDown2Click(Sender: TObject; X, Y: Integer);
var
  s, data: string;
  i, ii, n: Integer;
  List: TGList;
  pm: PTClientMission;
begin
  if DWMissions.Visible and (DWMissions.tag in [1..4]) then begin
    List := m_MissionList[DWMissions.tag];
    if List <> nil then begin
      List.Lock;
      try
        for i := 0 to List.Count - 1 do begin
          pm := List[i];
          if m_MissionSelectIndexStr = pm.sIndex then begin
            s := pm.sDesc;
            n := 0;
            while True do begin
              if s = '' then Break;
              s := GetValidStr3(s, data, ['\']);
              if data <> '' then
                Inc(n);
            end;
            Break;
          end;
        end;
      finally
        List.UnLock;
      end;
      if (n > 0) and (m_MissionIdxDesc + 8 < n) then begin
        for ii := 0 to m_MissionPoints.Count - 1 do
          Dispose(pTClickPoint(m_MissionPoints[ii]));
        m_MissionPoints.Clear;
        m_MissionRequireAddPoints := True;
        Inc(m_MissionIdxDesc);
      end;
    end;
  end;
end;

procedure TFrmDlg.DBLRNextClick(Sender: TObject; X, Y: Integer);
begin
  m_nLevelRankIndex := -1;
  m_nLevelRankMoveIndex := -1;
  m_nLevelRankPage := _MIN(199, m_nLevelRankPage + 1);
  frmMain.SendQueryLevelRank(m_nLevelRankPage, m_nLevelRankType);
end;

procedure TFrmDlg.DWRankClick(Sender: TObject; X, Y: Integer);
var
  lx, ly, idx: Integer;
  iname, d1, d2, d3: string;
  useable: Boolean;
begin
  if not g_boDrawLevelRank then Exit;
  lx := DWRank.LocalX(X) - DWRank.Left;
  ly := DWRank.LocalY(Y) - DWRank.Top;
  if (lx >= 30) and (lx <= 300) and (ly >= (120 - 22 div 2)) then begin
    idx := (ly - 120) div 22;
    if (idx < 10) and (m_nLevelRankIndex <> idx) then begin
      m_nLevelRankIndex := idx;
    end;
  end;
end;

procedure TFrmDlg.DWRankMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  lx, ly, idx: Integer;
  iname, d1, d2, d3: string;
  useable: Boolean;
begin
  if g_MouseItem.s.Name <> '' then
    g_MouseItem.s.Name := '';
  DScreen.ClearHint;

  if not g_boDrawLevelRank then Exit;
  lx := DWRank.LocalX(X) - DWRank.Left;
  ly := DWRank.LocalY(Y) - DWRank.Top;
  if (lx >= 30) and (lx <= 300) and (ly >= (120 - 22 div 2)) then begin
    idx := (ly - 120) div 22;
    if (idx < 10) and (m_nLevelRankMoveIndex <> idx) then
      m_nLevelRankMoveIndex := idx;
  end;
end;

procedure TFrmDlg.DWRankDblClick(Sender: TObject);
begin
  case m_nLevelRankType of
    0..3: begin
        if (m_nLevelRankIndex >= 0) and (m_nLevelRankIndex < 10) then begin
          if g_HumanLevelRanks[m_nLevelRankIndex].sCharName <> '' then begin
            g_SndMgr.PlaySound(s_glass_button_click);
            FrmDlg.DEdChat.Visible := True;
            FrmDlg.DEdChat.SetFocus;
            //SetImeMode(FrmDlg.DEdChat.Handle, g_LocalLanguage);
            FrmDlg.DEdChat.Text := '/' + g_HumanLevelRanks[m_nLevelRankIndex].sCharName + ' ';
            FrmDlg.DEdChat.ChangeCurPos(AnsiTextLength(FrmDlg.DEdChat.Text), True);
            FrmDlg.DEdChat.SelLength := 0;
          end;
        end;
      end;
    4..7: begin
        if (m_nLevelRankIndex >= 0) and (m_nLevelRankIndex < 10) then begin
          if g_HeroLevelRanks[m_nLevelRankIndex].sMasterName <> '' then begin
            g_SndMgr.PlaySound(s_glass_button_click);
            FrmDlg.DEdChat.Visible := True;
            FrmDlg.DEdChat.SetFocus;
            //SetImeMode(FrmDlg.DEdChat.Handle, g_LocalLanguage);
            FrmDlg.DEdChat.Text := '/' + g_HeroLevelRanks[m_nLevelRankIndex].sMasterName + ' ';
            FrmDlg.DEdChat.ChangeCurPos(AnsiTextLength(FrmDlg.DEdChat.Text), True);
            FrmDlg.DEdChat.SelLength := 0;
          end;
        end;
      end;
  end;

end;

procedure TFrmDlg.DWGameConfigDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  i, T: Integer;
  d, dc1, dc2: TCustomLockableTexture;
  pt: TPoint;
  Rect: TIntRect;
begin
  with DWGameConfig do begin
    d := g_opui.Images[g_sGameConfigBackGround];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    dc1 := g_opui.Images[g_sGameConfigCheckBox1];
    dc2 := g_opui.Images[g_sGameConfigCheckBox2];
    case tag of
      1: begin //base
          with dsurface do begin
            BoldTextOut(SurfaceX(Left + g_ptGeneral[0].Left), SurfaceX(Top + g_ptGeneral[0].Top - 20), '基本功能设置', clSilver, clBlack, [fsBold], 9);
            BoldTextOut(SurfaceX(Left + g_ptGeneral[4].Left), SurfaceX(Top + g_ptGeneral[0].Top - 20), '物品设置', clSilver, clBlack,[fsBold], 9);
            BoldTextOut(SurfaceX(Left + g_ptGeneral[9].Left), SurfaceX(Top + g_ptGeneral[0].Top - 20), '辅助设置', clSilver, clBlack,[fsBold], 9);
            if g_boSpeedRate and g_boSpeedRateShow then begin
              BoldTextOut(SurfaceX(Left + g_ptGeneral[0].Left), SurfaceX(Top + 205), clSilver, clBlack, '攻击速度调节');
              BoldTextOut(SurfaceX(Left + g_ptGeneral[4].Left), SurfaceX(Top + 205), clSilver, clBlack, '魔法速度调节');
              BoldTextOut(SurfaceX(Left + g_ptGeneral[9].Left), SurfaceX(Top + 205), clSilver, clBlack, '移动速度调节');
            end;
            //BoldTextOut(dsurface, SurfaceX(Left + g_ptGeneral[11].Left), SurfaceX(Top + g_ptGeneral[11].Top + 24), clSilver, clBlack, '声音大小');
          end;
          for i := Low(g_ptGeneral) to High(g_ptGeneral) do begin
            if not g_gcGeneral[i] then
              d := dc1
            else
              d := dc2;
            if d <> nil then begin
              dsurface.Draw(SurfaceX(Left + g_ptGeneral[i].Left), SurfaceY(Top + g_ptGeneral[i].Top), d.ClientRect, d, True);
              with dsurface do begin
                BoldTextOut(SurfaceX(Left + g_ptGeneral[i].Left + d.Width + 3), SurfaceY(Top + g_ptGeneral[i].Top + 3), g_clGeneral[i], clBlack, g_caGeneral[i]);
              end;
            end;
          end;
        end;
      2: begin //protect
          with dsurface do begin
            BoldTextOut(SurfaceX(Left + g_ptProtect[0].Left), SurfaceX(Top + g_ptProtect[0].Top - 20), '普通药品(百分比)', clSilver, clBlack,[fsBold], 9);
            BoldTextOut(SurfaceX(Left + g_ptProtect[0].Left), SurfaceX(Top + g_ptProtect[2].Top + 04), '特殊药品(百分比)', clSilver, clBlack,[fsBold], 9);
            BoldTextOut(SurfaceX(Left + g_ptProtect[0].Left), SurfaceX(Top + g_ptProtect[4].Top + 04), '随机保护(百分比)', clSilver, clBlack,[fsBold], 9);
            if g_boHero then BoldTextOut(SurfaceX(Left + g_ptProtect[7].Left), SurfaceX(Top + g_ptProtect[0].Top - 20), '英雄普通药品(百分比)', clSilver, clBlack,[fsBold], 9);
            if g_boHero then BoldTextOut(SurfaceX(Left + g_ptProtect[7].Left), SurfaceX(Top + g_ptProtect[2].Top + 04), '英雄特殊药品(百分比)', clSilver, clBlack,[fsBold], 9);
            if g_boHero then BoldTextOut(SurfaceX(Left + g_ptProtect[7].Left), SurfaceX(Top + g_ptProtect[4].Top + 04), '英雄躲避保护(百分比)', clSilver, clBlack,[fsBold], 9);
            BoldTextOut(SurfaceX(Left + g_ptProtect[0].Left), SurfaceX(Top + g_ptProtect[6].Top + 04), clSilver, clBlack, g_caProtect[6]);
          end;

          for i := Low(g_ptProtect) to High(g_ptProtect) do begin
            if i in [2, 4, 6] then Continue;
            if not g_boHero and (i >= 7) then Continue;
            if not g_gcProtect[i] then
              d := dc1
            else
              d := dc2;
            if d <> nil then
              dsurface.Draw(SurfaceX(Left + g_ptProtect[i].Left), SurfaceY(Top + g_ptProtect[i].Top), d.ClientRect, d, True);
            with dsurface do begin
              if g_caProtect[i] <> '' then begin
                if i = 11 then
                  BoldTextOut(
                    SurfaceX(Left + g_ptProtect[i].Left + d.Width + 5),
                    SurfaceY(Top + g_ptProtect[i].Top + 3),
                    g_clProtect[i], clBlack, g_caProtect[i])
                else
                  BoldTextOut(
                    SurfaceX(Left + g_ptProtect[i].Left + d.Width + 20),
                    SurfaceY(Top + g_ptProtect[i].Top + 3),
                    g_clProtect[i], clBlack, g_caProtect[i]);

              end;
            end;
          end;
        end;
      3: begin
          with dsurface do begin
            BoldTextOut( SurfaceX(Left + g_ptTec[0].Left), SurfaceX(Top + g_ptTec[0].Top - 020), '战士技能', clSilver, clBlack,[fsBold], 9);
            BoldTextOut( SurfaceX(Left + g_ptTec[4].Left), SurfaceX(Top + g_ptTec[0].Top - 020), '法师技能', clSilver, clBlack,[fsBold], 9);
            BoldTextOut( SurfaceX(Left + g_ptTec[6].Left), SurfaceX(Top + g_ptTec[0].Top - 020), '道士技能', clSilver, clBlack,[fsBold], 9);
            BoldTextOut( SurfaceX(Left + g_ptTec[7].Left), SurfaceX(Top + g_ptTec[7].Top - 020), '自动练功', clSilver, clBlack,[fsBold], 9);
          end;
          for i := Low(g_ptTec) to High(g_ptTec) do begin
            if i = 8 then Continue;
            if not g_boHero and (i in [5, 12]) then Continue;
            if (i = 10) then begin
              if not g_boAutoLongAttack then
                Continue;
            end;
            if not g_gcTec[i] then
              d := dc1
            else
              d := dc2;
            if d <> nil then
              dsurface.Draw(SurfaceX(Left + g_ptTec[i].Left), SurfaceY(Top + g_ptTec[i].Top), d.ClientRect, d, True);
            with dsurface do begin
              BoldTextOut(
                SurfaceX(Left + g_ptTec[i].Left + d.Width + 3),
                SurfaceY(Top + g_ptTec[i].Top + 3),
                g_clTec[i], clBlack, g_caTec[i]);
            end;
          end;
        end;
      4: begin
          with dsurface do begin
            BoldTextOut( SurfaceX(Left + g_ptHotkey[0].Left + 000 + 3), SurfaceX(Top + g_ptHotkey[0].Top + 22), '功能描述', clSilver, clBlack,[fsBold], 9);
            BoldTextOut( SurfaceX(Left + g_ptHotkey[0].Left + 108 + 3), SurfaceX(Top + g_ptHotkey[0].Top + 22), '默认快捷键', clSilver, clBlack,[fsBold], 9);
            BoldTextOut( SurfaceX(Left + g_ptHotkey[0].Left + 208 + 3), SurfaceX(Top + g_ptHotkey[0].Top + 22), '自定义快捷键', clSilver, clBlack,[fsBold], 9);
          end;
          if not g_gcHotkey[0] then
            d := dc1
          else
            d := dc2;
          if d <> nil then
            dsurface.Draw(SurfaceX(Left + g_ptHotkey[0].Left + 2), SurfaceY(Top + g_ptHotkey[0].Top), d.ClientRect, d, True);
{$IF SERIESSKILL}
          for i := Low(g_ptHotkey) to High(g_ptHotkey) do begin
            if not g_boHero and (i in [1..5]) then Continue;
            with dsurface do begin
              if (i = 0) and (d <> nil) then
                BoldTextOut(SurfaceX(Left + g_ptHotkey[i].Left + d.Width + 3), SurfaceY(Top + g_ptHotkey[i].Top + 3), g_clHotkey[i], clBlack, g_caHotkey[i])
              else
                BoldTextOut(SurfaceX(Left + g_ptHotkey[i].Left + 3), SurfaceY(Top + g_ptHotkey[i].Top + 1), g_clHotkey[i], clBlack, g_caHotkey[i]);
            end;
          end;
{$ELSE}
          for i := Low(g_ptHotkey) to High(g_ptHotkey) - 1 do begin
            with dsurface.Canvas do begin
              if (i = 0) and (d <> nil) then
                BoldTextOut(dsurface, SurfaceX(Left + g_ptHotkey[i].Left + d.Width + 3), SurfaceY(Top + g_ptHotkey[i].Top + 3), g_clHotkey[i], clBlack, g_caHotkey[i])
              else
                BoldTextOut(dsurface, SurfaceX(Left + g_ptHotkey[i].Left + 3), SurfaceY(Top + g_ptHotkey[i].Top + 1), g_clHotkey[i], clBlack, g_caHotkey[i]);
            end;
          end;
{$IFEND SERIESSKILL}
        end;
      5: begin
          if not g_boOpenAutoPlay then begin
            with dsurface do begin
              BoldTextOut(SurfaceX(Left + g_ptAss[0].Left), SurfaceX(Top + g_ptTec[0].Top - 020), '游戏辅助设置', clSilver, clBlack,[fsBold], 9);
              //BoldTextOut(dsurface, SurfaceX(Left + g_ptAss[4].Left), SurfaceX(Top + g_ptTec[0].Top + 100), clSilver, clBlack, '法师技能');
            end;
            d := nil;
            if not g_gcAss[5] then
              d := dc1
            else
              d := dc2;
            if d <> nil then begin
              dsurface.Draw(SurfaceX(Left + g_ptAss[5].Left), SurfaceY(Top + g_ptAss[5].Top), d.ClientRect, d, True);
              with dsurface do
                BoldTextOut(SurfaceX(Left + g_ptAss[5].Left + d.Width + 3), SurfaceY(Top + g_ptAss[5].Top + 3), g_clAss[5], clBlack, g_caAss[5]);
            end;
          end else begin
            with dsurface do begin
              BoldTextOut(SurfaceX(Left + g_ptAss[0].Left), SurfaceX(Top + g_ptTec[0].Top - 020), '游戏辅助设置', clSilver, clBlack,[fsBold], 9);
              //BoldTextOut(dsurface, SurfaceX(Left + g_ptAss[4].Left), SurfaceX(Top + g_ptTec[0].Top + 100), clSilver, clBlack, '法师技能');
            end;
            for i := Low(g_ptAss) to High(g_ptAss) do begin
              if not g_gcAss[i] then
                d := dc1
              else
                d := dc2;
              if d <> nil then begin
                dsurface.Draw(SurfaceX(Left + g_ptAss[i].Left), SurfaceY(Top + g_ptAss[i].Top), d.ClientRect, d, True);
                with dsurface do
                  BoldTextOut(SurfaceX(Left + g_ptAss[i].Left + d.Width + 3), SurfaceY(Top + g_ptAss[i].Top + 3), g_clAss[i], clBlack, g_caAss[i]);
              end;
            end;
          end;
        end;
      6: begin
          if g_boMutiHero then
            with dsurface do begin
              BoldTextOut(
                SurfaceX(Left + 25),
                SurfaceY(Top + 45 + 3),
                clSilver,
                clBlack,
                '选择召唤英雄');
            end;
        end;
      7: begin
          d := g_WMain2Images.Images[291];
          if d <> nil then begin
            Rect := d.ClientRect;
            Rect.Bottom := Rect.Bottom - 12;
//            Dec(Rect.Bottom, 12);
            dsurface.Draw(SurfaceX(Left + 383), SurfaceY(Top + 37), Rect, d, True);
          end;

          with dsurface do begin
            BoldTextOut(SurfaceX(Left + g_ptItems0[0].Left + 005), SurfaceY(Top + g_ptItems0[0].Top - 025), '物品名称', clSilver, clBlack,[fsBold], 9);
            BoldTextOut(SurfaceX(Left + g_ptItems1[0].Left - 014), SurfaceY(Top + g_ptItems1[0].Top - 025), '极品提示', clSilver, clBlack,[fsBold], 9);
            BoldTextOut(SurfaceX(Left + g_ptItems2[0].Left - 014), SurfaceY(Top + g_ptItems2[0].Top - 025), '自动拾取', clSilver, clBlack,[fsBold], 9);
            BoldTextOut(SurfaceX(Left + g_ptItems3[0].Left - 014), SurfaceY(Top + g_ptItems3[0].Top - 025), '显示名字', clSilver, clBlack,[fsBold], 9);
            Line(SurfaceX(Left + g_ptItems0[0].Left - 2), SurfaceY(Top + g_ptItems0[0].Top - 010),
                 SurfaceX(Left + g_ptItems0[0].Left - 2) + 352, SurfaceY(Top + g_ptItems0[0].Top - 010),
                 clGray)
//            Pen.Color := clGray;
//            MoveTo(SurfaceX(Left + g_ptItems0[0].Left - 2), SurfaceY(Top + g_ptItems0[0].Top - 010));
//            LineTo(SurfaceX(Left + g_ptItems0[0].Left - 2) + 352, SurfaceY(Top + g_ptItems0[0].Top - 010));

          end;

          if not g_boPickUpAll then
            d := dc1
          else
            d := dc2;
          if d <> nil then begin
            dsurface.Draw(SurfaceX(Left + g_ptItemsA.Left + 2), SurfaceY(Top + g_ptItemsA.Top), d.ClientRect, d, True);
            with dsurface do
              BoldTextOut(
                SurfaceX(Left + g_ptItemsA.Left + d.Width + 3),
                SurfaceY(Top + g_ptItemsA.Top + 3),
                clSilver,
                clBlack,
                '全部拾取');
          end;

          if not g_boAutoPickUp then
            d := dc1
          else
            d := dc2;
          if d <> nil then begin
            dsurface.Draw(SurfaceX(Left + g_ptAutoPickUp.Left + 2), SurfaceY(Top + g_ptAutoPickUp.Top), d.ClientRect, d, True);
            with dsurface do
              BoldTextOut(
                SurfaceX(Left + g_ptAutoPickUp.Left + d.Width + 3),
                SurfaceY(Top + g_ptAutoPickUp.Top + 3),
                clSilver,
                clBlack,
                '自动拾取(~)');
          end;

          for i := Low(g_ptItems0) to High(g_ptItems0) do begin
            if g_caItems[i] = nil then Continue;

            if not g_caItems[i].rare then
              d := dc1
            else
              d := dc2;
            if d <> nil then
              dsurface.Draw(SurfaceX(Left + g_ptItems1[i].Left + 2), SurfaceY(Top + g_ptItems1[i].Top), d.ClientRect, d, True);

            if not g_caItems[i].pick then
              d := dc1
            else
              d := dc2;
            if d <> nil then
              dsurface.Draw(SurfaceX(Left + g_ptItems2[i].Left + 2), SurfaceY(Top + g_ptItems2[i].Top), d.ClientRect, d, True);

            if not g_caItems[i].Show then
              d := dc1
            else
              d := dc2;
            if d <> nil then
              dsurface.Draw(SurfaceX(Left + g_ptItems3[i].Left + 2), SurfaceY(Top + g_ptItems3[i].Top), d.ClientRect, d, True);

            with dsurface do begin
              if g_ptItems_Pos = i then
                BoldTextOut(
                  SurfaceX(Left + g_ptItems0[i].Left + 3),
                  SurfaceY(Top + g_ptItems0[i].Top + 1),
                  clRed,
                  clBlack,
                  g_caItems[i].Name)
              else
                BoldTextOut(
                  SurfaceX(Left + g_ptItems0[i].Left + 3),
                  SurfaceY(Top + g_ptItems0[i].Top + 1),
                  g_clItems[i],
                  clBlack,
                  g_caItems[i].Name);
            end;
          end;
        end;
    end;
  end;
end;

procedure TFrmDlg.DWGameConfigClick(Sender: TObject; X, Y: Integer);
var
  i: Integer;
  p: TPoint;
  s: string;
  d: TCustomCanvas;
  ini: TiniFile;
begin
  p.X := (X - DWGameConfig.Left);
  p.Y := (Y - DWGameConfig.Top);
  case DWGameConfig.tag of
    1: for i := Low(g_ptGeneral) to High(g_ptGeneral) do begin
        if PtInRect(g_ptGeneral[i], p) then begin
          g_gcGeneral[i] := not g_gcGeneral[i];
          if (i = 3) then DxEditExpFilter.Visible := g_gcGeneral[3];
          if (i = 8) then frmMain.SendClientMessage(CM_HIDEDEATHBODY, g_Myself.m_nRecogId, Integer(g_gcGeneral[8]), 0, 0);
          if (i = 11) then begin
            OpenSoundOption(False);
          end;
          if (i = 12) then begin
            OpenSoundOption(True);
          end;
          g_SndMgr.PlaySound(s_norm_button_click);
          Break;
        end;
      end;
    2: for i := Low(g_ptProtect) to High(g_ptProtect) do begin
        if i in [2, 4] then Continue;
        if not g_boHero and (i >= 7) then Continue;
        if PtInRect(g_ptProtect[i], p) then begin
          g_gcProtect[i] := not g_gcProtect[i];
          g_SndMgr.PlaySound(s_norm_button_click);
          Break;
        end;
      end;
    3: begin
        for i := Low(g_ptTec) to High(g_ptTec) do begin
          if i = 8 then Continue;
          if not g_boHero and (i in [5, 12]) then Continue;
          if (i = 10) then begin
            if not g_boAutoLongAttack then
              Continue;
          end;
          if PtInRect(g_ptTec[i], p) then begin
            if (i = 7) and not g_gcTec[i] then
              SaveGameConfig();
            g_gcTec[i] := not g_gcTec[i];
            g_SndMgr.PlaySound(s_norm_button_click);
            Break;
          end;
        end;
      end;
    4: begin
        if PtInRect(g_ptHotkey[0], p) then begin
          g_gcHotkey[0] := not g_gcHotkey[0];
          g_SndMgr.PlaySound(s_norm_button_click);
        end;
      end;
    5: if g_boOpenAutoPlay then begin
        for i := Low(g_ptAss) to High(g_ptAss) do begin
          if PtInRect(g_ptAss[i], p) then begin
            g_gcAss[i] := not g_gcAss[i];
            g_SndMgr.PlaySound(s_norm_button_click);
            if i = 0 then begin
              frmMain.TimerAutoPlay.Enabled := g_gcAss[i];
              if frmMain.TimerAutoPlay.Enabled then begin
                g_APTagget := nil;
                g_AutoPicupItem := nil;
                g_nAPStatus := -1;
                g_nTargetX := -1;
                g_APGoBack := False;
                DScreen.AddChatBoardString('[挂机] 开始自动挂机...', clWhite, clRed);
                SaveWayPoint;
                if (g_APMapPath <> nil) then begin
                  g_APStep := 0;
                  g_APLastPoint.X := -1;
                  GetNearPoint();
                end;
                if (g_Myself.m_HeroObject = nil) then begin
                  FrmDlg.m_dwUnRecallHeroTick := GetTickCount - 58000;
                end;
              end else begin
                //SetLength(g_APMapPath, 0);
                //SetLength(g_APMapPath2, 0);
                //g_APStep := -1;
                //g_APLastPoint.X := -1;
                DScreen.AddChatBoardString('[挂机] 停止自动挂机...', clWhite, clRed);
              end;
            end else if i in [5, 6] then begin
              if g_gcAss[i] then begin
                if i = 5 then begin
                  GuildEditHint := '提示：每行1个物品名，列表中的物品将会自动拾取（极品显示如：金币 1）';
                  ShowAssistantItemFilter;
                end else begin
                  GuildEditHint := '[挂机时不进行攻击的怪物列表，每行一个怪物名字]';
                  ShowAssistantMonFilter;
                end;
              end;
            end;
            Break;
          end;
        end;
      end else begin
        if PtInRect(g_ptAss[5], p) then begin
          g_gcAss[5] := not g_gcAss[5];
          g_SndMgr.PlaySound(s_norm_button_click);
          if g_gcAss[5] then begin
            GuildEditHint := '提示：每行1个物品名，列表中的物品将会自动拾取（极品显示如：金币 1）';
            ShowAssistantItemFilter;
          end;
        end;
      end;

    7: begin
        if PtInRect(g_ptItemsA, p) then begin
          g_boPickUpAll := not g_boPickUpAll;
          g_SndMgr.PlaySound(s_norm_button_click);
        end;
        if PtInRect(g_ptAutoPickUp, p) then begin
          g_boAutoPickUp := not g_boAutoPickUp;
          g_SndMgr.PlaySound(s_norm_button_click);
        end;

        for i := Low(g_ptItems0) to High(g_ptItems0) do begin
          if g_caItems[i] = nil then Continue;
          if PtInRect(g_ptItems0[i], p) then begin
            g_ptItems_Pos := i;
            //g_gcItems0[i] := not g_gcItems0[i];
            //PlaySound(s_norm_button_click);
          end;
          if PtInRect(g_ptItems1[i], p) then begin
            g_caItems[i].rare := not g_caItems[i].rare;
            g_SndMgr.PlaySound(s_norm_button_click);
          end else if PtInRect(g_ptItems2[i], p) then begin
            g_caItems[i].pick := not g_caItems[i].pick;
            g_SndMgr.PlaySound(s_norm_button_click);
          end else if PtInRect(g_ptItems3[i], p) then begin
            g_caItems[i].Show := not g_caItems[i].Show;
            g_SndMgr.PlaySound(s_norm_button_click);
          end;
        end;
      end;

  end;
end;

procedure TFrmDlg.DWGameConfigMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  i: Integer;
  p: TPoint;
  s: string;
  d: TCustomCanvas;
begin
  DScreen.ClearHint;
  p.X := (X - DWGameConfig.Left);
  p.Y := (Y - DWGameConfig.Top);
  case DWGameConfig.tag of
    1: for i := Low(g_ptGeneral) to High(g_ptGeneral) do begin
        if PtInRect(g_ptGeneral[i], p) then begin
          g_clGeneral[i] := clWhite;
          with DWGameConfig do
            DScreen.ShowHint(SurfaceX(Left + g_ptGeneral[i].Left),
              SurfaceY(Top + g_ptGeneral[i].Top + 18),
              g_HintGeneral[i],
              clYellow, False);
          //if i = 3 then with DWGameConfig do DScreen.ShowHint(SurfaceX(Left + g_ptGeneral[i].Left), SurfaceY(Top + g_ptGeneral[i].Top + 20), '钩选此选项将过滤掉2000以下经验的显示', clYellow, False);
        end else
          g_clGeneral[i] := g_clGeneralDef[i];
      end;
    2: begin

      end;
    3: for i := Low(g_ptTec) to High(g_ptTec) do begin
        if i = 8 then Continue;
        if not g_boHero and (i in [5, 12]) then Continue;
        if (i = 10) then begin
          if not g_boAutoLongAttack then
            Continue;
        end;
        if PtInRect(g_ptTec[i], p) then begin
          g_clTec[i] := clWhite;
          if g_HintTec[i] <> '' then
            with DWGameConfig do
              DScreen.ShowHint(SurfaceX(Left + g_ptTec[i].Left),
                SurfaceY(Top + g_ptTec[i].Top + 18),
                g_HintTec[i],
                clYellow, False);
        end else
          g_clTec[i] := clSilver;
      end;
    4: begin
        if PtInRect(g_ptHotkey[0], p) then begin
          g_clHotkey[0] := clWhite;
        end else
          g_clHotkey[0] := clSilver;
      end;
    5: if g_boOpenAutoPlay then begin
        for i := Low(g_ptAss) to High(g_ptAss) do begin
          if PtInRect(g_ptAss[i], p) then begin
            if i = 0 then
              g_clAss[i] := $FF00
            else
              g_clAss[i] := clWhite;
            if g_HintAss[i] <> '' then
              with DWGameConfig do
                DScreen.ShowHint(SurfaceX(Left + g_ptAss[i].Left),
                  SurfaceY(Top + g_ptAss[i].Top + 18),
                  g_HintAss[i],
                  clYellow, False);
          end else
            g_clAss[i] := clSilver;
        end;
      end else begin
        if PtInRect(g_ptAss[5], p) then begin
          if i = 0 then
            g_clAss[5] := $FF00
          else
            g_clAss[5] := clWhite;
          if g_HintAss[5] <> '' then
            with DWGameConfig do
              DScreen.ShowHint(SurfaceX(Left + g_ptAss[5].Left),
                SurfaceY(Top + g_ptAss[5].Top + 18),
                g_HintAss[5],
                clYellow, False);
        end else
          g_clAss[5] := clSilver;
      end;
  end;
end;

procedure TFrmDlg.GameConfigEditChange(Sender: TObject);
begin
  //
end;

procedure TFrmDlg.GameConfigKeyPress(Sender: TObject; var Key: Char);
begin
  //
end;

procedure TFrmDlg.DWGameConfigKeyPress(Sender: TObject; var Key: Char);
begin
  //DWGameConfig.Caption :=
end;

procedure TFrmDlg.DxEditLoginIDKeyPress(Sender: TObject; var Key: Char);
begin
  LoginScene.EdLoginIdKeyPress(Sender, Key);
end;

procedure TFrmDlg.DxEditLoginIDMouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
  i: Integer;
  DC: TDControl;
  dp: TDEdit;
  cStr: string;
begin
  if not (Sender is TDEdit) then Exit;
  dp := Sender as TDEdit;
  if dp.IsHotKey or dp.NomberOnly then Exit;

  if (Button = mbLeft) then begin
    if (LastMenuControl <> nil) then begin
      for i := LastMenuControl.DControls.Count - 1 downto 0 do begin
        DC := TDControl(LastMenuControl.DControls[i]);
        if DC.Visible and (DC is TDHint) then begin
          DC.Visible := False;
          Break;
        end;
      end;
    end;
    Exit;
  end;

  //-------------
  DxHint.ParentControl := nil;
  if (LastMenuControl <> nil) then begin
    if (LastMenuControl <> dp) then begin
      for i := LastMenuControl.DControls.Count - 1 downto 0 do begin
        DC := TDControl(LastMenuControl.DControls[i]);
        if DC is TDHint then begin
          LastMenuControl.DControls.Delete(i);
          Break;
        end;
      end;
    end;
    LastMenuControl.DxHint := nil;
  end;

  for i := 0 to DxHint.Items.Count - 1 do begin
    case i of
      0, 1, 3: begin
          if (dp.Caption <> '') and (dp.SelStart > -1) and (dp.SelEnd > -1) and (dp.SelStart <> dp.SelEnd) then
            DxHint.Items.Objects[i] := TObject(Integer(0))
          else
            DxHint.Items.Objects[i] := TObject(Integer(1));
        end;
      2: begin
          FrmDlg.EditTemp.SelectAll;
          FrmDlg.EditTemp.PasteFromClipboard;
          cStr := FrmDlg.EditTemp.Text;
          if cStr <> '' then begin
            DxHint.Items.Objects[i] := TObject(Integer(0))
          end else
            DxHint.Items.Objects[i] := TObject(Integer(1));
        end;
      4: begin
          if dp.Caption <> '' then begin
            DxHint.Items.Objects[i] := TObject(Integer(0))
          end else
            DxHint.Items.Objects[i] := TObject(Integer(1));
        end;
    end;
  end;

  if (LastMenuControl = nil) or (LastMenuControl <> dp) then begin
    DxHint.DParent := dp;
    dp.AddChild(DxHint);
  end;
  if (LastMenuControl <> nil) and (LastMenuControl <> dp) then begin
    if not dp.IsHotKey and (dp.Caption <> '') then begin
      dp.SelStart := 0;
      dp.SelEnd := AnsiTextLength(dp.Caption);
      dp.ChangeCurPos(dp.SelEnd, True);
    end;
  end;
  LastMenuControl := dp;

  DxHint.Left := X - dp.Left;
  DxHint.Top := Y - dp.Top - DxHint.Height;
  DxHint.ParentControl := dp;
  DxHint.Visible := True;
  dp.DxHint := DxHint;

end;

procedure TFrmDlg.DxEditPasswordKeyPress(Sender: TObject; var Key: Char);
begin
  LoginScene.EdLoginPasswdKeyPress(Sender, Key);
end;

procedure TFrmDlg.DxHint1ChangeSelect(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
var
  cmd: string;
begin
  cmd := '';
  if (DxHint1.FSelected > -1) and (DxHint1.FSelected < DxHint1.Items.Count) then begin
    if DxHint1.FSelected = DxHint1.Items.Count - 1 then begin
      cmd := '@传 ';
    end else if DxHint1.FSelected = DxHint1.Items.Count - 2 then begin
      cmd := '!!';
    end else if DxHint1.FSelected = DxHint1.Items.Count - 3 then begin
      cmd := '!~';
    end else if DxHint1.FSelected = DxHint1.Items.Count - 4 then begin
      cmd := '!';
    end else begin
      cmd := Trim(DxHint1.Items[DxHint1.FSelected]);
    end;

    if cmd <> '' then begin
      FrmDlg.DEdChat.Visible := True;
      SetDFocus(FrmDlg.DEdChat);
      FrmDlg.DEdChat.Text := cmd;
      FrmDlg.DEdChat.ChangeCurPos(AnsiTextLength(FrmDlg.DEdChat.Text), True);
      FrmDlg.DEdChat.SelLength := 0;
    end;
  end;
end;

procedure TFrmDlg.DOptionClick();
var
  i: Integer;
  pcm: PTClientMagic;
begin
  if g_Myself = nil then Exit;
  if not DWGameConfig.Visible then begin
    //base
    DxEditExpFilter.Caption := IntToStr(g_MaxExpFilter);
    //Protect
    DxEditRenewHPPercent.Caption := IntToStr(g_gnProtectPercent[0]);
    DxEditRenewMPPercent.Caption := IntToStr(g_gnProtectPercent[1]);
    DxEditRenewSpecialPercent.Caption := IntToStr(g_gnProtectPercent[3]);

    DxEditRenewHPPercentHero.Caption := IntToStr(g_gnProtectPercent[7]);
    DxEditRenewMPPercentHero.Caption := IntToStr(g_gnProtectPercent[8]);
    DxEditRenewSpecialPercentHero.Caption := IntToStr(g_gnProtectPercent[9]);
    DxEditPerHeroSidestep.Caption := IntToStr(g_gnProtectPercent[10]);

    DxEditRenewBookPercent.Caption := IntToStr(g_gnProtectPercent[5]);

    ///------------------------------------------------------------------
    DxEditRenewHPTime.Caption := IntToStr(g_gnProtectTime[0] { div 1000});
    DxEditRenewMPTime.Caption := IntToStr(g_gnProtectTime[1] {div 1000});
    DxEditRenewSpecialTime.Caption := IntToStr(g_gnProtectTime[3] {div 1000});

    DxEditRenewHPTimeHero.Caption := IntToStr(g_gnProtectTime[7] {div 1000});
    DxEditRenewMPTimeHero.Caption := IntToStr(g_gnProtectTime[8] {div 1000});
    DxEditRenewSpecialTimeHero.Caption := IntToStr(g_gnProtectTime[9] {div 1000});

    DxEditRenewBookTime.Caption := IntToStr(g_gnProtectTime[5] {div 1000});
    if (DCBRenewBookNowBook.DropDownList <> nil) and (g_gnProtectPercent[6] > -1) and (g_gnProtectPercent[6] < DCBRenewBookNowBook.DropDownList.Items.Count) then
      DCBRenewBookNowBook.Caption := DCBRenewBookNowBook.DropDownList.Items[g_gnProtectPercent[6]];
    //tec
    DLBPractice.tag := 0;
    DLBPractice.Items.Clear;
    for i := g_MagicList.Count - 1 downto 0 do begin
      pcm := g_MagicList.Items[i];
      if (pcm.Def.btJob = g_Myself.m_btJob) and (pcm.Def.btEffectType <> 0) then
        DLBPractice.Items.AddObject(pcm.Def.sMagicName, TObject(pcm.Def.wMagicId));
    end;
    DLBPractice.Height := 15 * DLBPractice.Items.Count + 1;

    pcm := frmMain.GetMagicByID(g_gnTecPracticeKey);
    if pcm <> nil then begin
      DCBPractice.Caption := pcm.Def.sMagicName;
      DCBPractice.tag := pcm.Def.wMagicId;
    end else {if DLBRenewBookNowBook.Items.count > 0 then}  begin
      DCBPractice.Caption := '请选择技能';
      DCBPractice.tag := -1;
    end;
    DxEditPractice.Caption := IntToStr(g_gnTecTime[8] div 1000);

    if g_boSpeedRate and g_boSpeedRateShow then begin
      DMBHitSpeed.UpdatePos(g_HitSpeedRate);
      DMBHitSpeedMouseMove(DMBHitSpeed, [ssLeft], 0, 0);

      DMBMagSpeed.UpdatePos(g_MagSpeedRate);
      DMBHitSpeedMouseMove(DMBMagSpeed, [ssLeft], 0, 0);

      DMBMoveSpeed.UpdatePos(g_MoveSpeedRate);
      DMBHitSpeedMouseMove(DMBMoveSpeed, [ssLeft], 0, 0);
    end;
    DMBVolume.UpdatePos(g_lWavMaxVol);
    DMBHitSpeedMouseMove(DMBVolume, [ssLeft], 0, 0);

    DBGCActivePage1Click(DBGCActivePage1, 0, 0);
    g_gcGeneral[11] := not g_SndMgr.Silent;

    DWGameConfig.Visible := True;
  end else
    SaveGameConfig();

  {DConfigDlg.Visible := not DConfigDlg.Visible;
  DConfigDlgClose.Visible := DConfigDlg.Visible;
  frmMain.OpenConfigDlg(DConfigDlg.Visible);}
end;

procedure TFrmDlg.SaveGameConfig();
var
  ini, ini2: TiniFile;
  pcm: PTClientMagic;
begin
  if not DirectoryExists('.\Config\') then
    ForceDirectories('.\Config\');

  ini := TiniFile.Create('.\Config\' + g_sServerName + '.' + frmMain.m_sCharName + '.Set');

  ini.WriteBool('Basic', 'ShowActorName', g_gcGeneral[0]);
  ini.WriteBool('Basic', 'DuraWarning', g_gcGeneral[1]);
  ini.WriteBool('Basic', 'AutoAttack', g_gcGeneral[2]);
  ini.WriteBool('Basic', 'ShowExpFilter', g_gcGeneral[3]);
  g_MaxExpFilter := StrToInt(DxEditExpFilter.Caption);
  ini.WriteInteger('Basic', 'ShowExpFilterMax', g_MaxExpFilter);
  ini.WriteBool('Basic', 'ShowDropItems', g_gcGeneral[4]);
  ini.WriteBool('Basic', 'ShowDropItemsFilter', g_gcGeneral[5]);
  ini.WriteBool('Basic', 'ShowHumanWing', g_gcGeneral[6]);
  ini.WriteBool('Basic', 'AutoPickUp', g_boAutoPickUp);
  ini.WriteBool('Basic', 'AutoPickUpFilter', g_gcGeneral[7]);
  ini.WriteBool('Basic', 'PickUpAllItem', g_boPickUpAll);

  ini.WriteBool('Basic', 'HideDeathBody', g_gcGeneral[8]);
  ini.WriteBool('Basic', 'AutoFixItem', g_gcGeneral[9]);
  ini.WriteBool('Basic', 'ShakeScreen', g_gcGeneral[10]);
  ini.WriteBool('Basic', 'StruckShow', g_gcGeneral[13]);
  ini.WriteBool('Basic', 'HideStruck', g_gcGeneral[15]);

  ini.WriteBool('Basic', 'CompareItems', g_gcGeneral[14]);

  ini2 := TiniFile.Create('.\lscfg.ini');
  ini2.WriteBool('Setup', 'EffectSound', g_gcGeneral[11]);
  ini2.WriteBool('Setup', 'EffectBKGSound', g_gcGeneral[12]);
  ini2.WriteInteger('Setup', 'EffectSoundLevel', g_lWavMaxVol);
  ini2.free;

  ini.WriteInteger('Basic', 'HitSpeedRate', g_HitSpeedRate);
  ini.WriteInteger('Basic', 'MagSpeedRate', g_MagSpeedRate);
  ini.WriteInteger('Basic', 'MoveSpeedRate', g_MoveSpeedRate);

  g_gnProtectPercent[0] := Str_ToInt(DxEditRenewHPPercent.Caption, 10);
  g_gnProtectPercent[1] := Str_ToInt(DxEditRenewMPPercent.Caption, 10);
  g_gnProtectPercent[3] := Str_ToInt(DxEditRenewSpecialPercent.Caption, 10);
  g_gnProtectPercent[7] := Str_ToInt(DxEditRenewHPPercentHero.Caption, 10);
  g_gnProtectPercent[8] := Str_ToInt(DxEditRenewMPPercentHero.Caption, 10);
  g_gnProtectPercent[9] := Str_ToInt(DxEditRenewSpecialPercentHero.Caption, 10);
  g_gnProtectPercent[10] := Str_ToInt(DxEditPerHeroSidestep.Caption, 20);
  g_gnProtectPercent[5] := Str_ToInt(DxEditRenewBookPercent.Caption, 10);
  g_gnProtectPercent[6] := DCBRenewBookNowBook.DropDownList.ItemSelected;

  g_gnProtectTime[0] := _MAX(g_nEatItemInvTime, Str_ToInt(DxEditRenewHPTime.Caption, 4000)); // * 1000;
  g_gnProtectTime[1] := _MAX(g_nEatItemInvTime, Str_ToInt(DxEditRenewMPTime.Caption, 4000)); // * 1000;
  g_gnProtectTime[3] := _MAX(g_nEatItemInvTime, Str_ToInt(DxEditRenewSpecialTime.Caption, 500)); // * 1000;
  g_gnProtectTime[7] := _MAX(g_nEatItemInvTime, Str_ToInt(DxEditRenewHPTimeHero.Caption, 400)); // * 1000;
  g_gnProtectTime[8] := _MAX(g_nEatItemInvTime, Str_ToInt(DxEditRenewMPTimeHero.Caption, 400)); // * 1000;
  g_gnProtectTime[9] := _MAX(g_nEatItemInvTime, Str_ToInt(DxEditRenewSpecialTimeHero.Caption, 500)); // * 1000;
  g_gnProtectTime[5] := _MAX(200, Str_ToInt(DxEditRenewBookTime.Caption, 4000)); // * 1000;
  ini.WriteBool('Protect', 'RenewHPIsAuto', g_gcProtect[0]);
  ini.WriteBool('Protect', 'RenewMPIsAuto', g_gcProtect[1]);
  ini.WriteBool('Protect', 'RenewSpecialIsAuto', g_gcProtect[3]);
  ini.WriteBool('Protect', 'HeroRenewHPIsAuto', g_gcProtect[7]);
  ini.WriteBool('Protect', 'HeroRenewMPIsAuto', g_gcProtect[8]);
  ini.WriteBool('Protect', 'HeroRenewSpecialIsAuto', g_gcProtect[9]);
  ini.WriteBool('Protect', 'HeroSidestep', g_gcProtect[10]);
  ini.WriteBool('Protect', 'RenewSpecialIsAuto_MP', g_gcProtect[11]);

  frmMain.SendClientMessage(CM_HEROSIDESTEP, MakeLong(Integer(g_gcProtect[10]), g_gnProtectPercent[10]), 0, 0, 0);

  ini.WriteBool('Protect', 'RenewBookIsAuto', g_gcProtect[5]);
  ini.WriteInteger('Protect', 'RenewHPTime', g_gnProtectTime[0]);
  ini.WriteInteger('Protect', 'RenewMPTime', g_gnProtectTime[1]);
  ini.WriteInteger('Protect', 'RenewSpecialTime', g_gnProtectTime[3]);
  ini.WriteInteger('Protect', 'HeroRenewHPTime', g_gnProtectTime[7]);
  ini.WriteInteger('Protect', 'HeroRenewMPTime', g_gnProtectTime[8]);
  ini.WriteInteger('Protect', 'HeroRenewSpecialTime', g_gnProtectTime[9]);
  ini.WriteInteger('Protect', 'RenewBookTime', g_gnProtectTime[5]);
  ini.WriteInteger('Protect', 'RenewHPPercent', g_gnProtectPercent[0]);
  ini.WriteInteger('Protect', 'RenewMPPercent', g_gnProtectPercent[1]);
  ini.WriteInteger('Protect', 'RenewSpecialPercent', g_gnProtectPercent[3]);
  ini.WriteInteger('Protect', 'HeroRenewHPPercent', g_gnProtectPercent[7]);
  ini.WriteInteger('Protect', 'HeroRenewMPPercent', g_gnProtectPercent[8]);
  ini.WriteInteger('Protect', 'HeroRenewSpecialPercent', g_gnProtectPercent[9]);
  ini.WriteInteger('Protect', 'HeroPerSidestep', g_gnProtectPercent[10]);
  ini.WriteInteger('Protect', 'RenewBookPercent', g_gnProtectPercent[5]);
  ini.WriteInteger('Protect', 'RenewBookNowBookIndex', g_gnProtectPercent[6]);

  g_gnTecTime[8] := Str_ToInt(DxEditPractice.Caption, 4) * 1000;
  g_gnTecPracticeKey := DCBPractice.tag;
  ini.WriteBool('Tec', 'SmartLongHit', g_gcTec[0]);
  ini.WriteBool('Tec', 'SmartWideHit', g_gcTec[1]);
  ini.WriteBool('Tec', 'SmartFireHit', g_gcTec[2]);
  ini.WriteBool('Tec', 'SmartPureHit', g_gcTec[3]);
  ini.WriteBool('Tec', 'SmartShield', g_gcTec[4]);
  ini.WriteBool('Tec', 'SmartShieldHero', g_gcTec[5]);
  ini.WriteBool('Tec', 'SmartTransparence', g_gcTec[6]);
  ini.WriteBool('Tec', 'SmartThunderHit', g_gcTec[9]);
  ini.WriteBool('Tec', 'SmartLongHit2', g_gcTec[10]);
  ini.WriteBool('Tec', 'SmartSLongHit', g_gcTec[11]);
  ini.WriteBool('Tec', 'HeroSeriesSkillFilter', g_gcTec[12]);
  ini.WriteBool('Tec', 'SLongHit', g_gcTec[13]);
  ini.WriteBool('Tec', 'SmartGoMagic', g_gcTec[14]);

  frmMain.SendClientMessage(CM_HEROSERIESSKILLCONFIG, MakeLong(Integer(g_gcTec[12]), 0), 0, 0, 0);

  ini.WriteBool('AutoPractice', 'PracticeIsAuto', g_gcTec[7]);
  ini.WriteInteger('AutoPractice', 'PracticeKey', g_gnTecPracticeKey);
  ini.WriteInteger('AutoPractice', 'PracticeTime', g_gnTecTime[8]);

  ini.WriteBool('Hotkey', 'UseHotkey', g_gcHotkey[0]);
  ini.WriteInteger('Hotkey', 'HeroCallHero', FrmDlg.DEHeroCallHero.HotKey);
  ini.WriteInteger('Hotkey', 'HeroSetAttackState', FrmDlg.DEHeroSetAttackState.HotKey);
  ini.WriteInteger('Hotkey', 'HeroSetGuard', FrmDlg.DEHeroSetGuard.HotKey);
  ini.WriteInteger('Hotkey', 'HeroSetTarget', FrmDlg.DEHeroSetTarget.HotKey);
  ini.WriteInteger('Hotkey', 'HeroUnionHit', FrmDlg.DEHeroUnionHit.HotKey);
  ini.WriteInteger('Hotkey', 'SwitchAttackMode', FrmDlg.DESwitchAttackMode.HotKey);
  ini.WriteInteger('Hotkey', 'SwitchMiniMap', FrmDlg.DESwitchMiniMap.HotKey);
  ini.WriteInteger('Hotkey', 'SerieSkill', FrmDlg.DxEditSSkill.HotKey);

  //=========================================================================
  //ini.WriteBool('Ass', '0', g_gcAss[0]);
  ini.WriteBool('Ass', '1', g_gcAss[1]);
  ini.WriteBool('Ass', '2', g_gcAss[2]);
  ini.WriteBool('Ass', '3', g_gcAss[3]);
  ini.WriteBool('Ass', '4', g_gcAss[4]);
  ini.WriteBool('Ass', '5', g_gcAss[5]);
  ini.WriteBool('Ass', '6', g_gcAss[6]);
  ini.free;
  DWGameConfig.Visible := False;
end;


procedure TFrmDlg.DWBookBkgndDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
begin
  if g_Myself = nil then Exit;
  if not DWBookBkgnd.Visible then Exit;
  if g_nBookPath <= 0 then begin
    DWBookBkgnd.Visible := False;
    Exit;
  end;
  with DWBookBkgnd do begin
    if g_nBookPath = 1 then begin
      //d := g_WMain3Images.ImagesName[90, g_sBookBkgnd];
      d := g_opui.Images[g_sBookBkgnd];
      if d <> nil then begin
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);

        if not DBBookPage.Visible then
          DBBookPage.Visible := True;
        if not DBBookPrior.Visible then
          DBBookPrior.Visible := True;
        if g_nBookPage <> 4 then
          if not DBBookNext.Visible then
            DBBookNext.Visible := True;
      end;
    end else begin
      if DBBookPage.Visible then DBBookPage.Visible := False;
      //d := g_WMain3Images.ImagesName[92, Format(F, [g_nBookPath, g_nBookPage])];
      d := g_opui.Images[(g_nBookPath * 10 + g_nBookPage)+100];
      if d <> nil then begin
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
        if DBBookPrior.Visible then DBBookPrior.Visible := False;
        if DBBookNext.Visible then DBBookNext.Visible := False;
      end;
    end;
  end;
end;

procedure TFrmDlg.DBBookCloseDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
begin
  if g_Myself = nil then Exit;
  with DBBookClose do begin
    if not Downed then
      //d := g_WMain3Images.ImagesName[84, g_sBookCloseNormal]
      d := g_opui.Images[g_sBookCloseNormal]
    else
      //d := g_WMain3Images.ImagesName[85, g_sBookCloseDown];
      d := g_opui.Images[g_sBookCloseDown];
    if d <> nil then begin
      if g_nBookPath = 1 then begin
        if Left <> 528 - 20 - 2 then Left := 528 - 20 - 2;
        if Top <> 2 then Top := 2;
      end else begin
        if Left <> 528 - 4 then Left := 528 - 4;
        if Top <> 3 then Top := 3;
      end;
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    end;
  end;
end;

procedure TFrmDlg.DBBookCloseClick(Sender: TObject; X, Y: Integer);
begin
  DWBookBkgnd.Visible := False;
end;

procedure TFrmDlg.DBBookPageDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
begin
  if g_Myself = nil then Exit;
  if not DWBookBkgnd.Visible then Exit;
  with DBBookPage do begin
    if Left <> 40 then Left := 40;
    if Top <> 30 then Top := 30;
    //d := g_WMain3Images.ImagesName[114 + g_nBookPage, Format(F, [g_nBookPath, g_nBookPage + 1])];
    d := g_opui.Images[(g_nBookPath * 10 +  g_nBookPage + 1)+100];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
  end;
end;

procedure TFrmDlg.DBBookPriorDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  s: integer;
  d: TCustomLockableTexture;
begin
  if g_Myself = nil then Exit;
  if not DWBookBkgnd.Visible then Exit;
  with DBBookPrior do begin
    if Left <> 310 then Left := 310;
    if Top <> 286 then Top := 286;
    if g_nBookPage = 4 then begin
      if Left <> 325 then Left := 325;
      DBBookNext.Visible := False;
      if not Downed then
        d := g_opui.Images[100]
      else
        d := g_opui.Images[101];

      if d <> nil then begin
        if Width <> d.Width then Width := d.Width;
        if Height <> d.Height then Height := d.Height;
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
      end;
    end else begin
      if not Downed then
        s := g_sBookPrevPageNormal
      else
        s := g_sBookPrevPageDown;
      d := g_opui.Images[s];
      if d <> nil then begin
        if Width <> d.Width then Width := d.Width;
        if Height <> d.Height then Height := d.Height;
        //SetImgName(frmMain.WMainUibImages, S);
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
      end;
    end;
  end;
end;

procedure TFrmDlg.DBBuildAcusHelpClick(Sender: TObject; X, Y: Integer);
var
  i, n, T: Integer;
  s: string;
begin
  if g_BuildAcusesStep = 1 then Exit;
  with Sender as TDButton do begin
    T := DWBuildAcus.tag;
    DWBuildAcus.tag := tag;
    DBAcus1.Visible := False;
    DBAcus2.Visible := False;
    DBAcus3.Visible := False;
    DBAcus4.Visible := False;
    DBAcus5.Visible := False;

    DBCharm1.Visible := False;
    DBCharm2.Visible := False;
    DBCharm3.Visible := False;
    if tag in [1, 2] then begin
      DBAcus1.Visible := True;
      DBAcus2.Visible := True;
      DBAcus3.Visible := True;
      DBAcus4.Visible := True;
      DBAcus5.Visible := True;

      DBCharm1.Visible := True;
      DBCharm2.Visible := True;
      DBCharm3.Visible := True;
    end;
    if (Sender = DBBuildAcusStart) then begin
      n := 0;
      for i := 0 to 4 do begin
        if g_BuildAcuses[i].item.s.Name <> '' then
          Inc(n);
      end;
      if n = 0 then Exit;
      if tag = T then begin
        s := '';
        if g_BAFirstShape in [10..14] then
          case g_BAFirstShape of
            10: s := '一级金针';
            11: s := '二级金针';
            12: s := '三级金针';
            13: s := '四级金针';
            14: s := '五级金针';
          end;
        if FrmDlg.DMessageDlg(Format('是否开始锻造 %s？', [s]), [mbOk, mbCancel]) = mrOk then begin
          g_BuildAcusesStep := 1;
          g_BuildAcusesProc := 0;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DBBuildAcusHelpDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
begin
  with Sender as TDButton do begin
    if Downed then
      d := WLib.Images[FaceIndex + 1]
    else
      d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
  end;
end;

procedure TFrmDlg.DBChatDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
begin
  with Sender as TDButton do begin
    d := WLib.Images[FaceIndex];
    if d <> nil then begin
      //dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
//      DrawBlend_Mix(dsurface, SurfaceX(Left), SurfaceY(Top), d, 0, 0, d.Width, d.Height, 0);
    end;
    //g_ChatWindowLines
    if g_ChatStatusLarge then begin

    end;
  end;
end;

procedure TFrmDlg.DBChatNextClick(Sender: TObject; X, Y: Integer);  //聊天框拉伸条 下拉
begin
  if DScreen.ChatStrs.Count > 1 then begin
    if DScreen.ChatBoardTop + 1 < DScreen.ChatStrs.Count then begin
      Inc(DScreen.ChatBoardTop);
      DBDBChatScroll.Position := Round(DBDBChatScroll.Max / (DScreen.ChatStrs.Count - 1) * DScreen.ChatBoardTop);
      DBDBChatScroll.UpdatePos(DBDBChatScroll.Position, True);
    end;
  end;
end;

procedure TFrmDlg.DBChatNextDirectPaint(Sender: TObject; //聊天框拉伸条 下拉
  DSurface: TCustomCanvas);
var
  d: TDButton;
  dd: TCustomLockableTexture;
begin
  if Sender is TDButton then begin
    d := TDButton(Sender);
    if d.Downed then begin
      dd := d.WLib.Images[d.FaceIndex + 2];
    end else begin
      dd := d.WLib.Images[d.FaceIndex];
    end;
    if dd <> nil then
      dsurface.Draw(d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, True);
  end;
end;

procedure TFrmDlg.DBChatPrevClick(Sender: TObject; X, Y: Integer);  //聊天框拉伸条 上拉
begin
  if (DScreen.ChatStrs.Count > 1) and (DScreen.ChatBoardTop > 0) then begin
    Dec(DScreen.ChatBoardTop);
    DBDBChatScroll.Position := Round(DBDBChatScroll.Max / (DScreen.ChatStrs.Count - 1) * DScreen.ChatBoardTop);
    DBDBChatScroll.UpdatePos(DBDBChatScroll.Position, True);
  end;
end;

procedure TFrmDlg.DBChatPrevDirectPaint(Sender: TObject; //聊天框拉伸条 上拉
  DSurface: TCustomCanvas);
var
  d: TDButton;
  dd: TCustomLockableTexture;
begin
  if Sender is TDButton then begin
    d := TDButton(Sender);
    if d.Downed then begin
      dd := d.WLib.Images[d.FaceIndex + 2];
    end else begin
      dd := d.WLib.Images[d.FaceIndex];
    end;
    if dd <> nil then
      dsurface.Draw(d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, True);
  end;
end;

procedure TFrmDlg.DBChatRangeClick(Sender: TObject; X, Y: Integer);
begin
  X := g_ChatWindowLines;
  Inc(X, 4);
  if (X > 12) or (X mod 4 <> 0) then
    X := 4;
  g_ChatWindowLines := X;
  DMBChat.SlotLen := 12 * (Round(g_ChatWindowLines * 1.25) + 3);
  DMBChat.UpdatePos(DScreen.ChatBoardTop, True);
end;

procedure TFrmDlg.DBChatRangeDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TDButton;
  dd: TCustomLockableTexture;
begin
  if Sender is TDButton then begin
    d := TDButton(Sender);
    dd := d.WLib.Images[d.FaceIndex];
    if d.Downed then begin
      dd := d.WLib.Images[d.FaceIndex];
    end else if d.Arrived then begin
      dd := d.WLib.Images[d.FaceIndex + 1];
    end;
    if dd <> nil then
      dsurface.Draw(d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, True);
  end;
end;

procedure TFrmDlg.DBChatRecordListCloseClick(Sender: TObject; X, Y: Integer);
begin
  DWChatRecordList.Visible := False;
end;

procedure TFrmDlg.DBChatRecordListCloseDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
begin
  with Sender as TDButton do begin
    if not Downed then
      d := WLib.Images[FaceIndex]
    else
      d := WLib.Images[FaceIndex + 1];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
  end;
end;

procedure TFrmDlg.DBChatRecordNextClick(Sender: TObject; X, Y: Integer);
begin
  if m_xChatRecordList.Count > 1 then begin
    if m_nChatRecordListTop + 1 < m_xChatRecordList.Count then begin
      Inc(m_nChatRecordListTop);
      DBDBChatRecordScroll.Position := Round(DBDBChatRecordScroll.Max / (m_xChatRecordList.Count - 1) * m_nChatRecordListTop);
      DBDBChatRecordScroll.UpdatePos(DBDBChatRecordScroll.Position, True);
    end;
  end;
end;

procedure TFrmDlg.DBChatRecordPrevClick(Sender: TObject; X, Y: Integer);
begin
  if (m_xChatRecordList.Count > 1) and (m_nChatRecordListTop > 0) then begin
    Dec(m_nChatRecordListTop);
    DBDBChatRecordScroll.Position := Round(DBDBChatRecordScroll.Max / (m_xChatRecordList.Count - 1) * m_nChatRecordListTop);
    DBDBChatRecordScroll.UpdatePos(DBDBChatRecordScroll.Position, True);
  end;
end;

procedure TFrmDlg.DBChatStatusClick(Sender: TObject; X, Y: Integer);
begin
  g_ChatStatusLarge := not g_ChatStatusLarge;
end;

procedure TFrmDlg.DBChatStatusDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TDButton;
  dd: TCustomLockableTexture;
begin
  if Sender is TDButton then begin
    d := TDButton(Sender);
    if d.Downed then begin
      dd := d.WLib.Images[d.FaceIndex];
      if dd <> nil then
        dsurface.Draw(d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, True);
    end else if d.Arrived then begin
      dd := d.WLib.Images[d.FaceIndex + 1];
      if dd <> nil then
        dsurface.Draw(d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, True);
    end;
  end;
end;

procedure TFrmDlg.DBChatWinDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  n, sX, sY, i, fcolor, bcolor: Integer;
  d: TCustomLockableTexture;
begin
  with Sender as TDButton do begin
    d := WLib.Images[FaceIndex];
    if d <> nil then begin
//      DrawBlend_Mix(dsurface, SurfaceX(Left), SurfaceY(Top), d, 0, 0, d.Width, d.Height, 0);
    end;
    n := VIEWCHATLINE;
    for i := DScreen.ChatBoardTop to DScreen.ChatBoardTop + n - 1 do begin
      if i > DScreen.ChatStrs.Count - 1 then Break;
      fcolor := Integer(DScreen.ChatStrs.Objects[i]);
      bcolor := Integer(DScreen.ChatBks[i]);
//      dsurface.Canvas.Font.Color := fcolor;
//      dsurface.Canvas.Brush.Color := bcolor;
//      dsurface.Canvas.TextOutA(SurfaceX(Left + 21), SurfaceY(Top + 30 + (i - DScreen.ChatBoardTop) * 12), DScreen.ChatStrs.Strings[i], OPAQUE);
    end;

  end;
end;

procedure TFrmDlg.DBChatWinInRealArea(Sender: TObject; X, Y: Integer; var IsRealArea: Boolean);
begin
  IsRealArea := True;
end;

procedure TFrmDlg.DBChatWinMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);

  function ExtractUserName(line: string): string;
  var
    uname: string;
  begin
    GetValidStr3(line, line, ['(', '!', '*', '/', ')']);
    GetValidStr3(line, uname, [' ', '=', ':']);
    if uname <> '' then
      if (uname[1] = '/') or (uname[1] = '(') or (uname[1] = ' ') or (uname[1] = '[') then
        uname := '';
    Result := uname;
  end;
var
  n, nY: Integer;
  Str: string;
begin
  nY := (12 - g_ChatWindowLines) * 15;
  if (X >= 21) and (X <= 21 + 316) and (Y >= -204 + nY) and (Y <= -204 + (VIEWCHATLINE * 12)) then begin
    n := DScreen.ChatBoardTop + (Y + 204 - nY) div 12;
    if (n < DScreen.ChatStrs.Count) then begin
      FrmDlg.DEdChat.Visible := True;
      FrmDlg.DBChat.Visible := True;
      SetDFocus(FrmDlg.DEdChat);

      if ssCtrl in Shift then
        FrmDlg.DEdChat.Text := DScreen.ChatStrs[n]
      else
        FrmDlg.DEdChat.Text := '/' + ExtractUserName(DScreen.ChatStrs[n]) + ' ';
      FrmDlg.DEdChat.ChangeCurPos(AnsiTextLength(FrmDlg.DEdChat.Text), True);
      FrmDlg.DEdChat.SelLength := 0;
    end else
      FrmDlg.DEdChat.Text := '';
  end;
end;

procedure TFrmDlg.DBChatWinMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
begin
  DScreen.ClearHint;
end;

procedure TFrmDlg.DBCollectExpDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  n, M: Integer;
  d, dd: TCustomLockableTexture;
  rc: TIntRect;
begin
  with Sender as TDButton do begin

    if (g_dwCollectExpLv <> 4) or (g_dwCollectExp <> g_dwCollectExpMax) or (g_dwCollectIPExp <> g_dwCollectIPExpMax) then begin
      if g_boCollectExpShineCount > 0 then begin
        if GetTickCount - g_dwCollectExpShineTick > 150 then begin
          g_dwCollectExpShineTick := GetTickCount;
          g_boCollectExpShine := not g_boCollectExpShine;

          M := 3;
          if g_dwCollectExpLv = 4 then
            M := 4;
          Inc(g_nCollectStateShine);
          if g_nCollectStateShine >= M then
            g_nCollectStateShine := 0;

          Dec(g_boCollectExpShineCount);

        end;
      end else begin
        g_boCollectExpShine := False;
        g_nCollectStateShine := -1;
      end;
    end;

    dd := WLib.Images[FaceIndex + Integer(g_boCollectExpShine)];
    if dd <> nil then begin
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), dd.ClientRect, dd, True);
    end;

    dd := WLib.Images[FaceIndex + 8 + Integer(g_boCollectExpShine)];
    if dd <> nil then begin
      rc := dd.ClientRect;

      if Sender = DBCollectExp then begin
        if g_dwCollectExpMax > 0 then begin
          n := rc.Bottom - rc.Top;
          rc.Bottom := n - Round(n / g_dwCollectExpMax * g_dwCollectExp);
        end;
      end else begin
        if g_dwCollectIPExpMax > 0 then begin
          n := rc.Bottom - rc.Top;
          rc.Bottom := n - Round(n / g_dwCollectIPExpMax * g_dwCollectIPExp);
        end;
      end;
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), rc, dd, True);
    end;

    if (g_dwCollectExpLv = 4) and (g_dwCollectExp = g_dwCollectExpMax) and (g_dwCollectIPExp = g_dwCollectIPExpMax) then begin
      if GetTickCount - g_dwCollectStateShineTick2 > 150 then begin
        g_dwCollectStateShineTick2 := GetTickCount;
        Inc(g_nCollectStateShine);
        if g_nCollectStateShine >= g_dwCollectExpLv then
          g_nCollectStateShine := 0;
      end;
      d := g_WMainImages.Images[525 + g_nCollectStateShine];
      if d <> nil then
        dsurface.DrawBlend(DWCollectExp.SurfaceX(DWCollectExp.Left) - 6, DWCollectExp.SurfaceY(DWCollectExp.Top), d, 1);
    end else if (g_nCollectStateShine >= 0) and (g_dwCollectExpLv in [2..4]) then begin
      d := g_WMainImages.Images[495 + (g_dwCollectExpLv - 1) * 8 + g_nCollectStateShine];
      if d <> nil then begin
        if (g_dwCollectExpLv = 4) then
          dsurface.DrawBlend(DBCollectState.SurfaceX(DBCollectState.Left) - 16, DBCollectState.SurfaceY(DBCollectState.Top) - 27, d, 1)
        else
          dsurface.DrawBlend(DBCollectState.SurfaceX(DBCollectState.Left) - 18, DBCollectState.SurfaceY(DBCollectState.Top) - 18, d, 1);
      end;
    end;

    //d := g_WMainImages.Images[521];
    //DrawBlend(dsurface, DBCollectState.SurfaceX(DBCollectState.Left) - 16, DBCollectState.SurfaceY(DBCollectState.Top) - 24, d, 1)

  end;
end;

procedure TFrmDlg.DBCollectExpMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
begin
  DScreen.ClearHint;
  DScreen.ShowHint(DWCollectExp.SurfaceX(DWCollectExp.Left + 40), DWCollectExp.SurfaceY(DWCollectExp.Top + 60),
    Format('经验: %d/%d\内功: %d/%d', [g_dwCollectExp, g_dwCollectExpMax, g_dwCollectIPExp, g_dwCollectIPExpMax]),
    clWhite, False);
end;

procedure TFrmDlg.DBCollectStateDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  n: Integer;
  d: TCustomLockableTexture;
begin
  if (g_dwCollectExpLv >= 2) then begin
    with DBCollectState do begin
      if GetTickCount - g_dwCollectStateShineTick > 300 then begin
        g_dwCollectStateShineTick := GetTickCount;
        g_boCollectStateShine := not g_boCollectStateShine;
      end;
      d := WLib.Images[FaceIndex + Integer(g_boCollectStateShine)];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);

      {if g_dwCollectExpLv in [1..4] then begin
        if GetTickCount - g_dwCollectStateShineTick2 > 150 then begin
          g_dwCollectStateShineTick2 := GetTickCount;
          n := 3;
          if g_dwCollectExpLv = 4 then
            n := 4;
          Inc(g_nCollectStateShine);
          if g_nCollectStateShine >= n then
            g_nCollectStateShine := 0;
        end;
        if g_dwCollectExpLv = 4 then begin
          d := g_WMainImages.Images[525 + g_nCollectStateShine];
          if d <> nil then
            DrawBlend(dsurface, DWCollectExp.SurfaceX(DWCollectExp.Left) - 6, DWCollectExp.SurfaceY(DWCollectExp.Top), d, 1);
        end else begin
          d := g_WMainImages.Images[495 + (g_dwCollectExpLv - 1) * 8 + g_nCollectStateShine];
          if d <> nil then
            DrawBlend(dsurface, SurfaceX(Left) - 18, SurfaceY(Top) - 18, d, 1);
        end;
      end;}
    end;
  end;
end;

procedure TFrmDlg.DBCollectStateMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
begin
  DScreen.ClearHint;
  if g_dwCollectExpLv >= 2 then
    DScreen.ShowHint(DWCollectExp.SurfaceX(DWCollectExp.Left + 50), DWCollectExp.SurfaceY(DWCollectExp.Top + 30),
      '点击释放经验及内功经验',
      clWhite, False)
  else
    DScreen.ShowHint(DWCollectExp.SurfaceX(DWCollectExp.Left + 50), DWCollectExp.SurfaceY(DWCollectExp.Top + 30),
      '当经验池散发着光辉时，点击释放经验及内功经验',
      clWhite, False);
end;

procedure TFrmDlg.DBCollectStateMouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  if g_dwCollectExpLv >= 2 then
    frmMain.SendClientMessage(CM_RELEASECOLLECTEXP, 0, 0, 0, 0);
end;

procedure TFrmDlg.DBCommandClick(Sender: TObject; X, Y: Integer);
begin
  //
  DxHint1.Visible := not DxHint1.Visible;
end;

procedure TFrmDlg.DBConKeyClick(Sender: TObject; X, Y: Integer);
begin
  FrmDlg.DOptionClick();
  DBGCActivePage1Click(DBGCActivePage4, 0, 0);
end;

procedure TFrmDlg.DBConKeyMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
  //设置施展连击的快捷键
end;

procedure TFrmDlg.DBConRandomClick(Sender: TObject; X, Y: Integer);
begin
{$IF SERIESSKILL}
  if Sender = DBConRandom then begin
    if g_MagicList2.Count <= 1 then Exit;
    FillChar(g_TempSeriesSkillArr, SizeOf(g_TempSeriesSkillArr), 0);
    for X := 0 to g_MagicList2.Count - 1 do begin
      if X = High(TSeriesSkillArr) + 1 then Break;
      frmMain.SendSetSeriesSkill(X, 1, 0);
    end;
  end else begin
    if g_hMagicList2.Count <= 1 then Exit;
    FillChar(g_hTempSeriesSkillArr, SizeOf(g_hTempSeriesSkillArr), 0);
    for X := 0 to g_hMagicList2.Count - 1 do begin
      if X = High(TSeriesSkillArr) + 1 then Break;
      frmMain.SendSetSeriesSkill(X, 1, 1);
    end;
  end;
{$IFEND SERIESSKILL}
end;

procedure TFrmDlg.DBConRandomDirectPaint(Sender: TObject;
  dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
begin
  with Sender as TDButton do begin
    if not Downed then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
      if OnbtnState = tdisable then
        dsurface.BoldTextOut(SurfaceX(Left + (Width - FontManager.Default.TextWidth(Caption)) div 2 + 1), SurfaceY(Top + (Height - FontManager.Default.TextHeight(Caption)) div 2 + 1), clGray, $202020, Caption)
      else begin
        if Arrived then
          dsurface.BoldTextOut(SurfaceX(Left + (Width - FontManager.Default.TextWidth(Caption)) div 2 + 1), SurfaceY(Top + (Height - FontManager.Default.TextHeight(Caption)) div 2 + 1), GetRGB(95), $202020, Caption)
        else
          dsurface.BoldTextOut(SurfaceX(Left + (Width - FontManager.Default.TextWidth(Caption)) div 2 + 1), SurfaceY(Top + (Height - FontManager.Default.TextHeight(Caption)) div 2 + 1), GetRGB(93), $202020, Caption)
      end;
    end else begin
      d := WLib.Images[FaceIndex + 1];
      if d <> nil then dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
      dsurface.BoldTextOut(SurfaceX(Left + (Width - FontManager.Default.TextWidth(Caption)) div 2 + 2), SurfaceY(Top + (Height - FontManager.Default.TextHeight(Caption)) div 2 + 2), GetRGB(94), $202020, Caption);
    end;
  end;
end;

procedure TFrmDlg.DBConRandomMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
  //随机组合连击招式
end;

procedure TFrmDlg.DBBookNextDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  s: integer;
  d: TCustomLockableTexture;
begin
  if g_Myself = nil then Exit;
  if not DWBookBkgnd.Visible then Exit;
  with DBBookNext do begin
    if Left <> 375 then Left := 375;
    if Top <> 286 then Top := 286;
    if not Downed then
      s := g_sBookNextPageNormal
    else
      s := g_sBookNextPageDown;
    d := g_opui.Images[s];
    if d <> nil then begin
      if Width <> d.Width then Width := d.Width;
      if Height <> d.Height then Height := d.Height;
      //SetImgName(frmMain.WMainUibImages, S);
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    end;
  end;
end;

procedure TFrmDlg.DHListBoxSSkillDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  fy, nY, L, T, i, oSize: Integer;
  OldColor: TColor;
  d: TCustomLockableTexture;
begin
  with DHListBoxSSkill do begin
    L := SurfaceX(Left);
    T := SurfaceY(Top);
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(L, T, d.ClientRect, d, True);

    with dsurface do begin
      L := L + 3;
      T := T + 3;
      OldColor := Font.Color;
      oSize := Font.Size;
      Font.Color := clYellow;
      Font.Size := 9;
      Brush.Color := SelectionColor;
      if FSelected <> -1 then begin
        nY := T + (-Font.Height + LineSpace) * FSelected;
        fy := nY + (-Font.Height + LineSpace);
        if (nY < T + Height - 1) and (fy > T + 1) then begin
          if (fy > T + Height - 1) then fy := T + Height - 1;
          if (nY < T + 1) then nY := T + 1;
//          FillRect(Rect(L, nY - 1, L + Width - 6, fy));
        end;
      end;
      Brush.Style := bsClear;
      for i := 0 to g_hSeriesSkillSelList.Count - 1 do
        TextOut(L + 2, 1 + T + (-Font.Height + LineSpace) * i, g_hSeriesSkillSelList.Strings[i]);
      Font.Color := OldColor;
      Font.Size := oSize;
    end;
  end;
end;

procedure TFrmDlg.DBBookPriorClick(Sender: TObject; X, Y: Integer);
var
  msg: TDefaultMessage;
  param: string;
begin
  if g_Myself = nil then Exit;
  if not DWBookBkgnd.Visible then Exit;
  if g_nBookPath = 1 then begin
    if g_nBookPage = 4 then begin
      DWBookBkgnd.Visible := False;
      msg := EDcode.MakeDefaultMsg(CM_MERCHANTDLGSELECT, g_HillMerchant, 0, 0, 0);
      frmMain.SendSocket(EncodeMessage(msg) + g_sBookLabel);
      g_nBookPath := 0;
      g_nBookPage := 0;
      g_HillMerchant := 0;
      g_sBookLabel := '';
    end else if g_nBookPage > 0 then
      Dec(g_nBookPage);
  end;
end;

procedure TFrmDlg.DBBookNextClick(Sender: TObject; X, Y: Integer);
begin
  if g_Myself = nil then Exit;
  if g_nBookPath = 1 then begin
    if g_nBookPage < 4 then Inc(g_nBookPage);
    //if g_nBookPage = 4 then Inc(g_nBookPage);
  end;
end;

procedure TFrmDlg.DWBoxBKGndClick(Sender: TObject; X, Y: Integer);
var
  where, n, sel: Integer;
  flag: Boolean;
  obi: TOpenBoxItem;
begin
  if not DWBoxBKGnd.Visible then Exit;
  if g_OpenBoxItem.item.s.Name = '' then Exit;
  if g_boItemMoving then begin
    flag := False;
    if (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) then Exit;
    //if (g_WaitingUseItem.Item.S.Name <> '') then Exit;
    if (g_MovingItem.item.s.Name = '') then begin
      AddItemBag(g_OpenBoxItem.item, g_OpenBoxItem.Index);
      g_OpenBoxItem.item.s.Name := '';
      DWBoxBKGnd.Visible := False;
      Exit;
    end;
    if (g_MovingItem.Index >= 0) and (g_MovingItem.Index < HERO_MIIDX_OFFSET) then begin
      if (g_MovingItem.item.s.StdMode = 46) and (g_MovingItem.item.s.Shape in [12..16]) then begin
        if g_MovingItem.item.s.Shape - 10 = g_OpenBoxItem.item.s.Shape then begin
          g_RareBoxWindow.m_boKeyAvail := True;
          obi.nBoxItemMIdx := g_OpenBoxItem.item.MakeIndex;
          obi.sBoxItemName := g_OpenBoxItem.item.s.Name;
          obi.nKeyItemMIdx := g_MovingItem.item.MakeIndex;
          obi.sKeyItemName := g_MovingItem.item.s.Name;
          g_WaitingUseItem := g_MovingItem;
          frmMain.SendOpenBox(obi);
          g_SndMgr.ItemClickSound(g_MovingItem.item.s);
          g_MovingItem.item.s.Name := '';
          g_boItemMoving := False;
        end else begin
          DScreen.AddChatBoardString(Format('%s不能开启%s', [g_MovingItem.item.s.Name, g_OpenBoxItem.item.s.Name]), clWhite, clBlue);
          Exit;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DWBoxBKGndDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  idx, ax, ay: Integer;
  d: TCustomLockableTexture;
begin
  if not g_RareBoxWindow.m_boRareBoxShow then begin
    if g_OpenBoxItem.item.s.Name <> '' then begin
      with DWBoxBKGnd do begin
        if g_OpenBoxItem.item.s.Shape in [2..5] then begin
          idx := 520 + (g_OpenBoxItem.item.s.Shape - 2) * 20;
          d := g_WMain3Images.Images[idx];
          if d <> nil then begin
            SetImgIndex(g_WMain3Images, idx);
            dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
          end;
        end else if g_OpenBoxItem.item.s.Shape = 6 then begin
          d := g_WMain2Images.Images[130];
          if d <> nil then begin
            SetImgIndex(g_WMain2Images, 130);
            dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
          end;
        end;
      end;
    end;
  end else begin
    with DWBoxBKGnd do begin
      d := g_WMain3Images.Images[510];
      if d <> nil then begin
        SetImgIndex(g_WMain3Images, 510);
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
      end;
    end;
  end;

end;

procedure TFrmDlg.DBFlashRareBoxDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
begin
  if not g_RareBoxWindow.m_boRareBoxShow then Exit;
  with DBFlashRareBox do begin
    if Downed then begin
      if g_RareBoxWindow.m_btSvrItemIdx = 0 then begin
        d := WLib.Images[FaceIndex];
        if d <> nil then dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);

        if GetTickCount - g_RareBoxWindow.m_dwFlashIndex > 100 then begin
          g_RareBoxWindow.m_dwFlashIndex := GetTickCount;
          Inc(g_RareBoxWindow.m_btFlashIdx, 2);
          g_SndMgr.PlaySound('wav\SelectBoxFlash.wav');
          if g_RareBoxWindow.m_btFlashIdx > 16 then
            g_RareBoxWindow.m_btFlashIdx := 0;
          g_RareBoxWindow.m_nFlashBoxTime := (16 - g_RareBoxWindow.m_btFlashIdx) + 20;
        end;
      end;
    end;
    //btn effect
    if GetTickCount - g_RareBoxWindow.m_dwRareBtnFlash > 300 then begin
      g_RareBoxWindow.m_dwRareBtnFlash := GetTickCount;
      Inc(g_RareBoxWindow.m_btRareBtnFlash);
      if g_RareBoxWindow.m_btRareBtnFlash > 3 then
        g_RareBoxWindow.m_btRareBtnFlash := 0
    end;
    d := WLib.Images[515 + g_RareBoxWindow.m_btRareBtnFlash];
    if d <> nil then
      dsurface.DrawBlend(SurfaceX(Left) - 10, SurfaceY(Top) - 20, d, 1);
  end;
end;

procedure TFrmDlg.DBRareItem1DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  n, idx: Integer;
  d: TCustomLockableTexture;
begin
  if not g_RareBoxWindow.m_boRareBoxShow then Exit;
  with Sender as TDButton do begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);

    if g_RareBoxWindow.m_boSelBoxFlash then begin
      if GetTickCount - g_RareBoxWindow.m_dwFlashBoxTick > g_RareBoxWindow.m_nFlashBoxTime then begin
        g_RareBoxWindow.m_dwFlashBoxTick := GetTickCount;
        Inc(g_RareBoxWindow.m_btItemIdx);
        g_SndMgr.PlaySound('wav\FlashBox.wav');
        if g_RareBoxWindow.m_nFlashBoxCount > 20 then
          Inc(g_RareBoxWindow.m_nFlashBoxTime, g_RareBoxWindow.m_nFlashBoxTime div (g_RareBoxWindow.m_btFlashIdx div 2 + 2))
        else
          Inc(g_RareBoxWindow.m_nFlashBoxTime, (9 - g_RareBoxWindow.m_btFlashIdx div 2) * 5);
        if g_RareBoxWindow.m_btItemIdx > 8 then
          g_RareBoxWindow.m_btItemIdx := 1;
        Inc(g_RareBoxWindow.m_nFlashBoxCount);
        if g_RareBoxWindow.m_nFlashBoxTime > 450 then
          if g_RareBoxWindow.m_btItemIdx = g_RareBoxWindow.m_btSvrItemIdx then
            g_RareBoxWindow.m_boSelBoxFlash := False;
      end;
    end;
    n := (Sender as TDButton).tag;
    if g_RareBoxWindow.m_btItemIdx = n then begin
      if GetTickCount - g_RareBoxWindow.m_dwLightFlash > 300 then begin
        g_RareBoxWindow.m_dwLightFlash := GetTickCount;
        g_RareBoxWindow.m_boLightFlash := not g_RareBoxWindow.m_boLightFlash;
      end;
      d := g_WMain3Images.Images[600 + g_RareBoxWindow.m_btFlashIdx + Integer(g_RareBoxWindow.m_boLightFlash)];
      if d <> nil then begin
        if n = 9 then begin
          dsurface.DrawBlend( SurfaceX(Left) - 5, SurfaceY(Top) - 6, d, 1);
        end else begin
          dsurface.DrawBlend( SurfaceX(Left) - 10, SurfaceY(Top) - 11, d, 1);
        end;
      end;

    end;
    if g_RareBoxWindow.m_btItemIdx = n then begin
      idx := g_RareBoxWindow.m_BoxItems[n].nLooks;
      if idx >= 0 then begin
        //d := g_WBagItemImages.Images[idx]; //frmMain.GetWStateImg(idx);
        d := frmMain.GetWBagItemImg(idx);
        if d <> nil then
          dsurface.Draw(SurfaceX(Left + (Width - d.Width) div 2 + Integer(Downed)), SurfaceY(Top + (Height - d.Height) div 2 + Integer(Downed)), d.ClientRect, d, True);
      end;
    end else begin
      idx := g_RareBoxWindow.m_BoxItems[n].nLooks;
      if idx >= 0 then begin
        //d := g_WBagItemImages.Images[idx]; //frmMain.GetWStateImg(idx);
        d := frmMain.GetWBagItemImg(idx);
        if d <> nil then begin
//          g_ImgMixSurface.Draw(0, 0, d.ClientRect, d, False);
//          DrawEffect(0, 0, d.Width, d.Height, g_ImgMixSurface, ceGrayScale);
          dsurface.Draw(SurfaceX(Left + (Width - d.Width) div 2), SurfaceY(Top + (Height - d.Height) div 2), d.ClientRect, d, True);
          DrawEffect(0, 0, dsurface, d, ceGrayScale, True);
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DBFlashRareBoxMouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  if not g_RareBoxWindow.m_boRareBoxShow then Exit;
  if not g_RareBoxWindow.m_boFlashStart and (g_RareBoxWindow.m_btSvrItemIdx = 0) and not g_RareBoxWindow.m_boSelBoxFlash then begin
    frmMain.SendClientMessage(CM_SELETEBOXFLASH, 0, 0, 0, 0);
    g_RareBoxWindow.m_boFlashStart := True;
  end;
end;

procedure TFrmDlg.DBRareItem1DblClick(Sender: TObject);
begin
  if not g_RareBoxWindow.m_boRareBoxShow then Exit;
  if not g_RareBoxWindow.m_boFlashStart and not g_RareBoxWindow.m_boSelBoxFlash and g_RareBoxWindow.m_boRareBoxShow then begin
    if g_RareBoxWindow.m_btItemIdx = (Sender as TDButton).tag then begin
      frmMain.SendClientMessage(CM_GETBOXITEM, 0, 0, 0, 0);
      //g_RareBoxWindow.m_boRareBoxShow := False;
      g_RareBoxWindow.m_boFlashStart := True;
      //g_RareBoxWindow.m_boActive := False;
      //g_RareBoxWindow.m_boKeyAvail := False;
      //PlaySound(s_norm_button_click);
    end;
  end;
end;

procedure TFrmDlg.DBRareItem1MouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  s: string;
begin
  if not g_RareBoxWindow.m_boRareBoxShow then Exit;
  with (Sender as TDButton) do begin
    s := g_RareBoxWindow.m_BoxItems[tag].sName + '\数量: ' + IntToStr(g_RareBoxWindow.m_BoxItems[tag].nNumber);
    if g_RareBoxWindow.m_btItemIdx = (Sender as TDButton).tag then begin
      if not g_RareBoxWindow.m_boSelBoxFlash then
        s := s + '\(双击获取)';
      DScreen.ShowHint(SurfaceX(Left + 40), SurfaceY(Top), s, clYellow, False);
    end else
      DScreen.ShowHint(SurfaceX(Left + 40), SurfaceY(Top), s, clYellow, False);
  end;
end;

procedure TFrmDlg.DWBoxBKGndMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
begin
  if not g_RareBoxWindow.m_boRareBoxShow then Exit;
  DScreen.ClearHint;
  if g_MouseItem.s.Name <> '' then
    g_MouseItem.s.Name := '';
end;

procedure TFrmDlg.OpenBuildAcusWin();
begin
  if DWBuildAcus.Visible then Exit;
  FrmDlg.CloseMDlg;
  if not DItemBag.Visible then
    DItemBag.Visible := True;
  if not DWBuildAcus.Visible then
    DWBuildAcus.Visible := True;

  DBBuildAcusHelpClick(DBBuildAcusHelp, 0, 0);
  g_BuildAcusesRate := 0;
  g_BuildAcusesProc := 0;
  g_BuildAcusesProcTick := GetTickCount;
  g_BuildAcusesStep := 0;
  g_BAFirstShape := -1;

  DItemBag.Left := 0;
  DItemBag.Top := 60;
  DWBuildAcus.Left := DItemBag.Left + DItemBag.Width + 10;
  DWBuildAcus.Top := 98;

  ArrangeItembag;

end;

procedure TFrmDlg.DWBuildAcusCloseClick(Sender: TObject; X, Y: Integer);
var
  i: Integer;
begin
  //if Building then exit;
  if (Sender <> nil) and (g_BuildAcusesStep = 1) then Exit;
  DWBuildAcus.Visible := False;
  DItemBag.Visible := False;
  for i := Low(g_BuildAcuses) to High(g_BuildAcuses) do begin
    if g_BuildAcuses[i].item.s.Name <> '' then begin
      AddItemBag(g_BuildAcuses[i].item);
      g_BuildAcuses[i].item.s.Name := '';
    end;
  end;
end;

procedure TFrmDlg.DWBuildAcusDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  i, n: Integer;
  Rate: Integer;
  rc: TIntRect;
  cr: TClientBuildAcus;
  d, dd: TCustomLockableTexture;
begin
  with Sender as TDWindow do begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);

    d := g_WMainImages.Images[750];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left + 11), SurfaceY(Top + 19), d.ClientRect, d, True);
    dsurface.BoldTextOut(SurfaceX(Left + 20), SurfaceY(Top + 123), clWhite, clBlack, '金针锻造师');
    case tag of
      0: begin
          d := g_WMainImages.Images[754];
          if d <> nil then
            dsurface.Draw(SurfaceX(Left + 94), SurfaceY(Top + 18), d.ClientRect, d, True);
        end;
      1: begin
          d := g_WMainImages.Images[755];
          if d <> nil then
            dsurface.Draw(SurfaceX(Left + 94), SurfaceY(Top + 18), d.ClientRect, d, True);
        end;
      2: begin
          if GetTickCount - g_BuildAcusesFrameTick > 100 then begin
            g_BuildAcusesFrameTick := GetTickCount;
            Inc(g_BuildAcusesFrame);
            if g_BuildAcusesFrame >= 30 then
              g_BuildAcusesFrame := 0;
          end;
          d := g_WMainImages.Images[1000 + g_BuildAcusesFrame];
          if d <> nil then
            dsurface.Draw(SurfaceX(Left + 95), SurfaceY(Top + 18), d.ClientRect, d, True);

          d := g_WMainImages.Images[753];
          if d <> nil then
            dsurface.Draw(SurfaceX(Left + 94), SurfaceY(Top + 18 + 168), d.ClientRect, d, True);

          d := g_WMainImages.Images[756];
          if d <> nil then
            dsurface.Draw(SurfaceX(Left + 94), SurfaceY(Top + 177), d.ClientRect, d, True);
          case g_BuildAcusesStep of
            0: begin
                ////////////////////////////
                d := g_WMainImages.Images[991]; //成功率
                if d <> nil then
                  //dsurface.Draw(SurfaceX(Left + 94 + 30), SurfaceY(Top + 130), d.ClientRect, d, True);
                  dsurface.DrawBlend( SurfaceX(Left + 94 + 30), SurfaceY(Top + 130), d, 1);
                d := g_WMainImages.Images[990]; //%
                if d <> nil then
                  //dsurface.Draw(SurfaceX(Left + 94 + 200), SurfaceY(Top + 132), d.ClientRect, d, True);
                  dsurface.DrawBlend( SurfaceX(Left + 94 + 200), SurfaceY(Top + 132), d, 1);

                Rate := g_BuildAcusesRate div 100;
                if Rate > 0 then begin
                  d := g_WMainImages.Images[Rate + 970];
                  if d <> nil then
                    //dsurface.Draw(SurfaceX(Left + 94 + 200 - 20 * 3), SurfaceY(Top + 132), d.ClientRect, d, True);
                    dsurface.DrawBlend( SurfaceX(Left + 94 + 200 - 20 * 3), SurfaceY(Top + 132), d, 1);
                  d := g_WMainImages.Images[970];
                  if d <> nil then begin
                    //dsurface.Draw(SurfaceX(Left + 94 + 200 - 20 * 2), SurfaceY(Top + 132), d.ClientRect, d, True);
                    //dsurface.Draw(SurfaceX(Left + 94 + 200 - 20 * 1), SurfaceY(Top + 132), d.ClientRect, d, True);
                    dsurface.DrawBlend( SurfaceX(Left + 94 + 200 - 20 * 2), SurfaceY(Top + 132), d, 1);
                    dsurface.DrawBlend( SurfaceX(Left + 94 + 200 - 20 * 1), SurfaceY(Top + 132), d, 1);
                  end;
                end else begin
                  Rate := g_BuildAcusesRate div 10;
                  if Rate > 0 then begin
                    d := g_WMainImages.Images[Rate + 970];
                    if d <> nil then
                      //dsurface.Draw(SurfaceX(Left + 94 + 200 - 20 * 2), SurfaceY(Top + 132), d.ClientRect, d, True);
                      dsurface.DrawBlend( SurfaceX(Left + 94 + 200 - 20 * 2), SurfaceY(Top + 132), d, 1);
                    d := g_WMainImages.Images[970 + (g_BuildAcusesRate mod 10)];
                    if d <> nil then begin
                      //dsurface.Draw(SurfaceX(Left + 94 + 200 - 20 * 1), SurfaceY(Top + 132), d.ClientRect, d, True);
                      dsurface.DrawBlend( SurfaceX(Left + 94 + 200 - 20 * 1), SurfaceY(Top + 132), d, 1);
                    end;
                  end else begin
                    d := g_WMainImages.Images[970 + g_BuildAcusesRate];
                    if d <> nil then begin
                      //dsurface.Draw(SurfaceX(Left + 94 + 200 - 20 * 1), SurfaceY(Top + 132), d.ClientRect, d, True);
                      dsurface.DrawBlend( SurfaceX(Left + 94 + 200 - 20 * 1), SurfaceY(Top + 132), d, 1);
                    end;
                  end;
                end;

                d := g_WMainImages.Images[759];
                if d <> nil then begin
                  rc := d.ClientRect;
                  if g_BuildAcusesRate > 0 then begin
                    rc.Right := Round((rc.Right - rc.Left) / 100 * g_BuildAcusesRate);
                    dsurface.Draw(SurfaceX(Left + 94), SurfaceY(Top + 177), rc, d, True);
                  end;
                end;

                if g_BAFirstShape in [10..14] then begin
                  d := g_WMainImages.Images[760 + g_BAFirstShape - 10];
                  if d <> nil then begin
                    n := 0;
                    for i := 0 to 4 do begin
                      if g_BuildAcuses[i].item.s.Name <> '' then begin
                        dsurface.Draw(SurfaceX(Left + 34 + n * 50), SurfaceY(Top - 33), d.ClientRect, d, True);
                        Inc(n);
                      end;
                    end;
                  end;
                end;
              end;
            1: begin
                ////////////////////////////
                d := g_WMainImages.Images[991]; //成功率
                if d <> nil then
                  //dsurface.Draw(SurfaceX(Left + 94 + 30), SurfaceY(Top + 130), d.ClientRect, d, True);
                  dsurface.DrawBlend(SurfaceX(Left + 94 + 30), SurfaceY(Top + 130), d, 1);
                d := g_WMainImages.Images[990]; //%
                if d <> nil then
                  //dsurface.Draw(SurfaceX(Left + 94 + 200), SurfaceY(Top + 132), d.ClientRect, d, True);
                  dsurface.DrawBlend(SurfaceX(Left + 94 + 200), SurfaceY(Top + 132), d, 1);

                Rate := g_BuildAcusesRate div 100;
                if Rate > 0 then begin
                  d := g_WMainImages.Images[Rate + 970];
                  if d <> nil then
                    //dsurface.Draw(SurfaceX(Left + 94 + 200 - 20 * 3), SurfaceY(Top + 132), d.ClientRect, d, True);
                    dsurface.DrawBlend(SurfaceX(Left + 94 + 200 - 20 * 3), SurfaceY(Top + 132), d, 1);
                  d := g_WMainImages.Images[970];
                  if d <> nil then begin
                    //dsurface.Draw(SurfaceX(Left + 94 + 200 - 20 * 2), SurfaceY(Top + 132), d.ClientRect, d, True);
                    //dsurface.Draw(SurfaceX(Left + 94 + 200 - 20 * 1), SurfaceY(Top + 132), d.ClientRect, d, True);
                    dsurface.DrawBlend(SurfaceX(Left + 94 + 200 - 20 * 2), SurfaceY(Top + 132), d, 1);
                    dsurface.DrawBlend(SurfaceX(Left + 94 + 200 - 20 * 1), SurfaceY(Top + 132), d, 1);
                  end;
                end else begin
                  Rate := g_BuildAcusesRate div 10;
                  if Rate > 0 then begin
                    d := g_WMainImages.Images[Rate + 970];
                    if d <> nil then
                      //dsurface.Draw(SurfaceX(Left + 94 + 200 - 20 * 2), SurfaceY(Top + 132), d.ClientRect, d, True);
                      dsurface.DrawBlend(SurfaceX(Left + 94 + 200 - 20 * 2), SurfaceY(Top + 132), d, 1);
                    d := g_WMainImages.Images[970 + (g_BuildAcusesRate mod 10)];
                    if d <> nil then begin
                      //dsurface.Draw(SurfaceX(Left + 94 + 200 - 20 * 1), SurfaceY(Top + 132), d.ClientRect, d, True);
                      dsurface.DrawBlend(SurfaceX(Left + 94 + 200 - 20 * 1), SurfaceY(Top + 132), d, 1);
                    end;
                  end else begin
                    d := g_WMainImages.Images[970 + g_BuildAcusesRate];
                    if d <> nil then begin
                      //dsurface.Draw(SurfaceX(Left + 94 + 200 - 20 * 1), SurfaceY(Top + 132), d.ClientRect, d, True);
                      dsurface.DrawBlend(SurfaceX(Left + 94 + 200 - 20 * 1), SurfaceY(Top + 132), d, 1);
                    end;
                  end;
                end;

                if g_BuildAcusesProc < 100 then begin
                  if GetTickCount - g_BuildAcusesProcTick > 6 then begin
                    g_BuildAcusesProcTick := GetTickCount;
                    Inc(g_BuildAcusesProc);
                    if g_BuildAcusesProc >= 100 then begin
                      FillChar(cr, SizeOf(cr), 0);
                      for i := 0 to 7 do begin
                        if g_BuildAcuses[i].item.s.Name <> '' then begin
                          cr[i].nMakeIndex := g_BuildAcuses[i].item.MakeIndex;
                          cr[i].sItemName := g_BuildAcuses[i].item.s.Name;
                        end;
                      end;
                      frmMain.SendBuildAcus(cr);
                      //g_BuildAcusesStep := 2;
                    end;
                  end;
                end;
                d := g_WMainImages.Images[757];
                if d <> nil then begin
                  rc := d.ClientRect;
                  if g_BuildAcusesProc > 0 then begin
                    rc.Right := Round((rc.Right - rc.Left) / 100 * g_BuildAcusesProc);
                    dsurface.Draw(SurfaceX(Left + 94), SurfaceY(Top + 177), rc, d, True);
                  end;
                end;

                if g_BAFirstShape in [10..14] then begin
                  d := g_WMainImages.Images[760 + g_BAFirstShape - 10];
                  if d <> nil then begin
                    n := 0;
                    for i := 0 to 4 do begin
                      if g_BuildAcuses[i].item.s.Name <> '' then begin
                        dsurface.Draw(SurfaceX(Left + 34 + n * 50), SurfaceY(Top - 33), d.ClientRect, d, True);
                        dd := g_WMainImages.Images[1030 + (g_BuildAcusesProc div 3 mod 8)];
                        dsurface.DrawBlend(SurfaceX(Left + 34 + n * 50), SurfaceY(Top - 33), dd, 1);
                        Inc(n);
                      end;
                    end;
                  end;
                end;

              end;
            2: begin
                if g_BuildAcusesProc < 7 then begin
                  if GetTickCount - g_BuildAcusesProcTick > 120 then begin
                    g_BuildAcusesProcTick := GetTickCount;
                    Inc(g_BuildAcusesProc);
                  end;
                end;
                if g_BuildAcusesProc in [0..3] then begin
                  d := g_WMainImages.Images[1040 + g_BuildAcusesProc];
                  if d <> nil then
                    dsurface.DrawBlend(SurfaceX(Left + 95), SurfaceY(Top + 18), d, 1);
                end else if g_BuildAcusesProc in [4..7] then begin
                  d := g_WMainImages.Images[1070 + g_BuildAcusesProc - 4];
                  if d <> nil then
                    dsurface.DrawBlend(SurfaceX(Left + 95), SurfaceY(Top + 18), d, 1);
                end;
                if g_BuildAcusesProc >= 4 then begin
                  if g_BuildAcusesSuc in [0..4] then begin
                    d := g_WMainImages.Images[761 + g_BuildAcusesSuc];
                    if d <> nil then
                      dsurface.Draw(SurfaceX(Left + 34 + 2 * 50), SurfaceY(Top - 33), d.ClientRect, d, True);
                  end;
                  if g_BuildAcusesSucFrame > 13 then g_BuildAcusesSucFrame := 0;
                  if GetTickCount - g_BuildAcusesSucFrameTick > 100 then begin
                    g_BuildAcusesSucFrameTick := GetTickCount;
                    Inc(g_BuildAcusesSucFrame);
                    if g_BuildAcusesSucFrame >= 13 then
                      g_BuildAcusesSucFrame := 0;
                  end;
                  d := g_WMainImages.Images[1050 + g_BuildAcusesSucFrame];
                  if d <> nil then
                    dsurface.DrawBlend(SurfaceX(Left + 95), SurfaceY(Top + 18), d, 1);
                end;

                d := g_WMainImages.Images[757];
                if d <> nil then begin
                  dsurface.Draw(SurfaceX(Left + 94), SurfaceY(Top + 177), d.ClientRect, d, True);
                end;
              end;
            3: begin
                if g_BuildAcusesProc < 7 then begin
                  if GetTickCount - g_BuildAcusesProcTick > 120 then begin
                    g_BuildAcusesProcTick := GetTickCount;
                    Inc(g_BuildAcusesProc);
                  end;
                end;
                if g_BuildAcusesProc in [0..3] then begin
                  d := g_WMainImages.Images[1080 + g_BuildAcusesProc];
                  if d <> nil then
                    dsurface.DrawBlend(SurfaceX(Left + 95), SurfaceY(Top + 18), d, 1);
                end else if g_BuildAcusesProc in [4..7] then begin
                  d := g_WMainImages.Images[1100 + g_BuildAcusesProc - 4];
                  if d <> nil then
                    dsurface.DrawBlend(SurfaceX(Left + 95), SurfaceY(Top + 18), d, 1);
                end;

                d := g_WMainImages.Images[757];
                if d <> nil then begin
                  dsurface.Draw(SurfaceX(Left + 94), SurfaceY(Top + 177), d.ClientRect, d, True);
                end;
              end;
          end; //case

        end;
    end;
  end;
end;

procedure TFrmDlg.DWChatRecordListDirectPaint(Sender: TObject; dsurface: TCustomCanvas);

  function sX(X: Integer): Integer;
  begin
    Result := (Sender as TDWindow).SurfaceX((Sender as TDWindow).Left + X);
  end;

  function sY(Y: Integer): Integer;
  begin
    Result := (Sender as TDWindow).SurfaceY((Sender as TDWindow).Top + Y);
  end;
var
  i, ii, n, nn, Color: Integer;
  d: TCustomLockableTexture;
  clRect, clBoundsRect: TIntRect;
begin
  with Sender as TDWindow do begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);

    d := g_WMain2Images.Images[574];
    if d <> nil then begin
      clRect := d.ClientRect;
      clRect.Bottom := 200;
      dsurface.Draw(SurfaceX(Left + 365), SurfaceY(Top + 42), clRect, d, True);
    end;

    clBoundsRect := IntRect(SurfaceX(Left + 17), SurfaceY(Top + 39),
      SurfaceX(Left + 362), SurfaceY(Top + 240));
//    frmMain.DDClipper.SetClipRects([clBoundsRect]);
//    dsurface.Clipper := frmMain.DDClipper;
    try
      n := 0;
      nn := 0;
      ii := 0;
      for i := m_nChatRecordListTop to m_nChatRecordListTop + 15 - 1 do begin
        if i > m_xChatRecordList.Count - 1 then
          Break;
        if i = m_nChatRecordListCurIdx then begin
          Color := clRed;
        end else if ii = m_nChatRecordListMouseIdx then
          Color := clWhite
        else
          Color := $C0C0C0;

        dsurface.BoldTextOut( sX(020 - m_nChatRecordListRightClip), sY(45 + (ii) * 13), Color, clBlack, m_xChatRecordList[i]);

        n := FontManager.Default.TextWidth(m_xChatRecordList[i]);
        if n > nn then
          nn := n;
        Inc(ii);
      end;
      if nn > Height then
        m_nChatRecordListRightClipMax := nn
      else
        m_nChatRecordListRightClipMax := 0;
    finally
//      dsurface.Clipper := nil;
    end;
  end;
end;

procedure TFrmDlg.DWChatRecordListMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
const
  ClipRect: TRect = (Left: 17; Top: 45; Right: 362; Bottom: 240);
var
  lx, ly, idx: Integer;
begin
  if g_MouseItem.s.Name <> '' then
    g_MouseItem.s.Name := '';
  DScreen.ClearHint;

  with TDWindow(Sender) do begin
    lx := LocalX(X) - Left;
    ly := LocalY(Y) - Top;
    if (lx >= ClipRect.Left) and
      (lx < ClipRect.Right) and
      (ly >= ClipRect.Top) and
      (ly < ClipRect.Bottom + 15 * 3) then begin
      idx := (ly - ClipRect.Top) div 15;
      if (m_nChatRecordListMouseIdx <> idx) then begin
        m_nChatRecordListMouseIdx := idx;
      end;
    end else
      m_nChatRecordListMouseIdx := -1;
  end;
end;

procedure TFrmDlg.DWChatRecordListMouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
const
  ClipRect: TRect = (Left: 17; Top: 45; Right: 362; Bottom: 240);
var
  lx, ly, idx: Integer;
  szLine, szTime, szChatStr: string;
begin
  with TDWindow(Sender) do begin
    lx := LocalX(X) - Left;
    ly := LocalY(Y) - Top;
    if (lx >= ClipRect.Left) and
      (lx < ClipRect.Right) and
      (ly >= ClipRect.Top) and
      (ly < ClipRect.Bottom + 15 * 3) then begin
      m_nChatRecordListCurIdx := (ly - ClipRect.Top) div 15 + m_nChatRecordListTop;
      if (m_nChatRecordListCurIdx < 0) or (m_nChatRecordListCurIdx >= m_xChatRecordList.Count) then
        Exit;
      g_SndMgr.PlaySound(s_glass_button_click);
      szLine := m_xChatRecordList[m_nChatRecordListCurIdx];
      szLine := GetValidStr3(szLine, szTime, [' ']);
      szLine := GetValidStr3(szLine, szChatStr, [' ']);
      if szChatStr <> '' then begin
        DEdChat.Visible := True;
        SetDFocus(DEdChat);
        if ssCtrl in Shift then
          DEdChat.Text := szChatStr
        else
          DEdChat.Text := '/' + ExtractUserName(szChatStr) + ' ';

        DEdChat.ChangeCurPos(AnsiTextLength(DEdChat.Text), True);
        DEdChat.SelLength := 0;
      end;
    end;
  end;
end;

procedure TFrmDlg.DWCollectExpDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
begin
  with DWCollectExp do begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
  end;
end;

procedure TFrmDlg.DWCollectExpMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
begin
  DScreen.ClearHint;
end;

procedure TFrmDlg.DSServer1DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
  tStr: string;
  Color: TColor;
  oSize, nStatus: Integer;
begin
  try
    nStatus := -1;
    with Sender as TDButton do begin
      if not Downed then
        d := WLib.Images[FaceIndex]
      else
        d := WLib.Images[FaceIndex + 1];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);

      tStr := '';
      if (Name = 'DSServer1') and (g_ServerList.Count >= 1) then begin
        tStr := g_ServerList.Strings[0];
        nStatus := Integer(g_ServerList.Objects[0]);
      end;
      if (Name = 'DSServer2') and (g_ServerList.Count >= 2) then begin
        tStr := g_ServerList.Strings[1];
        nStatus := Integer(g_ServerList.Objects[1]);
      end;
      if (Name = 'DSServer3') and (g_ServerList.Count >= 3) then begin
        tStr := g_ServerList.Strings[2];
        nStatus := Integer(g_ServerList.Objects[2]);
      end;
      if (Name = 'DSServer4') and (g_ServerList.Count >= 4) then begin
        tStr := g_ServerList.Strings[3];
        nStatus := Integer(g_ServerList.Objects[3]);
      end;
      if (Name = 'DSServer5') and (g_ServerList.Count >= 5) then begin
        tStr := g_ServerList.Strings[4];
        nStatus := Integer(g_ServerList.Objects[4]);
      end;
      if (Name = 'DSServer6') and (g_ServerList.Count >= 6) then begin
        tStr := g_ServerList.Strings[5];
        nStatus := Integer(g_ServerList.Objects[5]);
      end;
      if tStr = '' then
        Exit;
      if tStr <> '' then
      begin
        Color := $0093F4F2;
        D := FontManager.GetFont('宋体', 12, [fsBold]).TextOut(tStr);
        if D <> nil then
        begin
          if TDButton(Sender).Downed then
            dsurface.DrawBoldText(SurfaceX(Left + (WIDTH - D.WIDTH) div 2) + 2,
              SurfaceY(Top + (Height - D.Height) div 2) + 2, D, Color, $08080808)
          else
            dsurface.DrawBoldText(SurfaceX(Left + (WIDTH - D.WIDTH) div 2),
              SurfaceY(Top + (Height - D.Height) div 2), D, Color, $08080808);
        end;
      end;
    end;
  except
    on E: Exception do begin
      DebugOutStr(E.Message);
    end;
  end;
end;

procedure TFrmDlg.DItemMarketDlgDirectPaint(Sender: TObject;
  dsurface: TCustomCanvas);
var
  idx: Integer;

  function sX(X: Integer): Integer;
  begin
    Result := DItemMarketDlg.SurfaceX(DItemMarketDlg.Left + X);
  end;

  function sY(Y: Integer): Integer;
  begin
    Result := DItemMarketDlg.SurfaceY(DItemMarketDlg.Top + Y);
  end;
var
  i, L, lh, k, M, n, MenuLine, itemidx, FontColor: Integer;
  d, TempSurface: TCustomLockableTexture;
  pg: PTMarketITem;
  year, mon, day, hour, Min, datestr: string;
  targdate: TDateTime;
  d0, d1, d2, d3, d4, pagestr: string;
  useable: Boolean;
  MouseItemTemp: TClientItem;
begin
  i := 0;
  pg := nil;
  DScreen.ClearHint;
  with dsurface do begin
    with DItemMarketDlg do begin
      d := DItemMarketDlg.WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
      //DEditItemFind.Left := SurfaceX(Left + 15);
      //DEditItemFind.Top := SurfaceY(Top + 331);
    end;

    Font.Color := clWhite;
    lh := MAKETLINEHEIGHT;
    MenuLine := _MIN(MAXMENU, g_Market.Count - MenuTop);

    if g_Market.GetUserMode = 1 then begin
      TextOut(sX(204 - 20), sY(37 - 21), '寄售物品列表');
      DMarketMemo.Visible := True;
    end else if g_Market.GetUserMode = 2 then begin
      TextOut(sX(204 - 20), sY(37 - 21), '我的寄售物品');
      DMarketMemo.Visible := False;
    end;

    TextOut(sX(379 - 5), sY(37 - 21), Format('%4d', [(MenuTop + 10) div 10]));
    if g_Market.RecvMaxPage < 1 then
      TextOut(sX(409 - 5), sY(37 - 21), '/ ' + '1')
    else
      TextOut(sX(409 - 5), sY(37 - 21), '/ ' + IntToStr(g_Market.RecvMaxPage));

    TextOut(sX(60), sY(71 - 25), '物品');
    TextOut(sX(230 - 5), sY(71 - 25), '价格');
    if g_Market.GetUserMode = 2 then
      TextOut(sX(382 - 5), sY(71 - 25), '状态')
    else
      TextOut(sX(382 - 5), sY(71 - 25), '卖家');

    for i := MenuTop to MenuTop + MenuLine - 1 do begin
      M := i - MenuTop;
      pg := g_Market.GetItem(i);
      if i = menuindex then begin
        FontColor := clRed;
        TextOut(sX(53 - 10), sY(97 + M * lh - 30), Char(7), FontColor);
        MemoCharID := pg.SellWho;
      end else if pg.SellState = 2 then
        FontColor := clYellow
      else if pg.UpgCount > 0 then
        FontColor := clAqua
      else
        FontColor := clWhite;

      if pg <> nil then begin
        TextOut(sX(40), sY(97 + MAKETLINEHEIGHT * M - 28), pg.item.s.Name, FontColor);
        TextOut(sX(170), sY(97 + MAKETLINEHEIGHT * M - 28), Format('%15s', [GetGoldStr(pg.SellPrice)]), FontColor);
        if g_Market.GetUserMode = 2 then begin //query self item
          if pg.SellState = 1 then
            TextOut(sX(365), sY(97 + MAKETLINEHEIGHT * M - 28), '正在寄售', FontColor)
          else if pg.SellState = 2 then
            TextOut(sX(365), sY(97 + MAKETLINEHEIGHT * M - 28), '已经出售', FontColor);
        end else begin
          if pg.SellState = 1 then
            TextOut(sX(365), sY(97 + MAKETLINEHEIGHT * M - 28), pg.SellWho, FontColor)
          else if pg.SellState = 2 then
            TextOut(sX(350), sY(97 + MAKETLINEHEIGHT * M - 28), pg.SellWho + '(已出售)', FontColor);
        end;
      end;
    end;
    FontColor := clWhite;
    if (menuindex >= 0) and (menuindex < g_Market.Count) then begin
      pg := g_Market.GetItem(menuindex);
      year := Copy(pg.Selldate, 1, 2);
      mon := Copy(pg.Selldate, 3, 2);
      day := Copy(pg.Selldate, 5, 2);
      hour := Copy(pg.Selldate, 7, 2);
      Min := Copy(pg.Selldate, 9, 2);
      datestr := '20' + year + '-' + mon + '-' + day + ' ' + hour + ':' + Min;
      TextOut(sX(34), sY(304 - 28), '寄售日期: ' + datestr, FontColor);
      targdate := EncodeDate(StrToInt(year) + 2000, StrToInt(mon), StrToInt(day)) + EncodeTime(StrToInt(hour), StrToInt(Min), 0, 0);
      targdate := targdate + 100;
      TextOut(sX(34), sY(320 - 28), '寄售到期: ' + FormatDateTime('YYYY-MM-DD', targdate), FontColor);
    end;

    if (menuindex >= 0) and (menuindex < g_Market.Count) then begin
      MouseItemTemp := g_MouseItem;
      g_MouseItem := pg.item;
      if (g_MouseItem.s.Name <> '') then begin
        itemidx := GetItemWhere(g_MouseItem);
        if itemidx in [0..U_FASHION] then begin
          g_ShowSuite := 1;
          g_SuiteIdx := itemidx;
        end;
        GetMouseItemInfoHint(g_MouseItem, d0);
        g_MouseItem := MouseItemTemp;
        if d0 <> '' then begin

          DScreen.ShowHint(sX(280 - 10), sY(298 - 30), d0, clWhite, False, False, True, True);
        end;
      end;
      g_MouseItem.s.Name := '';
      {GetMouseItemInfo(g_MouseItem, d0, d1, d2, d3, d4, useable, False);
      g_MouseItem := MouseItemTemp;
      if d0 <> '' then begin
        n := TextWidth(d0, False);
        Font.Color := clYellow;
        TextOutA(sX(280 - 10), sY(298 - 30), d0);
        Font.Color := clWhite;
        TextOutA(sX(280 - 10) + n, sY(298 - 30), d1);
        TextOutA(sX(280 - 10), sY(298 + 14 * 1 - 30), d2);
        if not useable then Font.Color := clRed;
        TextOutA(sX(280 - 10), sY(299 + 14 * 2 - 30), d3);

        if d4 <> '' then begin
          L := 1;
          Font.Color := $FF00;
          while True do begin
            if d4 = '' then Break;
            d4 := GetValidStr3(d4, d0, ['\']);
            if d0 <> '' then TextOutA(sX(280 - 10), sY(299 + 14 * (2 + L) - 30), d0);
            Inc(L);
            if L > 2 then Break;
          end;
        end;

        //
      end;}
    end;
  end;

  if (menuindex >= 0) and (menuindex < g_Market.Count) then begin
    pg := g_Market.GetItem(menuindex);
    //TempSurface := g_WBagItemImages.Images[pg.item.s.looks];
    TempSurface := frmMain.GetWBagItemImg(pg.item.s.looks);
    if TempSurface <> nil then
      dsurface.Draw(sX(196 + 33) + (36 - TempSurface.Width) div 2,
        sY(303 - 35) + (32 - TempSurface.Height) div 2,
        TempSurface.ClientRect, TempSurface, True);
  end;

  //if (ItemSearchEdit.Left <> sX(39)) or (ItemSearchEdit.Top <> sY(355)) then begin
  //  ItemSearchEdit.Left := sX(39);
  //  ItemSearchEdit.Top := sY(355);
  //end;
end;

procedure TFrmDlg.DItemMarketDlgClick(Sender: TObject; X, Y: Integer);
var
  lx, ly, idx: Integer;
  pg: PTMarketITem;
begin
  pg := nil;
  lx := DItemMarketDlg.LocalX(X) - DItemMarketDlg.Left;
  ly := DItemMarketDlg.LocalY(Y) - DItemMarketDlg.Top;
  if (lx >= 6) and (lx <= 448) and (ly >= (92 - 28)) and (ly <= (282 - 28)) then begin
    idx := (ly - (97 - 28)) div MAKETLINEHEIGHT + MenuTop;
    if idx < g_Market.Count then begin
      g_SndMgr.PlaySound(s_glass_button_click);
      menuindex := idx;
    end;
  end;
  if (menuindex >= 0) and (menuindex < g_Market.Count) then begin
    pg := g_Market.GetItem(menuindex);
    if pg.SellState = 1 then
      MItemSellState := 1
    else if pg.SellState = 2 then
      MItemSellState := 2;
  end;
end;

procedure TFrmDlg.DItemMarketDlgMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
  if boInRect then begin
    DItemMarketDlg.SpotX := X;
    DItemMarketDlg.SpotY := Y;
  end;
end;

procedure TFrmDlg.DItemListPrevClick(Sender: TObject; X, Y: Integer);
begin
  menuindex := -1;
  if MenuTop > 0 then begin
    Dec(MenuTop, MAXMENU);
    if MenuTop < 0 then MenuTop := 0;
  end;
  menuindex := MenuTop;
  DItemMarketDlgClick(DItemMarketDlg, 0, 0);
end;

procedure TFrmDlg.DItemListNextClick(Sender: TObject; X, Y: Integer);
var
  MaxNum: Integer;
begin
  menuindex := -1;
  MaxNum := (g_Market.RecvMaxPage) * 10;
  if (MaxNum >= g_Market.Count) and (MaxNum >= (MenuTop + 19)) then begin
    Inc(MenuTop, MAXMENU);
    if g_Market.Count <= MenuTop then
      frmMain.SendGetMarketPageList(g_nCurMerchant, 1, '')
  end;
  menuindex := MenuTop;
  DItemMarketDlgClick(DItemMarketDlg, 0, 0);
end;

procedure TFrmDlg.DItemBuyClick(Sender: TObject; X, Y: Integer);
var
  pg: PTMarketITem;
  MsgResult: Integer;
begin
  if GetTickCount < LastestClickTime then begin
    DScreen.AddChatBoardString('一定时间内不能连使用.', clYellow, clRed);
    Exit;
  end;
  DScreen.ClearHint;
  if (menuindex >= 0) and (menuindex < g_Market.Count) then begin
    //DEditItemFind.Visible := False;
    pg := g_Market.GetItem(menuindex);
    if g_Myself.m_nGold < pg.SellPrice then begin
      MsgResult := DMessageDlg('[提示]: 你的金币不足.', [mbOk, mbCancel]);
      Exit;
    end;
    MsgResult := DMessageDlg('确认使用 ' + IntToStr(pg.SellPrice) + ' 金币购买' + pg.item.s.Name + '吗?', [mbOk, mbCancel]);

    if MsgResult = mrOk then begin
      frmMain.SendBuyMarket(g_nCurMerchant, pg.Index);
      DItemBag.Show;
    end else if MsgResult = mrCancel then begin
      //
    end;
  end;
end;

procedure TFrmDlg.DItemMarketCloseClick(Sender: TObject; X, Y: Integer);
begin
  g_Market.Clear;
  frmMain.SendMarketClose;

  //DEditItemFind.Visible := False;
  DItemMarketDlg.Visible := False;
  DItemMarketClose.Downed := False;

  //PlayScene.EdChat.SetFocus;
  //LocalLanguage := imSAlpha;
  //SetImeMode(PlayScene.EdChat.Handle, LocalLanguage);
  LastestClickTime := GetTickCount;

  MemoCharID := '';
end;

procedure TFrmDlg.DItemMarketDlgKeyDown(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin
  if Key = 27 then
    if DItemMarketDlg.Visible then CloseItemMarketDlg;

  if Key = 13 then
    DItemFindClick(DItemFind, 0, 0);

  DScreen.ClearHint;
  case Key of
    VK_UP: begin
        if (MenuTop <= (menuindex - 1)) and (menuindex <> -1) then begin
          Dec(menuindex, 1);
          DItemMarketDlgClick(DItemMarketDlg, 0, 0);
        end;
      end;
    VK_DOWN: begin
        if (MenuTop + MAXMENU > (menuindex + 1)) and (menuindex <> -1) and ((menuindex + 1) < g_Market.Count) then begin
          Inc(menuindex, 1);
          DItemMarketDlgClick(DItemMarketDlg, 0, 0);
        end;
      end;
    VK_LEFT: begin
        DItemListPrevClick(DItemListPrev, 0, 0);
      end;
    VK_RIGHT: begin
        DItemListNextClick(DItemListNext, 0, 0);
      end;
  else
  end;
end;

procedure TFrmDlg.DItemListRefreshClick(Sender: TObject; X, Y: Integer);
begin
  if GetTickCount < LastestClickTime then begin
    DScreen.AddChatBoardString('一定时间内不能连续刷新列表.', clYellow, clRed);
    Exit;
  end;
  DScreen.ClearHint;
  menuindex := -1;
  MenuTop := 0;
  MenuTopLine := 0;
  frmMain.SendGetMarketPageList(g_nCurMerchant, 0, '');
  LastestClickTime := GetTickCount + NPC_CILCK_INVTIME;
end;

procedure TFrmDlg.DItemCancelClick(Sender: TObject; X, Y: Integer);
begin
  DItemMarketCloseClick(Sender, 0, 0);
end;

procedure TFrmDlg.DItemFindClick(Sender: TObject; X, Y: Integer);
var
  findstr: string;
begin
  if GetTickCount < LastestClickTime then begin
    DScreen.AddChatBoardString('请稍候片刻使用...', clYellow, clRed);
    Exit;
  end;
  findstr := Trim(DEditItemFind.Caption);
  findstr := Copy(findstr, 1, 14);
  if findstr <> '' then
    frmMain.SendGetMarketPageList(g_nCurMerchant, 2, findstr);
  LastestClickTime := GetTickCount + NPC_CILCK_INVTIME;
end;

procedure TFrmDlg.DItemMarketDlgMouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  with DItemMarketDlg do
    if (X < SurfaceX(Left + 36)) or (X > SurfaceX(Left + 477)) or (Y < SurfaceY(Top + 92)) or (Y > SurfaceY(Top + 282)) then begin
      boInRect := False;
    end else begin
      boInRect := True;
    end;
  {if g_Market.GetUserMode = 1 then begin
    with DItemMarketDlg do
      if (X > SurfaceX(Left + 34)) and (X < SurfaceX(Left + 176)) and (Y > SurfaceY(Top + 354)) and (Y < SurfaceY(Top + 374)) then begin
        DItemMarketDlg.EnableFocus := True;
        DEditItemFind.Visible := True;
        DEditItemFind.SetFocus;
      end else
        ; //DEditItemFind.Visible := False;
  end;}
end;

procedure TFrmDlg.DItemSellCancelClick(Sender: TObject; X, Y: Integer);
var
  pg: PTMarketITem;
  MsgResult: Integer;
begin
  if GetTickCount < LastestClickTime then
    Exit;
  DScreen.ClearHint;
  if (menuindex >= 0) and (menuindex < g_Market.Count) then begin
    //DEditItemFind.Visible := False;
    pg := g_Market.GetItem(menuindex);
    if pg.SellState = 1 then begin
      MsgResult := DMessageDlg('确认取消物品 ' + pg.item.s.Name + ' 的寄售吗?', [mbOk, mbCancel]);
      if MsgResult = mrOk then begin
        frmMain.SendCancelMarket(g_nCurMerchant, pg.Index);
        DItemBag.Show;
      end;
    end else if pg.SellState = 2 then begin
      MsgResult := DMessageDlg('确认收取物品出售得到的金额吗?', [mbOk, mbCancel]);
      if MsgResult = mrOk then
        frmMain.SendGetPayMarket(g_nCurMerchant, pg.Index);
    end;
    MItemSellState := 0;
  end;
end;

procedure TFrmDlg.DWYBDealDlgDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
begin
  with Sender as TDButton do begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
  end;
end;

procedure TFrmDlg.DWYBDealDlgMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
begin
  DScreen.ClearHint;
  if g_MouseItem.s.Name <> '' then
    g_MouseItem.s.Name := '';
end;

procedure TFrmDlg.DGridYBDealGridMouseMove(Sender: TObject; X, Y, ACol, ARow: Integer; Shift: TShiftState);
var
  idx, itemidx: Integer;
  temp: TClientItem;
  shint: string;
  b1, b2, useable: Boolean;
  hcolor: TColor;
begin
  idx := ACol + ARow * DGridYBDeal.ColCount;
  if idx in [0..19] then begin
    g_MouseItem := g_YbDealItems[idx];
    if g_MovingItem.item.s.Name = '' then begin
      itemidx := GetItemWhere(g_MouseItem);
      if itemidx in [0..U_FASHION] then begin
        g_ShowSuite := 1;
        g_SuiteIdx := itemidx;
      end;
      GetMouseItemInfoHint(g_MouseItem, shint);
      if shint <> '' then begin
        with TDGrid(Sender) do begin
          DScreen.ShowHint(
            SurfaceX(Left + (ACol) * 36),
            SurfaceY(Top + (ARow + 1) * 34),
            shint,
            clWhite, False, False, True, True);
        end;
      end;
      g_MouseItem.s.Name := '';
    end;
  end;
end;

procedure TFrmDlg.DGridYBDealGridPaint(Sender: TObject; ACol, ARow: Integer; Rect: TRect; State: TGridDrawState; dsurface: TCustomCanvas);
var
  idx: Integer;
  d: TCustomLockableTexture;
begin
  idx := ACol + ARow * DGridYBDeal.ColCount;
  if idx in [0..9] then begin
    if idx = 9 then begin
      with dsurface do begin
        with DGridYBDeal do begin
          TextOut(SurfaceX(Left + 36 * 4), SurfaceY(Top + 35), IntToStr(g_YbDealItems[idx].MakeIndex), clWhite);
          TextOut(SurfaceX(Left + 36 * 4), SurfaceY(Top + 35 + 13), '金刚石', clWhite);
        end;
      end;
    end else begin
      if g_YbDealItems[idx].s.Name <> '' then begin
        //d := g_WBagItemImages.Images[g_YbDealItems[idx].s.looks];
        d := frmMain.GetWBagItemImg(g_YbDealItems[idx].s.looks);
        if d <> nil then
          with DGridYBDeal do
            dsurface.Draw(SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
              SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
              d.ClientRect,
              d, True);
      end;
    end;
  end;
end;

procedure TFrmDlg.DGridYBDealGridSelect(Sender: TObject; X, Y, ACol, ARow: Integer; Shift: TShiftState);
var
  b: Boolean;
  temp: TClientItem;
  mi, idx, nc: Integer;
  valstr: string;
begin
  b := False;
  if not g_boItemMoving then begin
    idx := ACol + ARow * DGridYBDeal.ColCount;
    if idx in [0..9] then begin
      if idx = 9 then begin
        DMessageDlg('请输入金刚石数量，在0-9999之间', [mbOk, mbAbort]);
        GetValidStrVal(DlgEditText, valstr, [' ']);
        try
          nc := Str_ToInt(valstr, 0);
        except
          DMessageDlg('输入数量有错误.', [mbOk]);
          Exit;
        end;
        if (nc >= 0) and (nc <= 9999) then begin
          g_YbDealItems[idx].s.Name := '金刚石';
          g_YbDealItems[idx].MakeIndex := nc;
        end else begin
          g_YbDealItems[idx].s.Name := '';
          g_YbDealItems[idx].MakeIndex := 0;
          DMessageDlg('[失败]: 请输入合理金刚石数量，在0-9999之间', [mbOk]);
        end;
      end else if g_YbDealItems[idx].s.Name <> '' then begin
        g_boItemMoving := True;
        g_MovingItem.Index := -idx - 30;
        g_MovingItem.item := g_YbDealItems[idx];
        g_YbDealItems[idx].s.Name := '';
        g_SndMgr.ItemClickSound(g_MovingItem.item.s);
      end;
    end;
  end else begin
    mi := g_MovingItem.Index;
    if (mi in [0..MAXBAGITEM - 1]) or (mi <= -30) and (mi > -40 - 1) then begin
      g_SndMgr.ItemClickSound(g_MovingItem.item.s);
      g_boItemMoving := False;
      if g_MovingItem.item.s.Name <> '' then
        AddYbDealItem(g_MovingItem.item);
      g_MovingItem.item.s.Name := '';
      ArrangeItembag;
    end;
  end;
end;

procedure TFrmDlg.QueryYbSell();
begin
  if DWYBDealDlg.Visible or g_boYbDealing then Exit;
  g_boYbDealing := True;
  FillChar(g_YbDealItems, SizeOf(g_YbDealItems), #0);
  DWYBDealDlg.Visible := True;
end;

procedure TFrmDlg.DBYBDealDlgCloseClick(Sender: TObject; X, Y: Integer);
begin
  DBYBDealCalcelClick(Sender, 0, 0);
end;

procedure TFrmDlg.DBYBDealOKClick(Sender: TObject; X, Y: Integer);
var
  s: string;
  i, n, nc: Integer;
  psi: TCPostSell;
  DefMsg: TDefaultMessage;
begin
  if not g_boYbDealing then Exit;
  nc := 0;
  for i := Low(g_YbDealItems) to High(g_YbDealItems) - 1 do
    if g_YbDealItems[i].s.Name <> '' then
      Inc(nc);
  if nc <= 0 then begin
    FrmDlg.DMessageDlg('[失败]：交易物品不能为空！', [mbOk]);
    Exit;
  end;
  s := DEYBDealCharName.Caption;
  DEYBDealCharName.Caption := '';
  if (s = '') or (Length(s) <= 2) or (Length(s) > 14) then begin
    FrmDlg.DMessageDlg('[失败]：对方角色名不正确！', [mbOk]);
    Exit;
  end;
  if CompareText(s, frmMain.m_sCharName) = 0 then begin
    FrmDlg.DMessageDlg('[失败]：角色名不能是自己', [mbOk]);
    Exit;
  end;
  n := StrToInt(DEYBDealCount.Caption);
  DEYBDealCount.Caption := '';
  if (n <= 0) or (n > 9999) then begin
    FrmDlg.DMessageDlg('[失败]：请输入合理的元宝数量，在0~9999之间！', [mbOk]);
    Exit;
  end;
  /////////////////////////////////////////////

  FillChar(psi, SizeOf(psi), #0);
  psi[0].sStr := s;
  psi[0].nInt := n;
  for i := 1 to nc do begin
    psi[i].sStr := g_YbDealItems[i - 1].s.Name;
    psi[i].nInt := g_YbDealItems[i - 1].MakeIndex;
  end;
  if (g_YbDealItems[9].s.Name = '金刚石') and (g_YbDealItems[9].MakeIndex > 0) and (g_YbDealItems[9].MakeIndex <= 9999) then begin
    Inc(nc);
    psi[nc].sStr := g_YbDealItems[9].s.Name;
    psi[nc].nInt := g_YbDealItems[9].MakeIndex;
  end;
  Inc(nc);
  DefMsg := MakeDefaultMsg(CM_POSTSELL, g_nCurMerchant, 0, nc, 0);
  frmMain.SendSocket(EncodeMessage(DefMsg) + EncodeBuffer(@psi, SizeOf(TPSInfo) * nc));
  DWYBDealDlg.Visible := False;

end;

procedure TFrmDlg.DBYBDealCalcelClick(Sender: TObject; X, Y: Integer);
begin
  YbDealItemReturnBag();
  DWYBDealDlg.Visible := False;
  g_boYbDealing := False;
end;

procedure TFrmDlg.ServerSendYBSell(nCode, nCount: Integer; sMsg: string);
var
  n: Integer;
  st, s1, s2: string;
begin
  if (nCount <= 0) or DWYbDealItems.Visible then Exit;
  FillChar(g_YbDealInfo, SizeOf(g_YbDealInfo), #0);
  if nCode > 9999 then begin
    g_YbDealInfo.nPostPrice := nCode;
    g_YbDealInfo.sPostState := '过期'
  end else begin
    g_YbDealInfo.nPostPrice := nCode;
    g_YbDealInfo.sPostState := '正常';
  end;
  s2 := GetValidStr3(sMsg, s1, ['/']);
  s1 := DecodeString(s1);

  s1 := GetValidStr3(s1, st, ['/']);
  g_YbDealInfo.sCharName := st;
  s1 := GetValidStr3(s1, st, ['/']);
  g_YbDealInfo.sTargName := st;
  g_YbDealInfo.sPostTime := s1;

  n := 0;
  while s2 <> '' do begin
    s2 := GetValidStr3(s2, st, ['/']);
    if st <> '' then begin
      DecodeBuffer(st, @g_YbDealInfo.aPostItems[n], SizeOf(TClientItem));
      Inc(n);
      if n > nCount then Break;
    end else
      Break;
  end;
  if n > 0 then begin
    m_YbItemIndex := -1;
    DBYbBuyItems.Visible := False;
    DBYbBuyCancel.Visible := False;
    DBYbCalcelSell.Visible := True;
    DWYbDealItems.Visible := True;

  end;
end;

procedure TFrmDlg.ServerSendYBDeal(nCode, nCount: Integer; sMsg: string);
var
  n: Integer;
  st, s1, s2: string;
begin
  if (nCount <= 0) or DWYbDealItems.Visible then Exit;
  FillChar(g_YbDealInfo, SizeOf(g_YbDealInfo), #0);
  if nCode > 9999 then begin
    g_YbDealInfo.nPostPrice := nCode;
    g_YbDealInfo.sPostState := '过期'
  end else begin
    g_YbDealInfo.nPostPrice := nCode;
    g_YbDealInfo.sPostState := '正常';
  end;
  s2 := GetValidStr3(sMsg, s1, ['/']);
  s1 := DecodeString(s1);

  s1 := GetValidStr3(s1, st, ['/']);
  g_YbDealInfo.sCharName := st;
  s1 := GetValidStr3(s1, st, ['/']);
  g_YbDealInfo.sTargName := st;
  g_YbDealInfo.sPostTime := s1;

  n := 0;
  while s2 <> '' do begin
    s2 := GetValidStr3(s2, st, ['/']);
    if st <> '' then begin
      DecodeBuffer(st, @g_YbDealInfo.aPostItems[n], SizeOf(TClientItem));
      Inc(n);
      if n > nCount then Break;
    end else
      Break;
  end;
  if n > 0 then begin
    m_YbItemIndex := -1;
    DBYbBuyItems.Visible := True;
    DBYbBuyCancel.Visible := True;
    DBYbCalcelSell.Visible := False;
    DWYbDealItems.Visible := True;

  end;
end;

procedure TFrmDlg.DWYbDealItemsDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  i, itemidx, FontColor: Integer;
  d: TCustomLockableTexture;
  MouseItemTemp: TClientItem;
  d0, d1, d2, d3, d4: string;
  useable: Boolean;
  hcolor: TColor;
begin
  with DWYbDealItems do begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    with dsurface do begin
      FontColor := clWhite;
      TextOut(SurfaceX(Left + 020), SurfaceY(Top + 12), '交易明细', FontColor);
      TextOut(SurfaceX(Left + 180), SurfaceY(Top + 12), '物品列表');

      TextOut(SurfaceX(Left + 020), SurfaceY(Top + 12 + 20 * 1), '卖方角色：', FontColor);
      FontColor := $FF00;
      TextOut(SurfaceX(Left + 020 + 60), SurfaceY(Top + 12 + 20 * 1), g_YbDealInfo.sCharName, FontColor);
      FontColor := clWhite;
      TextOut(SurfaceX(Left + 020), SurfaceY(Top + 12 + 20 * 2), '买方角色：', FontColor);
      FontColor := $FF00;
      TextOut(SurfaceX(Left + 020 + 60), SurfaceY(Top + 12 + 20 * 2), g_YbDealInfo.sTargName, FontColor);
      FontColor := clWhite;
      TextOut(SurfaceX(Left + 020), SurfaceY(Top + 12 + 20 * 3), '元宝数量：', FontColor);
      FontColor := clYellow;
      Font.Style := [fsBold];
      TextOut(SurfaceX(Left + 020 + 60), SurfaceY(Top + 12 + 20 * 3), IntToStr(g_YbDealInfo.nPostPrice), FontColor);
      Font.Style := [];
      FontColor := clWhite;
      TextOut(SurfaceX(Left + 020), SurfaceY(Top + 12 + 20 * 4), '提交日期：', FontColor);
      TextOut(SurfaceX(Left + 020 + 60), SurfaceY(Top + 12 + 20 * 4), g_YbDealInfo.sPostTime, FontColor);
      TextOut(SurfaceX(Left + 020), SurfaceY(Top + 12 + 20 * 5), '交易状态：', FontColor);
      TextOut(SurfaceX(Left + 020 + 60), SurfaceY(Top + 12 + 20 * 5), g_YbDealInfo.sPostState, FontColor);
      for i := Low(g_YbDealInfo.aPostItems) to High(g_YbDealInfo.aPostItems) do
        if g_YbDealInfo.aPostItems[i].s.Name <> '' then begin
          if m_YbItemIndex = i then
            FontColor := clRed
          else
            FontColor := clWhite;
          if (g_YbDealInfo.aPostItems[i].MakeIndex = 1) then
            TextOut(SurfaceX(Left + 180), SurfaceY(Top + 12 + 20 * (i + 1)), g_YbDealInfo.aPostItems[i].s.Name + ' ' + IntToStr(g_YbDealInfo.aPostItems[i].Dura), FontColor)
          else
            TextOut(SurfaceX(Left + 180), SurfaceY(Top + 12 + 20 * (i + 1)), g_YbDealInfo.aPostItems[i].s.Name, FontColor);
        end;
    end;
    if m_YbItemIndex in [0..9] then begin
      if (g_YbDealInfo.aPostItems[m_YbItemIndex].s.Name <> '') and ((g_YbDealInfo.aPostItems[m_YbItemIndex].MakeIndex <> 1)) then begin
        MouseItemTemp := g_MouseItem;
        g_MouseItem := g_YbDealInfo.aPostItems[m_YbItemIndex];
        itemidx := GetItemWhere(g_MouseItem);
        if itemidx in [0..U_FASHION] then begin
          g_ShowSuite := 1;
          g_SuiteIdx := itemidx;
        end;
        GetMouseItemInfoHint(g_MouseItem, d0);
        if d0 <> '' then
          DScreen.ShowHint(SurfaceX(Left + 270),
            SurfaceY(Top + 12 + 20 * (m_YbItemIndex + 1)),
            d0,
            clWhite,
            False,
            False,
            True);

        {MouseItemTemp := g_MouseItem;
        g_MouseItem := g_YbDealInfo.aPostItems[m_YbItemIndex];
        GetMouseItemInfo(g_MouseItem, d0, d1, d2, d3, d4, useable, False);
        if d0 <> '' then begin
          if g_MouseItem.Dura = 0 then
            hcolor := clRed
          else
            hcolor := clWhite;
          with Sender as TDButton do begin
            if d4 <> '' then
              d0 := d0 + d1 + '\' + d2 + '\' + d3 + '\' + d4
            else
              d0 := d0 + d1 + '\' + d2 + '\' + d3;
            DScreen.ShowHint(SurfaceX(Left + 270),
              SurfaceY(Top + 12 + 20 * (m_YbItemIndex + 1)),
              d0,
              hcolor,
              False);
          end;
        end;
        //g_MouseItem.S.Name := '';}
        g_MouseItem := MouseItemTemp;
      end else
        DScreen.ClearHint;
    end;
  end;
end;

procedure TFrmDlg.DBYbDealItemsCloseClick(Sender: TObject; X, Y: Integer);
begin
  DWYbDealItems.Visible := False;
end;

procedure TFrmDlg.DBYbCalcelSellClick(Sender: TObject; X, Y: Integer);
begin
  if DWYbDealItems.Visible then begin
    DWYbDealItems.Visible := False;
    frmMain.SendClientMessage(CM_CANCELYBSELL, g_nCurMerchant, 0, 0, 0);
  end;
end;

procedure TFrmDlg.DWYbDealItemsMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
  lx, ly, idx: Integer;
  iname, d1, d2, d3: string;
  useable: Boolean;
begin
  if not DWYbDealItems.Visible then Exit;
  if m_YbItemIndex <> -1 then m_YbItemIndex := -1;
  lx := DWYbDealItems.LocalX(X) - DWYbDealItems.Left;
  ly := DWYbDealItems.LocalY(Y) - DWYbDealItems.Top;
  if (lx >= 180) and (lx <= 280) and (ly >= 12 + 20) then begin
    idx := (ly - 32) div 20;
    if (idx < 10) and (m_YbItemIndex <> idx) then
      m_YbItemIndex := idx;
  end;
end;

procedure TFrmDlg.DBYbBuyItemsClick(Sender: TObject; X, Y: Integer);
begin
  if DWYbDealItems.Visible then begin
    DWYbDealItems.Visible := False;
    frmMain.SendClientMessage(CM_AFFIRMYBDEAL, g_nCurMerchant, 0, 0, 0);
  end;
end;

procedure TFrmDlg.DBYbBuyCancelClick(Sender: TObject; X, Y: Integer);
begin
  if DWYbDealItems.Visible then begin
    DWYbDealItems.Visible := False;
    frmMain.SendClientMessage(CM_CANCELYBDEAL, g_nCurMerchant, 0, 0, 0);
  end;
end;

procedure TFrmDlg.DBotGroupMouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
  if (mbRight = Button) then
    DGrpAllowGroupClick(Sender, 0, 0)
  else if (mbLeft = Button) then
    ToggleShowGroupDlg;
end;

procedure TFrmDlg.DWHeroStatusMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
  //
  if (g_Myself <> nil) and (g_Myself.m_HeroObject <> nil) then begin
    DScreen.ClearHint;
    DScreen.ShowHint(DWHeroStatus.Left + 177, 20,
      '体力值: ' + IntToStr(g_Myself.m_HeroObject.m_Abil.HP) + '/' + IntToStr(g_Myself.m_HeroObject.m_Abil.MaxHP) + '\' +
      '魔法值: ' + IntToStr(g_Myself.m_HeroObject.m_Abil.MP) + '/' + IntToStr(g_Myself.m_HeroObject.m_Abil.MaxMP) + '\' +
      '经验值: ' + IntToStr(Round((g_Myself.m_HeroObject.m_Abil.Exp / g_Myself.m_HeroObject.m_Abil.MaxExp) * 100)) + '%\' +
      '醉酒度: ' + '%0'
      , clWhite, False);
  end;
end;

procedure TFrmDlg.DWHeroStoreDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
begin
  //if g_Myself = nil then Exit;
  with DWHeroStore do begin
    //d := WLib.Images[FaceIndex];
    d := WLib.Images[FaceIndex];
    if d <> nil then dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);

  end;
end;

procedure TFrmDlg.DWHeroStoreMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
begin
  DScreen.ClearHint;
end;

procedure TFrmDlg.DWMissionsDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  i, ii, lx, ly, sX, j, k, L, n: Integer;
  List: TGList;
  d: TCustomLockableTexture;
  cl: TColor;
  scl: string;
  Str, data, FData, fdata2: string;
  cmdstr, cmdmsg, cmdparam: string;
  sTitle: string[128];
  pcp: pTClickPoint;
  pm: PTClientMission;
begin
  if g_Myself = nil then Exit;
  with Sender as TDWindow do begin

    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, False);

    lx := 27;
    ly := 71;
    List := m_MissionList[DWMissions.tag];

    List.Lock;
    try
      L := 0;
      for i := m_MissionIdxTitle to List.Count - 1 do begin
        pm := List[i];
        sTitle := pm.sTitle;
        sX := 0;
        if sTitle <> '' then begin
          if m_MissionRequireAddPoints then begin
            New(pcp);
            pcp.rc := Rect(lx + sX, ly, lx + sX + FontManager.Default.TextWidth(sTitle), ly + 14);
            pcp.rstr := '';
            pcp.sidx := pm.sIndex;
            m_MissionPoints.Add(pcp);
          end;
//          dsurface.Canvas.Font.Style := dsurface.Canvas.Font.Style + [fsUnderline];
          if m_MissionSelectIndexStr = pm.sIndex then
            dsurface.BoldTextOut(SurfaceX(Left + lx + sX), SurfaceY(Top + ly), clRed, clBlack, sTitle)
          else
            dsurface.BoldTextOut(SurfaceX(Left + lx + sX), SurfaceY(Top + ly), clYellow, clBlack, sTitle);
//          sX := sX + dsurface.Canvas.TextWidth(sTitle, False);
//          dsurface.Canvas.Font.Style := dsurface.Canvas.Font.Style - [fsUnderline];
        end;
        Inc(L);
        if L >= 7 then Break;
        ly := ly + 16;
      end;
    finally
      List.UnLock;
    end;

    List.Lock;
    try
      for i := 0 to List.Count - 1 do begin
        pm := List[i];
        if m_MissionSelectIndexStr = pm.sIndex then begin
          L := 0;
          n := 0;
          lx := 27;
          ly := 220;
          Str := pm.sDesc;
          while True do begin
            if Str = '' then Break;
            Str := GetValidStr3(Str, data, ['\']);
            if (data <> '') then begin
              Inc(L);
              if (L > m_MissionIdxDesc) then begin
                Inc(n);
                sX := 0;
                while (data <> '') and (Pos('<', data) > 0) and (Pos('>', data) > 0) do begin
                  FData := '';
                  if data[1] <> '<' then
                    data := '<' + GetValidStr3(data, FData, ['<']);
                  data := ArrestStringEx(data, '<', '>', cmdstr);

                  fdata2 := '';
                  if cmdstr <> '' then begin
                    j := Pos('COLOR=', UpperCase(cmdstr));
                    if j > 0 then begin
                      fdata2 := GetValidStr3(cmdstr, scl, [' ', #9, ',']);
                      scl := Copy(scl, 7, Length(scl) - 6);
                      cl := clWhite;
                      if scl <> '' then begin
                        if scl[1] = '#' then begin
                          cl := StrToInt(Copy(scl, 2, Length(scl) - 1));
                        end else begin
                          if CompareText('clLtGray', scl) = 0 then
                            cl := clLtGray
                          else if CompareText('clDkGray', scl) = 0 then
                            cl := clDkGray
                          else
                            cl := StringToColor(scl);
                        end;
                      end;
                      cmdstr := '';
                    end else
                      cmdparam := GetValidStr3(cmdstr, cmdstr, ['/']);
                  end;

                  if FData <> '' then begin
                    dsurface.BoldTextOut(SurfaceX(Left + lx + sX), SurfaceY(Top + ly), clWhite, clBlack, FData);
                    sX := sX + FontManager.Default.TextWidth(FData);
                  end;

                  if fdata2 <> '' then begin
                    dsurface.BoldTextOut(SurfaceX(Left + lx + sX), SurfaceY(Top + ly), cl, clBlack, fdata2);
                    sX := sX + FontManager.Default.TextWidth(fdata2);
                  end;

                  if cmdstr <> '' then begin
                    if m_MissionRequireAddPoints then begin
                      New(pcp);
                      pcp.rc := Rect(lx + sX, ly, lx + sX + FontManager.Default.TextWidth(cmdstr), ly + 14);
                      pcp.rstr := cmdparam;
                      m_MissionPoints.Add(pcp);
                    end;
//                    dsurface.Canvas.Font.Style := dsurface.Canvas.Font.Style + [fsUnderline];
                    if (m_MissionSelectMenuStr <> '') and (m_MissionSelectMenuStr = cmdparam) then
                      dsurface.BoldTextOut(SurfaceX(Left + lx + sX), SurfaceY(Top + ly), clRed, clBlack, cmdstr)
                    else
                      dsurface.BoldTextOut(SurfaceX(Left + lx + sX), SurfaceY(Top + ly), clYellow, clBlack, cmdstr);
                    sX := sX + FontManager.Default.TextWidth(cmdstr);
//                    dsurface.Canvas.Font.Style := dsurface.Canvas.Font.Style - [fsUnderline];
                  end;
                end;
                if data <> '' then
                  dsurface.BoldTextOut(SurfaceX(Left + lx + sX), SurfaceY(Top + ly), clWhite, clBlack, data);
                if n >= 8 then Break;
                ly := ly + 16;
              end;
            end;
            //if l >= 8 then Break;
            //ly := ly + 16;
          end;
          Break;
        end;
      end;
    finally
      List.UnLock;
    end;
    m_MissionRequireAddPoints := False;
  end;
end;

procedure TFrmDlg.DWMissionsClick(Sender: TObject; X, Y: Integer);
var
  i, ii, L, T: Integer;
  p: pTClickPoint;
begin
  if GetTickCount < LastestClickTime then Exit;
  L := DWMissions.Left;
  T := DWMissions.Top;
  with DWMissions do
    for i := 0 to m_MissionPoints.Count - 1 do begin
      p := pTClickPoint(m_MissionPoints[i]);
      if (X >= SurfaceX(L + p.rc.Left)) and (X <= SurfaceX(L + p.rc.Right)) and
        (Y >= SurfaceY(T + p.rc.Top)) and (Y <= SurfaceY(T + p.rc.Bottom)) then begin
        g_SndMgr.PlaySound(s_glass_button_click);
        if p.rstr <> '' then begin
          frmMain.SendMerchantDlgSelect(g_nCurMerchant, p.rstr);
        end else begin
          m_MissionSelectIndexStr := p.sidx;
          for ii := 0 to m_MissionPoints.Count - 1 do
            Dispose(pTClickPoint(m_MissionPoints[ii]));
          m_MissionPoints.Clear;
          m_MissionRequireAddPoints := True;
        end;
        LastestClickTime := GetTickCount + 500;
        Break;
      end;
    end;
end;

procedure TFrmDlg.DWMissionsMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
  i, L, T: Integer;
  p: pTClickPoint;
begin
  if GetTickCount < LastestClickTime then Exit;
  m_MissionSelectMenuStr := '';
  L := DWMissions.Left;
  T := DWMissions.Top;
  with DWMissions do
    for i := 0 to m_MissionPoints.Count - 1 do begin
      p := pTClickPoint(m_MissionPoints[i]);
      if (X >= SurfaceX(L + p.rc.Left)) and (X <= SurfaceX(L + p.rc.Right)) and (Y >= SurfaceY(T + p.rc.Top)) and (Y <= SurfaceY(T + p.rc.Bottom)) then begin
        if p.rstr <> '' then
          m_MissionSelectMenuStr := p.rstr
        else
          m_MissionSelectIndexStr := p.sidx;
        //LastestClickTime := GetTickCount + 500;
        Break;
      end;
    end;
end;

procedure TFrmDlg.DWMissionsMouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  m_MissionSelectMenuStr := '';
end;

procedure TFrmDlg.DLogInDirectPaint(Sender: TObject;
  dsurface: TCustomCanvas);
var
  i: Integer;
  d: TCustomLockableTexture;
  Rect: TRect;
begin
  with Sender as TDButton do begin
    d := WLib.Images[FaceIndex];

    //d := g_WMagic6Images.Images[663];
    if d <> nil then begin

      {g_ImgLargeMixSurface.Draw(0, 0, d.ClientRect, d, False);
      DrawEffect(0, 0, d.Width, d.Height, g_ImgLargeMixSurface, TColorEffect(3));
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, g_ImgLargeMixSurface, True);}

      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);

      {DrawBlend(dsurface, SurfaceX(0 + 00), SurfaceY(Top - 100), d, 1);
      i := 3;
      // for i := 1 to 10 do begin
      g_ImgLargeMixSurface.Draw(0, 0, d.ClientRect, d, False);
      DrawEffect(0, 0, d.Width, d.Height, g_ImgLargeMixSurface, TColorEffect(i));
      DrawBlend(dsurface, SurfaceX(0 + 60 * i), SurfaceY(Top - 100), g_ImgLargeMixSurface, 1);
      // end;}

    end;
  end;
end;

procedure TFrmDlg.DBRefuseSayDirectPaint(Sender: TObject;
  dsurface: TCustomCanvas);
var
  d: TDButton;
  dd: TCustomLockableTexture;
begin
  if Sender is TDButton then begin
    d := TDButton(Sender);
    dd := d.WLib.Images[d.FaceIndex + d.tag];
    if dd <> nil then
      dsurface.Draw(d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, True);
  end;
end;

procedure TFrmDlg.DBSPClick(Sender: TObject; X, Y: Integer);
var
  s: string;
begin
  with Sender as TDButton do begin
    if DWSP.tag = 1 then begin
      s := '';
      if (g_SpItems[0].item.s.Name = '') then
        s := '[失败] 缺少待解读物品。';
      if (g_SpItems[1].item.s.Name = '') then begin
        if s <> '' then
          s := s + '\' + '       缺少神秘卷轴。'
        else
          s := '[失败] 缺少神秘卷轴。';
      end;

      if s <> '' then begin
        FrmDlg.DMessageDlg(s, [mbOk]);
        Exit;
      end;
      FrmDlg.DBSP.OnbtnState := tdisable;
      FrmDlg.DBMB1.OnbtnState := tdisable;
      FrmDlg.DBMB2.OnbtnState := tdisable;
      FrmDlg.DBMB3.OnbtnState := tdisable;
      FrmDlg.DBMB4.OnbtnState := tdisable;
      frmMain.SendClientMessage(CM_SecretProperty,
        g_SpItems[0].item.MakeIndex,
        LoWord(g_SpItems[1].item.MakeIndex),
        HiWord(g_SpItems[1].item.MakeIndex),
        0);
    end;

    if DWSP.tag = 2 then begin
      if (g_SpItems[0].item.s.Name = '') then begin
        FrmDlg.DMessageDlg('[失败] 请放入羊皮卷。', [mbOk]);
        Exit;
      end;
      FrmDlg.DBSP.OnbtnState := tdisable;
      FrmDlg.DBMB1.OnbtnState := tdisable;
      FrmDlg.DBMB2.OnbtnState := tdisable;
      FrmDlg.DBMB3.OnbtnState := tdisable;
      FrmDlg.DBMB4.OnbtnState := tdisable;
      frmMain.SendClientMessage(CM_SecretProperty,
        g_SpItems[0].item.MakeIndex,
        0,
        0,
        (Sender as TDButton).tag);
    end;
  end;
end;

procedure TFrmDlg.DBSPCloseClick(Sender: TObject; X, Y: Integer);
begin
  CloseDBSP();
end;

procedure TFrmDlg.DBSPenergyDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
  rc: TIntRect;
begin
  d := g_Wui.Images[894];
  if d <> nil then begin
    rc := d.ClientRect;
    if g_btMyEnergy > 0 then begin
      rc.Right := Round((rc.Right - rc.Left) / 100 * g_btMyEnergy);
      with Sender as TDButton do dsurface.Draw(SurfaceX(Left), SurfaceY(Top), rc, d, False);
    end;
  end;
end;

procedure TFrmDlg.DBSPLuckDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
  rc: TIntRect;
begin
  d := g_Wui.Images[895];
  if d <> nil then begin
    rc := d.ClientRect;
    if g_btMyLuck > 0 then begin
      rc.Right := Round((rc.Right - rc.Left) / 100 * g_btMyLuck);
      with Sender as TDButton do dsurface.Draw(SurfaceX(Left), SurfaceY(Top), rc, d, False);
    end;
  end;
end;

procedure TFrmDlg.DBSPenergyMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
begin
  with Sender as TDButton do begin
    if tag = 1 then
      DScreen.ShowHint(
        SurfaceX(Left),
        SurfaceY(Top) - 2,
        Format('精力值: %d/100', [g_btMyEnergy]),
        clWhite, False)
    else
      DScreen.ShowHint(
        SurfaceX(Left),
        SurfaceY(Top) - 2,
        Format('幸运值: %d/100', [g_btMyLuck]),
        clWhite, False);
  end;

end;

procedure TFrmDlg.DBSPItem1Click(Sender: TObject; X, Y: Integer);
var
  b: byte;
  temp: TMovingItem;
begin
  with Sender as TDButton do begin
    if DWSP.tag = 1 then begin
      if not g_boItemMoving then begin
        if g_SpItems[TDButton(Sender).tag].item.s.Name <> '' then begin
          g_SndMgr.ItemClickSound(g_SpItems[TDButton(Sender).tag].item.s);
          g_boItemMoving := True;
          g_MovingItem := g_SpItems[TDButton(Sender).tag];
          g_SpItems[TDButton(Sender).tag].item.s.Name := '';
          if TDButton(Sender).tag = 0 then GetspHintString1(0);
        end;
      end else begin
        if IsBagItem(g_MovingItem.Index) then begin
          if TDButton(Sender).tag = 0 then begin
            if not GetSecretAbil(g_MovingItem.item) then begin
              CancelItemMoving;
              FrmDlg.DMessageDlg('[失败] 必须放入有“神秘属性(待解读)”的装备！', [mbOk]);
              Exit;
            end;
          end;
          if TDButton(Sender).tag = 1 then begin
            if (g_MovingItem.item.s.StdMode <> 56) or (g_MovingItem.item.s.Shape <> 0) then begin
              CancelItemMoving;
              FrmDlg.DMessageDlg('[失败] 必须放入有效的神秘卷轴！', [mbOk]);
              Exit;
            end;
          end;
          if g_SpItems[TDButton(Sender).tag].item.s.Name <> '' then begin
            temp := g_SpItems[TDButton(Sender).tag];
            g_SpItems[TDButton(Sender).tag] := g_MovingItem;
            g_MovingItem := temp;
            g_SndMgr.ItemClickSound(g_MovingItem.item.s);

            AutoPutOntiSecretBooks();
          end else begin
            g_SpItems[TDButton(Sender).tag] := g_MovingItem;
            g_MovingItem.item.s.Name := '';
            g_boItemMoving := False;

            AutoPutOntiSecretBooks();
          end;

        end;
      end;
    end else if DWSP.tag = 2 then begin
      if not g_boItemMoving then begin
        if g_SpItems[0].item.s.Name <> '' then begin
          g_SndMgr.ItemClickSound(g_SpItems[0].item.s);
          g_boItemMoving := True;
          g_MovingItem := g_SpItems[0];
          g_SpItems[0].item.s.Name := '';
          if 0 = 0 then begin
            GetspHintString2(0);
          end;
        end;
      end else begin
        if IsBagItem(g_MovingItem.Index) then begin
          if (g_MovingItem.item.s.StdMode <> 41) or (g_MovingItem.item.s.Shape <> 50) then begin
            CancelItemMoving;
            FrmDlg.DMessageDlg('[失败] 必须放入有效的羊皮卷！', [mbOk]);
            Exit;
          end;

          if g_SpItems[0].item.s.Name <> '' then begin
            temp := g_SpItems[0];
            g_SpItems[0] := g_MovingItem;
            g_MovingItem := temp;
            g_SndMgr.ItemClickSound(g_MovingItem.item.s);
          end else begin
            g_SpItems[0] := g_MovingItem;
            g_MovingItem.item.s.Name := '';
            g_boItemMoving := False;
          end;

        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DBSPItem1DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  s: string;
  d: TCustomLockableTexture;
begin
  with Sender as TDButton do begin
    d := WLib.Images[FaceIndex];
    if d <> nil then begin
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    end;

    if g_SpItems[tag].item.s.Name <> '' then begin
      d := frmMain.GetWBagItemImg(g_SpItems[tag].item.s.looks);
      if d <> nil then begin
        dsurface.Draw(SurfaceX(Left + (Width - d.Width) div 2), SurfaceY(Top + (Height - d.Height) div 2), d.ClientRect, d, True);
        if g_SpItems[tag].item.s.Overlap > 0 then begin
          s := IntToStr(g_SpItems[tag].item.Dura);
          dsurface.BoldTextOut(
            SurfaceX(Left + Width) - 6 - FontManager.Default.TextWidth(s),
            SurfaceY(Top + (Height - d.Height) div 2) + 20,
            clSilver, clBlack, s);
        end;
      end;
    end;

//    if g_boItemMoving and (g_MovingItem.item.s.Name <> '') and IsBagItem(g_MovingItem.Index) then begin
//      DrawBlend_Mix(dsurface,
//        SurfaceX(Left),
//        SurfaceY(Top),
//        g_HintSurface_Olive, 0, 0,
//        Width,
//        Height, 0);
//    end;
  end;
end;

procedure TFrmDlg.DBSPItem1MouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  itemidx: Integer;
  shint: string;
begin
  if g_Myself = nil then Exit;
  DScreen.ClearHint;
  with Sender as TDButton do begin
    if g_SpItems[tag].item.s.Name <> '' then begin
      g_MouseItem := g_SpItems[tag].item;
      itemidx := GetItemWhere(g_MouseItem);
      if itemidx in [0..U_FASHION] then begin
        g_ShowSuite := 1;
        g_SuiteIdx := itemidx;
      end;
      GetMouseItemInfoHint(g_MouseItem, shint);
      if shint <> '' then begin
        with Sender as TDButton do
          DScreen.ShowHint(
            SurfaceX(Left + Width) + 3,
            SurfaceY(Top + Height),
            shint,
            clWhite, True, False, True, True);
      end;
      g_MouseItem.s.Name := '';
    end;
  end;
end;

procedure TFrmDlg.DBSPPage1Click(Sender: TObject; X, Y: Integer);
var
  bChg: Boolean;
begin
  bChg := (Sender as TDButton).tag <> DWSP.tag;
  if bChg then
    DWSP.tag := (Sender as TDButton).tag;
  case DWSP.tag of
    1: begin
        g_spHintStr2 := '';
        DBSPItem1.SetImgIndex(g_Wui, 923);
        DBSPItem1.Visible := True;
        DBSPItem2.SetImgIndex(g_Wui, 925);
        DBSPItem2.Visible := True;

        DBSP.Visible := True;
        DBMB1.Visible := False;
        DBMB2.Visible := False;
        DBMB3.Visible := False;
        DBMB4.Visible := False;

        if bChg then begin
          if g_SpItems[0].item.s.Name <> '' then begin
            AddItemBag(g_SpItems[0].item);
            g_SpItems[0].item.s.Name := '';
          end;
          GetspHintString1(0);
        end;
      end;
    2: begin
        g_spHintStr2 := '';

        DBSPItem1.SetImgIndex(g_Wui, 926);
        DBSPItem1.Visible := True;

        DBSPItem2.Visible := False;

        DBSP.Visible := False;
        DBMB1.Visible := True;
        DBMB2.Visible := True;
        DBMB3.Visible := True;
        DBMB4.Visible := True;

        if bChg then begin
          if g_SpItems[0].item.s.Name <> '' then begin
            AddItemBag(g_SpItems[0].item);
            g_SpItems[0].item.s.Name := '';
          end;
          if g_SpItems[1].item.s.Name <> '' then begin
            AddItemBag(g_SpItems[1].item);
            g_SpItems[1].item.s.Name := '';
          end;
          GetspHintString2(0);
        end;
      end;
    3, 4: begin
        DBSPItem1.Visible := False;
        DBSPItem2.Visible := False;

        DBSP.Visible := False;
        DBMB1.Visible := False;
        DBMB2.Visible := False;
        DBMB3.Visible := False;
        DBMB4.Visible := False;

        if g_SpItems[0].item.s.Name <> '' then begin
          AddItemBag(g_SpItems[0].item);
          g_SpItems[0].item.s.Name := '';
        end;
        if g_SpItems[1].item.s.Name <> '' then begin
          AddItemBag(g_SpItems[1].item);
          g_SpItems[1].item.s.Name := '';
        end;
        if DWSP.tag = 3 then begin
          g_spHintStr1 := '';
          g_spHintStr2 :=

          '1、神秘属性可以通过使用神秘卷轴进行解读' + #$0D#$0A +
            '2、神秘卷轴的等级决定了可以解读的神秘属性的个数，等级' + #$0D#$0A +
            '   一的神秘卷轴可以解读第一个神秘属性，等级二的神秘卷' + #$0D#$0A +
            '   轴可以解读第一个和第二个神秘属性，等级三的神秘卷轴' + #$0D#$0A +
            '   可以解读前三个神秘属性，等级四的神秘卷轴可以解读前' + #$0D#$0A +
            '   四个神秘属性' + #$0D#$0A +
            '3、解读神秘属性有一定的成功率，使用的神秘卷轴等级越高' + #$0D#$0A +
            '   、熟练度越高，解读的成功率也越高';

        end else if DWSP.tag = 4 then begin
          g_spHintStr1 := '';
          g_spHintStr2 :=

          '1、制作神秘卷轴需要使用羊皮卷，羊皮卷可以从商城进行购' + #$0D#$0A +
            '   买' + #$0D#$0A +
            '2、制作神秘卷轴有一定的成功率，成功率由幸运值、要制作' + #$0D#$0A +
            '   的卷轴等级和玩家的神秘解读技能的等级相关，制作页面' + #$0D#$0A +
            '   中的红色进度条为玩家的幸运值，每次制作失败都会增加' + #$0D#$0A +
            '   幸运值' + #$0D#$0A +
            '3、每次制作成功都会消耗一定的精力值，精力值不足的时候' + #$0D#$0A +
            '   不能制作卷轴，精力值会随着在线时间的延长有所增长。';
        end;
      end;
  end;
end;

procedure TFrmDlg.DBState2DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
begin
  //
end;

procedure TFrmDlg.DBState2MouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  if (g_Myself = nil) or (g_Myself.m_nIPowerLvl <= 0) then
    Exit;

  with TDButton(Sender) do begin
{$IFDEF UI_0508}
    X := DStateWin.LocalX(X - Left);
    //DScreen.AddChatBoardString(format('%d', [x]), clWhite, clBlack);
    if (X >= 27) and (X <= 82) then begin
      if g_Myself.n_boState then begin
        g_Myself.n_boState := False;
        PageChanged;
        g_SndMgr.PlaySound(s_norm_button_click);
      end;
    end else if (X >= 94) and (X <= 148) then begin
      if not g_Myself.n_boState then begin
        g_Myself.n_boState := True;
        PageChanged;
        g_SndMgr.PlaySound(s_norm_button_click);
      end;
    end;
{$ELSE}
    X := DStateWin.LocalX(X - Left);
    if (X >= 45) and (X <= 110) then begin
      if g_Myself.n_boState then begin
        DBState.SetImgIndex(g_Wui, 3235, 7, 123);
        g_Myself.n_boState := False;
        PageChanged;
        g_SndMgr.PlaySound(s_norm_button_click);
      end;
    end else if (X >= 125) and (X <= 190) then begin
      if not g_Myself.n_boState then begin
        DBState.SetImgIndex(g_Wui, 3235, 7, 123);
        g_Myself.n_boState := True;
        PageChanged;
        g_SndMgr.PlaySound(s_norm_button_click);
      end;
    end;
{$ENDIF}
  end;
end;

procedure TFrmDlg.DBStateDirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  i, L: Integer;
  d: TCustomLockableTexture;
begin
  with TDButton(Sender) do begin
{$IFDEF UI_0508}
    if not g_Myself.n_boState then begin
      d := WLib.Images[FaceIndex + StatePage];
      if d <> nil then begin
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
//        L := dsurface.Canvas.Font.Size;
//        dsurface.Canvas.Font.Size := 10;
//        dsurface.Canvas.Font.Style := [fsBold];
        for i := 0 to 3 do begin
          if StatePage = i then begin
            dsurface.BoldTextOut(
              SurfaceX(Left + 6),
              SurfaceY(Top + 47 * i + 12),
              g_DBStateStrArr[i][1],
              GetRGB(103), clBlack, [fsBold],10);
            dsurface.BoldTextOut(
              SurfaceX(Left + 6),
              SurfaceY(Top + 47 * i + 12 + FontManager.Default.TextHeight('') + 1),
               g_DBStateStrArr[i][2],GetRGB(103),
              clBlack, [fsBold],10);
          end else begin
            dsurface.BoldTextOut(
              SurfaceX(Left + 6),
              SurfaceY(Top + 47 * i + 12),
              g_DBStateStrArr[i][1],
              GetRGB(92), clBlack, [fsBold],10);
            dsurface.BoldTextOut(
              SurfaceX(Left + 6),
              SurfaceY(Top + 47 * i + 12 + FontManager.Default.TextHeight('') + 1),
              g_DBStateStrArr[i][2], GetRGB(92),
              clBlack, [fsBold],10);
          end;
        end;
//        dsurface.Canvas.Font.Size := L;
//        dsurface.Canvas.Font.Style := [];
      end;
    end else begin
      d := WLib.Images[FaceIndex + m_nIPStatePage];
      if d <> nil then begin
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
//        L := dsurface.Canvas.Font.Size;
//        dsurface.Canvas.Font.Size := 10;
//        dsurface.Canvas.Font.Style := [fsBold];
        for i := 0 to 3 do begin
          if m_nIPStatePage = i then begin
            dsurface.BoldTextOut(
              SurfaceX(Left + 6),
              SurfaceY(Top + 47 * i + 12),
              g_DBStateStrArr2[i][1],
              GetRGB(103), clBlack, [fsBold],10);
            dsurface.BoldTextOut(
              SurfaceX(Left + 6),
              SurfaceY(Top + 47 * i + 12 + FontManager.Default.TextHeight('') + 1),
               g_DBStateStrArr2[i][2],GetRGB(103),
              clBlack, [fsBold],10);
          end else begin
            dsurface.BoldTextOut(
              SurfaceX(Left + 6),
              SurfaceY(Top + 47 * i + 12),
              g_DBStateStrArr2[i][1],
              GetRGB(92), clBlack, [fsBold],10);
            dsurface.BoldTextOut(
              SurfaceX(Left + 6),
              SurfaceY(Top + 47 * i + 12 + FontManager.Default.TextHeight('') + 1),
              g_DBStateStrArr2[i][2], GetRGB(92),
              clBlack, [fsBold],10);
          end;
        end;
//        dsurface.Canvas.Font.Size := L;
//        dsurface.Canvas.Font.Style := [];
      end;
    end;
{$ELSE}
    if not g_Myself.n_boState then begin
      d := WLib.Images[FaceIndex + StatePage];
      if d <> nil then begin
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);

        try
          for i := 0 to 6 do begin
            if StatePage = i then begin
              dsurface.BoldTextOut(
                SurfaceX(Left + 6),
                SurfaceY(Top + 41 * i + 12),
                g_DBStateStrArr[i][1],
                GetRGB(103), clBlack, [fsBold],10);
              dsurface.BoldTextOut(
                SurfaceX(Left + 6),
                SurfaceY(Top + 41 * i + 12 + FontManager.Default.TextHeight('') + 1),
                 g_DBStateStrArr[i][2],GetRGB(103),
                clBlack, [fsBold],10);
            end else begin
              dsurface.BoldTextOut(
                SurfaceX(Left + 6),
                SurfaceY(Top + 41 * i + 12),
                g_DBStateStrArr[i][1],
                GetRGB(92), clBlack, [fsBold],10);
              dsurface.BoldTextOut(
                SurfaceX(Left + 6),
                SurfaceY(Top + 41 * i + 12 + FontManager.Default.TextHeight('') + 1),
                g_DBStateStrArr[i][2], GetRGB(92),
                clBlack, [fsBold], 10);
            end;
          end;
        finally
        end;
      end;
    end else begin
      d := WLib.Images[FaceIndex + m_nIPStatePage];
      if d <> nil then begin
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
        try
          for i := 0 to {$IF SERIESSKILL}4{$ELSE}1{$IFEND SERIESSKILL} do begin
            if m_nIPStatePage = i then begin
              dsurface.BoldTextOut(
                SurfaceX(Left + 6),
                SurfaceY(Top + 41 * i + 12),
                g_DBStateStrArr2[i][1],
                GetRGB(103), clBlack, [fsBold],10);
              dsurface.BoldTextOut(
                SurfaceX(Left + 6),
                SurfaceY(Top + 41 * i + 12 + FontManager.Default.TextHeight('') + 1),
                 g_DBStateStrArr2[i][2],GetRGB(103),
                clBlack, [fsBold],10);
            end else begin
              dsurface.BoldTextOut(
                SurfaceX(Left + 6),
                SurfaceY(Top + 41 * i + 12),
                g_DBStateStrArr2[i][1],
                GetRGB(92), clBlack, [fsBold],10);
              dsurface.BoldTextOut(
                SurfaceX(Left + 6),
                SurfaceY(Top + 41 * i + 12 + FontManager.Default.TextHeight('') + 1),
                g_DBStateStrArr2[i][2], GetRGB(92),
                clBlack, [fsBold],10);
            end;
          end;
        finally
        end;
      end;
    end;
{$ENDIF}
  end;
end;

procedure TFrmDlg.DBStateMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
  DScreen.ClearHint;
  if g_MouseStateItem.s.Name <> '' then
    g_MouseStateItem.s.Name := '';
end;

procedure TFrmDlg.DBStateMouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
var
  oStatePage: Integer;
begin
  if g_Myself = nil then Exit;
{$IFDEF UI_0508}
  if (X > 24) or (X < 2) then Exit;
  if not g_Myself.n_boState then begin
    oStatePage := StatePage;
    if (Y >= 70) and (Y <= 102) then begin
      StatePage := 0;
    end else if (Y >= 116) and (Y <= 152) then begin
      StatePage := 1;
    end else if (Y >= 162) and (Y <= 198) then begin
      StatePage := 2;
    end else if (Y >= 208) and (Y <= 244) then begin
      StatePage := 3;
    end;
    if oStatePage <> StatePage then begin
      g_SndMgr.PlaySound(s_norm_button_click);
      PageChanged;
    end;
  end else begin
    oStatePage := m_nIPStatePage;
    if (Y >= 70) and (Y <= 102) then begin
      m_nIPStatePage := 0;
    end else if (Y >= 116) and (Y <= 152) then begin
      m_nIPStatePage := 1;
    end else if (Y >= 162) and (Y <= 198) then begin
      m_nIPStatePage := 2;
    end else if (Y >= 208) and (Y <= 244) then begin
      m_nIPStatePage := 3;
    end;
    if oStatePage <> m_nIPStatePage then begin
      g_SndMgr.PlaySound(s_norm_button_click);
      PageChanged;
    end;
  end;
{$ELSE}
  if (X > 27) or (X < 9) then Exit;
  if not g_Myself.n_boState then begin
    oStatePage := StatePage;
    if (Y >= 128) and (Y <= 162) then begin
      StatePage := 0;
    end else if (Y >= 172) and (Y <= 202) then begin
      StatePage := 1;
    end else if (Y >= 212) and (Y <= 242) then begin
      StatePage := 2;
    end else if (Y >= 252) and (Y <= 282) then begin
      StatePage := 3;
    end else if (Y >= 295) and (Y <= 328) then begin
      StatePage := 4;
    end else if (Y >= 335) and (Y <= 365) then begin
      StatePage := 5;
    end else if (Y >= 376) and (Y <= 406) then begin
      StatePage := 6;
    end;
    if oStatePage <> StatePage then begin
      g_SndMgr.PlaySound(s_norm_button_click);
      PageChanged;
    end;
  end else begin
    oStatePage := m_nIPStatePage;
    if (Y >= 128) and (Y <= 162) then begin
      m_nIPStatePage := 0;
    end else if (Y >= 172) and (Y <= 202) then begin
      m_nIPStatePage := 1;
    end else if (Y >= 212) and (Y <= 242) then begin
      m_nIPStatePage := 2;
    end else if (Y >= 252) and (Y <= 282) then begin
      m_nIPStatePage := 3;
    end else if (Y >= 295) and (Y <= 328) then begin
      m_nIPStatePage := 4;
    end;
    if oStatePage <> m_nIPStatePage then begin
      g_SndMgr.PlaySound(s_norm_button_click);
      PageChanged;
    end;
  end;
{$ENDIF}
end;

procedure TFrmDlg.DBStoreBuyClick(Sender: TObject; X, Y: Integer);
var
  i, ii, cnt: Integer;
  msg: TDefaultMessage;

  cr: TClientStallItems;
begin
  if (g_Myself = nil) then Exit;
  if g_Myself.m_StallMgr.OnSale then Exit;
  cnt := StallItemCount();
  if cnt in [1..10] then begin
    FillChar(cr, SizeOf(TClientStallItems), #0);

    g_Myself.m_StallMgr.mBlock.StallName := DxEditStoreName.Text;
    cr.Name := g_Myself.m_StallMgr.mBlock.StallName;

    ii := 0;
    for i := 0 to 9 do begin
      if (g_Myself.m_StallMgr.mBlock.Items[i].MakeIndex <> 0) and (g_Myself.m_StallMgr.mBlock.Items[i].s.Name <> '') then begin
        cr.Items[ii].MakeIndex := g_Myself.m_StallMgr.mBlock.Items[i].MakeIndex;
        cr.Items[ii].Price := g_Myself.m_StallMgr.mBlock.Items[i].s.Price;
        cr.Items[ii].GoldType := g_Myself.m_StallMgr.mBlock.Items[i].s.NeedIdentify;
        Inc(ii);
      end;
    end;
    case g_Myself.m_btDir of
      0, 1: g_Myself.m_btDir := 1;
      2, 3: g_Myself.m_btDir := 3;
      4, 5: g_Myself.m_btDir := 5;
      6, 7: g_Myself.m_btDir := 7;
    end;
    frmMain.SendStallInfo(cr, cnt);
    DCloseBagClick(nil, 0, 0);
  end else begin

  end;
  //DxEditStoreItemPrice
end;

procedure TFrmDlg.DBStoreCancelClick(Sender: TObject; X, Y: Integer);
var
  cr: TClientStallItems;
begin
  if (g_Myself = nil) then Exit;
  if not g_Myself.m_StallMgr.OnSale then Exit;
  frmMain.SendStallInfo(cr, 0);
end;

procedure TFrmDlg.DBStoreCloseClick(Sender: TObject; X, Y: Integer);
var
  i: Integer;
begin
  {for i := 0 to 10 - 1 do begin
    if g_Myself.m_StallMgr.mBlock.Items[i].s.Name <> '' then begin
      AddItemBag(g_Myself.m_StallMgr.mBlock.Items[i]);
      g_Myself.m_StallMgr.mBlock.Items[i].s.Name := '';
    end;
  end;}
  DWHeroStore.Visible := False;
end;

procedure TFrmDlg.DBStoreItemPriceCancelClick(Sender: TObject; X, Y: Integer);
begin
  //
  if g_WaitingStallItem.item.s.Name <> '' then begin
    //AddItemBag(g_WaitingStallItem.item, g_WaitingStallItem.Index);
    UpdateBagStallItem(g_WaitingStallItem.item, 0);
    g_WaitingStallItem.item.s.Name := '';
  end;
  DWStoreItemPrice.Visible := False;
end;

procedure TFrmDlg.DBStoreItemPriceOkClick(Sender: TObject; X, Y: Integer);
var
  Price: Integer;
  DefMsg: TDefaultMessage;
  StallItem: TClientStall;
begin
  if DxEditStoreItemPrice.Text = '' then Exit;
  if g_WaitingStallItem.item.s.Name = '' then Exit;
  Price := Str_ToInt(DxEditStoreItemPrice.Text, -1);
  if DWStoreItemPrice.tag = 4 then begin
    if (Price <= 0) or (Price > 150000000) then begin
      DMessageDlg('输入金币价格错误，请输入一个在 1~150,000,000 之间的数字', [mbOk, mbCancel]);
      if (Price > 150000000) then
        DxEditStoreItemPrice.Text := '150000000';
      Exit;
    end;
  end else if DWStoreItemPrice.tag = 5 then begin
    if (Price <= 0) or (Price > 150000000) then begin
      DMessageDlg('输入元宝价格错误，请输入一个在 1~150,000,000 之间的数字', [mbOk, mbCancel]);
      if (Price > 150000000) then
        DxEditStoreItemPrice.Text := '150000000';
      Exit;
    end;
  end;
  g_WaitingStallItem.item.s.NeedIdentify := DWStoreItemPrice.tag;
  g_WaitingStallItem.item.s.Price := Price;

  if not g_Myself.m_StallMgr.OnSale then begin
    if AddStallItem(g_WaitingStallItem.item) then begin
      UpdateBagStallItem(g_WaitingStallItem.item, 4);
      g_SndMgr.ItemClickSound(g_WaitingStallItem.item.s);
      g_WaitingStallItem.item.s.Name := '';
    end else begin
      AddItemBag(g_WaitingStallItem.item, g_WaitingStallItem.Index);
      UpdateBagStallItem(g_WaitingStallItem.item, 0);
      g_WaitingStallItem.item.s.Name := '';
    end;
    DBStoreItemPriceCancelClick(nil, 0, 0);
    Exit;
  end;

  if CanAddStallItem() then begin
    StallItem.MakeIndex := g_WaitingStallItem.item.MakeIndex;
    StallItem.GoldType := DWStoreItemPrice.tag;
    StallItem.Price := Price;
    DefMsg := EDcode.MakeDefaultMsg(CM_UPDATESTALLITEM, 0, 0, 0, 1);
    frmMain.SendSocket(EncodeMessage(DefMsg) + EncodeBuffer(@StallItem, SizeOf(StallItem)));
    DWStoreItemPrice.Visible := False;
  end;
end;

procedure TFrmDlg.DBStorePage1Click(Sender: TObject; X, Y: Integer);

  procedure FillComponentTag();
  begin
    DBStorePage1.PageActive := False;
    DBStorePage2.PageActive := False;
    TDButton(Sender).PageActive := True;
  end;
var
  i: Integer;
begin
  DxEditStoreItemPrice.Text := '';
  DxEditStoreItemPrice.SelStart := -1;
  DxEditStoreItemPrice.SelEnd := -1;
  FillComponentTag();
  DWStoreItemPrice.tag := TDButton(Sender).tag;
  with DWStoreItemPrice do begin
    case tag of
      4: begin
          DxEditStoreItemPrice.MaxLength := 9;
        end;
      5: begin
          DxEditStoreItemPrice.MaxLength := 9;
        end;
    end;
  end;
end;

procedure TFrmDlg.DBStorePage1DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  d: TCustomLockableTexture;
  i, itTop: Integer;
  cl: TColor;
begin
  //DBStorePage1.SetImgIndex(g_bui, 2);
  //DBStorePage1.SetImgname(g_WMainUibImages, g_PStallPrice);
  with TDButton(Sender) do begin
    itTop := Top;
    if not PageActive then begin
      d := WLib.Images[g_PStallPrice0];
      //d := g_WMainUibImages.Images[g_PStallPrice0];
      cl := GetRGB(92);
    end else begin
      d := WLib.Images[g_PStallPrice1];
      //d := g_WMainUibImages.Images[g_PStallPrice1];
      itTop := Top - 2;
      cl := GetRGB(95);
    end;
    if d <> nil then begin
      dsurface.Draw(SurfaceX(Left), SurfaceY(itTop), d.ClientRect, d, True);
      with dsurface do begin
        dsurface.BoldTextOut(
          SurfaceX(10 + (d.Width - FontManager.Default.TextWidth(Caption)) div 2 + (TDButton(Sender).tag - 4) * Width),
          SurfaceY(itTop + (d.Height - FontManager.Default.TextHeight(Caption)) div 2),
          Caption,cl, clBlack);
      end;
    end;
  end;
end;

procedure TFrmDlg.OpenDBTI();
begin
  if not DWTI.Visible then begin
    DBTIpag1Click(DBTIpag1, 0, 0);
    GetTIHintString1(0);
    DWTI.Visible := True;
  end else
    DWTI.Visible := True;
end;

procedure TFrmDlg.CloseDBTI();
begin
  DWTI.Visible := False;
  if g_TIItems[0].item.s.Name <> '' then begin
    AddItemBag(g_TIItems[0].item);
    g_TIItems[0].item.s.Name := '';
  end;
  if g_TIItems[1].item.s.Name <> '' then begin
    AddItemBag(g_TIItems[1].item);
    g_TIItems[1].item.s.Name := '';
  end;

end;

procedure TFrmDlg.OpenDBSP();
begin
  if not DWSP.Visible then begin
    DBSPPage1Click(DBSPPage1, 0, 0);
    GetspHintString1(0);
    DWSP.Visible := True;
  end else
    DWSP.Visible := True;
end;

procedure TFrmDlg.CloseDBSP();
begin
  DWSP.Visible := False;
  if g_SpItems[0].item.s.Name <> '' then begin
    AddItemBag(g_SpItems[0].item);
    g_SpItems[0].item.s.Name := '';
  end;
  if g_SpItems[1].item.s.Name <> '' then begin
    AddItemBag(g_SpItems[1].item);
    g_SpItems[1].item.s.Name := '';
  end;

end;

procedure TFrmDlg.DBTIbtn1Click(Sender: TObject; X, Y: Integer);
begin
  if (g_TIItems[0].item.s.Name = '') or (g_TIItems[1].item.s.Name = '') then begin
    FrmDlg.DMessageDlg('[失败] 物品不能空置。', [mbOk]);
    Exit;
  end;

  with Sender as TDButton do begin
    if DWTI.tag = 1 then begin
      FrmDlg.DBTIbtn1.OnbtnState := tdisable;
      FrmDlg.DBTIbtn2.OnbtnState := tdisable;
      frmMain.SendClientMessage(CM_TreasureIdentify, g_TIItems[0].item.MakeIndex, LoWord(g_TIItems[1].item.MakeIndex), HiWord(g_TIItems[1].item.MakeIndex), 0);
    end;
    if DWTI.tag = 2 then begin
      if g_TIItems[0].item.s.Eva.EvaTimes = 0 then begin
        FrmDlg.DMessageDlg('[失败] 你的宝物没有鉴定过，无需更换！', [mbOk]);
        Exit;
      end;
      FrmDlg.DBTIbtn1.OnbtnState := tdisable;
      FrmDlg.DBTIbtn2.OnbtnState := tdisable;
      frmMain.SendClientMessage(CM_ExchangeItem, g_TIItems[0].item.MakeIndex, LoWord(g_TIItems[1].item.MakeIndex), HiWord(g_TIItems[1].item.MakeIndex), 0);
    end;
  end;
end;

procedure TFrmDlg.DBTIbtn2Click(Sender: TObject; X, Y: Integer);
begin
  if (g_TIItems[0].item.s.Name = '') or (g_TIItems[1].item.s.Name = '') then Exit;

  with Sender as TDButton do begin
    if DWTI.tag = 1 then begin
      frmMain.SendClientMessage(CM_TreasureIdentify, g_TIItems[0].item.MakeIndex, LoWord(g_TIItems[1].item.MakeIndex), HiWord(g_TIItems[1].item.MakeIndex), 1);
    end;
  end;
end;

procedure TFrmDlg.DBTICloseClick(Sender: TObject; X, Y: Integer);
begin
  CloseDBTI();
end;

procedure TFrmDlg.DBTIItem1Click(Sender: TObject; X, Y: Integer);
var
  b: byte;
  temp: TMovingItem;
begin
  with Sender as TDButton do begin
    if DWTI.tag = 1 then begin
      if not g_boItemMoving then begin
        if g_TIItems[TDButton(Sender).tag].item.s.Name <> '' then begin
          g_SndMgr.ItemClickSound(g_TIItems[TDButton(Sender).tag].item.s);
          g_boItemMoving := True;
          g_MovingItem := g_TIItems[TDButton(Sender).tag];
          g_TIItems[TDButton(Sender).tag].item.s.Name := '';
          if TDButton(Sender).tag = 0 then GetTIHintString1(0);
        end;
      end else begin
        if IsBagItem(g_MovingItem.Index) then begin
          if TDButton(Sender).tag = 1 then begin
            if g_MovingItem.item.s.StdMode <> 56 then begin
              CancelItemMoving;
              FrmDlg.DMessageDlg('[失败] 必须放入有效的鉴定卷轴！', [mbOk]);
              Exit;
            end;
          end;
          if g_TIItems[TDButton(Sender).tag].item.s.Name <> '' then begin
            temp := g_TIItems[TDButton(Sender).tag];
            g_TIItems[TDButton(Sender).tag] := g_MovingItem;
            g_MovingItem := temp;
            g_SndMgr.ItemClickSound(g_MovingItem.item.s);

            AutoPutOntiBooks();
          end else begin
            g_TIItems[TDButton(Sender).tag] := g_MovingItem;
            g_MovingItem.item.s.Name := '';
            g_boItemMoving := False;

            AutoPutOntiBooks();
          end;
          if TDButton(Sender).tag = 0 then begin
            GetTIHintString1(1, @g_TIItems[TDButton(Sender).tag].item);
          end;
        end;
      end;
    end else if DWTI.tag = 2 then begin
      if not g_boItemMoving then begin
        if g_TIItems[TDButton(Sender).tag].item.s.Name <> '' then begin
          g_SndMgr.ItemClickSound(g_TIItems[TDButton(Sender).tag].item.s);
          g_boItemMoving := True;
          g_MovingItem := g_TIItems[TDButton(Sender).tag];
          g_TIItems[TDButton(Sender).tag].item.s.Name := '';
          if TDButton(Sender).tag = 0 then begin
            GetTIHintString2(0);
          end;
        end;
      end else begin
        if IsBagItem(g_MovingItem.Index) then begin
          if TDButton(Sender).tag = 0 then begin
            if g_MovingItem.item.s.Eva.EvaTimes = 0 then begin
              CancelItemMoving;
              GetTIHintString2(6);
              if (g_TIItems[0].item.s.Name = '') and (g_TIItems[1].item.s.Name = '') then begin
                FrmDlg.DBTIbtn1.OnbtnState := tdisable;
              end;
              Exit;
            end;
          end;

          if TDButton(Sender).tag = 1 then begin
            if (g_MovingItem.item.s.StdMode <> 41) or (g_MovingItem.item.s.Shape <> 30) then begin
              CancelItemMoving;
              GetTIHintString2(7);
              if (g_TIItems[0].item.s.Name = '') and (g_TIItems[1].item.s.Name = '') then begin
                FrmDlg.DBTIbtn1.OnbtnState := tdisable;
              end;
              Exit;
            end;
          end;
          if g_TIItems[TDButton(Sender).tag].item.s.Name <> '' then begin
            temp := g_TIItems[TDButton(Sender).tag];
            g_TIItems[TDButton(Sender).tag] := g_MovingItem;
            g_MovingItem := temp;
            g_SndMgr.ItemClickSound(g_MovingItem.item.s);

            AutoPutOntiCharms();
          end else begin
            g_TIItems[TDButton(Sender).tag] := g_MovingItem;
            g_MovingItem.item.s.Name := '';
            g_boItemMoving := False;

            AutoPutOntiCharms();
          end;
          if TDButton(Sender).tag = 0 then GetTIHintString2(1, @g_TIItems[TDButton(Sender).tag].item);
        end;
      end;
    end else if DWTI.tag = 3 then begin
      g_tiHintStr1 := '宝物除了能给你带来意外的财富，还能给你的装备附加强效属性。';
    end else if DWTI.tag = 4 then begin
      g_tiHintStr1 := '宝物除了能给你带来意外的财富，还能给你的装备附加强效属性。';
    end;
  end;
end;

procedure TFrmDlg.DBTIItem1DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  s: string;
  d: TCustomLockableTexture;
begin
  with Sender as TDButton do begin
    d := WLib.Images[FaceIndex];
    if d <> nil then begin
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    end;

    if g_TIItems[tag].item.s.Name <> '' then begin
      d := frmMain.GetWBagItemImg(g_TIItems[tag].item.s.looks);
      if d <> nil then begin
        dsurface.Draw(SurfaceX(Left + (Width - d.Width) div 2), SurfaceY(Top + (Height - d.Height) div 2), d.ClientRect, d, True);
        if g_TIItems[tag].item.s.Overlap > 0 then begin
          s := IntToStr(g_TIItems[tag].item.Dura);
          dsurface.BoldTextOut(
            SurfaceX(Left + Width) - 6 - FontManager.Default.TextWidth(s),
            SurfaceY(Top + (Height - d.Height) div 2) + 20,
            clSilver, clBlack, s);
        end;
      end;
    end;

//    if g_boItemMoving and (g_MovingItem.item.s.Name <> '') and IsBagItem(g_MovingItem.Index) then begin
//      DrawBlend_Mix(dsurface,
//        SurfaceX(Left),
//        SurfaceY(Top),
//        g_HintSurface_Olive, 0, 0,
//        Width,
//        Height, 0);
//    end;
  end;
end;

procedure TFrmDlg.DBTIItem1MouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  itemidx: Integer;
  shint: string;
begin
  if g_Myself = nil then Exit;
  DScreen.ClearHint;
  with Sender as TDButton do begin
    if g_TIItems[tag].item.s.Name <> '' then begin
      g_MouseItem := g_TIItems[tag].item;
      itemidx := GetItemWhere(g_MouseItem);
      if itemidx in [0..U_FASHION] then begin
        g_ShowSuite := 1;
        g_SuiteIdx := itemidx;
      end;
      GetMouseItemInfoHint(g_MouseItem, shint);
      if shint <> '' then begin
        with Sender as TDButton do
          DScreen.ShowHint(
            SurfaceX(Left + Width) + 3,
            SurfaceY(Top + Height),
            shint,
            clWhite, True, False, True, True);
      end;
      g_MouseItem.s.Name := '';
    end;
  end;
end;

procedure TFrmDlg.DBTIpag1Click(Sender: TObject; X, Y: Integer);
var
  bChg: Boolean;
begin
  bChg := (Sender as TDButton).tag <> DWTI.tag;
  if bChg then
    DWTI.tag := (Sender as TDButton).tag;
  case DWTI.tag of
    1: begin
        g_tiHintStr2 := '';
        DBTIbtn1.SetImgIndex(g_WMain2Images, 590);
        DBTIbtn1.Left := 325;
        DBTIbtn1.Top := 184;
        DBTIbtn1.Caption := '普通鉴定';
        DBTIbtn1.Visible := True;
        DBTIbtn2.Visible := True;

        DBTIItem1.SetImgIndex(g_Wui, 922);
        DBTIItem1.Visible := True;
        DBTIItem2.SetImgIndex(g_Wui, 924);
        DBTIItem2.Visible := True;
        //DBTIItem1Click(DBTIItem1, 0, 0);
        if bChg then begin
          if g_TIItems[0].item.s.Name <> '' then begin
            AddItemBag(g_TIItems[0].item);
            g_TIItems[0].item.s.Name := '';
          end;
          if g_TIItems[1].item.s.Name <> '' then begin
            AddItemBag(g_TIItems[1].item);
            g_TIItems[1].item.s.Name := '';
          end;
          GetTIHintString1(0);
        end else begin

        end;
      end;
    2: begin
        g_tiHintStr2 := '';
        DBTIbtn1.SetImgIndex(g_Wui, 885);
        DBTIbtn1.Left := 325;
        DBTIbtn1.Top := 188;
        DBTIbtn1.Caption := '更换';
        DBTIbtn1.Visible := True;

        DBTIbtn2.Visible := False;

        DBTIItem1.SetImgIndex(g_Wui, 883);
        DBTIItem1.Visible := True;
        DBTIItem2.SetImgIndex(g_Wui, 883);
        DBTIItem2.Visible := True;
        //DBTIItem1Click(DBTIItem1, 0, 0);
        if bChg then begin
          if g_TIItems[0].item.s.Name <> '' then begin
            AddItemBag(g_TIItems[0].item);
            g_TIItems[0].item.s.Name := '';
          end;
          if g_TIItems[1].item.s.Name <> '' then begin
            AddItemBag(g_TIItems[1].item);
            g_TIItems[1].item.s.Name := '';
          end;
          GetTIHintString2(0);
        end;
      end;
    3, 4: begin
        DBTIbtn1.Visible := False;
        DBTIbtn2.Visible := False;
        DBTIItem1.Visible := False;
        DBTIItem2.Visible := False;
        if g_TIItems[0].item.s.Name <> '' then begin
          AddItemBag(g_TIItems[0].item);
          g_TIItems[0].item.s.Name := '';
        end;
        if g_TIItems[1].item.s.Name <> '' then begin
          AddItemBag(g_TIItems[1].item);
          g_TIItems[1].item.s.Name := '';
        end;
        if DWTI.tag = 3 then begin
          g_tiHintStr1 := '宝物除了能给你带来意外的财富，还能给你的装备附加强效属性。';
          g_tiHintStr2 :=
            '1、只有标识可鉴定的物品才能进行鉴定' + #$0D#$0A +
            '2、每件物品最多可以鉴定三次，但是在鉴定过程中有可能获得追加的鉴定机会，还有可能获得让庄主帮忙鉴定的机会' + #$0D#$0A +
            '3、鉴定出来的宝物一般是带有额外属性加成，宝物等级越高，属性越多，属性越好' + #$0D#$0A +
            '4、鉴定失败，鉴定师会返还一定的经验或者荣耀点。';
        end else if DWTI.tag = 4 then begin
          g_tiHintStr1 := '宝物除了能给你带来意外的财富，还能给你的装备附加强效属性。';
          g_tiHintStr2 :=
            '1、如果你对鉴定出来的附加属性不满意，你可以和我更换，我会挑一件和你鉴定之前一模一样的装备给你的。' + #$0D#$0A +
            '2、更换后装备幸运值和已升级的点数保留，例如你给我一个三鉴的幸运+7，攻击12-87，暴击等级+10的传奇战刃，我会换给你一个没鉴定过的幸运+7，攻击12-87，暴击等级+10的传奇战刃。' + #$0D#$0A +
            '3、和我更换装备需要给我一个幸运符，幸运符可以从商城购买。';
        end;
      end;
  end;
end;

procedure TFrmDlg.DBTrainVenationMouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
var
  s, ss: string;
begin
{$IF SERIESSKILL}
  with Sender as TDButton do begin
    if g_VenationInfos[DStateWin.tag].Level in [1..5] then begin
      if g_VenationInfos[DStateWin.tag].Level = 1 then begin
        ss := '修炼%s到%s重，需要%s级金针%d枚。修炼后，能够\获得连击技招式-%s'
      end else begin
        ss := '修炼%s到%s重，需要%s级金针%d枚。修炼后，提升\%s的暴击率和暴击威力';
      end;

      s := Format(ss,
        [
        g_VaStrs[DStateWin.tag], //脉络
          g_VLevelStr[g_VenationInfos[DStateWin.tag].Level], //level
          g_VLevelStr[g_VenationInfos[DStateWin.tag].Level], //level
          g_VLvNeesAcus[DStateWin.tag][g_VenationInfos[DStateWin.tag].Level], //Acus
          g_JobofSeriesSkill[g_Myself.m_btJob][DStateWin.tag]
          ]);

      if FrmDlg.DMessageDlg(s, [mbOk, mbCancel]) = mrOk then begin
        frmMain.SendClientMessage(CM_TRAINVENATION, g_Myself.m_nRecogId, DStateWin.tag, 0, 0);
      end;
    end else begin
      if g_VenationInfos[DStateWin.tag].Level = 0 then
        ShowMDlg(0, '', Format('%s的目前未打通，不可修炼经络\ \<关闭/@closewin>', [g_VaStrs[DStateWin.tag]]))
      else if g_VenationInfos[DStateWin.tag].Level > 5 then
        ShowMDlg(0, '', Format('%s已修炼到最高级了\ \<关闭/@closewin>', [g_VaStrs[DStateWin.tag]]));
    end;
  end;
{$IFEND SERIESSKILL}
end;

procedure TFrmDlg.DBUserStallBuyClick(Sender: TObject; X, Y: Integer);
var
  i, ii, cnt: Integer;
  msg: TDefaultMessage;

  cr: TClientStallItems;

  MsgResult: Integer;
begin
  if (g_Myself = nil) then Exit;
  if g_Myself.m_StallMgr.OnSale then Exit;
  if not (g_Myself.m_StallMgr.uSelIdx in [0..9]) or (g_Myself.m_StallMgr.uBlock.Items[g_Myself.m_StallMgr.uSelIdx].s.Name = '') then Exit;

  //
  MsgResult := -1;
  case g_Myself.m_StallMgr.uBlock.Items[g_Myself.m_StallMgr.uSelIdx].s.NeedIdentify of
    4: MsgResult := DMessageDlg(Format('你将以 %d 金币购买 %s，确定吗？', [g_Myself.m_StallMgr.uBlock.Items[g_Myself.m_StallMgr.uSelIdx].s.Price, g_Myself.m_StallMgr.uBlock.Items[g_Myself.m_StallMgr.uSelIdx].s.Name]), [mbOk, mbCancel]);
    5: MsgResult := DMessageDlg(Format('你将以 %d 元宝购买 %s，确定吗？', [g_Myself.m_StallMgr.uBlock.Items[g_Myself.m_StallMgr.uSelIdx].s.Price, g_Myself.m_StallMgr.uBlock.Items[g_Myself.m_StallMgr.uSelIdx].s.Name]), [mbOk, mbCancel]);
  end;
  if MsgResult = mrCancel then begin
    g_Myself.m_StallMgr.uSelIdx := -1;
    Exit;
  end;
  if MsgResult = mrOk then begin
    if g_Myself.m_StallMgr.uBlock.Items[g_Myself.m_StallMgr.uSelIdx].s.Overlap > 0 then
      frmMain.SendBuyItem(g_Myself.m_StallMgr.CurActor,
        g_Myself.m_StallMgr.uBlock.Items[g_Myself.m_StallMgr.uSelIdx].MakeIndex,
        g_Myself.m_StallMgr.uBlock.Items[g_Myself.m_StallMgr.uSelIdx].s.Name,
        g_Myself.m_StallMgr.uBlock.Items[g_Myself.m_StallMgr.uSelIdx].Dura)
    else
      frmMain.SendBuyItem(g_Myself.m_StallMgr.CurActor,
        g_Myself.m_StallMgr.uBlock.Items[g_Myself.m_StallMgr.uSelIdx].MakeIndex,
        g_Myself.m_StallMgr.uBlock.Items[g_Myself.m_StallMgr.uSelIdx].s.Name,
        1);
  end;
end;

procedure TFrmDlg.DBUserStallCloseClick(Sender: TObject; X, Y: Integer);
begin
  DWUserStall.Visible := False;
end;

procedure TFrmDlg.DBRefuseSayClick(Sender: TObject; X, Y: Integer);
var
  fc, bc: TColor;
  s: string;
  d: TDButton;
  dd: TCustomCanvas;
begin
  d := TDButton(Sender);
  s := '';
  if d.tag = 0 then
    d.tag := 1
  else
    d.tag := 0;
  if d = DBRefuseSay then begin
    if d.tag = 0 then
      s := '允许接收公聊信息'
    else
      s := '拒绝接收公聊信息';
  end else if d = DBRefuseCry then begin
    if d.tag = 0 then
      s := '允许接收喊话信息'
    else
      s := '拒绝接收喊话信息';
  end else if d = DBRefuseWhisper then begin
    if d.tag = 0 then
      s := '允许接收私聊信息'
    else
      s := '拒绝接收私聊信息';
  end else if d = DBRefuseGuild then begin
    if d.tag = 0 then
      s := '允许接收行会聊天信息'
    else
      s := '拒绝接收行会聊天信息';
  end else if (d = DBAotoSay) and g_boAutoSay then begin
    if g_Myself <> nil then begin
      g_Myself.m_sAutoSayMsg := '';
      if d.tag = 1 then begin
        s := '自动喊话已关闭'
      end else begin
        if FrmDlg.DEdChat.Visible and (FrmDlg.DEdChat.Text <> '') then begin
          g_Myself.m_sAutoSayMsg := FrmDlg.DEdChat.Text;
          m_sAutoSayMsgTick := 0;
        end;
        s := '启用了自动喊话功能，聊天框中的内容已记录为喊话内容';
      end;
    end;

  end;
  fc := GetRGB(219);
  if (d.tag = 0) or (d = DBAotoSay) then
    bc := clWhite
  else
    bc := clBlack;
  if s <> '' then DScreen.AddChatBoardString(s, fc, bc);

end;

procedure TFrmDlg.QueryChangeHero(sName: string);
var
  srest, sHero, sLastHero: string;
  DefMsg: TDefaultMessage;
begin
  if not g_boMutiHero then Exit;
  GetValidStr3(DComboBox_Hero.Caption, sLastHero, [' ']);
  GetValidStr3(sName, sHero, [' ']);
  if sHero = sLastHero then begin
    DListBox_Hero.ChangingHero := False;
    Exit;
  end;

  g_lastHeroSel := sName;

  DefMsg := EDcode.MakeDefaultMsg(CM_HEROCHANGING, 0, 0, 0, 0);
  frmMain.SendSocket(EncodeMessage(DefMsg) + EncodeString(sHero));

end;

procedure TFrmDlg.DxEdit_Items_Search_OnTextChanged(Sender: TObject; sText: string);
var
  i, ii, idx: Integer;
  p, p2: pTCItemRule;
begin
  if sText = '' then begin
    for i := Low(g_caItems) to High(g_caItems) do
      g_caItems[i] := g_caItems2[i];
    Exit;
  end;
  FillChar(g_caItems, SizeOf(g_caItems), 0);
  p := pTCItemRule(g_ItemsFilter_All.GetValues(sText));
  if p <> nil then begin
    g_ptItems_Pos := 0;
    //DMoveButton_items.UpdatePos(DMoveButton_items.Position, True);
    g_caItems[0] := p;
  end;
end;

function TFrmDlg.ShowHintWindow1(X, Y: Integer; Str: string; Color: TColor; drawUp, drawLeft, ShowItem, ItemWearing: Boolean): Integer;
var
  dwCrc: Cardinal;
  data, FData, sData, sCustom, sSet, scfg: string;
  cl: TColor;
  i, j, k, w, idx, sX, nBold, ShowType: Integer;
  Segment: THintTextSegment;
  pSegment: pTHintTextSegment;
begin
  Result := 0;
  if Str = '' then Exit;

  {dwCrc := CRC32(Pointer(Str), Length(Str) * SizeOf(Char), 0);

  if (dwCrc = m_HintStrs.Crc) and (m_HintStrs.ShowType = ShowType) then begin
    m_HintStrs.Show := True;
    m_HintStrs.IsShowItem := ShowItem;
    m_HintStrs.ItemWearing := ItemWearing;
    m_HintStrs.X := X;
    m_HintStrs.Y := Y;
    m_HintStrs.LastTick := GetTickCount;
    if drawUp then m_HintStrs.Y := m_HintStrs.Y - m_HintStrs.Height;
    if drawLeft then m_HintStrs.X := m_HintStrs.X - m_HintStrs.Width;
    Result := m_HintStrs.Height;
    DWHint1.Visible := True;
    Exit;
  end;

  m_HintStrs.Show := True;
  m_HintStrs.Crc := dwCrc;
  m_HintStrs.X := X;
  m_HintStrs.Y := Y;
  m_HintStrs.Strs := TList.Create;
  m_HintStrs.Width := 0;
  m_HintStrs.Height := 0;
  m_HintStrs.IsShowItem := ShowItem;
  m_HintStrs.ItemWearing := ItemWearing;
  m_HintStrs.LastTick := GetTickCount;
  m_HintStrs.ShowType := 0;

  idx := 0;
  nBold := 0;
  while True do begin
    if Str = '' then Break;
    Str := GetValidStr3(Str, data, ['\']);
    w := 0;
    if data <> '' then begin
      sX := 0;
      if data[1] = '-' then begin
        New(pSegment);
        pSegment.Text := data;
        pSegment.offsetX := sX;
        pSegment.indexY := idx;
        pSegment.Size := 9;
        pSegment.Color := Color;
        pSegment.Bold := 0;
        pSegment.ShowLine := True;
        m_HintStrs.Strs.Add(pSegment);
        w := w + 6 + 8;
      end else begin
        while (data <> '') and (Pos('<', data) > 0) and (Pos('>', data) > 0) do begin
          FData := '';
          if data[1] <> '<' then
            data := '<' + GetValidStr3(data, FData, ['<']);

          if FData <> '' then begin
            New(pSegment);
            pSegment.Text := FData;
            pSegment.offsetX := sX;
            pSegment.indexY := idx;
            pSegment.Size := 9;
            pSegment.Color := Color;
            pSegment.Bold := 0;
            pSegment.ShowLine := False;
            m_HintStrs.Strs.Add(pSegment);
            sX := sX + Length(FData) * 6;
            w := w + Length(FData) * 6;
          end;

          data := ArrestStringEx(data, '<', '>', sCustom);

          sData := '';
          Segment.Color := Color;
          Segment.Size := 9;
          Segment.Bold := 0;
          Segment.ShowLine := False;
          if sCustom <> '' then begin
            sSet := GetValidStr3(sCustom, sData, ['|']);
            while sSet <> '' do begin
              sSet := GetValidStr3(sSet, scfg, [' ']);
              if scfg <> '' then begin
                scfg := UpperCase(scfg);
                case scfg[1] of
                  'C': begin
                      scfg := Copy(scfg, 3, Length(scfg) - 2);
                      if CompareText('clLtGray', scfg) = 0 then
                        Segment.Color := clLtGray
                      else if CompareText('clDkGray', scfg) = 0 then
                        Segment.Color := clDkGray
                      else
                        Segment.Color := StringToColor(scfg);
                    end;
                  'S': begin
                      scfg := Copy(scfg, 3, Length(scfg) - 2);
                      Segment.Size := StrToInt(scfg);
                    end;
                  'B': begin
                      scfg := Copy(scfg, 3, Length(scfg) - 2);
                      Segment.Bold := 0;
                      if CompareText(scfg, 'BOLD') = 0 then
                        Segment.Bold := 1
                      else if CompareText(scfg, 'UNDERLINE') = 0 then
                        Segment.Bold := 2;
                    end;
                end;
              end;
            end;
          end;
          if sData <> '' then begin
            New(pSegment);
            pSegment.Text := sData;
            pSegment.offsetX := sX;
            pSegment.indexY := idx;
            pSegment.Size := Segment.Size;
            pSegment.Color := Segment.Color;
            pSegment.Bold := Segment.Bold;
            pSegment.ShowLine := False;
            m_HintStrs.Strs.Add(pSegment);
            if pSegment.Bold = 1 then Inc(nBold);
            sX := sX + Length(sData) * 6;
            w := w + Length(sData) * 6;
          end;
        end;
        if data <> '' then begin
          New(pSegment);
          pSegment.Text := data;
          pSegment.offsetX := sX;
          pSegment.indexY := idx;
          pSegment.Size := 9;
          pSegment.Color := Color;
          pSegment.Bold := 0;
          pSegment.ShowLine := False;
          m_HintStrs.Strs.Add(pSegment);
          w := w + Length(data) * 6 + 8;
        end else
          w := w + 8;
      end;
    end;
    if w > m_HintStrs.Width then
      m_HintStrs.Width := w;
    Inc(idx);
  end;
  if ShowItem and (m_HintStrs.Width <> MAXITEMBOX_WIDTH) then m_HintStrs.Width := MAXITEMBOX_WIDTH;

  m_HintStrs.Height := 14 * idx + nBold * 2 + 6;
  Result := m_HintStrs.Height;

  if drawUp then
    m_HintStrs.Y := m_HintStrs.Y - m_HintStrs.Height;
  if drawLeft then
    m_HintStrs.X := m_HintStrs.X - m_HintStrs.Width;

  DWHint1.Left := (SCREENWIDTH - m_HintStrs.Width) div 2;
  DWHint1.Top := (SCREENHEIGHT - 250 - m_HintStrs.Height) div 2;
  DWHint1.Width := m_HintStrs.Width;
  DWHint1.Height := m_HintStrs.Height;
  DBHint1Close.Left := DWHint1.Width - 10;

  DWHint1.Visible := True;}
end;

procedure TFrmDlg.DWHint1DirectPaint(Sender: TObject; dsurface: TCustomCanvas);
var
  cl: TColor;
  d: TCustomCanvas;
  i, ii, hx, hy, idx: Integer;
  oSize, oColor: Integer;
  Str: string;
  rc: TRect;

  pStrins: pTHintStrings;
  pSegment: pTHintTextSegment;
begin
  hx := 0;
  hy := 0;

  {if not m_HintStrs.Show and (GetTickCount - m_HintStrs.LastTick > 30 * 1000) then begin
    for ii := 0 to m_HintStrs.Strs.Count - 1 do
      Dispose(pTHintTextSegment(m_HintStrs.Strs[ii]));
    m_HintStrs.Strs.Clear;
  end;}

  {if not m_HintStrs.Show then Exit;

  if m_HintStrs.IsShowItem or m_HintStrs.ItemWearing then
    d := g_HintSurface_B
  else
    d := g_WMainImages.Images[394];

  if d = nil then Exit;

  m_HintStrs.LastTick := GetTickCount;

  with Sender as TDWindow do begin
    if m_HintStrs.Width > d.Width then m_HintStrs.Width := d.Width;
    if m_HintStrs.Height > d.Height then m_HintStrs.Height := d.Height;

    if m_HintStrs.X + m_HintStrs.Width > SCREENWIDTH then
      hx := SCREENWIDTH - m_HintStrs.Width
    else
      hx := m_HintStrs.X;

    if m_HintStrs.Y < 0 then
      hy := 0
    else
      hy := m_HintStrs.Y;

    if hx < 0 then hx := 0;

    hx := SurfaceX(Left + 0);
    hy := SurfaceY(Top + 0);

    DrawBlend_Mix(dsurface, hx, hy, d, 0, 0, m_HintStrs.Width, m_HintStrs.Height, 0);

    if m_HintStrs.IsShowItem then begin
      with dsurface.Canvas do begin

        Pen.Color := GetRGB(85);
        MoveTo(hx - 1, hy);
        LineTo(hx + m_HintStrs.Width, hy);
        LineTo(hx + m_HintStrs.Width, hy + m_HintStrs.Height);
        LineTo(hx - 1, hy + m_HintStrs.Height);
        LineTo(hx - 1, hy);

        Pen.Color := GetRGB(87);
        MoveTo(hx - 2, hy - 1);
        LineTo(hx + m_HintStrs.Width + 1, hy - 1);
        LineTo(hx + m_HintStrs.Width + 1, hy + m_HintStrs.Height + 1);
        LineTo(hx - 2, hy + m_HintStrs.Height + 1);
        LineTo(hx - 2, hy - 1);

        Pen.Color := GetRGB(84);
        MoveTo(hx - 3, hy - 2);
        LineTo(hx + m_HintStrs.Width + 2, hy - 2);
        LineTo(hx + m_HintStrs.Width + 2, hy + m_HintStrs.Height + 2);
        LineTo(hx - 3, hy + m_HintStrs.Height + 2);
        LineTo(hx - 3, hy - 2);
//        Release;
      end;
    end;

    for ii := 0 to m_HintStrs.Strs.Count - 1 do begin
      pSegment := m_HintStrs.Strs[ii];
      if pSegment.ShowLine then begin
        with dsurface.Canvas do begin
          Pen.Color := clGray;
          MoveTo(hx + pSegment.offsetX + 3, hy + 14 * pSegment.indexY + 4 + 6);
          LineTo(hx + pSegment.offsetX + m_HintStrs.Width - 3, hy + 14 * pSegment.indexY + 4 + 6);
          Pen.Color := GetRGB(0);
          MoveTo(hx + pSegment.offsetX + 3, hy + 14 * pSegment.indexY + 4 + 7);
          LineTo(hx + pSegment.offsetX + m_HintStrs.Width - 3, hy + 14 * pSegment.indexY + 4 + 7);
//          Release;
        end;
      end else begin
        oSize := dsurface.Canvas.Font.Size;
        dsurface.Canvas.Font.Size := pSegment.Size;
        try
          if pSegment.Bold = 1 then
            BoldTextOut(dsurface, hx + pSegment.offsetX + 4, hy + 14 * pSegment.indexY + 4, pSegment.Color, clBlack, pSegment.Text, 2)
          else
            BoldTextOut(dsurface, hx + pSegment.offsetX + 4, hy + 14 * pSegment.indexY + 4, pSegment.Color, clBlack, pSegment.Text);
        finally
          dsurface.Canvas.Font.Size := oSize;
        end;
      end;
    end;
  end;}
end;

end.







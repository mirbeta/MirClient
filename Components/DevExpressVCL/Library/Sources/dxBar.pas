{********************************************************************}
{                                                                    }
{           Developer Express Visual Component Library               }
{           ExpressBars components                                   }
{                                                                    }
{           Copyright (c) 1998-2019 Developer Express Inc.           }
{           ALL RIGHTS RESERVED                                      }
{                                                                    }
{   The entire contents of this file is protected by U.S. and        }
{   International Copyright Laws. Unauthorized reproduction,         }
{   reverse-engineering, and distribution of all or any portion of   }
{   the code contained in this file is strictly prohibited and may   }
{   result in severe civil and criminal penalties and will be        }
{   prosecuted to the maximum extent possible under the law.         }
{                                                                    }
{   RESTRICTIONS                                                     }
{                                                                    }
{   THIS SOURCE CODE AND ALL RESULTING INTERMEDIATE FILES            }
{   (DCU, OBJ, DLL, ETC.) ARE CONFIDENTIAL AND PROPRIETARY TRADE     }
{   SECRETS OF DEVELOPER EXPRESS INC. THE REGISTERED DEVELOPER IS    }
{   LICENSED TO DISTRIBUTE THE EXPRESSBARS AND ALL ACCOMPANYING VCL  }
{   CONTROLS AS PART OF AN EXECUTABLE PROGRAM ONLY.                  }
{                                                                    }
{   THE SOURCE CODE CONTAINED WITHIN THIS FILE AND ALL RELATED       }
{   FILES OR ANY PORTION OF ITS CONTENTS SHALL AT NO TIME BE         }
{   COPIED, TRANSFERRED, SOLD, DISTRIBUTED, OR OTHERWISE MADE        }
{   AVAILABLE TO OTHER INDIVIDUALS WITHOUT EXPRESS WRITTEN CONSENT   }
{   AND PERMISSION FROM DEVELOPER EXPRESS INC.                       }
{                                                                    }
{   CONSULT THE END USER LICENSE AGREEMENT FOR INFORMATION ON        }
{   ADDITIONAL RESTRICTIONS.                                         }
{                                                                    }
{********************************************************************}

unit dxBar;

{$I cxVer.inc}

interface

uses
{$IFDEF DELPHI16}
  System.UITypes,
{$ENDIF}
  Types, SysUtils, TypInfo, Windows, Forms, Controls{must be after Forms for D11},
  Messages, Graphics, Classes, ImgList, ActnList, Menus, StdCtrls, IniFiles, Contnrs,
  Generics.Defaults, Generics.Collections,
  dxCore, dxCoreClasses, dxCoreGraphics, dxMessages, dxCommon, dxThemeManager,
  cxLookAndFeels, cxLookAndFeelPainters, dxGDIPlusClasses, dxForms,
  cxControls, cxContainer, cxClasses, cxGraphics, cxStyles, dxFading, cxAccessibility,
  dxCustomHint, dxScreenTip, dxSkinsCore, dxShadowWindow, cxGeometry;

type
  TdxBarItemPosition = (ipBeginsNewRow, ipBeginsNewColumn, ipContinuesRow);
  TdxByteSet = set of Byte;

  TdxBarItemViewLayout = (ivlGlyphCaptionControl, ivlGlyphControlCaption);
  TdxBarItemViewLevel = (ivlLargeIconWithText, ivlLargeControlOnly, ivlSmallIconWithText,
    ivlSmallIcon, ivlControlOnly, ivlDefault{D10 bug});
  TdxBarItemRealViewLevel = ivlLargeIconWithText..ivlControlOnly;
  TdxBarItemViewLevels = set of TdxBarItemRealViewLevel;

  TdxBarButtonGroupPosition = (bgpNone, bgpStart, bgpMember);
  TdxBarButtonGroupRealPosition = (bgrpNone, bgrpStart, bgrpMember, bgrpFinish, bgrpSingle);

  TdxBarItemAlign = (iaLeft, iaCenter, iaRight, iaClient);
  TdxBarGlyphLayout = (glLeft, glRight, glTop, glBottom);

  TdxBarMenuItemSize = (misNormal, misLarge);

  TdxBarCloseUpReason = (bcrUnknown, bcrCancel, bcrEnter, bcrEscape);

  TdxBarBehaviorOption = (bboAllowDetach, bboAllowSelectWindowItemsWithoutFocusing, bboAllowShowHints,
    bboClickItemsBySpaceKey, bboExtendItemWhenAlignedToClient, bboNeedsFocusWhenActive, bboMouseCantUnselectNavigationItem,
    bboUnmoved, bboItemCustomizePopup, bboSubMenuCaptureMouse, bboCanShowPopupMenuOnMouseClick);
  TdxBarBehaviorOptions = set of TdxBarBehaviorOption;

  TdxBarItemCachedWidthInfo = record
    Calculated: Boolean;
    Width: Integer;
  end;

  TdxBarItemStyleData = record
    AssignedValues: TcxStyleValues;
    Color: TColor;
    FontData: TFontData;
    TextColor: TColor;

    Style: TcxStyle;
  end;

  TdxBarMouseWheelEventReceiver = (mwrNone, mwrActiveBarControl, mwrFocusedItemControl, mwrWindow);

  TdxBarMDIButton = (mdibMinimize, mdibRestore, mdibClose);
  TdxBarMDIButtons = set of TdxBarMDIButton;

  TdxBarKind = (bkBarControl, bkBarQuickControl, bkSubMenu);
  TdxBarKinds = set of TdxBarKind;

const
  dxBarDefaultButtonArrowWidth = 11;
  dxBarDefaultLargeButtonArrowWidth = 13;//4;
  dxBarTransparentShadowSize = 4;
  dxBarOpaqueShadowSize = 2;

  DropDownGalleryVerticalSizeGripBitmapSize: TSize = (cx: 18; cy: 7);
  dxBarItemAllViewLevels = [ivlLargeIconWithText..ivlControlOnly];// Builder 2009 error [Low(TdxBarItemRealViewLevel)..High(TdxBarItemRealViewLevel)];
  dxBarItemDefaultPosition = ipBeginsNewRow;
  MDIButtonCommands: array[TdxBarMDIButton] of Integer =
    (SC_MINIMIZE, SC_RESTORE, SC_CLOSE);
  dxBarKindAny = [Low(TdxBarKind)..High(TdxBarKind)];

type
  TCustomdxBarControl = class;
  TCustomdxBarControlClass = class of TCustomdxBarControl;
  TCustomdxBarControlDesignHelper = class;
  TCustomdxBarControlDesignHelperClass = class of TCustomdxBarControlDesignHelper;
  TCustomdxBarControlViewInfo = class;
  TCustomdxBarControlViewInfoClass = class of TCustomdxBarControlViewInfo;
  TCustomdxBarSubItem = class;
  TdxBar = class;
  TdxBarAccessibilityHelper = class;
  TdxBarButton = class;
  TdxBarButtonLikeControlDrawParams = class;
  TdxBarButtonLikeControl = class;
  TdxBarCaptionButtons = class;
  TdxBarComponent = class;
  TdxBarComponentList = class;
  TdxBarControl = class;
  TdxBarControlClass = class of TdxBarControl;
  TdxBarPopupControl = class;
  TdxBarPopupControlClass = class of TdxBarPopupControl;
  TdxBarCustomizingPopup = class;
  TdxBarCustomEditControl = class;
  TdxBarCustomStaticControl = class;
  TdxBarDockControl = class;
  TdxBarDockControlClass = class of TdxBarDockControl;
  TdxBarEditControl = class;
  TdxBarItem = class;
  TdxBarItemClass = class of TdxBarItem;
  TdxBarItemControl = class;
  TdxBarItemControlClass = class of TdxBarItemControl;
  TdxBarItemControlViewInfo = class;
  TdxBarItemLink = class;
  TdxBarItemLinkClass = class of TdxBarItemLink;
  TdxBarItemLinks = class;
  TdxBarItemLinksClass = class of TdxBarItemLinks;
  TdxBarManager = class;
  TdxBarPainter = class;
  TdxBarPainterClass = class of TdxBarPainter;
  TdxBarCustomPopupMenuComponent = class;
  TdxBarCustomPopupMenu = class;
  TdxBarPopupMenu = class;
  TdxBarPopupMenuLink = class;
  TdxBarQuickControl = class;
  TdxBars = class;
  TdxBarShadow = class;
  TdxBarSubItem = class;
  TdxBarSubMenuControl = class;
  TdxDockControl = class;
  TdxDockRow = class;
  TdxObjectList = class;
  TdxBarCustomHintViewInfo = class;
  TdxBarCustomHintViewInfoClass = class of TdxBarCustomHintViewInfo;
  TdxBarScreenTipViewInfo = class;
  TdxBarHintWindow = class;
  TdxBarHintWindowClass = class of TdxBarHintWindow;
  TdxBarInternalLinksOwner = class;

  TdxBarItemSeparatorKind = (skHorizontal, skVertical);

  TdxBarItemSeparatorData = record
    AssociatedItemControl: TObject;
    Bounds: TRect;
    Kind: TdxBarItemSeparatorKind;
  end;

  TdxBarMergeOperation = (bmoMerge, bmoUnmerge);

  {--------------------------
      Non-visual components
   --------------------------}
  TdxBarSelectionStatus = (ssUnselected, ssActiveSelected, ssInactiveSelected);
  TdxBarSelectionOperation = (soAdd, soExclude, soExclusive);
  TdxBarCustomizationAction = (caReset, caDelete, caDeleteItem, caDeleteLink, caSelectLink,
    caChangeCaption, caChangeButtonPaintStyle, caChangePosition, caChangeViewLevels,
    caChangeButtonGroup, caChangeDistributed, caChangeBeginGroup, caChangeVisible, caChangeRecentList);
  TdxBarCustomizationActions = set of TdxBarCustomizationAction;

  IdxBarSelectableItem = interface
  ['{6DCCAA42-48D0-4D7D-BEDF-1EADC2197131}']
    function CanDelete(ADestruction: Boolean = False): Boolean;
    procedure DeleteSelection(var AReference: IdxBarSelectableItem; ADestruction: Boolean);
    procedure ExecuteCustomizationAction(ABasicAction: TdxBarCustomizationAction);
    function GetBarManager: TdxBarManager;
    function GetInstance: TPersistent;
    procedure GetMasterObjects(AList: TdxObjectList);
    function GetNextSelectableItem: IdxBarSelectableItem;
    function GetSelectableParent: TPersistent;
    function GetSelectionStatus: TdxBarSelectionStatus;
    function GetSupportedActions: TdxBarCustomizationActions;
    procedure Invalidate;
    function IsComplex: Boolean;
    function IsComponentSelected: Boolean;
    procedure SelectComponent(ASelectionOperation: TdxBarSelectionOperation = soExclusive);
    function SelectParentComponent: Boolean;
    procedure SelectionChanged;
  end;

  IdxBarDesigner = interface
  ['{B364658F-B4CE-46C3-83D5-D537F34B9482}']
    function CanDeleteComponent(AComponent: TComponent): Boolean;
    procedure GetSelection(AList: TList);
    function GetSelectionStatus(AComponent: TPersistent): TdxBarSelectionStatus;
    function IsComponentSelected(AComponent: TPersistent): Boolean;
    procedure SelectComponent(AComponent: TPersistent; ASelectionOperation: TdxBarSelectionOperation = soExclusive);
    procedure SetSelection(AList: TList);
    procedure ShowDefaultEventHandler(AItem: TdxBarItem);
    function UniqueName(const BaseName: string): string;
  end;

  IdxBarLinksOwner = interface
  ['{1CB4E538-769E-45F4-9BE3-20814F440106}']
    function CanContainItem(AItem: TdxBarItem; out AErrorText: string): Boolean;
    function CreateBarControl: TCustomdxBarControl;
    function GetBarManager: TdxBarManager;
    function GetImages: TCustomImageList;
    function GetInstance: TComponent;
    function GetItemLinks: TdxBarItemLinks;
    function IsLoading: Boolean;
  end;

  IdxBarSubMenuOwner = interface
  ['{218A3250-D279-44EA-9E87-3D5443B3C0ED}']
    function GetBarSize: Integer;
    procedure DoPaintBar(ACanvas: TCanvas; const R: TRect);
    procedure DoCloseUp;
    procedure DoPopup;
  end;

  IdxBarMultiColumnItemControlViewInfo = interface
  ['{B92D58D1-3251-4816-A43F-D4D4AF2F02EE}']
    function CanCollapse: Boolean;
    function GetCollapsed: Boolean;
    function GetColumnCount: Integer;
    function GetMaxColumnCount: Integer;
    function GetMinColumnCount: Integer;
    function GetWidthForColumnCount(AColumnCount: Integer): Integer;
    procedure SetCollapsed(Value: Boolean);
    procedure SetColumnCount(Value: Integer);
  end;

  IdxBarItemControlViewInfo = interface
  ['{99C4A703-E6D2-43AF-987E-F5DA81718295}']
    procedure CalculateFinalize;
    function GetAlign: TdxBarItemAlign;
    function GetAllowedViewLevels: TdxBarItemViewLevels;
    function GetBounds: TRect;
    function GetColumnRowCount: Integer;
    function GetDistributed: Boolean;
    function GetPosition: TdxBarItemPosition;
    function GetPositionInButtonGroup: TdxBarButtonGroupPosition;
    function GetRealPositionInButtonGroup: TdxBarButtonGroupRealPosition;
    function GetRow: Integer;
    function GetViewLevel: TdxBarItemViewLevel;
    function GetViewLevelForButtonGroup: TdxBarItemRealViewLevel;
    function GetWidth(AViewLevel: TdxBarItemRealViewLevel): Integer;
    function HasSeparator: Boolean;
    function IsPrimaryForDistribution: Boolean;
    function IsMultiColumnItemControl(ACheckCollapsed: Boolean;
      out AIMultiColumnItemControlViewInfo: IdxBarMultiColumnItemControlViewInfo): Boolean;
    procedure SetBounds(const Value: TRect);
    procedure SetColumnRowCount(Value: Integer);
    procedure SetDistributed(Value: Boolean);
    procedure SetRealPositionInButtonGroup(Value: TdxBarButtonGroupRealPosition);
    procedure SetRow(Value: Integer);
    procedure SetViewLevel(Value: TdxBarItemViewLevel);
  end;

  IdxBarHintKeeper = interface
  ['{587A00C4-A7E0-4032-98E5-4DB8F3918ADF}']
    function DoHint(var ANeedDeactivate: Boolean; out AHintText: string; out AShortCut: string): Boolean;
    function CreateHintViewInfo(const AHintText, AShortCut: string): TdxBarCustomHintViewInfo;
    function GetEnabled: Boolean;
    function GetHintPosition(const ACursorPos: TPoint; AHeight: Integer): TPoint;
  end;

  IdxBarHintKeeper2 = interface
  ['{9BFA849B-BF7D-4D17-A95E-6C4A7456CC6F}']
    function GetHintedControl: TControl;
    function IsCustomHintSupported: Boolean;
  end;

  IdxBarKeyTipWindowsManager = interface
  ['{ABA47F3E-5F8B-4A4B-863F-B70AC02F3C1D}']
    procedure Add(const ACaption: string; const ABasePoint: TPoint;
      AHorzAlign: TAlignment; AVertAlign: TcxAlignmentVert; AEnabled: Boolean;
      out AWindow: TObject);
    procedure Delete(AWindow: TObject);
    procedure Initialize;
    procedure Show;
  end;

  { IdxBarListener }

  IdxBarListener = interface
  ['{57FC7998-D189-47D9-9780-B56B4AC36812}']
    procedure BarVisibleChanged(ABar: TdxBar);
  end;

  { IdxBarComponentListener }

  IdxBarComponentListener = interface
  ['{5E594B1F-C8BD-479B-8A22-E2E04545D354}']
    procedure Changed(AComponent: TdxBarComponent);
    procedure EnabledChanged(AComponent: TdxBarComponent);
  end;

  { IdxBarManagerMergeOperationHandler }

  IdxBarManagerMergeOperationHandler = interface
  ['{B4B24468-7933-4935-B025-F7D4F21541CF}']
    procedure ProcessMergeOperation(ABarManager: TdxBarManager;
      AOperation: TdxBarMergeOperation; var AHandled: Boolean);
  end;

  { TdxBarKeyTipInfo }

  TdxBarKeyTipInfo = record
    KeyTip: string;
    BasePoint: TPoint;
    HorzAlign: TAlignment;
    VertAlign: TcxAlignmentVert;
    Visible: Boolean;
    Enabled: Boolean;
    OnExecute: TNotifyEvent;
  end;

  { TdxBarKeyTipData }

  TdxBarKeyTipData = class
  private
    FKeyTipInfo: TdxBarKeyTipInfo;
    FKeyTipWindow: TObject;
    function GetNormalizedKeyTip: string;
  public
    constructor Create(const AKeyTipInfo: TdxBarKeyTipInfo);
    procedure HideKeyTipWindow(AKeyTipWindowsManager: IdxBarKeyTipWindowsManager);
    procedure ShowKeyTipWindow(AKeyTipWindowsManager: IdxBarKeyTipWindowsManager);

    property BasePoint: TPoint read FKeyTipInfo.BasePoint;
    property Enabled: Boolean read FKeyTipInfo.Enabled;
    property HorzAlign: TAlignment read FKeyTipInfo.HorzAlign;
    property KeyTip: string read FKeyTipInfo.KeyTip write FKeyTipInfo.KeyTip;
    property NormalizedKeyTip: string read GetNormalizedKeyTip;
    property VertAlign: TcxAlignmentVert read FKeyTipInfo.VertAlign;
    property Visible: Boolean read FKeyTipInfo.Visible write FKeyTipInfo.Visible;
    property OnExecute: TNotifyEvent read FKeyTipInfo.OnExecute;
  end;

  { IdxBarAccessibilityHelper }

  IdxBarAccessibilityHelper = interface(IcxAccessibilityHelper)
  ['{5AE17753-A04D-4496-B5A3-08B2CEDE40F7}']
    function AreKeyTipsSupported(out AKeyTipWindowsManager: IdxBarKeyTipWindowsManager): Boolean;
    function CanNavigateToChildren(AKey: Word): Boolean;
    function CanUnselectOnKeyDown(AKey: Word; AKeyTipsWereHidden: Boolean): Boolean;
    function GetBarHelper: TdxBarAccessibilityHelper;
    function GetBarManager: TdxBarManager;
    function GetDefaultAccessibleObject: IdxBarAccessibilityHelper;
    function GetNextAccessibleObject(ADirection: TcxAccessibilityNavigationDirection): IdxBarAccessibilityHelper;
    function GetRootAccessibleObject: IdxBarAccessibilityHelper;
    function HandleNavigationKey(var AKey: Word): Boolean;
    function IsNavigationKey(AKey: Word): Boolean;
    function IsSelected: Boolean;
    function LogicalNavigationGetNextAccessibleObject(AShift: TShiftState): IdxBarAccessibilityHelper;
    procedure Select(ASetFocus: Boolean);
    procedure Unselect(ANextSelectedObject: IdxBarAccessibilityHelper);
  end;

  { IdxBarAccessibleObject }

  IdxBarAccessibleObject = interface
  ['{6411B5B8-FFF8-42BD-BFD4-0B53151C97DC}']
    function GetAccessibilityHelper: IdxBarAccessibilityHelper;
  end;

  { IdxSkin }

  IdxSkin = interface
  ['{ABCD2B3A-5F77-45A1-ADE2-3C028D4DB64C}']
    procedure DrawBackground(DC: HDC; const ARect: TRect; APart: Integer; AState: Integer = 0);
    procedure DrawBackgroundEx(DC: HDC; const ARect, AContentRect: TRect; APart: Integer; AState: Integer = 0);
    procedure DrawCaption(DC: HDC; const ACaption: string; const ARect: TRect; APart: Integer; AState: Integer = 0);
    function GetBarItemControlFadingOptions: TdxFadingOptions;
    function GetCaptionRect(const ARect: TRect; APart: Integer): TRect;
    function GetContentOffsets(APart: Integer): TRect;
    function GetIsAlphaUsed(APart: Integer): Boolean;
    function GetName: string;
    function GetPartColor(APart: Integer; AState: Integer = 0): TColor;
    function GetPartColorPalette(APart: Integer; AState: Integer = 0): IdxColorPalette;
    function GetPartSize(APart: Integer): Integer;
    function UseRoundedWindowCorners: Boolean;
  end;

  { IdxBarCustomItemLink }

  IdxBarCustomItemLink = interface
  ['{9C21B313-10BA-4FFB-B78E-A781223C1012}']
    procedure ProcessCustomizationPopup(ACustomizationPopupItemLinks: TdxBarItemLinks);
    function ProcessDragLineParameters(var ADragLineFirstPart, ADragOverBeginGroup: Boolean;
      var ADragLineRect: TRect): Boolean;
    procedure ProcessDroppedItemLink(ADroppedItemLink: TdxBarItemLink);
    function ProcessNeedDragLine(ADraggingItemLink: TdxBarItemLink;
      const ADragOverFirstPart, ADragOverBeginGroup: Boolean): Boolean;
  end;

  { TdxBarPersistent }

  TdxBarPersistent = class(TPersistent)
  private
    FBarManager: TdxBarManager;
  protected
    function GetOwner: TPersistent; override;
  public
    constructor Create(ABarManager: TdxBarManager); virtual;
    property BarManager: TdxBarManager read FBarManager;
  end;

  { TdxBarControlEditors }

  TdxBarControlEditor = class
  protected
    class function GetAddedItemClass(const AAddedItemName: string): TdxBarItemClass; virtual;
    class function GetPopupItemCaption: string; virtual;
    class procedure InitializePopupItem(AItemLink: TdxBarItemLink); virtual;
    class function PopupItemClass: TdxBarItemClass; virtual;

    class procedure AddItem(AClickedButton: TdxBarButton);
    class procedure InitializeAddedItem(AItemLink: TdxBarItemLink; AAddedItemName: string); virtual;
    class procedure OnButtonClick(Sender: TObject);
  public
    class procedure InitCustomizationPopup(AItemLinks: TdxBarItemLinks); virtual;
  end;
  TdxBarControlEditorClass = class of TdxBarControlEditor;

  TdxAddSubItemEditor = class(TdxBarControlEditor)
  protected
    class function GetAddedItemClass(const AAddedItemName: string): TdxBarItemClass; override;
    class function GetPopupItemCaption: string; override;
    class procedure InitializePopupItem(AItemLink: TdxBarItemLink); override;
    class function PopupItemClass: TdxBarItemClass; override;
  end;

  TdxAddButtonEditor = class(TdxAddSubItemEditor)
  protected
    class function GetAddedItemClass(const AAddedItemName: string): TdxBarItemClass; override;
    class function GetPopupItemCaption: string; override;
  end;

  TdxAddLargeButtonEditor = class(TdxAddSubItemEditor)
  protected
    class function GetAddedItemClass(const AAddedItemName: string): TdxBarItemClass; override;
    class function GetPopupItemCaption: string; override;
  end;

  TdxAddSeparatorEditor = class(TdxAddSubItemEditor)
  protected
    class function GetAddedItemClass(const AAddedItemName: string): TdxBarItemClass; override;
    class function GetPopupItemCaption: string; override;
  end;

  TdxItemsEditorEx = class(TdxBarControlEditor)
  protected
    class procedure InitSubItem(AItemLinks: TdxBarItemLinks); virtual;
    class function GetAddedItemClass(const AAddedItemName: string): TdxBarItemClass; override;
    class function GetPopupItemCaption: string; override;
    class procedure InitializePopupItem(AItemLink: TdxBarItemLink); override;
    class function PopupItemClass: TdxBarItemClass; override;
  end;

  { TdxBarCustomizingPopup }

  TdxChangeViewLevelAction = (vlaChangeLargeIconWithText, vlaChangeLargeControlOnly,
    vlaChangeSmallIconWithText, vlaChangeSmallIcon, vlaChangeControl,
    vlaSetAll,
    vlaSetLargeIconWithTextOnly, vlaSetLargeControlOnly, vlaSetSmallIconWithTextOnly, vlaSetSmallIconOnly, vlaSetControlOnly);

  TdxChangeButtonGroupAction = (bgaNone, bgaStart, bgaMember, bgaGroup, bgaUngroup);

  { TdxBarDesignController }

  TdxDesignState = (dsKeyAlreadyProcessed);
  TdxDesignStates = set of TdxDesignState;
  TInitPopupProc = procedure (AItemLinks: TdxBarItemLinks) of object;

  TdxBarDesignController = class(TcxDesignController)
  private
    FCustomizingBarControl: TCustomdxBarControl;
    FCustomizingBarManager: TdxBarManager;
    FCustomizingItemLink: TdxBarItemLink;
    FCustomizingItemLinks: TdxBarItemLinks;
    FInternalItems: TComponentList;
    FRegisteredBarControlDesignHelpers: TcxRegisteredClassList;
    FRegisteredBarControlEditors: TList;

    FLastSelectedItem: IdxBarSelectableItem;

    FCustomizationPopup: TdxBarInternalLinksOwner;
    FQuickControl: TdxBarPopupControl;
    FPrevQuickControlDestroy: TNotifyEvent;
    FToolbarsPopup: TdxBarInternalLinksOwner;

    FNotifyComponent: TcxFreeNotificator;

    function CanDeleteSelectedObjects: Boolean;
    procedure GetSelection(ASelection: TdxObjectList);
    function IsObjectUnbound(AObject: TObject; AMasterObjects: TdxObjectList): Boolean;
    procedure RemoveIrrelevantObjectsForDelete(ASelection: TdxObjectList; ADestruction: Boolean = False);

    procedure ClearOwnedItems(AItemLinks: TdxBarItemLinks);

    procedure CustomizeItemClick(Sender: TObject);

    // CustomizationPopup
    procedure TextItemChange(Sender: TObject);
    procedure CustomizationPopupCloseUp(Sender: TObject; AReason: TdxBarCloseUpReason);
    procedure CustomizationPopupItemClick(Sender: TObject);
    function GetBarControlDesignHelperClass: TCustomdxBarControlDesignHelperClass;
    procedure InitCustomizationPopup(AItemLinks: TdxBarItemLinks);
    procedure SynchronizeAction(ABasicAction: TdxBarCustomizationAction);
    procedure UpdateViewLevelsSubItemButtonStates(AItemLinks: TdxBarItemLinks);

    // ToolbarsPopup
    procedure ToolbarsPopupClick(Sender: TObject);

    // QuickControl
    procedure QuickControlDestroy(Sender: TObject);

    function CanCustomize(ABarManager: TdxBarManager; AIsKeyboardAction: Boolean): Boolean;
    procedure FindCustomizingBarManager;
    procedure SetLastSelectedItem(Value: IdxBarSelectableItem);

    procedure FreeNotification(AComponent: TComponent);
  protected
    FDesignStates: TdxDesignStates;
  public
    constructor Create;
    destructor Destroy; override;

    procedure AddCustomizeItem(AItemLinks: TdxBarItemLinks;
      AItemClass: TdxBarItemClass; ABeginGroup: Boolean = True);
    function AddInternalItem(AItemLinks: TdxBarItemLinks;
      AItemClass: TdxBarItemClass; ACaption: string; AOnClick: TNotifyEvent = nil;
      ATag: TcxTag = 0; ABeginGroup: Boolean = False): TdxBarItemLink; overload;
    procedure AddInternalItem(AItem: TdxBarItem; AList: TList = nil); overload;
    procedure ClearInternalItems;
    procedure RemoveItemFromBarManagerList(AItem: TdxBarItem);

    function AddItem(ABarItemClass: TdxBarItemClass): TdxBarItemLink;
    procedure SelectItemLink(AItemLink: TdxBarItemLink);

    procedure DesignerModified; overload;

    function IsCustomizedByPopup: Boolean;
    procedure RegisterBarControlDesignHelper(ABarControlClass: TCustomdxBarControlClass;
      AHelperClass: TCustomdxBarControlDesignHelperClass);
    procedure RegisterBarControlEditor(AEditor: TdxBarControlEditorClass);
    procedure UnregisterBarControlDesignHelper(ABarControlClass: TCustomdxBarControlClass;
      AHelperClass: TCustomdxBarControlDesignHelperClass);
    procedure UnregisterBarControlEditor(AEditor: TdxBarControlEditorClass);

    procedure DropSelection(ASelectableItem: IdxBarSelectableItem);
    function IsItemCustomized(ASelectableItem: IdxBarSelectableItem): Boolean;
    function IsItemLastSelected(ASelectableItem: IdxBarSelectableItem): Boolean;
    function IsItemLinkCustomized: Boolean;
    function IsItemSingleSelected(ASelectableItem: IdxBarSelectableItem): Boolean;
    function IsSelectionComplex(ABarManager: TdxBarManager): Boolean;
    function IsSelectionSingle(ABarManager: TdxBarManager): Boolean;
    function NeedDefaultSelection(ASelectableItem: IdxBarSelectableItem): Boolean;
    procedure SelectItem(ASelectableItem: IdxBarSelectableItem;
      ASelectionOperation: TdxBarSelectionOperation = soExclusive);
    procedure SelectObject(AObject: TPersistent;
      ASelectionOperation: TdxBarSelectionOperation = soExclusive);
    procedure SynchronizeLastSelectedItem;

    function DeleteSelectedObjects(ADestruction, AIsKeyboardAction: Boolean): Boolean;
    procedure DeleteCustomizingItem;
    procedure DeleteCustomizingItemLink;
    function SelectParentComponent: Boolean;

    function AddInternalBar(ABarManager: TdxBarManager): TdxBar;

    // CustomCustomizePopup
    procedure ShowCustomCustomizePopup(ABarManager: TdxBarManager;
      AInitPopupProc: TInitPopupProc; APainter: TdxBarPainter; APopupPoint: TPoint;
      ACustomizingBarControl: TCustomdxBarControl = nil; ACustomizingItemLink: TdxBarItemLink = nil); overload;
    procedure ShowCustomCustomizePopup(ABarManager: TdxBarManager;
      AInitPopupProc: TInitPopupProc; APainter: TdxBarPainter;
      ACustomizingBarControl: TCustomdxBarControl = nil; ACustomizingItemLink: TdxBarItemLink = nil); overload;
    // CustomizePopup
    procedure ShowCustomizePopup(ABarControl: TCustomdxBarControl;
      ACustomizingItemLink: TdxBarItemLink);
    procedure SetCustomizePopupTopMosts(AShow: Boolean);

    // ToolbarsPopup
    procedure InitToolBarPopup(AItemLinks: TdxBarItemLinks);
    procedure ShowToolbarsPopup(ABarManager: TdxBarManager; APainter: TdxBarPainter);

    // QuickControl
    procedure ShowQuickControl(ABarControl: TdxBarControl; const AOwnerRect: TRect); overload;
    procedure ShowQuickControl(AQuickControl: TdxBarPopupControl; APainter: TdxBarPainter; const ARect: TRect); overload;

    property CustomizingBarControl: TCustomdxBarControl read FCustomizingBarControl;
    property CustomizingItemLink: TdxBarItemLink read FCustomizingItemLink;
    property CustomizingBarManager: TdxBarManager read FCustomizingBarManager;
    property LastSelectedItem: IdxBarSelectableItem read FLastSelectedItem write SetLastSelectedItem;
    property QuickControl: TdxBarPopupControl read FQuickControl;
  end;

  { TdxBarComponent }

  TdxBarItemVisible = (ivNever, ivInCustomizing, ivAlways, ivNotInCustomizing);

  TdxBarComponent = class(TcxCustomComponent, IdxBarSelectableItem)
  protected
    FBarManager: TdxBarManager;
    FChangeNotifies: TInterfaceList;
    FEnabled: Boolean;
    FVisible: TdxBarItemVisible;

    procedure AddChangeNotify(AListener: IdxBarComponentListener);
    procedure RemoveChangeNotify(AListener: IdxBarComponentListener);
    procedure Changed(AllItems: Boolean = False); virtual;
    function GetEnabled: Boolean; virtual;
    function GetVisible: TdxBarItemVisible; virtual;
    procedure SetBarManager(Value: TdxBarManager); virtual;
    procedure SetEnabled(Value: Boolean); virtual;
    procedure SetVisible(Value: TdxBarItemVisible); virtual;

    // IdxBarSelectableItem
    function CanDelete(ADestruction: Boolean = False): Boolean; virtual;
    procedure DeleteSelection(var AReference: IdxBarSelectableItem; ADestruction: Boolean); virtual;
    procedure ExecuteCustomizationAction(ABasicAction: TdxBarCustomizationAction); virtual;
    function GetBarManager: TdxBarManager; virtual;
    function IdxBarSelectableItem.GetInstance = GetPersistentInstance;
    procedure GetMasterObjects(AList: TdxObjectList); virtual;
    function GetNextSelectableItem: IdxBarSelectableItem; virtual;
    function GetSelectableParent: TPersistent; virtual;
    function GetSelectionStatus: TdxBarSelectionStatus; virtual;
    function GetSupportedActions: TdxBarCustomizationActions; virtual;
    procedure Invalidate; virtual;
    function IsComplex: Boolean; virtual;
    function IsComponentSelected: Boolean; virtual;
    procedure SelectComponent(ASelectionOperation: TdxBarSelectionOperation = soExclusive); virtual;
    function SelectParentComponent: Boolean; virtual;
    procedure SelectionChanged; virtual;

    function GetPersistentInstance: TPersistent; virtual;
    function GetComponentInstance: TComponent; virtual;

    property Enabled: Boolean read GetEnabled write SetEnabled;
    property Visible: TdxBarItemVisible read GetVisible write SetVisible;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    property BarManager: TdxBarManager read GetBarManager write SetBarManager;
  end;

  { TdxList }

  TdxObjectList = class(TObjectList)
  private
    procedure AddFromList(ASource, AExcludedList: TList);
  protected
    procedure CopyList(ASource, ADestination: TList);
    function GetItem(AIndex: Integer): TObject;
  public
    constructor Create; overload;
    procedure Add(AObject: TObject);
    procedure AddList(AObjects: TList);
    procedure CopyFrom(ASource: TList);
    procedure CopyTo(ADestination: TList);
    procedure XorList(ASourceA, ASourceB: TList);
    function First: TObject;
    function Last: TObject;
  end;

  { TdxBarComponentList }

  TdxBarComponentList = class(TcxComponentList, IUnknown, IdxBarComponentListener)
  protected
    procedure DoNotify(AItem: TComponent; AAction: TListNotification); override;
    function GetItemClass: TClass; override;
    // IUnknown
    function _AddRef: Integer; stdcall;
    function _Release: Integer; stdcall;
    function QueryInterface(const IID: TGUID; out Obj): HRESULT; stdcall;
    // IdxBarComponentListener
    procedure IdxBarComponentListener.Changed = BarComponentChanged;
    procedure IdxBarComponentListener.EnabledChanged = BarComponentEnabledChanged;
    procedure BarComponentChanged(AComponent: TdxBarComponent);
    procedure BarComponentEnabledChanged(AComponent: TdxBarComponent);
  end;

  { TdxBarGroup }

  TdxBarGroup = class(TdxBarComponent)
  private
    FItems: TdxBarComponentList;
    FItemsNames: TStringList;
    function GetCount: Integer;
    function GetIndex: Integer;
    function GetItem(Index: Integer): TComponent;

    function InternalGetCount: Integer;
    function InternalGetItemName(Index: Integer): string;

    procedure SetIndex(Value: Integer);
    procedure ReadItems(Reader: TReader);
    procedure WriteItems(Writer: TWriter);
  protected
    procedure DefineProperties(Filer: TFiler); override;
    procedure Loaded; override;
    procedure SetName(const NewName: TComponentName); override;
    procedure SetEnabled(Value: Boolean); override;
    procedure SetVisible(Value: TdxBarItemVisible); override;
    property ItemList: TdxBarComponentList read FItems;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    function GetParentComponent: TComponent; override;
    function HasParent: Boolean; override;
    procedure SetParentComponent(AParent: TComponent); override;

    procedure Add(AItem: TdxBarComponent);
    procedure Delete(Index: Integer);
    function IndexOf(AItem: TdxBarComponent): Integer;
    procedure Move(FromIndex, ToIndex: Integer);
    procedure Remove(AItem: TdxBarComponent);

    property Count: Integer read GetCount;
    property Index: Integer read GetIndex write SetIndex;
    property Items[Index: Integer]: TComponent read GetItem; default;
  published
    property Enabled default True;
    property Visible default ivAlways;
  end;

  TdxBarPopupMenuLinkActionEvent = procedure(Sender: TdxBarPopupMenuLink; var X, Y: Integer;
    ClickedByMouse: Boolean; var AllowPopup: Boolean) of object;

  TdxBarPopupMenuLink = class(TCollectionItem)
  private
    FControl: TControl;
    FPopupMenu: TdxBarCustomPopupMenuComponent;
    FProcessChildren: Boolean;
    FWindowProcObject: TcxWindowProcLinkedObject;
    FOnAction: TdxBarPopupMenuLinkActionEvent;

    FPrevOnContextPopup: TContextPopupEvent;

    function GetBarManager: TdxBarManager;
    function GetWinControl: TWinControl;
    procedure SetControl(Value: TControl);
    procedure SetPopupMenu(Value: TdxBarCustomPopupMenuComponent);
    procedure ContextPopup(Sender: TObject; MousePos: TPoint; var Handled: Boolean);
    property WinControl: TWinControl read GetWinControl;
  protected
    function DoAction(AClientPopupPoint: TPoint): Boolean; overload;

    function IsShortCut(AShortCut: TShortCut): Boolean;
    procedure NewWndProc(var Message: TMessage);
  public
    constructor Create(Collection: TCollection); override;
    destructor Destroy; override;
    procedure Assign(Source: TPersistent); override;
    function DoAction(Wnd: HWND; const P: TPoint): Boolean; overload;
    property BarManager: TdxBarManager read GetBarManager;
  published
    property Control: TControl read FControl write SetControl;
    property PopupMenu: TdxBarCustomPopupMenuComponent read FPopupMenu write SetPopupMenu;
    property ProcessChildren: Boolean read FProcessChildren write FProcessChildren default True;
    property OnAction: TdxBarPopupMenuLinkActionEvent read FOnAction write FOnAction;
  end;

  TdxBarPopupMenuLinks = class(TCollection)
  private
    FBarManager: TdxBarManager;
    function GetItem(Index: Integer): TdxBarPopupMenuLink;
    procedure SetItem(Index: Integer; Value: TdxBarPopupMenuLink);
  protected
    function GetOwner: TPersistent; override;
    function IsShortCut(AControl: TWinControl; AShortCut: TShortCut): Boolean;
  public
    constructor Create(ABarManager: TdxBarManager);
    function Add: TdxBarPopupMenuLink;
    function DoAction(AControl: TWinControl; Wnd: HWND; const P: TPoint): Boolean;
    property BarManager: TdxBarManager read FBarManager;
    property Items[Index: Integer]: TdxBarPopupMenuLink read GetItem write SetItem; default;
  end;

  TdxBarBackgrounds = class(TdxBarPersistent)
  private
    FBarBackgroundBitmap: TBitmap;
    FSubMenuBackgroundBitmap: TBitmap;
    procedure BitmapChanged(Sender: TObject);
    procedure SetBarBackgroundBitmap(Value: TBitmap);
    procedure SetSubMenuBackgroundBitmap(Value: TBitmap);
  protected
    procedure Changed;
  public
    constructor Create(ABarManager: TdxBarManager); override;
    destructor Destroy; override;
    procedure Assign(Source: TPersistent); override;
  published
    property Bar: TBitmap read FBarBackgroundBitmap write SetBarBackgroundBitmap;
    property SubMenu: TBitmap read FSubMenuBackgroundBitmap write SetSubMenuBackgroundBitmap;
  end;

  TdxBarDockingStyle = (dsNone, dsLeft, dsTop, dsRight, dsBottom);
  TdxBarDockingStyles = set of TdxBarDockingStyle;
  TdxBarDockedDockingStyle = dsLeft..dsBottom;
  TdxBarManagerStyle = (bmsStandard, bmsEnhanced, bmsFlat, bmsXP, bmsOffice11, bmsUseLookAndFeel);
  TdxBarRealPaintStyle = (rpsStandard, rpsEnhanced, rpsFlat, rpsXP, rpsOffice11, rpsSkin);
  TdxBarMenuAnimations = (maNone, maRandom, maUnfold, maSlide, maFade);

  TdxBarEvent = procedure(Sender: TdxBarManager; ABar: TdxBar) of object;
  TdxBarItemLinkEvent = procedure(Sender: TdxBarManager; AItemLink: TdxBarItemLink) of object;
  TdxBarVisibleChangeEvent = procedure(Sender: TdxBarManager; ABar: TdxBar) of object;
  TdxBarCanDockingEvent = procedure(Sender: TdxBar; Style: TdxBarDockingStyle;
    DockControl: TdxDockControl; var CanDocking: Boolean) of object;
  TdxBarShowPopupEvent = procedure(Sender: TdxBarManager; PopupItemLinks: TdxBarItemLinks) of object;
  TdxBarClickItemEvent = procedure(Sender: TdxBarManager; ClickedItem: TdxBarItem) of object;
  TdxBarIniFileEvent = procedure(Sender: TObject; AIniFile: TCustomIniFile;
    const ADelimiter: string; const ASection: string) of object;
  TdxBarCloseUpEvent = procedure(Sender: TObject; AReason: TdxBarCloseUpReason) of object;
  TdxBarHandleKeyEvent = procedure(Sender: TObject; AKey: Word; AShift: TShiftState; var AHandled: Boolean) of object;

  TdxBarItemMergeKind = (mkAdd, mkMergeByCaption, mkNone);
  TdxBarStoringKind = (skIni, skReg);
  TdxBarMergeEvent = procedure(Sender, ChildBarManager: TdxBarManager; AddItems: Boolean) of object;
  TdxBarMenuMergeEvent = TdxBarMergeEvent;
  TdxBarMergeItemLinkEvent = procedure(Sender: TdxBarManager;
    ADstItemLinks, ASrcItemLinks: TdxBarItemLinks; ASrcItemLink: TdxBarItemLink;
    var AMergeKind: TdxBarItemMergeKind; var AMergeIndex: Integer) of object;

  TdxBarInternalState = (bisAfterLoading, bisBarsLoading, bisCreating, bisHandleCreating, bisModalActivating, bisFormActivating,
    bisToolbarsVisibleChanging, bisWasActive, bisStateSaving, bisStyleChanging, bisLoadingFromIni);
  TdxBarInternalStates = set of TdxBarInternalState;

  TdxBarMDIStateChange = (scChildActivated, scChildDeactivated, scMaximizedChanged);

  TdxBarDraggingState = (dsNoDrag, dsNoDrop, dsBeginGroup, dsCategory, dsCopy, dsDrag);

  TdxBarItemSeparatorInfo = record
    Bounds: TRect;
    Kind: TdxBarItemSeparatorKind;
  end;

  TdxBarIniFileEventData = record
    IniFile: TCustomIniFile;
    StoringKind: TdxBarStoringKind;
    BaseSection: string;
    Delimiter: string;
  end;

  TdxBarMDIStateChangeEventData = record
    Change: TdxBarMDIStateChange;
    Wnd: HWND;
  end;

  TCustomdxBarControlViewInfo = class
  private
    FItemControlViewInfos: TList;
    FSeparatorsData: array of TdxBarItemSeparatorData;
    function GetItemControlCount: Integer;
    function GetItemControlViewInfo(AIndex: Integer): TdxBarItemControlViewInfo;
    function GetSeparatorCount: Integer;
    function GetSeparatorInfo(AIndex: Integer): TdxBarItemSeparatorInfo;
    procedure SetSeparatorInfo(AIndex: Integer; const Value: TdxBarItemSeparatorInfo);
  protected
    FBarControl: TCustomdxBarControl;
    procedure AddItemControlViewInfo(AViewInfo: TdxBarItemControlViewInfo);
    procedure AddSeparatorInfo(const ARect: TRect; AKind: TdxBarItemSeparatorKind;
      AAssociatedItemControl: TdxBarItemControl);
    procedure Clear; virtual;
    procedure RemoveItemControlViewInfo(AViewInfo: TdxBarItemControlViewInfo);
    procedure RemoveSeparatorInfos;
  public
    constructor Create(ABarControl: TCustomdxBarControl); virtual;
    destructor Destroy; override;
    procedure Calculate; virtual;
    function GetItemControlIndex(AItemControl: TdxBarItemControl): Integer;
    function IsAssociatedWithSeparator(AItemControl: TdxBarItemControl;
      out ASeparatorIndex: Integer): Boolean;
    function IsItemControlVisible(AItemControl: TdxBarItemControl): Boolean;
    property BarControl: TCustomdxBarControl read FBarControl;
    property ItemControlCount: Integer read GetItemControlCount;
    property ItemControlViewInfos[AIndex: Integer]: TdxBarItemControlViewInfo read GetItemControlViewInfo;
    property SeparatorCount: Integer read GetSeparatorCount;
    property SeparatorInfos[AIndex: Integer]: TdxBarItemSeparatorInfo
      read GetSeparatorInfo write SetSeparatorInfo;
  end;

  TdxBarDragInfo = class
  private
    FBarManager: TdxBarManager;
    FLockCount: Integer;
    FModified: Boolean;

    FCaptureWnd: HWND;

    FDefaultCursor: TCursor;
    FDragDownPoint: TPoint;

    FDragLineVisible: Boolean;
    FDragLineBarControlLink: TcxObjectLink;
    FDragLineFirstPart: Boolean;
    FDragLineRect: TRect;
    FDragLineVerticalDirection: Boolean;

    FDraggingItem: TdxBarItem;
    FDraggingItemLink: TdxBarItemLink;
    FDraggingItemLinkParentHandle: HWND;
    FDraggingState: TdxBarDraggingState;

    FDragOverFirstPart: Boolean;
    FDragOverBeginGroup: Boolean;
    FDragOverVerticalDirection: Boolean;
    FDragOverBarControlLink: TcxObjectLink;
    FDragOverItemLink: TdxBarItemLink;

    procedure CalcDragOverItemParameters(var ACursorPos: TPoint);
    function CategoriesList: TListBox;
    procedure DragInfoChanged;
    procedure DrawDraggingLine(AVisible: Boolean);
    function HasTarget: Boolean;
    function NoNeedDragLine: Boolean;

    procedure ChangeBeginGroup;
    procedure CreateNewItemLink;
    procedure DeleteDraggingItemLink;
    procedure InternalDrawDraggingLine;
    procedure MoveItemToAnotherCategory;

    function GetDraggingControl: TdxBarItemControl;
    function GetDragLineBarControl: TCustomdxBarControl;
    function GetDragOverBarControl: TCustomdxBarControl;
    function GetDragOverBarItemLinks: TdxBarItemLinks;
    function GetDragOverItemControl: TdxBarItemControl;
    procedure SetDraggingState(Value: TdxBarDraggingState);
    procedure SetDragLineBarControl(Value: TCustomdxBarControl);
    procedure SetDragOverBarControl(Value: TCustomdxBarControl);
    procedure SetDragOverBeginGroup(Value: Boolean);
    procedure SetDragOverFirstPart(Value: Boolean);
    procedure SetDragOverVerticalDirection(Value: Boolean);
    procedure SetDragOverItemLink(Value: TdxBarItemLink);

    property DragLineBarControl: TCustomdxBarControl read GetDragLineBarControl write SetDragLineBarControl;
  protected
    function IsDragCopy: Boolean; virtual;
  public
    constructor Create(ABarManager: TdxBarManager);
    destructor Destroy; override;
    procedure BeginDrag(AItem: TdxBarItem; AItemLink: TdxBarItemLink);
    procedure DragDrop; virtual;
    procedure EndDrag;
    procedure HandleDragging;

    procedure BeginUpdate;
    procedure EndUpdate;

    property DraggingControl: TdxBarItemControl read GetDraggingControl;
    property DraggingItem: TdxBarItem read FDraggingItem write FDraggingItem;
    property DraggingItemLink: TdxBarItemLink read FDraggingItemLink write FDraggingItemLink;
    property DraggingState: TdxBarDraggingState read FDraggingState write SetDraggingState;

    property DragOverBeginGroup: Boolean read FDragOverBeginGroup write SetDragOverBeginGroup;
    property DragOverFirstPart: Boolean read FDragOverFirstPart write SetDragOverFirstPart;
    property DragOverVerticalDirection: Boolean read FDragOverVerticalDirection write SetDragOverVerticalDirection;

    property DragOverBarControl: TCustomdxBarControl read GetDragOverBarControl write SetDragOverBarControl;
    property DragOverBarItemLinks: TdxBarItemLinks read GetDragOverBarItemLinks;
    property DragOverItemControl: TdxBarItemControl read GetDragOverItemControl;
    property DragOverItemLink: TdxBarItemLink read FDragOverItemLink write SetDragOverItemLink;
    property DraggingItemLinkParentHandle: HWND read FDraggingItemLinkParentHandle write FDraggingItemLinkParentHandle;
  end;

  { TdxBarImageOptions }

  TdxBarImageOptions = class(TdxBarPersistent)
  private
    FDisabledImages: TCustomImageList;
    FDisabledLargeImages: TCustomImageList;
    FHotImages: TCustomImageList;
    FImages: TCustomImageList;
    FLargeImages: TCustomImageList;

    FImagesChangeLink: TChangeLink;
    FLargeImagesChangeLink: TChangeLink;
    FHotImagesChangeLink: TChangeLink;
    FDisabledImagesChangeLink: TChangeLink;
    FDisabledLargeImagesChangeLink: TChangeLink;

    FCacheGlyphs: Boolean;
    FGlyphSize: Integer;
    FImageListBkColor: TColor;
    FLargeIcons: Boolean;
    FMakeDisabledImagesFaded: Boolean;
    FSmoothGlyphs: Boolean;
    FStretchGlyphs: Boolean;
    FUseLargeImagesForLargeIcons: Boolean;
    FUseLeftBottomPixelAsTransparent: Boolean;

    FOnImageOptionsChange: TNotifyEvent;
    FOnLargeIconsChange: TNotifyEvent;

    FNotifyComponent: TcxFreeNotificator;

    function GetIsLoading: Boolean;
    procedure SetImageList(var ANewValue, AOldValue: TCustomImageList; const AChangeLink: TChangeLink);
    procedure SetHotImages(Value: TCustomImageList);
    procedure SetImageListBkColor(Value: TColor);
    procedure SetImages(Value: TCustomImageList);
    procedure SetDisabledImages(Value: TCustomImageList);
    procedure SetDisabledLargeImages(Value: TCustomImageList);
    procedure SetLargeIcons(Value: Boolean);
    procedure SetLargeImages(Value: TCustomImageList);
    procedure SetMakeDisabledImagesFaded(Value: Boolean);
    procedure SetUseLargeImagesForLargeIcons(Value: Boolean);
    procedure SetUseLeftBottomPixelAsTransparent(Value: Boolean);

    procedure CalcGlyphSize;
    function IsLargeImagesForLargeIcons: Boolean;
    procedure FreeNotification(AComponent: TComponent);
  protected
    function GetImages(AEnabled: Boolean; var ADrawImageEnabled: TdxDefaultBoolean): TCustomImageList;
    function GetImagesCore(AEnabled: Boolean; AImages, ADisabledImages: TCustomImageList; var ADrawImageEnabled: TdxDefaultBoolean): TCustomImageList;
    function GetLargeImages(AEnabled: Boolean; var ADrawImageEnabled: TdxDefaultBoolean): TCustomImageList;

    property IsLoading: Boolean read GetIsLoading;
  public
    constructor Create(ABarManager: TdxBarManager); override;
    destructor Destroy; override;
    procedure Assign(Source: TPersistent); override;
    property GlyphSize: Integer read FGlyphSize;
  published
    property CacheGlyphs: Boolean read FCacheGlyphs write FCacheGlyphs default True;
    property DisabledImages: TCustomImageList read FDisabledImages write SetDisabledImages;
    property DisabledLargeImages: TCustomImageList read FDisabledLargeImages write SetDisabledLargeImages;
    property HotImages: TCustomImageList read FHotImages write SetHotImages;
    property ImageListBkColor: TColor read FImageListBkColor write SetImageListBkColor default clFuchsia;
    property Images: TCustomImageList read FImages write SetImages;
    property LargeImages: TCustomImageList read FLargeImages write SetLargeImages;
    property LargeIcons: Boolean read FLargeIcons write SetLargeIcons default False;
    property MakeDisabledImagesFaded: Boolean read FMakeDisabledImagesFaded write SetMakeDisabledImagesFaded default False;
    property SmoothGlyphs: Boolean read FSmoothGlyphs write FSmoothGlyphs default False;
    property StretchGlyphs: Boolean read FStretchGlyphs write FStretchGlyphs default True;
    property UseLargeImagesForLargeIcons: Boolean read FUseLargeImagesForLargeIcons write SetUseLargeImagesForLargeIcons default False;
    property UseLeftBottomPixelAsTransparent: Boolean read FUseLeftBottomPixelAsTransparent write SetUseLeftBottomPixelAsTransparent default True;
  end;

  { TdxBarManagerPostMergeOperationInfo }

  TdxBarManagerPostMergeOperationInfo = class
  public
    ChildBarManager: TdxBarManager;
    Operation: TdxBarMergeOperation;
  end;

  { TdxBarManagerPostMergeOperationInfoList }

  TdxBarManagerPostMergeOperationInfoList = class(TcxObjectList)
  private
    function GetItem(AIndex: Integer): TdxBarManagerPostMergeOperationInfo;
  public
    procedure AddOrSet(AChildBarManager: TdxBarManager; AOperation: TdxBarMergeOperation);
    function Extract(AChildBarManager: TdxBarManager; out AOperation: TdxBarMergeOperation): Boolean;
    function Find(AChildBarManager: TdxBarManager): Integer;
    //
    property Items[Index: Integer]: TdxBarManagerPostMergeOperationInfo read GetItem; default;
  end;

  { TdxBarManagerMDIStateHelper }

  TdxBarManagerMDIStateHelper = class(TcxMessageWindow)
  private
    FBarManager: TdxBarManager;
    FChildStateChangeLockCount: Integer;
    FMainFormLocked: Boolean;
    FPostMergeOperations: TdxBarManagerPostMergeOperationInfoList;

    procedure DoChildStateChanged(AWnd: HWND; AChange: TdxBarMDIStateChange);
  protected
    procedure WndProc(var Message: TMessage); override;

    function GetMergingParameters(AChildWnd: HWND; AChildStateChange: TdxBarMDIStateChange;
      out AMergeOperation: TdxBarMergeOperation; out AChildBarManager: TdxBarManager): Boolean;
    function NeedMergeMDIChild(AChange: TdxBarMDIStateChange; AAlwaysMerge: Boolean): Boolean;
    function NeedUnmergeMDIChild(AChange: TdxBarMDIStateChange): Boolean;
    procedure NotifyMDIStateChangedHandlers(AChange: TdxBarMDIStateChange; AWnd: HWND);
    procedure UpdateSystemMenu(AChange: TdxBarMDIStateChange; AWnd: HWND);
  public
    constructor Create(ABarManager: TdxBarManager); reintroduce;
    destructor Destroy; override;
    //
    procedure BeginChildStateChanging;
    procedure CheckLockMainForm;
    procedure EndChildStateChanging;
    //
    procedure DoActiveChildChanged(const ANewActiveChild, AOldActiveChild: HWND);
    procedure DoActiveChildMaximizedChanged(const AActiveChild: HWND);
    //
    property BarManager: TdxBarManager read FBarManager;
    property PostMergeOperations: TdxBarManagerPostMergeOperationInfoList read FPostMergeOperations;
  end;

  TdxBarManagerUpdateActionsListener = class(TControl)
  private
    FBarManager: TdxBarManager;
    procedure CorrectPosition;
  public
    constructor Create(AOwner: TComponent); override;
    procedure InitiateAction; override;
  end;

  { TdxBarManager }

  TdxBarItemChangeProc = procedure (AItem: TdxBarItem) of object;
  TdxBarResetEvent = procedure(Sender: TdxBarManager; ABar: TdxBar; var AHandled: Boolean; var AShowConfirmation: Boolean) of object;

  TdxBarManager = class(TcxScalableComponent,
    IcxLookAndFeelContainer,
    IdxBarDesigner,
    IdxBarListener,
    IdxManager,
    IdxScreenTipProvider,
    IdxSkinSupport,
    IdxSystemInfoListener,
    IdxAdornerRootTargetElement)
  strict private
    FBiDiMode: TBiDiMode;
    FWindowProcObject: TcxWindowProcLinkedObject;
    function GetParentBidiMode: TBiDiMode;
    procedure CheckBidiMode;
    procedure OwnerWindowProc(var Message: TMessage);
  private
    FAllowCallFromAnotherForm: Boolean;
    FAllowReset: Boolean;
    FAlwaysMerge: Boolean;
    FAlwaysSaveText: Boolean;
    FAutoAlignBars: Boolean;
    FAutoDockColor: Boolean;
    FAutoHideEmptyBars: Boolean;
    FBackgrounds: TdxBarBackgrounds;
    FBarCaptionFont: TFont;
    FBarRestoringList: TList;
    FBars: TdxBars;
    FButtonArrowWidth: Integer;
    FCanCustomize: Boolean;
    FChangedSubMenuControl: TdxBarSubMenuControl;
    FCategories: TStrings;
    FCustomHintSupported: Boolean;
    FDefaultPainter: TdxBarPainter;
    FDesignerModifiedInvoked: Boolean;
    FIgnoreKeyStroke: Boolean;

    FReadingOldBars: Boolean;

    FDisabledToolBarsList: TList;
    FDockColor: TColor;
    FDockControls: TList;

    FDragInfo: TdxBarDragInfo;
    FImageOptions: TdxBarImageOptions;

    FEditFont: TFont;
    FFlatCloseButton: Boolean;
    FFlatToolbarsBorderBrush: HBRUSH;
    FFlatToolbarsBrush: HBRUSH;
    FFlatToolbarsDownedBrush: HBRUSH;
    FFlatToolbarsDownedSelBrush: HBRUSH;
    FFlatToolbarsSelBrush: HBRUSH;
    FFocusedBarControl: TCustomdxBarControl;
    FFont: TFont;

    FHelpButtonGlyph: TdxSmartGlyph;
    FHelpContext: THelpContext;
    FHideFloatingBarsWhenInactive: Boolean;
    FHintObject: TObject;
    FIniFileName: string;
    FInternalFontChange: Boolean;
    FInternalState: TdxBarInternalStates;
    FIsCustomizing: Boolean;

    FLargeButtonArrowWidth: Integer;
    FLockDesignerModifiedCount: Integer;
    FLockUpdate: Boolean;
    FLockUpdateCount: Integer;
    FLookAndFeel: TcxLookAndFeel;
    FMainFormActive: Boolean;
    FMainMenuBar: TdxBar;
    FMenuAnimations: TdxBarMenuAnimations;
    FMenusShowRecentItemsFirst: Boolean;
    FModified: Boolean;
    FMostRecentItemsPercents: Byte;
    FMostRecentlyUsedUseCount: Integer;
    FMouseTrackingBarControl: TCustomdxBarControl;
    FNewItems: TStringList;
    FNotDocking: TdxBarDockingStyles;
    FReadStateCount: Integer;
    FRegistryPath: string;
    FUpdateActionsListener: TdxBarManagerUpdateActionsListener;

    FGroups: TdxBarComponentList;
    FItems: TdxBarComponentList;
    FMDIChildSystemMenuItems: TComponentList;
    FOwnedObjects: TComponentList;
    FPopupMenuLinks: TdxBarPopupMenuLinks;
    FPopupMenus: TComponentList;

    FSelectedItem: TdxBarItemControl; // obsolete
    FChangingFocusedItemControlLockCount: Integer;
    FPrevFocusedControl: HWND;

    FShowCloseButton: Boolean;
    FShowFullMenusAfterDelay: Boolean;
    FShowHelpButton: Boolean;
    FShowHint: Boolean;
    FShowHintForDisabledItems: Boolean;
    FShowShortCutInHint: Boolean;
    FShortCut: string;
    FStoreInIniFile: Boolean;
    FStoreInRegistry: Boolean;
    FIniFileStream: TStream;
    FStyle: TdxBarManagerStyle;
    FSunkenBorder: Boolean;
    FThemeAvailable: Boolean;
    FThemeChangedNotificator: TdxThemeChangedNotificator;
    FThemeToolbarsBrush: HBRUSH;
    FUseBarHintWindow: Boolean;
    FUseF10ForMenu: Boolean;
    FUseFullReset: Boolean;
    FUseSystemFont: Boolean;
    FWaitForDockingTime: Integer;

    FIsMDIMaximized: Boolean;
    FPrevActiveMDIChild: HWND;
    FMDIStateHelper: TdxBarManagerMDIStateHelper;

    FSavedState: TMemoryStream;

    FOnBarAdd: TdxBarEvent;
    FOnBarAfterReset: TdxBarEvent;
    FOnBarBeforeReset: TdxBarEvent;
    FOnBarClose: TdxBarEvent;
    FOnBarDelete: TdxBarEvent;
    FOnBarDockingStyleChange: TdxBarEvent;
    FOnBarReset: TdxBarResetEvent;
    FOnBarVisibleChange: TdxBarVisibleChangeEvent;

    FOnItemLinkAdd: TdxBarItemLinkEvent;
    FOnItemLinkChange: TdxBarItemLinkEvent;
    FOnItemLinkDelete: TdxBarItemLinkEvent;
    FOnItemLinksChanged: TNotifyEvent;

    FOnAfterMerge: TdxBarMergeEvent;
    FOnBeforeMerge: TdxBarMergeEvent;
    FOnCloseButtonClick: TNotifyEvent;
    FOnDocking: TdxBarCanDockingEvent;
    FOnHelpButtonClick: TNotifyEvent;
    FOnHideCustomizingForm: TNotifyEvent;
    FOnMenuMerge: TdxBarMenuMergeEvent;
    FOnMerge: TdxBarMergeEvent;
    FOnMergeItemLink: TdxBarMergeItemLinkEvent;
    FOnShowCustomizingForm: TNotifyEvent;
    FOnShowCustomizingPopup: TdxBarShowPopupEvent;
    FOnShowToolbarsPopup: TdxBarShowPopupEvent;

    FOnClickItem: TdxBarClickItemEvent;
    FOnHandleKey: TdxBarHandleKeyEvent;

    FMDIStateChangedHandlers: TcxEventHandlerCollection;
    FMergeOperationHandlers: TInterfaceList;
    FReadIniFileHandlers: TcxEventHandlerCollection;
    FSystemFontChangedHandlers: TcxEventHandlerCollection;
    FWriteIniFileHandlers: TcxEventHandlerCollection;

    procedure InternalSetSelectedItem(Value: TdxBarItemControl);

    function GetBarControlFocused: Boolean;
    function GetBarsLoading: Boolean;
    function GetCanModifyDesigner: Boolean;
    function GetCategoryItemsVisible(AIndex: Integer): TdxBarItemVisible;
    function GetCategoryVisible(AIndex: Integer): Boolean;
    function GetDesigning: Boolean; inline;
    function GetDockColor: TColor;
    function GetDockControl(Index: Integer): TdxDockControl;
    function GetDockControlCount: Integer;
    function GetDragging: Boolean;
    function GetDraggingItem: TdxBarItem;
    function GetDraggingItemLink: TdxBarItemLink;
    function GetFlat: Boolean;
    function GetFlatToolbarsBorderColor: COLORREF;
    function GetFlatToolbarsColor: COLORREF;
    function GetFlatToolbarsDownedColor: COLORREF;
    function GetFlatToolbarsDownedSelColor: COLORREF;
    function GetFlatToolbarsSelColor: COLORREF;
    function GetGroup(Index: Integer): TdxBarGroup;
    function GetGroupCount: Integer;
    function GetInternalDockControl(ADockingStyle: TdxBarDockedDockingStyle): TdxDockControl;
    function GetIsCustomizing: Boolean; inline;
    function GetIsDestroying: Boolean;
    function GetIsHandleCreating: Boolean;
    function GetIsInitializing: Boolean;
    function GetIsLoading: Boolean;
    function GetIsRecreating: Boolean;
    function GetIsStateSaving: Boolean;
    function GetItemCount: Integer;
    function GetItem(Index: Integer): TdxBarItem;
    function GetLastSelectedLinkAtDesign: TdxBarItemLink;
    function GetMainForm: TCustomForm;
    function GetMainMenuControl: TdxBarControl;
    function GetMasterForm: TCustomForm;
    function GetNotDocking: TdxBarDockingStyles;
    function GetParentBarManager: TdxBarManager;
    function GetParentedOwner: TWinControl;
    function GetRestoringListBar(Index: Integer): TdxBar;
    function GetRestoringListBarCount: Integer;
    function GetScaled: Boolean;
    function GetTabOrder: Integer;
    procedure IniFileCollectionCallMethods(ACollection: TcxEventHandlerCollection;
      AIniFile: TCustomIniFile; AStoringKind: TdxBarStoringKind; ASection: string);
    function InternalGetPainterClass: TdxBarPainterClass;
    procedure SetAutoAlignBars(Value: Boolean);
    procedure SetAutoDockColor(Value: Boolean);
    procedure SetAutoHideEmptyBars(Value: Boolean);
    procedure SetBackgrounds(Value: TdxBarBackgrounds);
    procedure SetButtonArrowWidth(Value: Integer);
    procedure SetCategories(Value: TStrings);
    procedure SetCategoryItemsVisible(AIndex: Integer; Value: TdxBarItemVisible);
    procedure SetCategoryVisible(AIndex: Integer; Value: Boolean);
    procedure SetDockColor(Value: TColor);
    procedure SetFlatCloseButton(Value: Boolean);
    procedure SetFont(Value: TFont);
    procedure SetHelpButtonGlyph(Value: TdxSmartGlyph);
    procedure SetHideFloatingBarsWhenInactive(Value: Boolean);
    procedure SetDraggingItem(Value: TdxBarItem);
    procedure SetDraggingItemLink(Value: TdxBarItemLink);
    procedure SetLargeButtonArrowWidth(Value: Integer);
    procedure SetLockUpdate(Value: Boolean);
    procedure SetLookAndFeel(Value: TcxLookAndFeel);
    procedure SetMenuAnimations(Value: TdxBarMenuAnimations);
    procedure SetMenusShowRecentItemsFirst(Value: Boolean);
    procedure SetMostRecentItemsPercents(Value: Byte);
    procedure SetNotDocking(Value: TdxBarDockingStyles);
    procedure SetPopupMenuLinks(Value: TdxBarPopupMenuLinks);
    procedure SetRegistryPath(Value: string);
    procedure SetScaled(AValue: Boolean);
    procedure SetSelectedItem(Value: TdxBarItemControl);
    procedure SetShowCloseButton(Value: Boolean);
    procedure SetShowFullMenusAfterDelay(Value: Boolean);
    procedure SetShowHelpButton(Value: Boolean);
    procedure SetShowHint(Value: Boolean);
    procedure SetShowShortCutInHint(Value: Boolean);
    procedure SetStyle(Value: TdxBarManagerStyle);
    procedure SetSunkenBorder(Value: Boolean);
    procedure SetTabOrder(Value: Integer);
    procedure SetUseSystemFont(Value: Boolean);
    procedure SetWaitForDockingTime(Value: Integer);

  // ImageOptions begin
    function GetDisabledImages: TCustomImageList;
    function GetDisabledLargeImages: TCustomImageList;
    function GetHotImages: TCustomImageList;
    function GetImageListBkColor: TColor;
    function GetImages: TCustomImageList;
    function GetLargeImages: TCustomImageList;
    function GetLargeIcons: Boolean;
    function GetMainMenuBar: TdxBar;
    function GetMakeDisabledImagesFaded: Boolean;
    function GetStretchGlyphs: Boolean;
    function GetUseLargeImagesForLargeIcons: Boolean;
    procedure SetDisabledImages(Value: TCustomImageList);
    procedure SetDisabledLargeImages(Value: TCustomImageList);
    procedure SetHotImages(Value: TCustomImageList);
    procedure SetImageListBkColor(Value: TColor);
    procedure SetImages(Value: TCustomImageList);
    procedure SetLargeIcons(Value: Boolean);
    procedure SetLargeImages(Value: TCustomImageList);
    procedure SetMakeDisabledImagesFaded(Value: Boolean);
    procedure SetStretchGlyphs(Value: Boolean);
    procedure SetUseLargeImagesForLargeIcons(Value: Boolean);

    procedure DisabledImageListChange(Sender: TObject);
    procedure DisabledLargeImageListChange(Sender: TObject);
    procedure HotImageListChange(Sender: TObject);
    procedure ImageListChange(Sender: TObject);
    procedure ImageOptionsChange(Sender: TObject);
    procedure LargeIconsChange(Sender: TObject);
    procedure LargeImageListChange(Sender: TObject);
  // ImageOptions end

    function BarByNewName(const AName: string): TdxBar;
    procedure FontChanged(Sender: TObject);
    procedure CreateMDIChildSystemMenu(AWnd: HWND);
    procedure DestroyMDIChildSystemMenu;
    function IsMDIChildSystemMenuExist: Boolean;

    procedure CheckToolbarsVisibility;

    class function IsFormBroadcastMessage(AMsg: UINT): Boolean;
    function IsOwnerMDIChild(ARecursive: Boolean): Boolean;
    procedure MainFormClientWndProc(Msg: UINT; AWParam: WPARAM; ALParam: LPARAM);
    procedure OwnerWndProc(AWnd: HWND; AMsg: UINT; AWParam: WPARAM; ALParam: LPARAM);
    class procedure SendFormBroadcastMessage(AOwnerHandle: HWND; AMsg: UINT;
      AWParam: WPARAM; ALParam: LPARAM);

    procedure DisplayHint;
    procedure DoActivateHint(AShow: Boolean; const CustomHint: string; AHintObject: TObject = nil);
    function GetHideHintTime: Integer;
    function GetHintWindowClass: THintWindowClass;
    function GetShowHintTime: Integer;
    function GetHintKeeper: IdxBarHintKeeper;
    function IsHintActive: Boolean;

    procedure DestroyItems;
    procedure HelpButtonGlyphChanged(Sender: TObject);
    procedure CalcMostRecentlyUsedUseCount;
    function ShowRecentItemsFirst: Boolean;

    procedure AddDockControl(ADockControl: TdxDockControl);
    procedure RemoveDockControl(ADockControl: TdxDockControl);

    procedure AddGroup(AGroup: TdxBarGroup);

    function CorrectRegistryPath(var APath: string): Boolean;
    function GetSavedBarIndex(AState: TCustomIniFile; const ABarCaption: string): Integer;
    function IsDockColorStored: Boolean;
    function IsStyleStored: Boolean;
    procedure LoadLinkItemNames;
    procedure ReadBars(AReader: TReader);
    procedure ReadDockControlHeights(Reader: TReader);
    procedure WriteDockControlHeights(Writer: TWriter);

    procedure CreateFlatToolbarsBrushes;
    procedure DestroyFlatToolbarsBrushes;

    procedure CreateThemeToolbarsBrushes;
    procedure DestroyThemeToolbarsBrushes;
    procedure DestroyToolbarsBrushes;

    procedure CreateToolbarsBrushes;
    procedure RecreateToolbarsBrushes;
    procedure RefreshFloatingBarsShadows;
    procedure ResetBackgrounds;
    procedure InitPainter;
    procedure InternalStyleChanged;
    procedure ThemeChanged;
    procedure LFChanged(Sender: TcxLookAndFeel; AChangedValues: TcxLookAndFeelValues);

    procedure DoActivate(AState, AMinimized: WORD; AHandle, AWndPrevious: HWND);
    procedure DoActivateApp(AActivate: Boolean; AThreadID: DWORD);
    procedure DoCreate;
    procedure DoModalActivate;

    procedure DoLockUpdate(ALock, ACheckBarsChanges, ACancelUpdate: Boolean; ALockRedraw: Boolean = True);
    procedure DoBeginUpdate(ALockRedraw: Boolean);
    procedure DoCancelUpdate(ALockRedraw: Boolean);
    procedure DoEndUpdate(ACheckBarsChanges, ALockRedraw: Boolean);

    function DoHandleKey(AKey: Word; AShift: TShiftState): Boolean;
  protected
    FdxBarDesignHelper: IdxBarDesigner;

    procedure ChangeScale(M, D: Integer); override;
    procedure DefineProperties(Filer: TFiler); override;
    procedure GetAdornerTargetElements(AList: TStrings); override;
    procedure GetChildren(Proc: TGetChildProc; Root: TComponent); override;
    function GetChildOwner: TComponent; override;
    procedure Loaded; override;
    procedure Notification(AComponent: TComponent; Operation: TOperation); override;
    procedure ReadState(Reader: TReader); override;
    procedure SetChildOrder(Child: TComponent; Order: Integer); override;
    procedure SetName(const NewName: TComponentName); override;

    // IdxBarDesigner
    function CanDeleteComponent(AComponent: TComponent): Boolean;
    procedure GetSelection(AList: TList);
    function GetSelectionStatus(AComponent: TPersistent): TdxBarSelectionStatus;
    function IsComponentSelected(AComponent: TPersistent): Boolean;
    procedure SelectComponent(AComponent: TPersistent; ASelectionOperation: TdxBarSelectionOperation = soExclusive);
    procedure SetSelection(AList: TList);
    procedure ShowDefaultEventHandler(AItem: TdxBarItem);
    function UniqueName(const BaseName: string): string;

    procedure GetActiveSelection(AList: TList);
    procedure DesignerModified;
    procedure LockDesignerModified(ALock: Boolean;
      AInvokeDesignerModifiedOnUnlock: Boolean = True);

    procedure CreateBarRestoringList;
    procedure DestroyBarRestoringList;
    function BarRestoringListExists: Boolean;
    procedure AddBarToRestoringList(ABar: TdxBar);
    procedure RemoveBarFromRestoringList(ABar: TdxBar);
    procedure ShowBarsFromRestoringList(ADockControl: TdxBarDockControl);
    function GetBarIndexInRestoringList(ABar: TdxBar): Integer;
    property RestoringListBarCount: Integer read GetRestoringListBarCount;
    property RestoringListBars[Index: Integer]: TdxBar read GetRestoringListBar;

    procedure AssignFont;
    function CanReset: Boolean;
    procedure DoBarAfterReset(ABar: TdxBar); dynamic;
    procedure DoBarBeforeReset(ABar: TdxBar); dynamic;
    procedure DoBarClose(ABar: TdxBar); dynamic;
    procedure DoBarDockingStyleChanged(ABar: TdxBar); dynamic;
    procedure DoClickItem(AItem: TdxBarItem); virtual;
    procedure DoCloseButtonClick; dynamic;
    function DoDocking(ABar: TdxBar; AStyle: TdxBarDockingStyle;
      ADockControl: TdxDockControl): Boolean; virtual;

    procedure DoItemLinkAdd(AItemLink: TdxBarItemLink);
    procedure DoItemLinkChange(AItemLink: TdxBarItemLink);
    procedure DoItemLinkDelete(AItemLink: TdxBarItemLink);

    procedure DoHelpButtonClick; dynamic;
    procedure DoMergeItemLink(ADstItemLinks, ASrcItemLinks: TdxBarItemLinks;
      ASrcItemLink: TdxBarItemLink; var AMergeKind: TdxBarItemMergeKind;
      var AMergeIndex: Integer);
    function DoResetBar(ABar: TdxBar; var AShowConfirmation: Boolean): Boolean; virtual;
    procedure DoShowCustomizingPopup(PopupItemLinks: TdxBarItemLinks); dynamic;
    procedure DoShowToolbarsPopup(PopupItemLinks: TdxBarItemLinks); dynamic;
    procedure DragAndDrop(AItem: TdxBarItem; AItemLink: TdxBarItemLink);
    function FindDockControl(APath: string): TdxBarDockControl;
    function GetCategoryRealIndex(AIndex: Integer): Integer;
    function GetPainterClass: TdxBarPainterClass; virtual;
    procedure GetRealLookAndFeel(ALookAndFeel: TcxLookAndFeel);
    function GetRealPaintStyle: TdxBarRealPaintStyle;
    function GetWindowForMouseCapturing: HWND;

//    function IsLinkSelected(AItemLink: TdxBarItemLink): Boolean;
//    procedure SelectLink(AItemLink: TdxBarItemLink;
//      ASelectionOperation: TdxBarSelectionOperation = soExclusive);
//    procedure SynchronizeSelectedLink;

    // ImageOptions
    procedure CustomImagesChanged(AChangeProc: TdxBarItemChangeProc);
    procedure DisabledImagesChanged(AItem: TdxBarItem);
    procedure DisabledLargeImagesChanged(AItem: TdxBarItem);
    procedure HotImagesChanged(AItem: TdxBarItem);
    procedure ImagesChanged(AItem: TdxBarItem);
    function GetGlyphSize(AScaleFactor: TdxScaleFactor): Integer;
    function IsLargeImagesForLargeIcons: Boolean;
    procedure LargeImagesChanged(AItem: TdxBarItem);

    // IdxBarListener
    procedure BarVisibleChanged(ABar: TdxBar);

    // IcxLookAndFeelContainer
    function GetLookAndFeel: TcxLookAndFeel;

    // IdxScreenTipProvider
    function GetAction: TBasicAction;
    function GetScreenTip: TdxScreenTip;
    function GetShortCut: string;

    // IdxManager
    function GetParentForm: TCustomForm;

    // IdxSystemInfoListener
    procedure IdxSystemInfoListener.Changed = SystemInfoChanged;
    procedure SystemInfoChanged(AParameter: Cardinal);

    procedure ActivateFloatToolbars(AActivate, AForceOperation: Boolean; AActiveWindow: HWND);
    procedure DisableFloatToolBars;
    procedure EnableFloatToolBars;

    function IsInternalDockControl(ADockControl: TdxDockControl): Boolean;
    function IsUpdateLocked: Boolean;

    procedure ShowToolbars(AShow, AForceOperation: Boolean; AActiveWindow: HWND);
    procedure UpdateControlByMouse(ABarControl: TCustomdxBarControl);

    procedure CheckHintWindow;
    function IsCustomHintStyle: Boolean;

    function GetBarManagerSection(const ABaseSection: string; AStoringKind: TdxBarStoringKind): string;
    function GetBaseIniSection: string;
    procedure LoadBarManager(ASource: TCustomIniFile; const ASection: string; AStoringKind: TdxBarStoringKind);
    function ReadSavedState: TMemIniFile;
    procedure SaveBarManager(ADestination: TCustomIniFile; const ASection: string; AStoringKind: TdxBarStoringKind);
    procedure SaveState;

    function CreateBarAsByMerging: TdxBar;
    procedure DoAfterMerge(AChildBarManager: TdxBarManager; AOperation: TdxBarMergeOperation);
    procedure DoBeforeMerge(AChildBarManager: TdxBarManager; AOperation: TdxBarMergeOperation);
    procedure DoMenuMerging(AChildBarManager: TdxBarManager; AOperation: TdxBarMergeOperation);
    procedure DoMerge(AChildBarManager: TdxBarManager; AOperation: TdxBarMergeOperation);
    function DoProcessMergeOperation(AChildBarManager: TdxBarManager; AOperation: TdxBarMergeOperation): Boolean;
    procedure InternalUnmerge(ABarManager: TdxBarManager; AForCustomization: Boolean);
    procedure RestoreMergeState;

    procedure BeginMouseTracking(ABarControl: TCustomdxBarControl);
    procedure EndMouseTracking(ABarControl: TCustomdxBarControl);
    function IsMouseTracking(ABarControl: TCustomdxBarControl): Boolean;

    property BarControlFocused: Boolean read GetBarControlFocused;
    property GroupList: TdxBarComponentList read FGroups;
    property InternalState: TdxBarInternalStates read FInternalState;
    property ItemList: TdxBarComponentList read FItems;
    property LastSelectedLinkAtDesign: TdxBarItemLink read GetLastSelectedLinkAtDesign;
    property MDIStateHelper: TdxBarManagerMDIStateHelper read FMDIStateHelper;

    property DraggingItem: TdxBarItem read GetDraggingItem write SetDraggingItem;
    property DraggingItemLink: TdxBarItemLink read GetDraggingItemLink write SetDraggingItemLink;
    property Dragging: Boolean read GetDragging;
    property DragInfo: TdxBarDragInfo read FDragInfo;

    function IsOwnerVisible: Boolean;
    function IsParentFormAvailable: Boolean;
    function IsUncustomizable: Boolean;
    property FocusedBarControl: TCustomdxBarControl read FFocusedBarControl;
    property IsDestroying: Boolean read GetIsDestroying;
    property IsHandleCreating: Boolean read GetIsHandleCreating;
    property IsInitializing: Boolean read GetIsInitializing;
    property IsLoading: Boolean read GetIsLoading;
    property IsRecreating: Boolean read GetIsRecreating;
    property IsStateSaving: Boolean read GetIsStateSaving;
    property MainFormActive: Boolean read FMainFormActive;
    property SavedState: TMemoryStream read FSavedState;
    property TabOrder: Integer read GetTabOrder write SetTabOrder; // TODO make published, default 0

    property ReadingOldBars: Boolean read FReadingOldBars write FReadingOldBars;

    function CanAddComponents: Boolean;
    function GetLightColor(ABtnFaceColorPart, AHighlightColorPart, AWindowColorPart: Integer): COLORREF;
    property BarCaptionFont: TFont read FBarCaptionFont;
    property CanModifyDesigner: Boolean read GetCanModifyDesigner;
    property Flat: Boolean read GetFlat;
    property FlatToolbarsBorderBrush: HBRUSH read FFlatToolbarsBorderBrush;
    property FlatToolbarsBrush: HBRUSH read FFlatToolbarsBrush;
    property FlatToolbarsDownedBrush: HBRUSH read FFlatToolbarsDownedBrush;
    property FlatToolbarsDownedSelBrush: HBRUSH read FFlatToolbarsDownedSelBrush;
    property FlatToolbarsSelBrush: HBRUSH read FFlatToolbarsSelBrush;
    property FlatToolbarsBorderColor: COLORREF read GetFlatToolbarsBorderColor;
    property FlatToolbarsColor: COLORREF read GetFlatToolbarsColor;
    property FlatToolbarsDownedColor: COLORREF read GetFlatToolbarsDownedColor;
    property FlatToolbarsDownedSelColor: COLORREF read GetFlatToolbarsDownedSelColor;
    property FlatToolbarsSelColor: COLORREF read GetFlatToolbarsSelColor;
    property ThemeToolbarsBrush: HBRUSH read FThemeToolbarsBrush;
    property OnItemLinksChanged: TNotifyEvent read FOnItemLinksChanged write FOnItemLinksChanged;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;

    procedure ActivateHint(AShow: Boolean; const CustomHint: string; AHintObject: TObject = nil);
    procedure HideHint;
    function ActiveMDIChild: HWND;
    procedure DoMDIButtonCommand(AButton: TdxBarMDIButton);
    procedure BeginUpdate;
    procedure EndUpdate(ACheckBarsChanges: Boolean = True);
    function BarByCaption(const ACaption: string): TdxBar;
    function BarByComponentName(const AName: string): TdxBar;
    function BarByOldName(const AName: string): TdxBar;
//    function CheckBarName(const AName: string): string;
    function GetUniqueToolbarCaption(const ABaseName: string): string;
    function GetUniqueToolbarName(const ABaseName: string): string;
    function GetAllItemsByCategory(ACategory: Integer; List: TList): Integer;
    function GetCountByCategory(ACategory: Integer): Integer;
    function GetItemByCategory(ACategory, AIndex: Integer): TdxBarItem;
    function GetItemByName(const AName: string): TdxBarItem;
    function GetItemsByCategory(ACategory: Integer; List: TList): Integer;
    function GetUniqueItemName(ABarItemClass: TdxBarItemClass): string;
    function AddButton: TdxBarButton;
    function AddItem(AClass: TdxBarItemClass): TdxBarItem;
    function AddSubItem: TdxBarSubItem;
    function AddToolBar(AIsMainMenu: Boolean = False; ANeedEditCaption: Boolean = False): TdxBar;
    function CreateGroup: TdxBarGroup;
    procedure DeleteToolBar(ABar: TdxBar; AConfirmation: Boolean);
    procedure ExchangeItems(Index1, Index2: Integer);
//    procedure FocusItem(AItem: TdxBarItem);
    procedure MoveItem(CurIndex, NewIndex: Integer);
    procedure RenameToolBar(ABar: TdxBar);
    procedure ResetToolBar(ABar: TdxBar);

    procedure Merge(ABarManager: TdxBarManager; ACanCreateNewBar: Boolean = True);
    procedure Unmerge(ABarManager: TdxBarManager = nil);

    procedure Customizing(Show: Boolean);
    procedure HideAll;
    procedure ResetUsageData;
    procedure ResetUsageDataWithConfirmation;

    procedure LoadFromRegistry(ARegistryPath: string);
    procedure SaveToRegistry(ARegistryPath: string);
    procedure LoadFromIniFile(const AFileName: string);
    procedure SaveToIniFile(const AFileName: string);
    procedure LoadFromStream(AStream: TStream);
    procedure SaveToStream(AStream: TStream);

    function CanShowRecentItems: Boolean;
    function GetPaintStyle: TdxBarManagerStyle;
    procedure IgnoreKeyStroke;

    property Bars: TdxBars read FBars;
    property BarsLoading: Boolean read GetBarsLoading;
    property BiDiMode: TBiDiMode read FBiDiMode;
    property CategoryItemsVisible[AIndex: Integer]: TdxBarItemVisible read GetCategoryItemsVisible write SetCategoryItemsVisible;
    property CategoryVisible[AIndex: Integer]: Boolean read GetCategoryVisible write SetCategoryVisible;
    property DefaultPainter: TdxBarPainter read FDefaultPainter;
    property Designing: Boolean read GetDesigning;
    property DockControlCount: Integer read GetDockControlCount;
    property DockControls[Index: Integer]: TdxDockControl read GetDockControl;
    property GroupCount: Integer read GetGroupCount;
    property Groups[Index: Integer]: TdxBarGroup read GetGroup;
    property InternalDockControls[ADockingStyle: TdxBarDockedDockingStyle]: TdxDockControl read GetInternalDockControl;
    property IsCustomizing: Boolean read GetIsCustomizing;
    property ItemCount: Integer read GetItemCount;
    property Items[Index: Integer]: TdxBarItem read GetItem;
    property IsMDIMaximized: Boolean read FIsMDIMaximized;
    property LockUpdate: Boolean read FLockUpdate write SetLockUpdate;
    property MainForm: TCustomForm read GetParentForm; { obsolete }
    property MasterForm: TCustomForm read GetMasterForm;
    property MainMenuControl: TdxBarControl read GetMainMenuControl;
    property MainMenuBar: TdxBar read GetMainMenuBar;
    property Modified: Boolean read FModified write FModified;  // only for Standard style
    property Owner: TWinControl read GetParentedOwner;
    property PainterClass: TdxBarPainterClass read InternalGetPainterClass;
    property ParentBarManager: TdxBarManager read GetParentBarManager;
    property ParentForm: TCustomForm read GetParentForm;
    property SelectedItem: TdxBarItemControl read FSelectedItem write SetSelectedItem;

    property MDIStateChangedHandlers: TcxEventHandlerCollection read FMDIStateChangedHandlers;
    property MergeOperationHandlers: TInterfaceList read FMergeOperationHandlers;
    property ReadIniFileHandlers: TcxEventHandlerCollection read FReadIniFileHandlers;
    property SystemFontChangedHandlers: TcxEventHandlerCollection read FSystemFontChangedHandlers;
    property WriteIniFileHandlers: TcxEventHandlerCollection read FWriteIniFileHandlers;
  published
    property AllowCallFromAnotherForm: Boolean read FAllowCallFromAnotherForm
      write FAllowCallFromAnotherForm default False;
    property AllowReset: Boolean read FAllowReset write FAllowReset default True;
    property AlwaysMerge: Boolean read FAlwaysMerge write FAlwaysMerge default False;
    property AlwaysSaveText: Boolean read FAlwaysSaveText write FAlwaysSaveText default False;
    property AutoAlignBars: Boolean read FAutoAlignBars write SetAutoAlignBars default False;
    property AutoDockColor: Boolean read FAutoDockColor write SetAutoDockColor default True;
    property AutoHideEmptyBars: Boolean read FAutoHideEmptyBars write SetAutoHideEmptyBars default False;
    property Scaled: Boolean read GetScaled write SetScaled default True; // must be before Font
    property Font: TFont read FFont write SetFont; // must be before Bars
    property Backgrounds: TdxBarBackgrounds read FBackgrounds write SetBackgrounds;
    property ButtonArrowWidth: Integer read FButtonArrowWidth write SetButtonArrowWidth default dxBarDefaultButtonArrowWidth;
    property CanCustomize: Boolean read FCanCustomize write FCanCustomize default True;
    property Categories: TStrings read FCategories write SetCategories;
    property DockColor: TColor read GetDockColor write SetDockColor stored IsDockColorStored;
    property FlatCloseButton: Boolean read FFlatCloseButton write SetFlatCloseButton default False;
    property HelpButtonGlyph: TdxSmartGlyph read FHelpButtonGlyph write SetHelpButtonGlyph;
    property HelpContext: THelpContext read FHelpContext write FHelpContext default 0;
    property HideFloatingBarsWhenInactive: Boolean read FHideFloatingBarsWhenInactive write SetHideFloatingBarsWhenInactive default True;

    // ImageOptions
    property ImageOptions: TdxBarImageOptions read FImageOptions write FImageOptions;
    // obsolete
    property DisabledImages: TCustomImageList read GetDisabledImages write SetDisabledImages stored False;
    property DisabledLargeImages: TCustomImageList read GetDisabledLargeImages write SetDisabledLargeImages stored False;
    property HotImages: TCustomImageList read GetHotImages write SetHotImages stored False;
    property ImageListBkColor: TColor read GetImageListBkColor write SetImageListBkColor stored False;
    property Images: TCustomImageList read GetImages write SetImages stored False;
    property LargeImages: TCustomImageList read GetLargeImages write SetLargeImages stored False;
    property LargeIcons: Boolean read GetLargeIcons write SetLargeIcons stored False;
    property MakeDisabledImagesFaded: Boolean read GetMakeDisabledImagesFaded write SetMakeDisabledImagesFaded stored False;
    property StretchGlyphs: Boolean read GetStretchGlyphs write SetStretchGlyphs stored False;
    property UseLargeImagesForLargeIcons: Boolean read GetUseLargeImagesForLargeIcons write SetUseLargeImagesForLargeIcons stored False;

    property IniFileName: string read FIniFileName write FIniFileName;
    property LargeButtonArrowWidth: Integer read FLargeButtonArrowWidth write
      SetLargeButtonArrowWidth default dxBarDefaultLargeButtonArrowWidth;
    property LookAndFeel: TcxLookAndFeel read FLookAndFeel write SetLookAndFeel;
    property MenuAnimations: TdxBarMenuAnimations read FMenuAnimations
      write SetMenuAnimations default maNone;
    property MenusShowRecentItemsFirst: Boolean read FMenusShowRecentItemsFirst
      write SetMenusShowRecentItemsFirst default True;
    property MostRecentItemsPercents: Byte read FMostRecentItemsPercents
      write SetMostRecentItemsPercents default 95;
    property NotDocking: TdxBarDockingStyles read GetNotDocking write SetNotDocking default [];
    property PopupMenuLinks: TdxBarPopupMenuLinks read FPopupMenuLinks write SetPopupMenuLinks;
    property RegistryPath: string read FRegistryPath write SetRegistryPath;
    property ShowCloseButton: Boolean read FShowCloseButton write SetShowCloseButton default False;
    property ShowFullMenusAfterDelay: Boolean read FShowFullMenusAfterDelay
      write SetShowFullMenusAfterDelay default True;
    property ShowHelpButton: Boolean read FShowHelpButton write SetShowHelpButton default False;
    property ShowHint: Boolean read FShowHint write SetShowHint default True;
    property ShowHintForDisabledItems: Boolean read FShowHintForDisabledItems
      write FShowHintForDisabledItems default True;
    property ShowShortCutInHint: Boolean read FShowShortCutInHint
      write SetShowShortCutInHint default False;
    property StoreInIniFile: Boolean read FStoreInIniFile write FStoreInIniFile default False;
    property StoreInRegistry: Boolean read FStoreInRegistry write FStoreInRegistry default False;
    property Style: TdxBarManagerStyle read FStyle write SetStyle stored IsStyleStored;
    property SunkenBorder: Boolean read FSunkenBorder write SetSunkenBorder default False;
    property UseBarHintWindow: Boolean read FUseBarHintWindow write FUseBarHintWindow default True;
    property UseF10ForMenu: Boolean read FUseF10ForMenu write FUseF10ForMenu default True;
    property UseFullReset: Boolean read FUseFullReset write FUseFullReset default False;
    property UseSystemFont: Boolean read FUseSystemFont write SetUseSystemFont;
    property WaitForDockingTime: Integer read FWaitForDockingTime write SetWaitForDockingTime default 21;

    property OnBarAdd: TdxBarEvent read FOnBarAdd write FOnBarAdd;
    property OnBarAfterReset: TdxBarEvent read FOnBarAfterReset write FOnBarAfterReset;
    property OnBarBeforeReset: TdxBarEvent read FOnBarBeforeReset write FOnBarBeforeReset;
    property OnBarClose: TdxBarEvent read FOnBarClose write FOnBarClose;
    property OnBarDelete: TdxBarEvent read FOnBarDelete write FOnBarDelete;
    property OnBarDockingStyleChange: TdxBarEvent read FOnBarDockingStyleChange write FOnBarDockingStyleChange;
    property OnBarVisibleChange: TdxBarVisibleChangeEvent read FOnBarVisibleChange write FOnBarVisibleChange;

    property OnItemLinkAdd: TdxBarItemLinkEvent read FOnItemLinkAdd write FOnItemLinkAdd;
    property OnItemLinkChange: TdxBarItemLinkEvent read FOnItemLinkChange write FOnItemLinkChange;
    property OnItemLinkDelete: TdxBarItemLinkEvent read FOnItemLinkDelete write FOnItemLinkDelete;
    property OnMergeItemLink: TdxBarMergeItemLinkEvent read FOnMergeItemLink write FOnMergeItemLink;

    property OnAfterMerge: TdxBarMergeEvent read FOnAfterMerge write FOnAfterMerge;
    property OnBeforeMerge: TdxBarMergeEvent read FOnBeforeMerge write FOnBeforeMerge;
    property OnCloseButtonClick: TNotifyEvent read FOnCloseButtonClick write FOnCloseButtonClick;
    property OnDocking: TdxBarCanDockingEvent read FOnDocking write FOnDocking;
    property OnHelpButtonClick: TNotifyEvent read FOnHelpButtonClick write FOnHelpButtonClick;
    property OnHideCustomizingForm: TNotifyEvent read FOnHideCustomizingForm write FOnHideCustomizingForm;
    property OnMenuMerge: TdxBarMenuMergeEvent read FOnMenuMerge write FOnMenuMerge;
    property OnMerge: TdxBarMergeEvent read FOnMerge write FOnMerge;
    property OnBarReset: TdxBarResetEvent read FOnBarReset write FOnBarReset;
    property OnShowCustomizingForm: TNotifyEvent read FOnShowCustomizingForm write FOnShowCustomizingForm;
    property OnShowCustomizingPopup: TdxBarShowPopupEvent read FOnShowCustomizingPopup write FOnShowCustomizingPopup;
    property OnShowToolbarsPopup: TdxBarShowPopupEvent read FOnShowToolbarsPopup write FOnShowToolbarsPopup;

    property OnClickItem: TdxBarClickItemEvent read FOnClickItem write FOnClickItem;
    property OnHandleKey: TdxBarHandleKeyEvent read FOnHandleKey write FOnHandleKey;
  end;

  { TdxBarManagerList }

  TdxBarManagerList = class(TObjectList)
  private
    function GetBarManager(Index: Integer): TdxBarManager;
    function GetCustomizingBarManager: TdxBarManager;
  public
    destructor Destroy; override;
    function NextActive(ABarManager: TdxBarManager; AGoForward: Boolean): TdxBarManager;
    //
    property BarManagers[Index: Integer]: TdxBarManager read GetBarManager; default;
    property CustomizingBarManager: TdxBarManager read GetCustomizingBarManager;
  end;

  TdxBarBorderStyle = (bbsNone, bbsSingle);
  TdxBarStaticBorderStyle = (sbsNone, sbsLowered, sbsRaised, sbsEtched, sbsBump);
  TdxBarSpinEditButton = (sbNone, sbUp, sbDown);
  TdxBarSpinEditButtons = set of TdxBarSpinEditButton;

  { TdxBarCustomMergeData }

  TdxBarCustomMergeData = class
  private
    FFreeNotificator: TcxFreeNotificator;
  protected
    procedure FreeNotification(Sender: TComponent); virtual; abstract;
    //
    property FreeNotificator: TcxFreeNotificator read FFreeNotificator;
  public
    CreatedByMerging: Boolean;
    VisibleBeforeMerging: Boolean;
    constructor Create; virtual;
    destructor Destroy; override;
  end;

  { TdxBarMergeData }

  TdxBarMergeData = class(TdxBarCustomMergeData)
  private
    FMergedBarList: TList;
    FSavedMergedBarList: TList;
    function GetSavedMergedBar(AIndex: Integer): TdxBar;
    function GetSavedMergedBarListCount: Integer;
    procedure SetFreeNotifications;
  protected
    procedure FreeNotification(Sender: TComponent); override;
  public
    CreatedByMergingBarVisibleBeforeCustomization: Boolean;
    MergedWith: TdxBar;
    constructor Create; override;
    destructor Destroy; override;
    procedure ClearSavedMergedBarList;
    procedure SaveMergedBarList(AList: TList = nil);
    property MergedBarList: TList read FMergedBarList;
    property SavedMergedBarCount: Integer read GetSavedMergedBarListCount;
    property SavedMergedBars[AIndex: Integer]: TdxBar read GetSavedMergedBar;
  end;

  { TdxBarAccessibilityHelper }

  TdxBarAccessibilityHelper = class(TcxAccessibilityHelper, IdxBarAccessibilityHelper)
  private
    function InternalGetChild(AIndex: Integer): TdxBarAccessibilityHelper;
    function InternalGetParent: TdxBarAccessibilityHelper;
  protected
    // IcxAccessibilityHelper
    procedure OwnerObjectDestroyed; override;

    // IdxBarAccessibilityHelper
    function AreKeyTipsSupported(out AKeyTipWindowsManager: IdxBarKeyTipWindowsManager): Boolean; virtual;
    function CanNavigateToChildren(AKey: Word): Boolean; virtual;
    function CanUnselectOnKeyDown(AKey: Word; AKeyTipsWereHidden: Boolean): Boolean; virtual;
    function GetBarHelper: TdxBarAccessibilityHelper;
    function GetBarManager: TdxBarManager; virtual;
    function GetDefaultAccessibleObject: IdxBarAccessibilityHelper; virtual;
    function GetNextAccessibleObject(ADirection: TcxAccessibilityNavigationDirection): IdxBarAccessibilityHelper; overload; virtual;
    function GetRootAccessibleObject: IdxBarAccessibilityHelper;
    function HandleNavigationKey(var AKey: Word): Boolean; virtual;
    function IsNavigationKey(AKey: Word): Boolean; virtual;
    function IsSelected: Boolean;
    function LogicalNavigationGetNextAccessibleObject(AShift: TShiftState): IdxBarAccessibilityHelper; virtual;
    procedure Select(ASetFocus: Boolean); virtual;
    procedure Unselect(ANextSelectedObject: IdxBarAccessibilityHelper); virtual;

    procedure GetChildrenForNavigation(ASelectedObject, AParentObject: TdxBarAccessibilityHelper;
      const ASelectedObjectScreenBounds: TRect; ADirection: TcxAccessibilityNavigationDirection;
      AAreOnlyNearObjectsAccepted: Boolean; AObjects: TList);

    procedure GetChilds(AChilds: TList; AOnlyVisible: Boolean = True);

    function GetAssignedKeyTip: string; virtual; abstract;
    function GetDefaultKeyTip: string; virtual; abstract;
    function GetKeyTip: string; virtual;

    function CreateKeyTipData: TdxBarKeyTipData; virtual;
    procedure GetKeyTipInfo(out AKeyTipInfo: TdxBarKeyTipInfo); virtual;
    procedure GetKeyTipData(AKeyTipsData: TList); virtual;
    procedure DoGetKeyTipsData(AKeyTipsData: TList); virtual;
    procedure GetKeyTipsData(AKeyTipsData: TList);
    procedure GenerateUniqueKeyTips(AKeyTipsData: TList);

    function GetParentForKeyTip: TdxBarAccessibilityHelper; virtual;
    function IsKeyTipContainer: Boolean; virtual;
    procedure KeyTipHandler(Sender: TObject); virtual;
    procedure KeyTipsEscapeHandler; virtual;
    function LogicalNavigationGetChild(AIndex: Integer): TdxBarAccessibilityHelper; virtual;
    function LogicalNavigationGetChildCount: Integer; virtual;
    function LogicalNavigationGetChildIndex(AChild: TdxBarAccessibilityHelper): Integer; virtual;
    function LogicalNavigationGetNextChild(AChildIndex: Integer; AGoForward: Boolean): TdxBarAccessibilityHelper; overload;
    function LogicalNavigationGetNextChild(AChildIndex: Integer; AShift: TShiftState): TdxBarAccessibilityHelper; overload; virtual;
    property ParentForKeyTip: TdxBarAccessibilityHelper read GetParentForKeyTip;
  public
    function GetDefaultSelectableObject(ADirection: TcxAccessibilityNavigationDirection): IdxBarAccessibilityHelper; virtual;
    function GetFirstSelectableObject: TdxBarAccessibilityHelper;
    //
    property BarManager: TdxBarManager read GetBarManager;
    property Childs[AIndex: Integer]: TdxBarAccessibilityHelper read InternalGetChild;
    property Parent: TdxBarAccessibilityHelper read InternalGetParent;
  end;

  TdxBarAccessibilityHelperClass = class of TdxBarAccessibilityHelper;

  { TdxBarCaptionButton }

  TdxBarCaptionButton = class(TcxInterfacedCollectionItem, IdxBarHintKeeper)
  private
    FEnabled: Boolean;
    FGlyph: TBitmap;
    FHint: string;
    FIAccessibilityHelper: IdxBarAccessibilityHelper;
    FKeyTip: string;
    FNotifyComponent: TcxFreeNotificator;
    FRect: TRect;
    FScreenTip: TdxScreenTip;
    FState: Integer;
    FOnClick: TNotifyEvent;
    function GetCollection: TdxBarCaptionButtons;
    function GetIAccessibilityHelper: IdxBarAccessibilityHelper;
    function GetParent: TdxBarControl;
    procedure GlyphChanged(Sender: TObject);
    procedure SetEnabled(Value: Boolean);
    procedure SetGlyph(Value: TBitmap);
    procedure SetScreenTip(Value: TdxScreenTip);
    procedure SetState(Value: Integer);
    procedure SetOnClick(Value: TNotifyEvent);

    procedure FreeNotification(AComponent: TComponent);

    property Parent: TdxBarControl read GetParent;
  protected
    FCreatedFromMergingWith: TdxBarCaptionButtons;
    function GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass; virtual;
    procedure Merge(AButton: TdxBarCaptionButton); virtual;
    procedure Unmerge(AButtons: TdxBarCaptionButtons = nil); virtual;
    // IdxBarHintKeeper
    function DoHint(var ANeedDeactivate: Boolean; out AHintText: string; out AShortCut: string): Boolean;
    function CreateHintViewInfo(const AHintText, AShortCut: string): TdxBarCustomHintViewInfo;
    function GetEnabled: Boolean;
    function GetHintPosition(const ACursorPos: TPoint; AHeight: Integer): TPoint;
  public
    constructor Create(Collection: TCollection); override;
    destructor Destroy; override;
    procedure Assign(Source: TPersistent); override;
    procedure Click;
    property Collection: TdxBarCaptionButtons read GetCollection;
    property Glyph: TBitmap read FGlyph write SetGlyph;
    property IAccessibilityHelper: IdxBarAccessibilityHelper read GetIAccessibilityHelper;
    property Rect: TRect read FRect write FRect;
    property State: Integer read FState write SetState;
  published
    property Enabled: Boolean read FEnabled write SetEnabled default True;
    property Hint: string read FHint write FHint;
    property KeyTip: string read FKeyTip write FKeyTip;
    property ScreenTip: TdxScreenTip read FScreenTip write SetScreenTip;
    property OnClick: TNotifyEvent read FOnClick write SetOnClick;
  end;

  { TdxBarCaptionButtons }

  TdxBarCaptionButtons = class(TcxOwnedInterfacedCollection)
  private
    FIAccessibilityHelper: IdxBarAccessibilityHelper;
    function GetBar: TdxBar;
    function GetIAccessibilityHelper: IdxBarAccessibilityHelper;
    function GetItem(Index: Integer): TdxBarCaptionButton;
    function GetRect: TRect;
    procedure SetItem(Index: Integer; Value: TdxBarCaptionButton);
  protected
    function GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass; virtual;
    function GetButtonIndex(const APoint: TPoint): Integer;
    procedure Merge(AButtons: TdxBarCaptionButtons); virtual;
    procedure Unmerge(AButtons: TdxBarCaptionButtons = nil); virtual;
  public
    constructor Create(ABar: TdxBar);
    destructor Destroy; override;
    function Add: TdxBarCaptionButton;
    procedure UpdateButtonStates(const AMousePos: TPoint; AMousePressed: Boolean = False);
    property Bar: TdxBar read GetBar;
    property IAccessibilityHelper: IdxBarAccessibilityHelper read GetIAccessibilityHelper;
    property Items[Index: Integer]: TdxBarCaptionButton read GetItem write SetItem; default;
    property Rect: TRect read GetRect;
  end;

  { TdxBar }

  TdxBar = class(TcxComponentCollectionItem,
    IdxBarSelectableItem,
    IdxBarLinksOwner,
    IdxScaleFactor)
  private
    FAllowClose: Boolean;
    FAllowCustomizing: Boolean;
    FAllowQuickCustomizing: Boolean;
    FAllowReset: Boolean;
    FAlphaBlendValue: Byte;
    FBackgroundBitmap: TBitmap;
    FBorderStyle: TdxBarBorderStyle;
    FCaption: string;
    FCaptionButtons: TdxBarCaptionButtons;
    FChanged: Boolean;
    FColor: TColor;
    FChangingDockingStyle: Boolean;
    FDockControl: TdxBarDockControl;
    FDockedDockControl: TdxBarDockControl;
    FDockedDockingStyle: TdxBarDockingStyle;
    FDockedLeft: Integer;
    FDockedTop: Integer;
    FDockingStyle: TdxBarDockingStyle;
    FDockRow: TdxDockRow;
    FEditFont: TFont;
    FFloatLeft: Integer;
    FFloatTop: Integer;
    FFloatClientWidth: Integer;
    FFloatClientHeight: Integer;
    FFont: TFont;
    FFreeNotificationItems: TList;
    FGlyph: TdxSmartGlyph;
    FHidden: Boolean;  // if True, then doesn't show in customizing form in run-time
    FInternalFontChange: Boolean;
    FInternallyHidden: Boolean;
    FIsMainMenu: Boolean;
    FIsPredefined: Boolean;
    FItemLinks: TdxBarItemLinks;
    FKeyTip: string;
    FListeners: TInterfaceList;
    FLoadedDockControl: TdxBarDockControl;
    FLoadedDockingStyle: TdxBarDockingStyle;
    FLoadedVisible: Boolean;
    FLockUpdate: Boolean;
    FMergeData: TdxBarMergeData;
    FNeedUpdateControlPosition: Boolean;
    FNotDocking: TdxBarDockingStyles;
    FMultiLine: Boolean;
    FOneOnRow: Boolean;
    FOldName: string;
    FRotateWhenVertical: Boolean;
    FRow: Integer;
    FScaleFactor: TdxScaleFactor;
    FShouldNotBeDestroyedIfEmptyAfterUnmerge: Boolean;
    FShowMark: Boolean;
    FSizeGrip: Boolean;
    FUseOwnFont: Boolean;
    FUseRestSpace: Boolean;
    FVisible: Boolean;  // is it currently visible or not?
    FWholeRow: Boolean;
    FOnDestroy: TNotifyEvent;


    procedure BitmapChanged(Sender: TObject);
    procedure DoDestroy;
    function GetBars: TdxBars;
    function GetControl: TdxBarControl;
    function GetDockControl: TdxBarDockControl;
    function GetDockedDockingStyle: TdxBarDockingStyle;
    function GetDockingStyle: TdxBarDockingStyle;
    function GetNext: TdxBar;
    function GetNotDocking: TdxBarDockingStyles;
    function GetPainter: TdxBarPainter;
    function GetRealDockControl: TdxDockControl;
    function GetRow: Integer;
    function GetUseRecentItems: Boolean;
    function GetVisible: Boolean;
    procedure GlyphChanged(Sender: TObject);
    procedure SetAllowClose(Value: Boolean);
    procedure SetAllowQuickCustomizing(Value: Boolean);
    procedure SetAlphaBlendValue(Value: Byte);
    procedure SetBackgroundBitmap(Value: TBitmap);
    procedure SetBorderStyle(Value: TdxBarBorderStyle);
    procedure SetCaption(Value: string);
    procedure SetCaptionButtons(Value: TdxBarCaptionButtons);
    procedure SetColor(Value: TColor);
    procedure SetDockControl(Value: TdxBarDockControl);
    procedure SetDockedDockControl(Value: TdxBarDockControl);
    procedure SetDockedValue(Index: Integer; Value: Integer);
    procedure SetDockingStyle(Value: TdxBarDockingStyle);
    procedure SetDockRow(Value: TdxDockRow);
    procedure SetFloatValue(Index: Integer; Value: Integer);
    procedure SetFont(Value: TFont);
    procedure SetGlyph(Value: TdxSmartGlyph);
    procedure SetHidden(Value: Boolean);
    procedure SetIsMainMenu(Value: Boolean);
    procedure SetItemLinks(Value: TdxBarItemLinks);
    procedure SetImages(AImages: TCustomImageList);
    procedure SetLockUpdate(Value: Boolean);
    procedure SetMultiLine(Value: Boolean);
    procedure SetNotDocking(Value: TdxBarDockingStyles);
    procedure SetOneOnRow(Value: Boolean);
    procedure SetRotateWhenVertical(Value: Boolean);
    procedure SetRow(Value: Integer);
    procedure SetShowMark(Value: Boolean);
    procedure SetSizeGrip(Value: Boolean);
    procedure SetUseOwnFont(Value: Boolean);
    procedure SetUseRecentItems(Value: Boolean);
    procedure SetUseRestSpace(Value: Boolean);
    procedure SetVisible(Value: Boolean);
    procedure SetWholeRow(Value: Boolean);

    procedure FontChanged(Sender: TObject);

    procedure ReadPixelsPerInch(Reader: TReader);
    procedure WritePixelsPerInch(Writer: TWriter);
    procedure UpdateControlPosition;
    procedure UpdateFloatingControlPosition;

    function IsDockedDockingStyleStored: Boolean;
    function IsDockingStyleStored: Boolean;
  protected
    procedure AddFreeNotification(AItem: TdxBarItem);
    procedure MakeFreeNotification;
    procedure RemoveFreeNotification(AItem: TdxBarItem);

    procedure DefineProperties(Filer: TFiler); override;
    procedure DoReset;
    procedure RemoveFromDockRow(ADestroyEmptyDockRow: Boolean);
    procedure SetCollection(AValue: TcxComponentCollection); override;
    procedure SetName(const NewName: TComponentName); override;
    procedure Updated; override;
    procedure Updating; override;

    function CreateControl: TdxBarControl;
    function GetControlClass: TdxBarControlClass; virtual;
    procedure ShowControl;

    class function GetIniSection(const ABaseSection: string; ABarIndex: Integer): string;
    procedure LoadFromIni(ASource: TCustomIniFile; const ABaseSection: string;
      ABarIndex: Integer; AStoringKind: TdxBarStoringKind; AFullLoad: Boolean = True);
    procedure LoadUsageData(ASource: TCustomIniFile; const ABaseSection: string; ABarIndex: Integer);
    procedure SaveToIni(ADestination: TCustomIniFile; const ABaseSection: string; ABarIndex: Integer; AStoringKind: TdxBarStoringKind);

    procedure InternalUpdateFont;

    procedure InternalMerge(ABar: TdxBar; ASaveMergingBarVisibility: Boolean);
    procedure InternalUnmergeFromBar(ABar: TdxBar; ARestoreMergedBarsVisibility: Boolean);
    procedure InternalUnmergeFromBarManager(ABarManager: TdxBarManager; ARestoreMergedBarsVisibility: Boolean);
    procedure RestoreMergeState;
    procedure SaveMergeState;
    procedure SetVisibility(Value: Boolean);

    procedure CaptionButtonsNotification(Sender: TObject; AItem: TCollectionItem); virtual;
    procedure DoChanged;
    procedure DoVisibleChanged;

    procedure NotifyListenersBarVisibilityChanged;

    function BarNCSizeX(AStyle: TdxBarDockingStyle): Integer;
    function BarNCSizeY(AStyle: TdxBarDockingStyle): Integer;
    function CanClose: Boolean;
    function CanMoving: Boolean;
    function CanReset: Boolean;
    function GetDockedPosition: Integer;
    function HasSizeGrip: Boolean;
    function IsFloat: Boolean;
    function IsShortCut(AShortCut: TShortCut): Boolean;
    function IsStatusBar: Boolean;

    // IdxBarSelectableItem
    function CanDelete(ADestruction: Boolean = False): Boolean;
    procedure DeleteSelection(var AReference: IdxBarSelectableItem; ADestruction: Boolean);
    procedure ExecuteCustomizationAction(ABasicAction: TdxBarCustomizationAction);
    function GetBarManager: TdxBarManager;
    function IdxBarSelectableItem.GetInstance = GetPersistentInstance;
    procedure GetMasterObjects(AList: TdxObjectList);
    function GetNextSelectableItem: IdxBarSelectableItem;
    function GetSelectableParent: TPersistent;
    function GetSelectionStatus: TdxBarSelectionStatus;
    function GetSupportedActions: TdxBarCustomizationActions;
    procedure Invalidate;
    function IsComplex: Boolean;
    function IsComponentSelected: Boolean;
    procedure SelectComponent(ASelectionOperation: TdxBarSelectionOperation = soExclusive);
    function SelectParentComponent: Boolean;
    procedure SelectionChanged;

    // IdxScaleFactor
    function GetScaleFactor: TdxScaleFactor;

    // IdxBarLinksOwner
    function CanContainItem(AItem: TdxBarItem; out AErrorText: string): Boolean;
    function CreateBarControl: TCustomdxBarControl;
    function IdxBarLinksOwner.GetInstance = GetComponentInstance;
    function GetItemLinks: TdxBarItemLinks;
    function GetImages: TCustomImageList;
    function IsLoading: Boolean;

    // Scaling
    procedure ChangeScale(M, D: Integer);

    procedure GetAdornerTargetElements(AList: TStrings); override;

    function GetComponentInstance: TComponent;
    function GetPersistentInstance: TPersistent;

    property MergeData: TdxBarMergeData read FMergeData;
    property Painter: TdxBarPainter read GetPainter;
    property ScaleFactor: TdxScaleFactor read FScaleFactor;
    property ShouldNotBeDestroyedIfEmptyAfterUnmerge: Boolean read FShouldNotBeDestroyedIfEmptyAfterUnmerge write FShouldNotBeDestroyedIfEmptyAfterUnmerge;

    property OnDestroy: TNotifyEvent read FOnDestroy write FOnDestroy;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Assign(Source: TPersistent); override;
    procedure ChangeDockingStyle(AStyle: TdxBarDockingStyle; ADockControl: TdxDockControl);
    function GetCollectionFromParent(AParent: TComponent): TcxComponentCollection; override;
    function IsVertical: Boolean;
    procedure Move(X, Y: Integer); overload;
    procedure Move(ADockControl: TdxDockControl; ARow, APosition: Integer); overload;
    procedure Move(ADockingStyle: TdxBarDockedDockingStyle; ARow, APosition: Integer); overload;
    procedure Move(ABar: TdxBar; AInsertAfter: Boolean = True); overload;
    procedure Reset(AShowConfirmation: Boolean = False);
    procedure ResetWithConfirmation;
    procedure SetParentComponent(AParent: TComponent); override;

    procedure AddListener(AListener: IdxBarListener);
    procedure RemoveListener(AListener: IdxBarListener);

    function IsMerged: Boolean;
    procedure Merge(ABar: TdxBar);
    procedure Unmerge(ABar: TdxBar = nil);

    property BarManager: TdxBarManager read GetBarManager;
    property Bars: TdxBars read GetBars;
    property Control: TdxBarControl read GetControl;
    property DockRow: TdxDockRow read FDockRow write SetDockRow;
    property IsPredefined: Boolean read FIsPredefined;
    property LockUpdate: Boolean read FLockUpdate write SetLockUpdate;
    property RealDockControl: TdxDockControl read GetRealDockControl;
  published
    property AllowClose: Boolean read FAllowClose write SetAllowClose default True;
    property AllowCustomizing: Boolean read FAllowCustomizing write FAllowCustomizing default True;
    property AllowQuickCustomizing: Boolean read FAllowQuickCustomizing write SetAllowQuickCustomizing default True;
    property AllowReset: Boolean read FAllowReset write FAllowReset default True;
    property BorderStyle: TdxBarBorderStyle read FBorderStyle write SetBorderStyle default bbsSingle;
    property Caption: string read FCaption write SetCaption;
    property CaptionButtons: TdxBarCaptionButtons read FCaptionButtons write SetCaptionButtons;
    property Color: TColor read FColor write SetColor default clDefault;
    property DockControl: TdxBarDockControl read GetDockControl write SetDockControl;
    property DockedDockControl: TdxBarDockControl read FDockedDockControl write SetDockedDockControl;
    property DockedDockingStyle: TdxBarDockingStyle read GetDockedDockingStyle write FDockedDockingStyle stored IsDockedDockingStyleStored;
    property DockedLeft: Integer index 1 read FDockedLeft write SetDockedValue;
    property DockedTop: Integer index 2 read FDockedTop write SetDockedValue;
    property DockingStyle: TdxBarDockingStyle read GetDockingStyle write SetDockingStyle stored IsDockingStyleStored;
    property FloatLeft: Integer index 1 read FFloatLeft write SetFloatValue;
    property FloatTop: Integer index 2 read FFloatTop write SetFloatValue;
    property FloatClientWidth: Integer index 3 read FFloatClientWidth write SetFloatValue;
    property FloatClientHeight: Integer index 4 read FFloatClientHeight write SetFloatValue;
    property Font: TFont read FFont write SetFont stored FUseOwnFont;
    property Glyph: TdxSmartGlyph read FGlyph write SetGlyph;
    property Hidden: Boolean read FHidden write SetHidden default False;
    property Images: TCustomImageList read GetImages write SetImages;
    property IsMainMenu: Boolean read FIsMainMenu write SetIsMainMenu default False;
    property ItemLinks: TdxBarItemLinks read GetItemLinks write SetItemLinks;
    property KeyTip: string read FKeyTip write FKeyTip;
    property MultiLine: Boolean read FMultiLine write SetMultiLine default False;
    property NotDocking: TdxBarDockingStyles read GetNotDocking write SetNotDocking default [];
    property OldName: string read FOldName write FOldName;
    property OneOnRow: Boolean read FOneOnRow write SetOneOnRow;
    property RotateWhenVertical: Boolean read FRotateWhenVertical write SetRotateWhenVertical default True;
    property Row: Integer read GetRow write SetRow;
    property ShowMark: Boolean read FShowMark write SetShowMark default True;
    property SizeGrip: Boolean read FSizeGrip write SetSizeGrip default True;
    property UseOwnFont: Boolean read FUseOwnFont write SetUseOwnFont;
    property UseRecentItems: Boolean read GetUseRecentItems write SetUseRecentItems default True;
    property UseRestSpace: Boolean read FUseRestSpace write SetUseRestSpace default False;
    property Visible: Boolean read GetVisible write SetVisible;
    property WholeRow: Boolean read FWholeRow write SetWholeRow;
    property BackgroundBitmap: TBitmap read FBackgroundBitmap write SetBackgroundBitmap;
    property AlphaBlendValue: Byte read FAlphaBlendValue write SetAlphaBlendValue default 255;
  end;

  TdxDockControls = array[dsLeft..dsBottom] of TdxDockControl;

  TdxBars = class(TcxComponentCollection)
  private
    FBarManager: TdxBarManager;
    FDockControls: TdxDockControls;
    FDocking: Boolean;
    FDockingZoneSize: Integer;
    FMoving: Boolean;
    FMovingBarControl: TdxBarControl;
    FMovingBarOriginalDockingStyle: TdxBarDockingStyle;
    FMovingOffset: TPoint;
    FMovingStaticOffset: TPoint;
    FScaling: Boolean;

    function GetDockControl(Index: TdxBarDockingStyle): TdxDockControl;
    function GetItem(Index: Integer): TdxBar;
    procedure SetItem(Index: Integer; Value: TdxBar);
  protected
    procedure ChangeScale(M, D: Integer);

    procedure CreateDockControls;
    function HasDockControls: Boolean;
    procedure RegInDock(AStyle: TdxBarDockingStyle; ADockControl: TdxDockControl; ABarControl: TdxBarControl; APos: TPoint);
    procedure UnregFromDock(AStyle: TdxBarDockingStyle; ADockControl: TdxDockControl; ABarControl: TdxBarControl);

    procedure ChangeBarControlPos(ABarControl: TdxBarControl; APos: TPoint);
    function GetDockingStyleAtPos(Bar: TdxBar; Pos: TPoint; var DockControl: TdxDockControl): TdxBarDockingStyle;
    procedure Moving(AMovingBarControl: TdxBarControl);
    procedure Repaint;
    procedure SetItemName(AItem: TcxComponentCollectionItem; ABaseIndex: Integer = -1); override;
    procedure Update(AItem: TcxComponentCollectionItem; AAction: TcxComponentCollectionNotification); override;

    property DockingZoneSize: Integer read FDockingZoneSize write FDockingZoneSize;
  public
    constructor Create(ABarManager: TdxBarManager); reintroduce;
    destructor Destroy; override;
    function Add: TdxBar;
    function GetUniqueToolbarName(const ABaseName: string): string;
    function Insert(Index: Integer): TdxBar;

    property BarManager: TdxBarManager read FBarManager;
    property DockControls[Index: TdxBarDockingStyle]: TdxDockControl read GetDockControl;
    property IsMoving: Boolean read FMoving;
    property Items[Index: Integer]: TdxBar read GetItem write SetItem; default;
  end;

  TdxBarUserDefine = (udCaption, udGlyph, udPaintStyle, udWidth);
  TdxBarUserDefines = set of TdxBarUserDefine;

  TdxBarPaintStyle = (psStandard, psCaption, psCaptionInMenu, psCaptionGlyph);

  TdxBarItemControlPart = (cpIcon, cpText);
  TdxBarItemControlViewStructure = set of TdxBarItemControlPart;
  TdxBarItemControlViewSize = (cvsSmall, cvsMedium, cvsLarge);

  TdxBarItemOptionValue = (ioShowDescriptions, ioShowShortCuts, ioSize);
  TdxBarItemOptionValues = set of TdxBarItemOptionValue;

  TdxBarItemOptions = class(TPersistent)
  strict private
    FItemLinks: TdxBarItemLinks;

    FAssignedValues: TdxBarItemOptionValues;
    FShowDescriptions: Boolean;
    FShowShortCuts: Boolean;
    FSize: TdxBarMenuItemSize;

    function GetShowDescriptions: Boolean; inline;
    function GetShowShortCuts: Boolean; inline;
    function GetSize: TdxBarMenuItemSize; inline;
    procedure SetAssignedValues(AValue: TdxBarItemOptionValues);
    procedure SetShowDescriptions(AValue: Boolean);
    procedure SetShowShortCuts(AValue: Boolean);
    procedure SetSize(AValue: TdxBarMenuItemSize);
  protected
    function GetDefaultValue(AOption: TdxBarItemOptionValue): Integer; inline;
    function GetValue(AOption: TdxBarItemOptionValue): Integer; inline;

    function IsShowDescriptionsStored: Boolean; inline;
    function IsShowShortCutsStored: Boolean; inline;
    function IsSizeStored: Boolean; inline;
    function IsValueStored(AOption: TdxBarItemOptionValue): Boolean; inline;
  public
    constructor Create(AItemLinks: TdxBarItemLinks);
    procedure Assign(Source: TPersistent); override;
  published
    property AssignedValues: TdxBarItemOptionValues read FAssignedValues write SetAssignedValues stored False;
    property ShowDescriptions: Boolean read GetShowDescriptions write SetShowDescriptions stored IsShowDescriptionsStored;
    property ShowShortCuts: Boolean read GetShowShortCuts write SetShowShortCuts stored IsShowShortCutsStored;
    property Size: TdxBarMenuItemSize read GetSize write SetSize stored IsSizeStored;
  end;

  TdxBarItemLink = class(TcxInterfacedCollectionItem,
    IdxBarSelectableItem,
    IdxAdornerTargetElement)
  private
    FBeginGroup: Boolean;
    FButtonGroup: TdxBarButtonGroupPosition;
    FControl: TdxBarItemControl;
    FCreatedFromMergingWith: TdxBar;
    FData: TcxTag;
    FDistributed: Boolean;
    FIAccessibilityHelper: IdxBarAccessibilityHelper;
    FImageIndex: Integer;
    FIsMarkedForDeletion: Boolean;
    FItem: TdxBarItem;
    FItemRect: TRect;
    FLoadedItemName: string;
    FLoadedRecentIndex: Integer;
    FLoadedUseCount: Integer;
    FLoadedVisible: Boolean;
    FMostRecentlyUsed: Boolean;
    FOriginalItemLink: TdxBarItemLink;
    FPosition: TdxBarItemPosition;
    FPrevItemName: string;
    FPrevRecentIndex: Integer;
    FRowHeight: Integer;
    FUseCount: Integer;
    FUserCaption: string;
    FUserDefine: TdxBarUserDefines;
    FUserGlyph: TdxSmartGlyph;
    FUserPaintStyle: TdxBarPaintStyle;
    FUserWidth: Integer;
    FViewLayout: TdxBarItemViewLayout;
    FViewLevels: TdxBarItemViewLevels;
    FVisible: Boolean;
    FOnViewLevelChanged: TNotifyEvent;

    function GetAllowedViewLevels: TdxBarItemViewLevels;
    function GetAvailableIndex: Integer;
    function GetBarControl: TCustomdxBarControl;
    function GetCanVisibleIndex: Integer;
    function GetCaption: string;
    function GetCollection: TdxBarItemLinks; inline;
    function GetGlyph: TdxSmartGlyph;
    function GetIAccessibilityHelper: IdxBarAccessibilityHelper;
    function GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass;
    function GetItem: TdxBarItem;
    function GetNext: TdxBarItemLink;
    function GetOwnerValue: TdxBarItemLinks; inline;
    function GetPaintStyle: TdxBarPaintStyle;
    function GetUserDefine: TdxBarUserDefines;
    function GetVisibleIndex: Integer;
    function GetWidth: Integer;
    procedure ReadItemName(AReader: TReader);
    procedure SetButtonGroup(Value: TdxBarButtonGroupPosition);
    procedure SetCollection(Value: TdxBarItemLinks); reintroduce; virtual;
    procedure SetDistributed(const Value: Boolean);
    procedure SetDistributedByPrimaryLink(const Value: Boolean);
    procedure SetImageIndex(Value: Integer);
    procedure SetItem(Value: TdxBarItem);
    procedure SetItemRect(Value: TRect);
    procedure SetMostRecentlyUsed(Value: Boolean);
    procedure SetPosition(Value: TdxBarItemPosition);

    procedure ForceSetUserDefine(AValue: TdxBarUserDefine);
    procedure SetUserDefine(Value: TdxBarUserDefines);
    procedure SetUserCaption(const Value: string);
    procedure SetUserGlyph(Value: TdxSmartGlyph);
    procedure SetUserPaintStyle(Value: TdxBarPaintStyle);
    procedure SetUserWidth(Value: Integer);

    procedure SetViewLayout(Value: TdxBarItemViewLayout);
    procedure SetViewLevels(Value: TdxBarItemViewLevels);
    procedure SetVisible(Value: Boolean);
    procedure WriteItemName(AWriter: TWriter);

    procedure AddToRecentList;
    procedure RemoveFromRecentList;
    procedure RestoreRecentIndex;
    procedure SaveRecentIndex;
    procedure InternalBringToTopInRecentList(IncCount: Boolean);
    function IsPrimaryForDistribution: Boolean;
    procedure Synchronize(AItemLink: TdxBarItemLink);
    procedure CheckMostRecentlyUsed;
    function GetRecentIndex: Integer;
    procedure SetRecentIndex(Value: Integer);
    property RecentIndex: Integer read GetRecentIndex write SetRecentIndex;

    function CanVisible: Boolean;
    function GetRealItemLink: TdxBarItemLink;
    procedure OnUserGlyphChanged(Sender: TObject);
  protected
    function GetBeginGroup: Boolean; virtual;
    procedure SetBeginGroup(Value: Boolean); virtual;

    procedure DefineProperties(Filer: TFiler); override;
    procedure LoadItemName;

    class function GetIniSection(const ABaseSection: string; ALinkIndex: Integer; AStoringKind: TdxBarStoringKind): string;
    procedure LoadFromIni(ASource: TCustomIniFile; const ABaseSection: string; ALinkIndex: Integer; AStoringKind: TdxBarStoringKind); virtual;
    procedure LoadUsageData(ASource: TCustomIniFile; ABaseSection: string; ALinkIndex: Integer);
    procedure SaveToIni(ADestination: TCustomIniFile; const ABaseSection: string; ALinkIndex: Integer; AStoringKind: TdxBarStoringKind); virtual;

    procedure InitiateAction;

    function CanChangePaintStyle: Boolean;
    procedure ChangeScale(M, D: Integer);
    function HasItem(AItem: TdxBarItem): Boolean;
    function IsReferencedBy(ALinksOwner: IdxBarLinksOwner): Boolean;
    function IsAccel(Key: Word; Shift: TShiftState): Boolean;
    procedure MoveBeginGroupItemIfNeeded;
    function ScreenToClient(const AScreenPos: TPoint): TPoint;
    procedure UserGlyphChanged; virtual;
    procedure VisibleChanged;

    // IdxBarSelectableItem
    function CanDelete(ADestruction: Boolean = False): Boolean;
    procedure DeleteSelection(var AReference: IdxBarSelectableItem; ADestruction: Boolean);
    procedure ExecuteCustomizationAction(ABasicAction: TdxBarCustomizationAction);
    function GetBarManager: TdxBarManager; inline;
    function GetInstance: TPersistent;
    procedure GetMasterObjects(AList: TdxObjectList);
    function GetNextSelectableItem: IdxBarSelectableItem;
    function GetSelectableParent: TPersistent;
    function GetSelectionStatus: TdxBarSelectionStatus;
    function GetSupportedActions: TdxBarCustomizationActions;
    procedure Invalidate;
    function IsComplex: Boolean;
    function IsComponentSelected: Boolean;
    procedure SelectComponent(ASelectionOperation: TdxBarSelectionOperation = soExclusive);
    function SelectParentComponent: Boolean;
    procedure SelectionChanged;

    //IdxAdornerTargetElement
    function IdxAdornerTargetElement.GetControl = GetAdornerTargetElementControl;
    function GetAdornerTargetElementControl: TWinControl; virtual;
    function IdxAdornerTargetElement.GetBounds = GetAdornerTargetElementBounds;
    function GetAdornerTargetElementBounds: TRect; virtual;
    function IdxAdornerTargetElement.GetVisible = GetAdornerTargetElementVisible;
    function GetAdornerTargetElementVisible: Boolean; virtual;

    property CreatedFromMergingWith: TdxBar read FCreatedFromMergingWith;
    property IAccessibilityHelper: IdxBarAccessibilityHelper read GetIAccessibilityHelper;
    property IsMarkedForDeletion: Boolean read FIsMarkedForDeletion;
    property RowHeight: Integer read FRowHeight write FRowHeight;
  public
    constructor Create(Collection: TCollection); override;
    destructor Destroy; override;
    procedure Assign(Source: TPersistent); override;
    procedure BringToTopInRecentList(IncCount: Boolean);
    procedure CreateControl;
    procedure DestroyControl;
    procedure RecreateControl;
    procedure SendToBottomInRecentList;

    property AvailableIndex: Integer read GetAvailableIndex;
    property BarControl: TCustomdxBarControl read GetBarControl;
    property BarManager: TdxBarManager read GetBarManager;
    property CanVisibleIndex: Integer read GetCanVisibleIndex;
    property Caption: string read GetCaption;
    property Collection: TdxBarItemLinks read GetCollection write SetCollection;
    property Control: TdxBarItemControl read FControl;
    property Data: TcxTag read FData write FData default 0;
    property Glyph: TdxSmartGlyph read GetGlyph;
    property ItemRect: TRect read FItemRect write SetItemRect;
    property OriginalItemLink: TdxBarItemLink read FOriginalItemLink;
    property Owner: TdxBarItemLinks read GetOwnerValue;
    property PaintStyle: TdxBarPaintStyle read GetPaintStyle;
    property RealItemLink: TdxBarItemLink read GetRealItemLink;
    property VisibleIndex: Integer read GetVisibleIndex;
    property Width: Integer read GetWidth;

    property OnViewLevelChanged: TNotifyEvent read FOnViewLevelChanged write FOnViewLevelChanged;
  published
    property BeginGroup: Boolean read GetBeginGroup write SetBeginGroup default False;
    property ButtonGroup: TdxBarButtonGroupPosition read FButtonGroup write SetButtonGroup default bgpNone;
    property Distributed: Boolean read FDistributed write SetDistributed default True;
    property ImageIndex: Integer read FImageIndex write SetImageIndex default -1;
    property Item: TdxBarItem read GetItem write SetItem stored False;
    property MostRecentlyUsed: Boolean read FMostRecentlyUsed write SetMostRecentlyUsed default True;
    property Position: TdxBarItemPosition read FPosition write SetPosition default dxBarItemDefaultPosition;
    property UserCaption: string read FUserCaption write SetUserCaption;
    property UserDefine: TdxBarUserDefines read GetUserDefine write SetUserDefine default [];
    property UserGlyph: TdxSmartGlyph read FUserGlyph write SetUserGlyph;
    property UserPaintStyle: TdxBarPaintStyle read FUserPaintStyle write SetUserPaintStyle default psStandard;
    property UserWidth: Integer read FUserWidth write SetUserWidth default 0;
    property ViewLayout: TdxBarItemViewLayout read FViewLayout write SetViewLayout default ivlGlyphCaptionControl;
    property ViewLevels: TdxBarItemViewLevels read FViewLevels write SetViewLevels default dxBarItemAllViewLevels;
    property Visible: Boolean read FVisible write SetVisible;
  end;

  { TdxBarItemLinks }

  TdxBarIterationProc = procedure(Index: Integer; ItemLink: TdxBarItemLink; var Stop: Boolean; var Data: Pointer) of object;

  TdxBarItemLinks = class(TCollection)
  private
    FAssigning: Boolean;
    FAvailableItems: TList;
    FBarControl: TCustomdxBarControl;
    FBarManager: TdxBarManager;
    FCanVisibleItems: TList;
    FInternal: Boolean;
    FItemOptions: TdxBarItemOptions;
    FItemRectsLockCount: Integer;
    FPrevRecentItemCount: Integer;
    FPrimaryForDistributionItems: TList;
    FRecentItemCount: Integer;
    FRecentItems: TList;
    FScaleFactor: TdxScaleFactor;
    FUseRecentItems: Boolean;
    FVisibleItems: TList;

    FOnChange: TNotifyEvent;

    FFreeNotificator: TcxFreeNotificator;
    FImages: TCustomImageList;

    procedure DesignerModified;

    function GetAvailableItem(Index: Integer): TdxBarItemLink;
    function GetAvailableItemCount: Integer;
    function GetCanVisibleItem(Index: Integer): TdxBarItemLink;
    function GetCanVisibleItemCount: Integer;
    function GetIndexByItemName(const AItemName: string): Integer;
    function GetItem(Index: Integer): TdxBarItemLink;
    function GetMostRecentItemCount: Integer;
    function GetParentLinks: TdxBarItemLinks;
    function GetRealVisibleItemCount: Integer;
    function GetItemShowDescriptions: Boolean;
    function GetItemShowShortCuts: Boolean;
    function GetItemSize: TdxBarMenuItemSize; inline;
    function GetVisibleItem(Index: Integer): TdxBarItemLink;
    function GetVisibleItemCount: Integer;
    procedure SetImages(AValue: TCustomImageList);
    procedure SetItem(Index: Integer; Value: TdxBarItemLink);
    procedure SetItemOptions(AValue: TdxBarItemOptions);
    procedure SetRecentItemCount(Value: Integer);

    function IsUpdateLocked: Boolean;
    procedure RefreshVisibilityLists;
    property MostRecentItemCount: Integer read GetMostRecentItemCount;
    procedure RestoreRecentItemCount;
    property RecentItemCount: Integer read FRecentItemCount write SetRecentItemCount;

    procedure Loaded(CheckVisible: Boolean);
    procedure CheckVisibleIntegrity;

    procedure FreeNotification(AComponent: TComponent);
  protected
    FLinksOwner: IdxBarLinksOwner;

    procedure EmptyItemRects;
    procedure BeginCalcItemRects;
    procedure EndCalcItemRects;

    function CanUseRecentItems: Boolean;
    procedure InitiateActions;
    function IsShortCut(AShortCut: TShortCut): Boolean;
    function IsScrollable: Boolean; virtual;

    function DoFindItemWithAccel(AKey: Word; AShift: TShiftState; ACurrentLink: TdxBarItemLink): TdxBarItemLink; virtual;
    function FindItemWithAccel(AKey: Word; AShift: TShiftState; ACurrentLink: TdxBarItemLink): TdxBarItemLink;

    procedure CheckLinks(ASource: TCustomIniFile; const ABaseSection: string);
    procedure LoadFromIni(ASource: TCustomIniFile; const ASection: string; AStoringKind: TdxBarStoringKind);
    procedure LoadUsageData(ASource: TCustomIniFile; ASection: string);
    procedure SaveToIni(ADestination: TCustomIniFile; const ASection: string; AStoringKind: TdxBarStoringKind);

    procedure ChangeScale(M, D: Integer);

    procedure Merge(AItemLinks: TdxBarItemLinks);
    procedure Unmerge(ABar: TdxBar);

    function AddItem(AItemClass: TdxBarItemClass; AOwner: TComponent): TdxBarItemLink; overload;

    function GetItemLinkClass: TdxBarItemLinkClass; virtual;
    function GetOwner: TPersistent; override;
    function GetOwnerComponent: TComponent; virtual;
    procedure LoadItemNames;
    procedure Update(Item: TCollectionItem); override;

    property Internal: Boolean read FInternal write FInternal;

    function IsLoading: Boolean;
    function GetCurrentImages: TCustomImageList; virtual;
    function GetDefaultValue(AOption: TdxBarItemOptionValue): Integer; virtual;
    function GetOptionsValue(AOption: TdxBarItemOptionValue; AItemLinks: TdxBarItemLinks): Integer; virtual;

    property Images: TCustomImageList read FImages write SetImages;
    property ItemShowDescriptions: Boolean read GetItemShowDescriptions;
    property ItemShowShortCuts: Boolean read GetItemShowShortCuts;
    property ItemSize: TdxBarMenuItemSize read GetItemSize;
    property LinksOwner: IdxBarLinksOwner read FLinksOwner;
    property ParentLinks: TdxBarItemLinks read GetParentLinks;
    property ScaleFactor: TdxScaleFactor read FScaleFactor;
  public {for friend classes}
    function First: TdxBarItemLink;
    function Last: TdxBarItemLink;
    function Next(Current: TdxBarItemLink; AAnyone: Boolean = False): TdxBarItemLink;
    function Prev(Current: TdxBarItemLink; AAnyone: Boolean = False): TdxBarItemLink;

    property RealVisibleItemCount: Integer read GetRealVisibleItemCount;
  public
    constructor Create(ABarManager: TdxBarManager; ALinksOwner: IdxBarLinksOwner); virtual;
    destructor Destroy; override;
    function Add: TdxBarItemLink; overload;
    function Add(AItem: TdxBarItem): TdxBarItemLink; overload;
    function AddItem(AItemClass: TdxBarItemClass): TdxBarItemLink; overload;
    function AddButton: TdxBarItemLink;
    function AddSubItem: TdxBarItemLink;
    procedure Assign(Source: TPersistent); override;
    function AvailableIndexOf(Value: TdxBarItemLink): Integer;
    function CanContainItem(AItem: TdxBarItem): Boolean; overload;
    function CanContainItem(AItem: TdxBarItem; out AErrorText: string): Boolean; overload; virtual;
    function CanVisibleIndexOf(Value: TdxBarItemLink): Integer;
    procedure CreateBarControl; virtual;
    procedure DestroyBarControl;
    function FindByItem(AItem: TdxBarItem): TdxBarItemLink;
    procedure FreeForeignItems(ForeignBarManager: TdxBarManager);
    function HasItem(AItem: TdxBarItem): Boolean;
    function IsControlExists(AItem: TdxBarItemControl): Boolean;
    function IsReferencedBy(ALinksOwner: IdxBarLinksOwner): Boolean;
    function IndexOf(Value: TdxBarItemLink): Integer;
    function Insert(AIndex: Integer): TdxBarItemLink;
    function VisibleIndexOf(Value: TdxBarItemLink): Integer;
    procedure Move(ACurIndex, ANewIndex: Integer);

    property AvailableItems[Index: Integer]: TdxBarItemLink read GetAvailableItem;
    property AvailableItemCount: Integer read GetAvailableItemCount;
    property BarControl: TCustomdxBarControl read FBarControl write FBarControl;
    property BarManager: TdxBarManager read FBarManager;
    property CanVisibleItems[Index: Integer]: TdxBarItemLink read GetCanVisibleItem;
    property CanVisibleItemCount: Integer read GetCanVisibleItemCount;
    property Items[Index: Integer]: TdxBarItemLink read GetItem write SetItem; default;
    property ItemOptions: TdxBarItemOptions read FItemOptions write SetItemOptions;
    property VisibleItems[Index: Integer]: TdxBarItemLink read GetVisibleItem;
    property VisibleItemCount: Integer read GetVisibleItemCount;

  {$WARNINGS OFF}
    property Owner: TComponent read GetOwnerComponent;  // TdxBar, TdxBarCustomPopupMenu, TCustomdxBarSubItem, nil
  {$WARNINGS ON}

    property OnChange: TNotifyEvent read FOnChange write FOnChange;
  end;

  TdxBarControlItemLinks = class(TdxBarItemLinks)
  protected
    function DoFindItemWithAccel(AKey: Word; AShift: TShiftState; ACurrentLink: TdxBarItemLink): TdxBarItemLink; override;
  end;

  TdxBarSubMenuControlItemLinks = class(TdxBarItemLinks)
  protected
    function IsScrollable: Boolean; override;
  end;

  TdxBarInternalLinksOwner = class(TComponent, IdxBarLinksOwner)
  private
    FBarManager: TdxBarManager;
    FBarControlClass: TCustomdxBarControlClass;
    FItemLinks: TdxBarItemLinks;

    function GetBarControl: TCustomdxBarControl;
    // IdxBarLinksOwner
    function CanContainItem(AItem: TdxBarItem; out AErrorText: string): Boolean;
    function CreateBarControl: TCustomdxBarControl;
    function GetBarManager: TdxBarManager;
    function GetInstance: TComponent;
    function GetItemLinks: TdxBarItemLinks;
    function GetImages: TCustomImageList;
    function IsLoading: Boolean;
  public
    constructor Create(ABarManager: TdxBarManager; ABarControlClass: TCustomdxBarControlClass); reintroduce;
    destructor Destroy; override;
    property ItemLinks: TdxBarItemLinks read FItemLinks;
    property BarControl: TCustomdxBarControl read GetBarControl;
  end;

  { TdxBarInternalItemLinks }

  TdxBarInternalItemLinks = class(TdxBarItemLinks)
  public
    constructor Create(ABarManager: TdxBarManager; ALinksOwner: IdxBarLinksOwner); override;
  end;

  TdxBarPaintSubMenuBarEvent = procedure(Sender: TObject; Canvas: TCanvas; const R: TRect) of object;

  { TdxBarCustomPopupComponent }

  TdxBarCustomPopupComponent = class(TdxBarComponent,
    IcxScalableComponent,
    IdxScaleFactor,
    IdxBarLinksOwner)
  strict private
    FItemLinks: TdxBarItemLinks;
    FScaleFactor: TdxScaleFactor;

    procedure SetImages(AImages: TCustomImageList);
    procedure SetItemLinks(Value: TdxBarItemLinks);

    procedure ReadPixelsPerInch(Reader: TReader);
    procedure WritePixelsPerInch(Writer: TWriter);
  protected
    procedure DefineProperties(Filer: TFiler); override;
    procedure Loaded; override;
    procedure Notification(AComponent: TComponent; Operation: TOperation); override;

    function GetControlClass: TCustomdxBarControlClass; virtual;
    function GetItemLinksClass: TdxBarItemLinksClass; virtual;

    // IcxScalableComponent
    procedure ChangeScale(M, D: Integer);
    procedure ChangeScaleCore(M, D: Integer); virtual;
    procedure ScaleForPPI(TargetPPI: Integer);
    // IdxScaleFactor
    function GetScaleFactor: TdxScaleFactor;

    // IdxBarLinksOwner
    function CanContainItem(AItem: TdxBarItem; out AErrorText: string): Boolean;
    function CreateBarControl: TCustomdxBarControl; virtual;
    function IdxBarLinksOwner.GetInstance = GetComponentInstance;
    function GetItemLinks: TdxBarItemLinks;
    function GetImages: TCustomImageList;
    function IsLoading: Boolean;

    property Images: TCustomImageList read GetImages write SetImages;
    property ScaleFactor: TdxScaleFactor read FScaleFactor;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;

    property ItemLinks: TdxBarItemLinks read GetItemLinks write SetItemLinks;
  end;

  { TdxBarCustomPopupMenuComponent }

  TdxBarCustomPopupMenuComponent = class(TdxBarCustomPopupComponent, IcxPopupMenu)
  strict private
    FFont: TFont;
    FInternalFontChange: Boolean;
    FUseOwnFont: Boolean;

    procedure SetFont(Value: TFont);
    procedure SetUseOwnFont(Value: Boolean);
  protected
    procedure ChangeScaleCore(M, D: Integer); override;
    procedure FontChanged(Sender: TObject); virtual;
    procedure InternalUpdateFont;
    procedure SetBarManager(Value: TdxBarManager); override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    function IsShortCut(AShortCut: TShortCut): Boolean; virtual;
    function IsShortCutKey(var Message: TWMKey): Boolean; virtual;
    procedure Popup(X, Y: Integer); virtual; abstract;
    procedure PopupFromCursorPos;

    property Font: TFont read FFont write SetFont stored FUseOwnFont;
    property UseOwnFont: Boolean read FUseOwnFont write SetUseOwnFont;
  end;

  { TdxBarCustomPopupMenu }

  TdxBarCustomPopupMenuClass = class of TdxBarCustomPopupMenu;
  TdxBarCustomPopupMenu = class(TdxBarCustomPopupMenuComponent,
    IcxPopupMenu,
    IcxPopupMenu2,
    IdxBarSubMenuOwner)
  private
    FBackgroundBitmap: TBitmap;
    FBarSize: Integer;
    FEditFont: TFont;
    FOwnerBounds: PRect;
    FOwnerControl: TWinControl;
    FOwnerItemControl: TdxBarItemControl;
    FOwnerWidth, FOwnerHeight: Integer;
    FPopupAlignment: TPopupAlignment;
    FPopupMenuVisible: Boolean;
    FShowAnimation: Boolean;

    FOnCloseUp: TNotifyEvent;
    FOnCloseUpEx: TdxBarCloseUpEvent;
    FOnPaintBar: TdxBarPaintSubMenuBarEvent;
    FOnPopup: TNotifyEvent;
    FOnShow: TNotifyEvent;

    function GetItemOptions: TdxBarItemOptions;
    function GetSubMenuControl: TdxBarSubMenuControl;
    function GetUseRecentItems: Boolean;
    procedure SetBackgroundBitmap(Value: TBitmap);
    procedure SetBarSize(Value: Integer);
    procedure SetItemOptions(Value: TdxBarItemOptions);
    procedure SetUseRecentItems(Value: Boolean);

    procedure SubMenuCloseUp(Sender: TObject; AReason: TdxBarCloseUpReason);
    procedure SubMenuPopup(Sender: TObject);
    procedure SubMenuShow(Sender: TObject);
    procedure OwnerDesignerModified;

    // IcxPopupMenu2
    procedure IcxPopupMenu2.Popup = InternalPopup;
    procedure InternalPopup(X, Y: Integer; const AOwnerBounds: TRect; APopupAlignment: TPopupAlignment);
  protected
    FUseOwnMessageLoop: Boolean;
    FMinWidth: Integer;

    procedure DoShow; virtual;
    function GetEnabled: Boolean; override;
    procedure FontChanged(Sender: TObject); override;

    // IdxBarSubMenuOwner
    function GetBarSize: Integer;
    procedure DoPaintBar(Canvas: TCanvas; const R: TRect); virtual;
    procedure DoPopup; virtual;
    procedure DoCloseUp; virtual;

    property ItemOptions: TdxBarItemOptions read GetItemOptions write SetItemOptions;
    property PopupAlignment: TPopupAlignment read FPopupAlignment write FPopupAlignment default paLeft;

    property OnCloseUpEx: TdxBarCloseUpEvent read FOnCloseUpEx write FOnCloseUpEx;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Popup(X, Y: Integer); override;
    procedure PopupEx(X, Y, AOwnerWidth, AOwnerHeight: Integer; AShowAnimation: Boolean;
      AOwnerBounds: PRect; AUseOwnMessageLoop: Boolean = True; AOwnerControl: TWinControl = nil);

    property BackgroundBitmap: TBitmap read FBackgroundBitmap write SetBackgroundBitmap;
    property BarSize: Integer read GetBarSize write SetBarSize default 0;
    property SubMenuControl: TdxBarSubMenuControl read GetSubMenuControl;
    property UseRecentItems: Boolean read GetUseRecentItems write SetUseRecentItems default False;
    property Visible: Boolean read FPopupMenuVisible;

    property OnCloseUp: TNotifyEvent read FOnCloseUp write FOnCloseUp;
    property OnPaintBar: TdxBarPaintSubMenuBarEvent read FOnPaintBar write FOnPaintBar;
    property OnPopup: TNotifyEvent read FOnPopup write FOnPopup;
    property OnShow: TNotifyEvent read FOnShow write FOnShow;
  end;

  { TdxBarPopupMenu }

  TdxBarPopupMenu = class(TdxBarCustomPopupMenu)
  published
    property BackgroundBitmap;
    property BarManager;
    property BarSize;
    property Font;
    property Images;
    property ItemLinks;
    property ItemOptions;
    property PopupAlignment;
    property UseOwnFont;
    property UseRecentItems;

    property OnCloseUp;
    property OnPaintBar;
    property OnPopup;
    property OnShow;
  end;

  {-----------------------
      Visual components
   -----------------------}

  { dock controls }

  TdxDockControl = class(TCustomControl, IdxScaleFactor)
  private
    FAllowDocking: Boolean;
    FBackgroundBitmap: TBitmap;
    FBackgroundTempBitmap: TcxBitmap;
    FBarManager: TdxBarManager;
    FDockingStyle: TdxBarDockingStyle;
    FIAccessibilityHelper: IdxBarAccessibilityHelper;
    FIsBarHandleDestroying: Boolean;
    FLockCount: Integer;
    FRowList: TList;
    FRowMarginSize: Integer;


    procedure BitmapChanged(Sender: TObject);
    function GetBars: TdxBars;
    function GetHorizontal: Boolean;
    function GetIAccessibilityHelper: IdxBarAccessibilityHelper;
    function GetIsDesigning: Boolean;
    function GetIsInternal: Boolean;
    function GetIsLoading: Boolean;
    function GetMain: Boolean;
    function GetRow(Index: Integer): TdxDockRow;
    function GetRowCount: Integer;
    function GetTopLeft: Boolean;
    function GetVertical: Boolean;
    procedure SetBarManager(Value: TdxBarManager);
    procedure SetBackgroundBitmap(Value: TBitmap);
    procedure WMDestroy(var Message: TMessage); message WM_DESTROY;
    procedure WMEraseBkgnd(var Message: TWMEraseBkgnd); message WM_ERASEBKGND;
    procedure WMGetObject(var Message: TMessage); message WM_GETOBJECT;
    procedure WMLButtonDblClk(var Message: TWMLButtonDblClk); message WM_LBUTTONDBLCLK;
    procedure WMMouseActivate(var Message: TWMMouseActivate); message WM_MOUSEACTIVATE;
    procedure WMNCCalcSize(var Message: TWMNCCalcSize); message WM_NCCALCSIZE;
    procedure WMNCPaint(var Message: TWMNCPaint); message WM_NCPAINT;
    procedure WMRButtonDown(var Message: TWMRButtonDown); message WM_RBUTTONDOWN;
    procedure WMSize(var Message: TWMSize); message WM_SIZE;
    procedure WMWindowPosChanged(var Message: TWMWindowPosChanged); message WM_WINDOWPOSCHANGED;
    procedure CMBiDiModeChanged(var Message: TMessage); message CM_BIDIMODECHANGED;
    procedure CMSysColorChange(var Message: TMessage); message CM_SYSCOLORCHANGE;
  protected
    procedure AlignControls(AControl: TControl; var Rect: TRect); override;
    procedure CreateParams(var Params: TCreateParams); override;
    procedure DestroyHandle; override;
    procedure Notification(AComponent: TComponent; Operation: TOperation); override;
    procedure RequestAlign; override;

    procedure AddBarControl(ABarControl: TdxBarControl; APos: TPoint; ANeedUpdate: Boolean);
    procedure DeleteBarControl(ABarControl: TdxBarControl; ADockCol: TObject; Update: Boolean);
    procedure MoveBarControl(ABarControl: TdxBarControl; APos: TPoint);

    procedure AssignPositions;
    procedure BarManagerChanged; virtual;
    procedure CalcLayout; virtual;
    procedure CalcRowToolbarPositions(ARowIndex: Integer; AClientSize: Integer); virtual;
    function CanCustomize: Boolean; virtual;
    function CanDocking(Bar: TdxBar): Boolean; virtual;
    procedure ColorChanged; virtual;
    function GetBarControlPos(AControlPos: Integer; AControlWidth: Integer): Integer;
    function GetDockZoneBounds: TRect;
    procedure GetDockZoneMargins(Row, ZoneNumber: Integer; var M1, M2: Integer);
    function GetRectForRow(ARow: Integer): TRect;
    function GetClientSize: Integer; virtual;
    function GetSize: Integer;
    function GetRowAtPos(APos: TPoint; out ANeedInsert: Boolean): Integer;
    function GetColAtPos(ARow: Integer; APos: TPoint): Integer;
    procedure GetPosForRow(Row: Integer; OneOnRow: Boolean; var P: TPoint);
    function GetSunkenBorder: Boolean; virtual;
    function GetMainForm: TCustomForm;
    function GetMasterForm: TCustomForm;
    function GetParentForm: TCustomForm;
    function IsMultiRow: Boolean; virtual;
    procedure NCChanged;
    procedure PaintBarControls;
    procedure SetSize; virtual;
    procedure ShowCustomizePopup; virtual;
    procedure UpdateDock;

    procedure BeginUpdate;
    procedure EndUpdate;
    function IsUpdateLocked: Boolean;

    function GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass; virtual;
    function GetDockedBarControlClass: TdxBarControlClass; virtual;
    function GetDockingStyle: TdxBarDockingStyle; virtual;
    function GetPainter: TdxBarPainter; virtual;
    function GetScaleFactor: TdxScaleFactor; virtual;

    procedure FillBackground(DC: HDC; const ADestR, ASourceR: TRect; ABrush: HBRUSH; AColor: TColor); virtual;
    function IsBackgroundBitmap: Boolean; virtual;
    function IsBarManagerValid: Boolean;
    function IsDrawDesignBorder: Boolean; virtual;
    function IsTransparent: Boolean; virtual;
    procedure RepaintBarControls; virtual;
    procedure ResetBackground; virtual;
    procedure UpdateDoubleBuffered; virtual;

    property BackgroundTempBitmap: TcxBitmap read FBackgroundTempBitmap;

    property AllowDocking: Boolean read FAllowDocking write FAllowDocking default True;
    property BackgroundBitmap: TBitmap read FBackgroundBitmap write SetBackgroundBitmap;
    property Horizontal: Boolean read GetHorizontal;
    property IsBarHandleDestroying: Boolean read FIsBarHandleDestroying write FIsBarHandleDestroying;
    property IsDesigning: Boolean read GetIsDesigning;
    property IsInternal: Boolean read GetIsInternal;
    property IsLoading: Boolean read GetIsLoading;
    property Main: Boolean read GetMain;
    property MainForm: TCustomForm read GetMainForm;
    property MasterForm: TCustomForm read GetMasterForm;
    property Painter: TdxBarPainter read GetPainter;
    property ParentForm: TCustomForm read GetParentForm;
    property RowMarginSize: Integer read FRowMarginSize write FRowMarginSize;
    property ScaleFactor: TdxScaleFactor read GetScaleFactor;
    property SunkenBorder: Boolean read GetSunkenBorder;
    property TopLeft: Boolean read GetTopLeft;
    property Vertical: Boolean read GetVertical;
  public
    constructor Create(AOwner: TComponent); override;
    constructor CreateEx(AOwner: TComponent; ABarManager: TdxBarManager;
      ADockStyle: TdxBarDockingStyle);
    destructor Destroy; override;

    property BarManager: TdxBarManager read FBarManager write SetBarManager;
    property Bars: TdxBars read GetBars;
    property DockingStyle: TdxBarDockingStyle read GetDockingStyle;
    property IAccessibilityHelper: IdxBarAccessibilityHelper read GetIAccessibilityHelper;
    property RowCount: Integer read GetRowCount;
    property RowList: TList read FRowList;
    property Rows[Index: Integer]: TdxDockRow read GetRow;
  end;

  TdxBarDockAlign = (dalNone, dalTop, dalBottom, dalLeft, dalRight);

  TdxBarDockControl = class(TdxDockControl)
  private
    FAllowZeroSizeInDesignTime: Boolean;
    FSunkenBorder: Boolean;
    FUseOwnColor: Boolean;
    FUseOwnSunkenBorder: Boolean;
    function GetAlign: TdxBarDockAlign;
    function GetColor: TColor;
    function GetIsLoading: Boolean;
    function GetParentColor: Boolean;
    procedure SetAlign(Value: TdxBarDockAlign);
    procedure SetAllowZeroSizeInDesignTime(Value: Boolean);
    procedure SetColor(Value: TColor);
    procedure SetParentColor(Value: Boolean);
    procedure SetSunkenBorder(Value: Boolean);
    procedure SetUseOwnColor(Value: Boolean);
    procedure SetUseOwnSunkenBorder(Value: Boolean);
    procedure SetMinSize;
    function IsColorStored: Boolean;
    function IsWidthStored: Boolean;
    function IsHeightStored: Boolean;
    procedure WMCreate(var Message: TWMCreate); message WM_CREATE;
    procedure WMSize(var Message: TWMSize); message WM_SIZE;
  protected
    function AllowUndockWhenLoadFromIni: Boolean; virtual;
    procedure CreateParams(var Params: TCreateParams); override;
    procedure Paint; override;
    procedure BarManagerChanged; override;
    function CanDocking(Bar: TdxBar): Boolean; override;
    procedure ColorChanged; override;
    function GetClientSize: Integer; override;
    function GetMinSize: Integer; virtual;
    function GetSunkenBorder: Boolean; override;
    property IsLoading: Boolean read GetIsLoading;
  public
    constructor Create(AOwner: TComponent); override;
    procedure AfterConstruction; override;
  published
    property Align: TdxBarDockAlign read GetAlign write SetAlign;
    property AllowDocking;
    property AllowZeroSizeInDesignTime: Boolean read FAllowZeroSizeInDesignTime
      write SetAllowZeroSizeInDesignTime default False;
    property Anchors;
    property BarManager;
    property Color read GetColor write SetColor stored IsColorStored;
    property ParentColor: Boolean read GetParentColor write SetParentColor
      stored IsColorStored;
    property SunkenBorder: Boolean read GetSunkenBorder write SetSunkenBorder
      stored FUseOwnSunkenBorder;
    property UseOwnColor: Boolean read FUseOwnColor write SetUseOwnColor default False;
    property UseOwnSunkenBorder: Boolean read FUseOwnSunkenBorder
      write SetUseOwnSunkenBorder default False;
    property Visible;
    property BackgroundBitmap;

    property Width stored IsWidthStored;
    property Height stored IsHeightStored;

    property OnClick;
    property OnDblClick;
    property OnMouseDown;
    property OnMouseMove;
    property OnMouseUp;
    property OnResize;
  end;

  { TdxBarShadowPart }

  TdxBarShadowPart = class(TdxCustomShadowWindow)
  private
    FOwner: TdxBarShadow;
  public
    constructor CreateEx(AOwner: TdxBarShadow);
    procedure UpdateBounds(const ABounds: TRect);
  end;

  { TdxBarShadow }

  TdxBarShadow = class
  private
    FBarBounds, FParentBarBounds: TRect;
    FHorizontal: Boolean;
    FOwner: TWinControl;
    FShadowPart: array[0..1] of TdxBarShadowPart;
    FVisible: Boolean;
    function GetShadowSize: Integer;
    function GetTransparent: Boolean;
    procedure SetVisible(Value: Boolean);
  protected
    procedure CreateParts;
    procedure DestroyParts;
    procedure Hide;
    procedure Show;

    property Transparent: Boolean read GetTransparent;
  public
    constructor Create(AOwner: TWinControl);
    destructor Destroy; override;
    procedure Refresh;
    procedure SetOwnerBounds(const AR1, AR2: TRect);

    property Horizontal: Boolean read FHorizontal;
    property Owner: TWinControl read FOwner;
    property ShadowSize: Integer read GetShadowSize;
    property Visible: Boolean read FVisible write SetVisible;
  end;

  { TCustomdxBarControl }

  TdxBarMarkState = (msNone, msSelected, msPressed);
  TdxBarItemControlParentKind = (pkBar, pkSubItemOrPopupMenu);
  TdxBarPaintType = (ptHorz, ptMenu, ptVert);
  TdxBarState = (bsCreatingControls, bsCreatingWindow, bsDestroyingControls, bsDestroyWindowHandle, bsDestroyWindow, bsDestroying, bsDestroyed, bsHideAll, bsPaintItem, bsRepaintBar, bsUpdatingCanvasFont);
  TdxBarStates = set of TdxBarState;
  TdxBarViewState = (bvsNormal, bvsHot);

  TCustomdxBarControl = class(TCustomControl,
    IcxMouseTrackingCaller,
    IcxMouseTrackingCaller2,
    IdxBarHintKeeper,
    IdxBarHintKeeper2,
    IdxScaleFactor,
    IdxManagedObject)
  private
    FActiveCanvas: TcxCanvas;
    FBackgroundTempBitmap: TcxBitmap;
    FBkBrush: HBRUSH;
    FCanvas: TcxCanvas;
    FChildBar: TCustomdxBarControl;
    FCloseUpReason: TdxBarCloseUpReason;
    FCurrentMessage: TMessage;
    FDockControl: TdxDockControl;
    FDockingStyle: TdxBarDockingStyle;
    FDragDown: Boolean;
    FDragPoint: TPoint;
    FExpandedItemLinks: TList;
    FIAccessibilityHelper: IdxBarAccessibilityHelper;
    FIgnoreMouseClick: Boolean;
    FIsActive: Boolean;
    FIsDowned: Boolean;
    FItemLinks: TdxBarItemLinks;
    FLockCount: Integer;
    FMovingChanging: Boolean;
    FOwnerBounds: TRect;
    FOwnerControl: TWinControl;
    FParentBar: TCustomdxBarControl;
    FPrevActiveBarControl: TCustomdxBarControl;

    FPrevTrackedLink: TdxBarItemLink;
    FClickedControl: TdxBarItemControl;
    FButtonPressTimer: TcxTimer;
    FSelectedLink: TdxBarItemLink; // to replace obsolete SelectedItem
    FShadow: TdxBarShadow;

    FTextSize, FEditTextSize: Integer;
    FMarkSize: Integer;
    FMenuArrowHeight, FMenuArrowWidth: Integer;
    FComboBoxArrowWidth: Integer;
    FIconAreaSize: Integer;
    FRatio: Double;

    FOnDestroy: TNotifyEvent;

    procedure MouseDownNotifyControls(ALinkAtPos: TdxBarItemLink; const AMousePos: TPoint; Button: TMouseButton; Shift: TShiftState);
    procedure MouseNotifyControls(ALinkAtPos: TdxBarItemLink; const AMousePos: TPoint; Shift: TShiftState);
    procedure MouseUpNotifyControls(ALinkAtPos: TdxBarItemLink; const AMousePos: TPoint; Button: TMouseButton; Shift: TShiftState);

    function GetActiveCanvas: TcxCanvas;
    function GetBarControlOwnerBrush: HBRUSH;
    function GetBarManager: TdxBarManager;
    function GetCanvas: TcxCanvas;
    function GetFlat: Boolean;
    function GetIAccessibilityHelper: IdxBarAccessibilityHelper;
    function GetIsDestroying: Boolean; inline;
    function GetOwnerLinkBounds(AOwnerPart: Boolean): TRect;
    function GetPainterClass: TdxBarPainterClass;
    function GetSelectedControlAtDesign: TdxBarItemControl;
    function GetSelectedControl: TdxBarItemControl;
    function ItemAtMousePos: TdxBarItemControl;
    procedure SetChildBar(Value: TCustomdxBarControl);
    procedure SetDockControl(Value: TdxDockControl);
    procedure SetIsActive(Value: Boolean);
    procedure SetParentBar(Value: TCustomdxBarControl);
    procedure SetViewState(Value: TdxBarViewState);

    procedure CMBiDiModeChanged(var Message: TMessage); message CM_BIDIMODECHANGED;
    procedure WMCaptureChanged(var Message: TMessage); message WM_CAPTURECHANGED;
    procedure WMClose(var Message: TMessage); message WM_CLOSE;
    procedure WMDestroy(var Message: TMessage); message WM_DESTROY;
    procedure WMEraseBkgnd(var Message: TWMEraseBkgnd); message WM_ERASEBKGND;
    procedure WMKeyDown(var Message: TWMKeyDown); message WM_KEYDOWN;
    procedure WMLButtonDblClk(var Message: TWMLButtonDblClk); message WM_LBUTTONDBLCLK;
    procedure WMLButtonDown(var Message: TWMLButtonDown); message WM_LBUTTONDOWN;
    procedure WMLButtonUp(var Message: TWMLButtonUp); message WM_LBUTTONUP;
    procedure WMMouseActivate(var Message: TWMMouseActivate); message WM_MOUSEACTIVATE;
    procedure WMMouseMove(var Message: TWMMouseMove); message WM_MOUSEMOVE;
    procedure WMNCPaint(var Message: TMessage); message WM_NCPAINT;
    procedure WMPaint(var Message: TWMPaint); message WM_PAINT;
    procedure WMPrint(var Message: TMessage); message WM_PRINT;
    procedure WMPrintClient(var Message: TMessage); message WM_PRINTCLIENT;
    procedure WMRepaintBar(var Message: TMessage); message DXM_BAR_REPAINTBAR;
    procedure WMSetCursor(var Message: TWMSetCursor); message WM_SETCURSOR;
    procedure WMSize(var Message: TWMSize); message WM_SIZE;
    procedure WMWindowPosChanged(var Message: TWMWindowPosChanged); message WM_WINDOWPOSCHANGED;

    procedure DXMHideAll(var Message: TMessage); message DXM_BAR_HIDEALL;
  protected
    FItemsRect: TRect;
    FLastMousePos: TPoint;
    FMarkState: TdxBarMarkState;
    FPainter: TdxBarPainter;
    FState: TdxBarStates;
    FViewInfo: TCustomdxBarControlViewInfo;
    FViewState: TdxBarViewState;
    FVisibleItemsRect: TRect;

    procedure AdjustSize; override;
    procedure CreateHandle; override;
    procedure CreateWindowHandle(const Params: TCreateParams); override;
    procedure CreateWnd; override;
    procedure DestroyWindowHandle; override;
    procedure WindowPosChanged(var Message: TWMWindowPosChanged); virtual;
    procedure WndProc(var Message: TMessage); override;

    procedure AfterMouseMove(Shift: TShiftState; X, Y: Integer); virtual;
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer); override;
    procedure MouseLeave; dynamic; { IcxMouseTrackingCaller }
    procedure MouseMove(Shift: TShiftState; X, Y: Integer); override;
    procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer); override;
    function NeedsMouseWheel: Boolean; virtual;
    procedure ProcessMouseDownMessageForMeaningParent(AWnd: HWND; AMsg: UINT; const AMousePos: TPoint); virtual;
    function PtInCaller(const P: TPoint): Boolean; { IcxMouseTrackingCaller2 }

    // Calculations
    procedure BeginUpdate;
    procedure CancelUpdate;
    procedure EndUpdate;
    function CalcChildBarBounds(out ARect: TRect): Boolean; virtual;
    procedure CalcControlsPositions; virtual;
    procedure CalcDragOverParameters(const ACursorPos: TPoint; var ADragOverItemLink: TdxBarItemLink;
      var AIsBeginGroup, AIsFirstPart, AIsVerticalDirection: Boolean); virtual;
    procedure CalcDrawingConsts; virtual;
    procedure CalcItemsRect; virtual;
    function CalcColumnItemRect(AItemLink: TdxBarItemLink; const AItemsRect: TRect): TRect; virtual;
    procedure CalcColumnItemRects(ATopIndex: Integer; out ALastItemBottom: Integer); virtual;
    procedure CalcRowItemRects; virtual;
    procedure CalcItemRects(APaintStyle: TdxBarPaintType; ATopIndex: Integer = 0); virtual;
    procedure CalcLayout; virtual;

    procedure AdjustHintWindowPosition(var APos: TPoint; const ABoundsRect: TRect; AHeight: Integer); virtual;
    procedure AfterControlEscape(AControl: TdxBarItemControl); virtual;
    function IsResizing: Boolean; virtual;
    procedure Resize; override;

    procedure BeforeDestroyHandle;
    procedure CreateControls; virtual;
    procedure DestroyControls; virtual;
    procedure ExpandContainerItems;
    procedure CollapseContainerItems;
    procedure LayoutChanged; virtual;
    procedure RecreateControls;

    // MessageHandler
    procedure DoKeyDown(var Message: TWMKey); virtual;
    procedure DoLButtonUp(var Message: TWMLButtonUp); virtual;

    function CanActiveChange: Boolean; virtual;
    function CanAlignControl(AControl: TdxBarItemControl): Boolean; virtual;
    function CanCallInheritedNCCalcSize: Boolean; virtual; // obsolete
    function CanControlPaint(AControl: TdxBarItemControl): Boolean; virtual;
    //function CanCallInheritedNCPaint: Boolean; virtual;
    function CanCustomizing: Boolean; virtual;
    function CanDeactivate(ABarManager: TdxBarManager; AActiveWindow: HWND): Boolean; virtual;
    function CanDrawClippedItem(AItemRect: TRect): Boolean; virtual;
    function CanHideOnDeactivate: Boolean;
    function CanProcessMouseMessage: Boolean; virtual;
    function CanSetMouseSelectedItem(const P: TPoint; AItemControl: TdxBarItemControl): Boolean; virtual;
    function CanShowHint: Boolean; virtual;
    function CanShowPopupMenuOnMouseClick(AMousePressed: Boolean): Boolean; virtual;
    function CheckLockUpdate: Boolean; virtual;
    function ChildrenHaveShadows: Boolean; virtual;
    procedure CorrectVisibleItemsRectTop; virtual;
    procedure CorrectVisibleItemsRectBottom; virtual;
    procedure CustomizePrepare(APoint: TPoint; ASecondClick: Boolean); virtual;
    procedure DblClickOnItem(AItemControl: TdxBarItemControl); dynamic;
    procedure DoBarGetFocus(ASelectedItem: TdxBarItemControl); virtual;
    procedure DoBarLostFocus; virtual;
    procedure DoBarMouseEnter(Shift: TShiftState; const APoint: TPoint; AItemControl: TdxBarItemControl); virtual;
    procedure DoBarMouseDown(Button: TMouseButton; Shift: TShiftState;
      const APoint: TPoint; AItemControl: TdxBarItemControl; APointInClientRect: Boolean); virtual;
    procedure DoBarMouseLeave; virtual;
    procedure DoBarMouseMove(Shift: TShiftState; const APoint: TPoint; AItemControl: TdxBarItemControl); virtual;
    procedure DoBarMouseUp(Button: TMouseButton; Shift: TShiftState;
      const APoint: TPoint; AItemControl: TdxBarItemControl; APointInClientRect: Boolean); virtual;
    procedure DoBarMouseLeftButtonDown(Shift: TShiftState; const APoint: TPoint;
      AItemControl, APrevSelectedControl: TdxBarItemControl; APointInClientRect: Boolean); virtual;
    procedure DoBarMouseRightButtonDown(Shift: TShiftState; const APoint: TPoint;
      AItemControl, APrevSelectedControl: TdxBarItemControl; APointInClientRect: Boolean); virtual;
    procedure DoCreateControls; virtual;
    procedure DoDestroy; virtual;
    procedure DoDestroyControls; virtual;
    procedure DoDropFocus; virtual;
    procedure DoHideAll(AReason: TdxBarCloseUpReason); virtual;
    procedure DoPaintItem(AControl: TdxBarItemControl; ACanvas: TcxCanvas; const AItemRect: TRect); virtual;
    procedure DoRepaintBar(ARecreateControls: Boolean); virtual;
    procedure DoSetIsActive(AValue: Boolean); virtual;
    procedure DrawItems; virtual;
    procedure DrawSelectedItem(ADC: HDC; AControl: TdxBarItemControl; const AItemRect: TRect);
    procedure DragOver(X, Y: Integer; var Accept: Boolean); reintroduce; virtual;
    function DoFindLinkWithAccel(AKey: Word; AShift: TShiftState; ACurrentLink: TdxBarItemLink): TdxBarItemLink; virtual;
    function FindLinkWithAccel(AKey: Word; AShift: TShiftState; ACurrentLink: TdxBarItemLink; out ADuplicate: Boolean): TdxBarItemLink; virtual;
    procedure FocusItemControl(AItemControl: TdxBarItemControl); virtual;
    procedure FocusNextBarControl(AForward: Boolean);
    procedure NavigationHandler(var ACharCode: Word; AShiftState: TShiftState); virtual;

    function GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass; virtual; abstract;
    function GetBackgroundBitmap: TGraphic; virtual; abstract;
    function GetBeginGroupSize: Integer; virtual; abstract;
    function GetBehaviorOptions: TdxBarBehaviorOptions; virtual;
    function GetClientOffset: TPoint;
    function GetCurrentImages: TCustomImageList;
    function GetCurrentCursor(const AMousePos: TPoint): TCursor; virtual;
    function GetDefaultItemHeight(AItem: TdxBarItemControl): Integer; virtual;
    function GetDefaultItemGlyph: TdxSmartGlyph; virtual;
    function GetEditFont: TFont; virtual;
    function GetEditFontHandle: HFONT;
    function GetEquivalentParentBar: TCustomdxBarControl;
    function GetFader: TdxFader; virtual;
    function GetFullItemRect(Item: TdxBarItemControl): TRect; virtual;
    function GetHintItemText: string; virtual;
    function GetIsCustomizing: Boolean; virtual;
    function GetIsFadingAvailable: Boolean; virtual;
    function GetIsFocused: Boolean;
    function GetIsMainMenu: Boolean; virtual; abstract;
    function GetIsShadowVisible: Boolean; virtual;
    function GetIsStatusBar: Boolean; virtual; abstract;
    function GetParentForm: TCustomForm; virtual;

    function GetItemControlDefaultViewLevel(AItemControl: TdxBarItemControl): TdxBarItemViewLevel; virtual;
    function GetItemControlOffset(AItemLink: TdxBarItemLink): Integer; virtual;
    function GetItemRectEx(Item: TdxBarItemControl; IsBeginGroup: Boolean): TRect; virtual;
    function GetItemRegion(Item: TdxBarItemControl): HRGN; virtual;
    function GetItemScreenRect(Item: TdxBarItemControl): TRect;
    function GetItemsRectOffset: TRect; virtual;

    function GetMarkDrawState: TdxBarMarkState; virtual;
    function GetMarkSize: Integer; virtual;
    function GetNextBarControl(AForward: Boolean): TdxBarControl; virtual;
    function GetNormalItemHeight: Integer; virtual;
    function GetOwnerControl: TWinControl; virtual;
    function GetPainter: TdxBarPainter; virtual;
    function GetPaintType: TdxBarPaintType; virtual;
    function GetSelectableObject: TPersistent; virtual;
    function GetSelectionOperation(AButton: TMouseButton; AShift: TShiftState; ASelectableItem: IdxBarSelectableItem): TdxBarSelectionOperation;
    function GetToolbarBrush: HBRUSH; virtual;
    function GetToolbarDownedBrush: HBRUSH; virtual;
    function GetToolbarDownedSelBrush: HBRUSH; virtual;
    function GetToolbarSelBrush: HBRUSH; virtual;
    function GetViewInfoClass: TCustomdxBarControlViewInfoClass; virtual; abstract;
    procedure RepaintBarEx(ARecreateControls: Boolean);
    procedure SetControlVisible(AControl: TdxBarItemControl); virtual;
    procedure SetItemLinks(Value: TdxBarItemLinks); virtual;

    function GetNCDrawingDC(AUpdatedRgn: HRGN): HDC; virtual;
    procedure ReleaseNCDrawingDC(ADC: HDC); virtual;

    function GetBorderSize: Integer; virtual;
    function GetIconAreaSize: Integer; virtual;
    function GetTextSize: Integer; virtual;

    function GetClientBounds: TRect;
    function GetMouseTrackingBounds: TRect; virtual;
    function GetNCRect: TRect;
    function GetWindowRect: TRect;
    function GetWindowPoint(const AClientPoint: TPoint): TPoint;

    procedure MakeItemControlFullyVisible(AItemControl: TdxBarItemControl); virtual;

    // mark
    function MarkExists: Boolean; virtual;
    function MarkRect: TRect; virtual;
    function MouseOnMark(const AMousePos: TPoint): Boolean; overload;
    function MouseOnMark: Boolean; overload;
    procedure SetMarkState(Value: TdxBarMarkState); virtual;

    // hint
    procedure ActivateHint; overload;
    procedure ActivateHint(AShow: Boolean; const ACustomHint: string; AHintObject: TObject = nil); overload;
    function CreateHintViewInfo(const AHintText, AShortCut: string; AScreenTip: TdxScreenTip): TdxBarCustomHintViewInfo; overload;
    function GetHintPosition(const AItemBounds: TRect; const ACursorPos: TPoint; AHeight: Integer): TPoint; overload;

    procedure ResizeShadow;
    procedure SetCursorForMoving(AMoving: Boolean);
    procedure SetDockingStyle(Value: TdxBarDockingStyle); virtual;
    procedure SetFont; virtual; abstract;
    procedure SetLayeredAttributes; virtual;

    // selected item
    function SelectedItemWantsKey(Key: Word): Boolean;
    procedure SelectItemControl(AItemControl: TdxBarItemControl; AButton: TMouseButton; AShift: TShiftState); virtual;
    procedure SetAccelSelectedItem(AItemLink: TdxBarItemLink; ADuplicate: Boolean); virtual;
    procedure SetKeySelectedItem(Value: TdxBarItemControl); virtual;
    procedure SetMouseSelectedItem(Value: TdxBarItemControl); virtual;
    procedure SetSelectedControl(Value: TdxBarItemControl); virtual;

    // update/changed
    procedure UpdateCanvasFont;
    procedure UpdateControlStyle;
    procedure UpdateItem(AControl: TdxBarItemControl); virtual; abstract;
    procedure UpdateParentItemControl; virtual;
    procedure ViewStateChanged(APrevValue: TdxBarViewState); virtual;

    // popup
    procedure DoShowPopup(ASelectedControl: TdxBarItemControl);
    procedure InitCustomizationPopup(AItemLinks: TdxBarItemLinks); virtual;
    procedure ShowPopup(AItem: TdxBarItemControl); virtual;

    // painting
    function AllowNCPaint: Boolean; virtual;
    function AllowSeparators: Boolean; virtual;
    procedure FillBackground(DC: HDC; const ARect: TRect; ABrush: HBRUSH; AColor: TColor;
      AIsClientArea: Boolean); virtual; abstract;
    procedure FillBackgroundRgn(DC: HDC; ARgn: HRGN; ABrush: HBRUSH; AIsClientArea: Boolean); virtual;
    procedure FullInvalidate;
    procedure FullRepaint;
    procedure PaintItem(ACanvas: TcxCanvas; AControl: TdxBarItemControl); virtual;
    procedure ResetBackground; virtual;
    procedure UpdateDoubleBuffered; virtual;
    // NC painting
    procedure InvalidateNCRect(ARect: TRect);
    function NCOffset: TPoint; virtual;
    procedure NCPaint(ADC: HDC); virtual;

    // conditionals
    function AllowSelectionFrame: Boolean; virtual;
    function AllowFade: Boolean; virtual;
    function HasShadow: Boolean; virtual;
    function IsBackgroundBitmap: Boolean; virtual;
    function IsChildBar(Value: TCustomdxBarControl): Boolean; virtual;
    function IsChildWindow(AWnd: HWND): Boolean; virtual;
    function IsControlExists(ABarItemControl: TdxBarItemControl): Boolean; virtual;
    function IsDoubleBufferedNeeded: Boolean; virtual;
    function IsInternal: Boolean; virtual;
    function IsLinkedToOwner: Boolean; virtual;
    function IsMeaningParent(AWnd: HWND): Boolean; virtual;
    function IsPopup: Boolean; virtual;
    function IsTransparent: Boolean; virtual;
    function IsVerticalDirection: Boolean; virtual;
    function IsWindowEnabled: Boolean; virtual;
    function NeedBufferedOnGlass(AControl: TdxBarItemControl): Boolean;
    function NeedHideOnClick: Boolean; virtual;
    function NeedHideOnKeyPress: Boolean; virtual;
    function NeedsKey(AKey: Word; AShift: TShiftState): Boolean; virtual;
    function PreProcessKey(AKey: Word; AShift: TShiftState): Boolean; virtual;

    function NeedShowGlyphAndCheckForItem: Boolean; virtual;
    function NotHandleMouseMove(ACheckLastMousePos: Boolean = True): Boolean; virtual;
    function WantMouse: Boolean;

    // IdxScaleFactor
    function GetScaleFactor: TdxScaleFactor; virtual;

    function PointBarToDock(const APoint: TPoint): TPoint;

    procedure Initialize; virtual;
    procedure Finalize; virtual;

    property BackgroundTempBitmap: TcxBitmap read FBackgroundTempBitmap;
    property ChildBar: TCustomdxBarControl read FChildBar write SetChildBar;
    property CloseUpReason: TdxBarCloseUpReason read FCloseUpReason;
    property DockControl: TdxDockControl read FDockControl write SetDockControl;
    property DockingStyle: TdxBarDockingStyle read FDockingStyle write SetDockingStyle;
    property Flat: Boolean read GetFlat; // TODO: obsolete
    property IgnoreMouseClick: Boolean read FIgnoreMouseClick write FIgnoreMouseClick;
    property IsDestroying: Boolean read GetIsDestroying;
    property IsDowned: Boolean read FIsDowned write FIsDowned;
    property IsFadingAvailable: Boolean read GetIsFadingAvailable;
    property IsMainMenu: Boolean read GetIsMainMenu;
    property IsShadowVisible: Boolean read GetIsShadowVisible;
    property IsStatusBar: Boolean read GetIsStatusBar;
    property MarkSize: Integer read FMarkSize;
    property MarkState: TdxBarMarkState read FMarkState write SetMarkState;
    property MarkDrawState: TdxBarMarkState read GetMarkDrawState;
    property SelectedControlAtDesign: TdxBarItemControl read GetSelectedControlAtDesign;
    property SelectedControl: TdxBarItemControl read GetSelectedControl write SetSelectedControl;
    property SelectedLink: TdxBarItemLink read FSelectedLink write FSelectedLink;
    property Shadow: TdxBarShadow read FShadow;
    property ViewState: TdxBarViewState read FViewState write SetViewState;

    property IconAreaSize: Integer read FIconAreaSize;
    property BeginGroupSize: Integer read GetBeginGroupSize;
    property OwnerBounds: TRect read FOwnerBounds write FOwnerBounds;
    property OwnerControl: TWinControl read GetOwnerControl write FOwnerControl;
    property OwnerLinkBounds[AOwnerPart: Boolean]: TRect read GetOwnerLinkBounds;
    property RealOwnerControl: TWinControl read FOwnerControl;

    property BarControlOwnerBrush: HBRUSH read GetBarControlOwnerBrush;
    property EditFont: TFont read GetEditFont;
    property Painter: TdxBarPainter read GetPainter;
    property PainterClass: TdxBarPainterClass read GetPainterClass;
    property ToolbarBrush: HBRUSH read GetToolbarBrush;
    property ToolbarDownedBrush: HBRUSH read GetToolbarDownedBrush;
    property ToolbarDownedSelBrush: HBRUSH read GetToolbarDownedSelBrush;
    property ToolbarSelBrush: HBRUSH read GetToolbarSelBrush;

    property ItemsRect: TRect read FItemsRect;
    property NCRect: TRect read GetNCRect;
    property VisibleItemsRect: TRect read FVisibleItemsRect;
    property WindowRect: TRect read GetWindowRect;

    property ActiveCanvas: TcxCanvas read GetActiveCanvas;
    property Ratio: Double read FRatio;
    property ScaleFactor: TdxScaleFactor read GetScaleFactor;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;

    procedure BarGetFocus(ASelectedItem: TdxBarItemControl);
    procedure BarLostFocus;
    procedure BeforeDestruction; override;
    function GetItemRect(Item: TdxBarItemControl): TRect;

    procedure Hide; virtual; abstract;
    procedure HideByEscape; virtual;
    procedure HideAll(AReason: TdxBarCloseUpReason = bcrCancel); virtual;
    procedure HideAllByEscape; virtual;
    procedure PostponedHideAll(AReason: TdxBarCloseUpReason = bcrCancel);
    procedure Show; virtual;
    procedure RepaintBar; virtual;

    // Conditions
    function IsOnGlass: Boolean; virtual;
    function IsRealVertical: Boolean; virtual;
    function IsVertical: Boolean; virtual;
    function ItemAtPos(const APos: TPoint): TdxBarItemControl;
    function Kind: TdxBarKind; virtual; abstract;

    // IdxBarHintKeeper
    function DoHint(var ANeedDeactivate: Boolean; out AHintText: string; out AShortCut: string): Boolean; virtual;
    function CreateHintViewInfo(const AHintText, AShortCut: string): TdxBarCustomHintViewInfo; overload;
    function IdxBarHintKeeper.GetEnabled = GetHintKeeperEnabled;
    function GetHintKeeperEnabled: Boolean;
    function GetHintPosition(const ACursorPos: TPoint; AHeight: Integer): TPoint; overload;

    // IdxBarHintKeeper2
    function GetHintedControl: TControl;
    function IsCustomHintSupported: Boolean;

    // IdxManagedObject
    function GetManager: IdxManager;

    property BarManager: TdxBarManager read GetBarManager;
    property BkBrush: HBRUSH read FBkBrush;
    property BehaviorOptions: TdxBarBehaviorOptions read GetBehaviorOptions;
    property Canvas: TcxCanvas read GetCanvas;
    property ClientBounds: TRect read GetClientBounds;
    property ComboBoxArrowWidth: Integer read FComboBoxArrowWidth;
    property EditFontHandle: HFONT read GetEditFontHandle;
    property EditTextSize: Integer read FEditTextSize;
    property Font;
    property IAccessibilityHelper: IdxBarAccessibilityHelper read GetIAccessibilityHelper;
    property IsActive: Boolean read FIsActive write SetIsActive;
    property IsCustomizing: Boolean read GetIsCustomizing;
    property IsFocused: Boolean read GetIsFocused;
    property ItemLinks: TdxBarItemLinks read FItemLinks write SetItemLinks;
    property MenuArrowHeight: Integer read FMenuArrowHeight;
    property MenuArrowWidth: Integer read FMenuArrowWidth;
    property ParentBar: TCustomdxBarControl read FParentBar write SetParentBar;
    property TextSize: Integer read FTextSize;
    property ViewInfo: TCustomdxBarControlViewInfo read FViewInfo;

    property OnDestroy: TNotifyEvent read FOnDestroy write FOnDestroy;
  end;

  { IdxFadingPainterHelper }

  IdxFadingPainterHelper = interface
  ['{B97FA518-6C2E-4219-9430-19546EF91A1F}']
    function BarMarkIsOpaque: Boolean;
    procedure DrawBarMarkState(ABarControl: TdxBarControl; DC: HDC; const R: TRect; AState: TdxBarMarkState);
    procedure DrawButtonBackground(const ADrawParams: TdxBarButtonLikeControlDrawParams);
  end;

  { IdxFadingPainterHelper2 }

  IdxFadingPainterHelper2 = interface
  ['{7697DA35-139F-4247-964C-B8A4C38362E5}']
    function GetButtonPartState(const ADrawParams: TdxBarButtonLikeControlDrawParams; AControlPart: Integer): Integer;
  end;

  { TCustomdxBarControlDesignHelper }

  TCustomdxBarControlDesignHelper = class
  public
    class function CanDynamicallyChangeViewLevels: Boolean; virtual;
    class procedure FilterItemActions(var ASupportedActions: TdxBarCustomizationActions); virtual;
    class procedure GetEditors(AEditors: TList); virtual;
    class function GetForbiddenActions: TdxBarCustomizationActions; virtual;
  end;

  TdxBarControlDesignHelper = class(TCustomdxBarControlDesignHelper)
  public
    class function GetForbiddenActions: TdxBarCustomizationActions; override;
  end;

  TdxBarSubMenuControlDesignHelper = class(TCustomdxBarControlDesignHelper)
  public
    class procedure GetEditors(AEditors: TList); override;
    class function GetForbiddenActions: TdxBarCustomizationActions; override;
  end;

  TdxDockCol = class
  private
    FBarControl: TdxBarControl;
    FDockRow: TdxDockRow;
    FPos: TPoint;
  public
    constructor Create(ADockRow: TdxDockRow; ABarControl: TdxBarControl);
    procedure AssignPosition;
    property BarControl: TdxBarControl read FBarControl;
    property DockRow: TdxDockRow read FDockRow;
    property Pos: TPoint read FPos write FPos;
  end;

  TdxDockRow = class
  protected
    FBars: TList;
    FColList: TList;
    FDockControl: TdxDockControl;
    procedure AddBar(ABar: TdxBar);
    procedure DeleteBar(ABar: TdxBar; ADestroyEmptyDockRow: Boolean);
    function GetCol(Index: Integer): TdxDockCol;
    function GetColCount: Integer;
    function GetVisible: Boolean;
    procedure UpdateOneOnRows;
  public
    constructor Create(ADockControl: TdxDockControl);
    destructor Destroy; override;
    function AddCol(ABarControl: TdxBarControl): TdxDockCol;
    procedure DeleteCol(ABarControl: TdxBarControl); overload;
    procedure DeleteCol(AIndex: Integer); overload;
    property ColCount: Integer read GetColCount;
    property ColList: TList read FColList;
    property Cols[Index: Integer]: TdxDockCol read GetCol;
    property DockControl: TdxDockControl read FDockControl;
    property Visible: Boolean read GetVisible;
  end;

  TXDirection = (xdLeft, xdRight);
  TYDirection = (ydTop, ydBottom);

  { TdxBarControlMarkFadingHelper }

  TdxBarControlMarkFadingHelper = class(TdxFadingObjectHelper)
  private
    FOwner: TdxBarControl;
  protected
    function CanFade: Boolean; override;
    procedure DrawFadeImage; override;
    procedure GetFadingImages(out AFadeOutImage, AFadeInImage: TcxBitmap); override;
  public
    constructor Create(AOwner: TdxBarControl); virtual;
    destructor Destroy; override;
    property Owner: TdxBarControl read FOwner;
  end;

  { TdxBarControlMDIButtonFadingHelper }

  TdxBarControlMDIButtonFadingHelper = class(TdxFadingObjectHelper)
  private
    FMDIButton: TdxBarMDIButton;
    FOwner: TdxBarControl;
  protected
    function CanFade: Boolean; override;
    procedure DrawFadeImage; override;
    procedure GetFadingImages(out AFadeOutImage, AFadeInImage: TcxBitmap); override;
  public
    constructor Create(AOwner: TdxBarControl; AMDIButton: TdxBarMDIButton); virtual;
    destructor Destroy; override;
    procedure FadeIn;
    procedure FadeOut;

    property Owner: TdxBarControl read FOwner;
    property MDIButton: TdxBarMDIButton read FMDIButton;
  end;

  { TdxBarDockedControl }

  TdxBarDockedControl = class(TCustomdxBarControl)
  private
    FBar: TdxBar;
    FBeforeBarGetFocusFocusedWnd: HWND;
    FHitTest: Longint;
    FInternalLockCount: Integer;

    // Flags
    FIsItemResizing: Boolean;

    function CanResizeSelectedLink(APoint: TPoint): Boolean;

    procedure WMCaptureChanged(var Message: TMessage); message WM_CAPTURECHANGED;
    procedure WMLButtonUp(var Message: TWMLButtonUp); message WM_LBUTTONUP;
    procedure WMNCLButtonDown(var Message: TWMNCLButtonDown); message WM_NCLBUTTONDOWN;
  protected
    function GetCurrentCursor(const AMousePos: TPoint): TCursor; override;
    procedure Resize; override;

    procedure InitializeForDock(ABar: TdxBar); virtual;

    procedure BeginInternal;
    procedure EndInternal;
    function GetInternallyLocked: Boolean;
    property InternallyLocked: Boolean read GetInternallyLocked;

    procedure CustomizePrepare(APoint: TPoint; ASecondClick: Boolean); override;
    procedure DoBarMouseMove(Shift: TShiftState; const APoint: TPoint; AItemControl: TdxBarItemControl); override;
    procedure DoBarMouseLeave; override;

    // Caption Buttons
    function GetCaptionButtonIndex(const APoint: TPoint): Integer; virtual;
    function GetCaptionButtons: TdxBarCaptionButtons;
    function HasCaptionButtons: Boolean; virtual;
    function NeedActivateOwnerOnCaptionButtonClick: Boolean;
    function NeedHideOnNCMouseClick: Boolean; virtual;
    procedure DoBeforeCaptionButtonClick; virtual;
    procedure CaptionButtonClick(AIndex: Integer); virtual;
    procedure UpdateCaptionButtons(const AMousePos: TPoint; AMousePressed: Boolean = False; AActiveButtonIndex: Integer = -1); virtual;
    procedure UpdateCaptionButton(ACaptionButton: TdxBarCaptionButton); virtual;
    property CaptionButtons: TdxBarCaptionButtons read GetCaptionButtons;

    function GetMasterBar: TdxBar; virtual;

    property HitTest: Longint read FHitTest write FHitTest;
    property MasterBar: TdxBar read GetMasterBar;
  public
    property Bar: TdxBar read FBar write FBar;
  end;

  { TdxBarControl }

  TdxBarControl = class(TdxBarDockedControl)
  private
    FCloseButtonState: TdxBarMarkState;
    FDockedHandle: HWND;
    FDrawBitmap: TBitmap;
    FFloatingHandle: HWND;
    FHasSizeGrip: Boolean;

    FMarkFadingHelper: TdxBarControlMarkFadingHelper;
    FMarkIAccessibilityHelper: IdxBarAccessibilityHelper;
    FQuickPopup: TdxBarPopupControl;

    FMDIButtonFadingHelper: array[TdxBarMDIButton] of TdxBarControlMDIButtonFadingHelper;
    FMDIButtonWidth, FMDIButtonHeight: Integer;

    FIsScaleChanging: Boolean;
    FMaxSize: Integer;
    FMinSize: Integer;
    FMoreButtonsHintTimer: UINT;
    FMoving: Boolean;
    FPosSaving: Boolean;
    FPrevClipRgn: TcxRegion;
    FPrevFocusedBarControlLink: TcxObjectLink;
    FTruncated: Boolean;

    NewLeft, NewTop, NewWidth, NewHeight: Integer;
    RX, RY: TPoint;

    function GetCaptionBkColor: COLORREF;
    function GetCaptionColor: COLORREF;
    function GetHorizontal: Boolean;

    function GetMarkIAccessibilityHelper: IdxBarAccessibilityHelper;
    function GetVertical: Boolean;
    procedure SetCloseButtonState(Value: TdxBarMarkState);
    procedure SetNewBounds;
    procedure SetMoving(Value: Boolean);

    procedure ChangeStyleWinTo(AStyle: TdxBarDockingStyle; ADockControl: TdxDockControl);
    function GetDragPointOffset(Style: TdxBarDockingStyle): TPoint;
    function GetCaptionNCRect: TRect;
    procedure HideBar;
    function NeedHideBarOnDestroyHandle: Boolean;

    procedure DrawCloseButton(DC: HDC);
    procedure DrawMark(DC: HDC);

    procedure DrawMDIButton(AButton: TdxBarMDIButton; ASelected, APressed: Boolean);
    function GetMDIAreaSize: TSize;
    function GetMDIWidth: Integer;
    function GetMDIHeight: Integer;
    function RectMDI(Button: TdxBarMDIButton): TRect;
    function MDIButtonsOnBar: Boolean;
    function MDIButtonEnabled(AButton: TdxBarMDIButton; State: Integer): Boolean;

    procedure StartMoreButtonsHintTimer;
    procedure FinishMoreButtonsHintTimer;

    procedure WMDestroy(var Message: TMessage); message WM_DESTROY;
    procedure WMDpiChanged(var Message: TMessage); message WM_DPICHANGED;
    procedure WMGetDlgCode(var Message: TWMGetDlgCode); message WM_GETDLGCODE;
    procedure WMGetMinMaxInfo(var Message: TWMGetMinMaxInfo); message WM_GETMINMAXINFO;
    procedure WMGetObject(var Message: TMessage); message WM_GETOBJECT;
    procedure WMMouseActivate(var Message: TWMMouseActivate); message WM_MOUSEACTIVATE;
    procedure WMNCCalcSize(var Message: TWMNCCalcSize); message WM_NCCALCSIZE;
    procedure WMNCHitTest(var Message: TWMNCHitTest); message WM_NCHITTEST;
    procedure WMSize(var Message: TWMSize); message WM_SIZE;
    procedure WMSizing(var Message: TMessage); message WM_SIZING;
    procedure WMWindowPosChanging(var Message: TWMWindowPosChanging); message WM_WINDOWPOSCHANGING;
    procedure CMEnabledChanged(var Message: TMessage); message CM_ENABLEDCHANGED;
    procedure CMFontChanged(var Message: TMessage); message CM_FONTCHANGED;
  protected
    procedure CreateParams(var Params: TCreateParams); override;
    procedure CreateWnd; override;
    procedure Paint; override;
    procedure WindowPosChanged(var Message: TWMWindowPosChanged); override;
    procedure WndProc(var Message: TMessage); override;

    procedure LayoutChanged; override;

    // MessageHandler
    procedure DoKeyDown(var Message: TWMKey); override;
    procedure DoLButtonUp(var Message: TWMLButtonUp); override;

    procedure CalcControlsPositions; override;
    procedure CalcRowItemRects; override;
    procedure CalcDrawingConsts; override;
    procedure CalcDragOverParameters(const ACursorPos: TPoint;
      var ADragOverItemLink: TdxBarItemLink;
      var AIsBeginGroup, AIsFirstPart, AIsVerticalDirection: Boolean); override;

    // Conditions
    function CanAlignControl(AControl: TdxBarItemControl): Boolean; override;
    function CanCallInheritedNCCalcSize: Boolean; override; // obsolete
    function CanCustomizing: Boolean; override;
    function CanHideAllItemsInSingleLine: Boolean; virtual;
    function CanMoving: Boolean; virtual;
    function CanBeFocused: Boolean;
    function CanProcessShortCut: Boolean; virtual;
    function CanSetMouseSelectedItem(const P: TPoint; AItemControl: TdxBarItemControl): Boolean; override;
    function CanUpdateControlByMouseOnLostFocus: Boolean; virtual;

    function CheckLockUpdate: Boolean; override;
    procedure DoBarGetFocus(ASelectedItem: TdxBarItemControl); override;
    procedure DoBarLostFocus; override;
    procedure DoBarMouseDown(Button: TMouseButton; Shift: TShiftState;
      const APoint: TPoint; AItemControl: TdxBarItemControl; APointInClientRect: Boolean); override;
    procedure DoBarMouseLeave; override;
    procedure DoBarMouseMove(Shift: TShiftState; const APoint: TPoint; AItemControl: TdxBarItemControl); override;
    procedure DoHideAll(AReason: TdxBarCloseUpReason); override;
    procedure DoRepaintBar(ARecreateControls: Boolean); override;
    procedure DoSetIsActive(AValue: Boolean); override;
    procedure FocusItemControl(AItemControl: TdxBarItemControl); override;
    function GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass; override;

    function GetCaptionButtonIndex(const APoint: TPoint): Integer; override;
    procedure CaptionButtonClick(AIndex: Integer); override;
    procedure UpdateCaptionButtons(const AMousePos: TPoint; AMousePressed: Boolean = False; AActiveButtonID: Integer = - 1); override;

    function GetCaptionRect: TRect;
    procedure CheckMarkState(const P: TPoint);
    function CloseButtonRect: TRect;
    function CloseButtonRectNC: TRect;

    function GetAlphaBlendValue: Byte;
    function GetBackgroundBitmap: TGraphic; override;
    function GetBeginGroupSize: Integer; override;
    function GetCol: Integer;
    function GetDockCol: TdxDockCol;
    function GetCurrentCursor(const AMousePos: TPoint): TCursor; override;
    function GetHintItemText: string; override;
    function GetIsFadingAvailable: Boolean; override;
    function GetIsMainMenu: Boolean; override;
    function GetIsStatusBar: Boolean; override;
    function GetMarkAccessibilityHelperClass: TdxBarAccessibilityHelperClass; virtual;
    function GetMarkDrawState: TdxBarMarkState; override;
    function GetMoreButtonsHint: string; virtual;
    function GetMultiLine: Boolean; virtual;
    function GetQuickControlClass: TdxBarPopupControlClass; virtual;
    function GetRow: Integer;
    function GetViewInfoClass: TCustomdxBarControlViewInfoClass; override;

    function GetNCDrawingDC(AUpdatedRgn: HRGN): HDC; override;
    procedure ReleaseNCDrawingDC(ADC: HDC); override;

    function GetMasterForm: TCustomForm;
    function GetParentForm: TCustomForm; override;
    function GetSelectableObject: TPersistent; override;

    function AllowQuickCustomizing: Boolean; virtual;
    procedure HandleQuickAccessSubItemPopup(Sender: TObject);
    procedure InitQuickControl(AQuickControl: TdxBarPopupControl); virtual;
    procedure InitQuickCustomizeItemLinks(AQuickControl: TdxBarPopupControl); virtual;
    procedure InitAddRemoveSubItemPopup(AItemLinks: TdxBarItemLinks); virtual;
    procedure ResetToolbarClick(Sender: TObject);

    function GetMinWidth(AStyle: TdxBarDockingStyle): Integer; virtual;
    function GetMinHeight(AStyle: TdxBarDockingStyle): Integer; virtual;

    function GetMaxSize(ADockingStyle: TdxBarDockingStyle; AOrdinate: Boolean): Integer;
    function GetMaxWidth(AStyle: TdxBarDockingStyle): Integer; virtual;
    function GetMaxHeight(AStyle: TdxBarDockingStyle): Integer; virtual;

    function CalculateSize(ACurrentSize: Integer; AOrdinate: Boolean; out ALackSize: Boolean): TSize;
    procedure GetMultiLineBarWidth(ADockingStyle: TdxBarDockingStyle; AWishedWidth: Integer; var Result: TSize);
    function GetMultilineSize(ADockingStyle: TdxBarDockingStyle; AWishedSize: Integer; AOptimal, AOrdinate: Boolean): TSize;
    function GetSizeAllCursorBounds: TRect; virtual;
    function GetSizeForBounds(ADockingStyle: TdxBarDockingStyle; AWishedSize: Integer; AOrdinate: Boolean): TSize;
    function GetSizeForWidth(AStyle: TdxBarDockingStyle; AWishedWidth: Integer): TSize; virtual;
    function GetSizeForHeight(AStyle: TdxBarDockingStyle; AWishedHeight: Integer; AOptimal: Boolean = False): TSize;
    function GetTrackSize(AStyle: TdxBarDockingStyle): TSize;
    function HasCaption: Boolean; virtual;
    function HasCloseButton: Boolean; virtual;
    procedure InvalidateMark;
    function IsMarkAccessible: Boolean;

    function GetMouseTrackingBounds: TRect; override;

    function MarkExists: Boolean; override;
    function MarkNCRect: TRect;
    function MarkRect: TRect; override;
    function MarkScreenRect: TRect;
    procedure SetMarkState(Value: TdxBarMarkState); override;

    function RealMDIButtonsOnBar: Boolean; virtual;
    // IdxScaleFactor
    function GetScaleFactor: TdxScaleFactor; override;

    procedure SelectItemControl(AItemControl: TdxBarItemControl; AButton: TMouseButton; AShift: TShiftState); override;
    procedure ShowPopup(AItem: TdxBarItemControl); override;
    function SizeGripRect: TRect;
    procedure UpdateItem(AControl: TdxBarItemControl); override;

    function AllowNCPaint: Boolean; override;
    procedure BarManagerStyleChanged;
    procedure CaptionChanged; virtual;
    procedure DoDrawBeginGroup(const ASeparatorRect: TRect; AHorz: Boolean); virtual;
    procedure DoNCPaint(DC: HDC); virtual;
    procedure DoPaint; virtual;
    procedure DrawBeginGroups;
    procedure DrawContentBackground; virtual;
    procedure DrawMarks;
    procedure DrawMDIButtons(AButtons: TdxBarMDIButtons; AExcludeClipRect: Boolean = False);
    procedure DrawSelection(ADC: HDC);
    procedure FillBackground(ADC: HDC; const ARect: TRect; ABrush: HBRUSH; AColor: TColor; AIsClientArea: Boolean); override;
    procedure FrameChanged;
    function GetCaption: TCaption; virtual;
    function GetEditFont: TFont; override;
    function GetFont: TFont; virtual;
    function GetFullItemRect(Item: TdxBarItemControl): TRect; override;
    function GetItemRegion(Item: TdxBarItemControl): HRGN; override;
    function GetToolbarBrush: HBRUSH; override;
    procedure GlyphChanged; virtual;
    function IsBackgroundBitmap: Boolean; override;
    function IsTransparent: Boolean; override;
    function NCOffset: TPoint; override;
    procedure NCPaint(ADC: HDC); override;
    function NotHandleMouseMove(ACheckLastMousePos: Boolean = True): Boolean; override;
    procedure RebuildBar;
    procedure RefreshShadow;
    procedure RepaintMDIButtons;
    procedure SavePos;
    procedure SetFont; override;
    procedure SetDockingStyle(Value: TdxBarDockingStyle); override;
    procedure SetKeySelectedItem(Value: TdxBarItemControl); override;
    procedure SetLayeredAttributes; override;

    property QuickPopup: TdxBarPopupControl read FQuickPopup;

    property CaptionBkColor: COLORREF read GetCaptionBkColor;
    property CaptionColor: COLORREF read GetCaptionColor;
    property CloseButtonState: TdxBarMarkState read FCloseButtonState write SetCloseButtonState;

    property Horizontal: Boolean read GetHorizontal;
    property Moving: Boolean read FMoving write SetMoving;
    property MultiLine: Boolean read GetMultiLine;
    property Truncated: Boolean read FTruncated write FTruncated;
    property Vertical: Boolean read GetVertical;

    property MDIButtonWidth: Integer read FMDIButtonWidth;
    property MDIButtonHeight: Integer read FMDIButtonHeight;

    property Fader: TdxFader read GetFader;
    property MarkFadingHelper: TdxBarControlMarkFadingHelper read FMarkFadingHelper;
    property MasterForm: TCustomForm read GetMasterForm;
    property ParentForm: TCustomForm read GetParentForm;
    property ScaleFactor: TdxScaleFactor read GetScaleFactor;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    function ClientToScreen(const APoint: TPoint): TPoint;
    procedure Hide; override;
    function IsRealVertical: Boolean; override;
    function IsVertical: Boolean; override;
    function Kind: TdxBarKind; override;
    procedure Repaint; override;
    procedure ScaleForPPI(NewPPI: Integer); {$IFDEF DELPHIBERLIN}override;{$ENDIF}
    procedure UpdateFont;
    property DockControl;
    property MarkIAccessibilityHelper: IdxBarAccessibilityHelper read GetMarkIAccessibilityHelper;
  end;

  { TdxBarControlViewInfo }

  TdxBarControlViewInfo = class(TCustomdxBarControlViewInfo)
  private
    function GetBarControl: TdxBarControl;
  protected
    procedure CalcSeparatorInfo(AItemLink: TdxBarItemLink); virtual;
    function CanShowButtonGroups: Boolean; virtual;
    procedure DoCalcSeparatorInfo(AItemLink: TdxBarItemLink; const AItemRect: TRect); virtual;
    function IsLastVisibleItemControl(AItemControl: TdxBarItemControl): Boolean; virtual;
  public
    procedure Calculate; override;
    property BarControl: TdxBarControl read GetBarControl;
  end;

  { TdxBarSubMenuControl }

  TdxBarButtonControl = class;
  TdxBarSubItemControl = class;

  TdxBarSubMenuControl = class(TCustomdxBarControl)
  private
    FAnimationThread: TThread;
    FDetachCaptionSelected: Boolean;
    FExpandingMenu: Boolean;
    FExpandMenuTimer: UINT;
    FLightBrush: HBRUSH;
    FLightPalette: HPALETTE;
    FLockChangeSizeByChildItemControl: Boolean;
    FMenuAnimations: TdxBarMenuAnimations;
    FNonRecent: Boolean;
    FScrollTimerID: UINT;
    FShowAnimation: Boolean;
    FTopIndex: Integer;
    FXDirection: TXDirection;
    FYDirection: TYDirection;

    FOnShowLeft: Integer;
    FOnShowTop: Integer;
    FOwnerWidth: Integer;
    FOwnerHeight: Integer;
    FMinWidth: Integer;
    FStoredHeight: Integer;
    FStoredWidth: Integer;

    FDropDownButton: TdxBarButtonControl;
    FSubItem: TdxBarSubItemControl;

    FOnCloseUp: TdxBarCloseUpEvent;
    FOnPopup: TNotifyEvent;
    FOnShow: TNotifyEvent;

    function GetBandSize: Integer;
    function GetBarSize: Integer;
    function GetBarRect: TRect;
    function GetBottomVisibleItemIndex: Integer;
    function GetContentRect: TRect;
    function GetDetachCaptionSize: Integer;
    function GetMaxVisibleCount: Integer;
    function GetParentItemControl: TdxBarItemControl;
    function GetSubMenuOwner: IdxBarSubMenuOwner;
    function GetToolbarItemsBrush: HBRUSH;
    function GetTopVisibleItemIndex: Integer;
    procedure SetDetachCaptionSelected(AValue: Boolean);
    procedure SetTopIndex(AValue: Integer);

    procedure CalcBounds(out ASize: TSize);
    procedure CalcSize(out ASize: TSize);

    procedure CreateLightBrush;
    procedure DestroyLightBrush;
    procedure PreparePalette(DC: HDC);
    procedure UnpreparePalette(DC: HDC);
    procedure ExpandMenu;
    function ExtendedView: Boolean;
    procedure InvalidateItemsRect;
    procedure InvalidateDetachCaption;
    function MouseOnArrow(AArrowDirection: TcxArrowDirection): Boolean;
    function MouseOnUpArrow: Boolean;
    function MouseOnDownArrow: Boolean;
    procedure SetExpandMenuTimer(Time: UINT; ExpandAfterDelay: Boolean);
    procedure KillExpandMenuTimer;
    procedure KillScrollTimer;

    function IsAnimationRunning: Boolean;
    procedure OnTerminateAnimation(Sender: TObject);

    procedure CMFontChanged(var Message: TMessage); message CM_FONTCHANGED;
    procedure WMEraseBkgnd(var Message: TWMEraseBkgnd); message WM_ERASEBKGND;
    procedure WMGetDlgCode(var Message: TWMGetDlgCode); message WM_GETDLGCODE;
    procedure WMKeyDown(var Message: TWMKeyDown); message WM_KEYDOWN;
    procedure WMLButtonDown(var Message: TWMLButtonDown); message WM_LBUTTONDOWN;
    procedure WMNCCalcSize(var Message: TWMNCCalcSize); message WM_NCCALCSIZE;
    procedure WMNCHitTest(var Message: TWMNCHitTest); message WM_NCHITTEST;
    procedure WMPrint(var Message: TMessage); message WM_PRINT;
    procedure WMRButtonDown(var Message: TWMRButtonDown); message WM_RBUTTONDOWN;
    procedure WMRButtonUp(var Message: TWMRButtonUp); message WM_RBUTTONUP;
    procedure WMTimer(var Message: TWMTimer); message WM_TIMER;
  protected
    FMousePosOnPopup: TPoint;
    FParentWnd: HWND;
    FPopupAlignment: TPopupAlignment;

    procedure CreateParams(var Params: TCreateParams); override;
    procedure CreateWnd; override;
    procedure DestroyWindowHandle; override;
    procedure DestroyWnd; override;
    procedure DoCloseUp; dynamic;
    procedure DoPopup; dynamic;
    procedure Paint; override;
    procedure NCPaint(ADC: HDC); override;

    // MessageHandler
    procedure DoKeyDown(var Message: TWMKey); override;

    procedure CalcControlsPositions; override;
    procedure CalcDrawingConsts; override;
    procedure CalcDragOverParameters(const ACursorPos: TPoint;
      var ADragOverItemLink: TdxBarItemLink;
      var AIsBeginGroup, AIsFirstPart, AIsVerticalDirection: Boolean); override;
    procedure CalcItemsRect; override;
    function CanActiveChange: Boolean; override;
    function CanCustomizing: Boolean; override;
    function CanDrawClippedItem(AItemRect: TRect): Boolean; override;
    function CanShowHint: Boolean; override;
    function CheckLockUpdate: Boolean; override;
    function ChildrenHaveShadows: Boolean; override;
    procedure CorrectVisibleItemsRectBottom; override;
    procedure CorrectVisibleItemsRectTop; override;
    procedure DoCreateControls; override;
    procedure DoDestroyControls; override;
    procedure DoBarMouseLeave; override;
    procedure DoBarMouseMove(Shift: TShiftState; const APoint: TPoint; AItemControl: TdxBarItemControl); override;
    procedure DoDropFocus; override;
    procedure DoNCPaint(DC: HDC; const ARect: TRect); virtual;
    procedure DoHideAll(AReason: TdxBarCloseUpReason); override;
    procedure DoPaintItem(AControl: TdxBarItemControl; ACanvas: TcxCanvas; const AItemRect: TRect); override;
    procedure DoRepaintBar(ARecreateControls: Boolean); override;
    procedure DoSetIsActive(AValue: Boolean); override;
    procedure DragOver(X, Y: Integer; var Accept: Boolean); override;

    function AllowSelectionFrame: Boolean; override;
    function ChangeSizeByChildItemControl(out ASize: TSize): Boolean; virtual;
    function GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass; override;
    function GetBeginGroupSize: Integer; override;
    function GetBehaviorOptions: TdxBarBehaviorOptions; override;
    function GetBottomItemControl: TdxBarItemControl;
    function GetDefaultItemHeight(AItem: TdxBarItemControl): Integer; override;
    function GetEditFont: TFont; override;
    function GetIsContextMenu: Boolean; virtual;
    function GetIsCustomizing: Boolean; override;
    function GetIsMainMenu: Boolean; override;
    function GetIsStatusBar: Boolean; override;
    function GetIsShadowVisible: Boolean; override;
    function GetItemControlOffset(AItemLink: TdxBarItemLink): Integer; override;
    function GetItemRectEx(Item: TdxBarItemControl; IsBeginGroup: Boolean): TRect; override;
    function GetItemsPaneSize: TSize; virtual;
    function GetHintItemText: string; override;
    function GetPaintType: TdxBarPaintType; override;
    function GetScaleFactor: TdxScaleFactor; override;
    function GetSelectableObject: TPersistent; override;
    function GetTextSize: Integer; override;
    function GetTopItemControl: TdxBarItemControl;
    function GetViewInfoClass: TCustomdxBarControlViewInfoClass; override;
    function NeedHideOnClick: Boolean; override;
    function IsInternal: Boolean; override;
    function IsMeaningParent(AWnd: HWND): Boolean; override;
    function IsPopup: Boolean; override;
    function IsVerticalDirection: Boolean; override;
    function MustFitInWorkAreaWidth: Boolean; virtual;
    function NeedBufferedRepaint: Boolean;
    function NeedsSelectFirstItemOnDropDownByKey: Boolean; virtual;
    procedure SetFont; override;
    procedure SetRecentItemCount;
    procedure SetAccelSelectedItem(AItemLink: TdxBarItemLink; ADuplicate: Boolean); override;
    procedure SetControlVisible(AControl: TdxBarItemControl); override;
    procedure SetSelectedControl(Value: TdxBarItemControl); override;
    procedure SetSizeAndCheckBounds(const APredefinedSize: TSize; out AChangeXDirection, AChangeYDirection: Boolean);
    procedure TerminateAnimation(ANeedFinish: Boolean);
    procedure UpdateItem(AControl: TdxBarItemControl); override;
    procedure UpdateParentItemControl; override;

    procedure InitCustomizationPopup(AItemLinks: TdxBarItemLinks); override;
    procedure ShowPopup(AItem: TdxBarItemControl); override;

    function CanDetach: Boolean;
    function Detachable: Boolean;
    function DetachCaptionAreaSize: Integer;
    function DetachCaptionRect: TRect;
    function MouseOnDetachCaption: Boolean;
    function NotHandleMouseMove(ACheckLastMousePos: Boolean = True): Boolean; override;
    procedure DoDetachMenu;

    function MarkArrowSize: Integer;
    function MarkExists: Boolean; override;
    function MarkRect: TRect; override;
    procedure SetMarkState(Value: TdxBarMarkState); override;

    function DownArrowExists: Boolean;
    function GetScrollTime: Integer; virtual;
    function UpArrowExists: Boolean;
    function UseScrollButtons: Boolean;

    procedure DoCalcSize(out ASize: TSize); virtual;
    procedure DoCorrectSize(var ASize: TSize);
    procedure DoShow; virtual;

    procedure RestoreSize; virtual;
    procedure StoreAndReduceSize; virtual;

    procedure DrawBar;
    procedure DrawContent; virtual;
    procedure DrawItems; override;
    procedure DrawScrollArea;
    procedure FillBackground(DC: HDC; const ARect: TRect; ABrush: HBRUSH; AColor: TColor;
      AIsClientArea: Boolean); override;
    procedure DoFillBackgroundEx(ACanvas: TcxCanvas; const ARect: TRect; ABrush: HBRUSH; AColor: TColor;
      AIsClientArea: Boolean); virtual;
    procedure FillBackgroundEx(ACanvas: TcxCanvas; const ARect: TRect; ABrush: HBRUSH; AColor: TColor;
      AIsClientArea: Boolean);

    function GetBackgroundBitmap: TGraphic; override;
    function GetBorderSize: Integer; override;
    function GetClientOffset(AIncludeDetachCaption: Boolean = True): TRect; virtual;
    function GetIndent1: Integer;
    function GetIndent2: Integer;
    function GetItemsRectOffset: TRect; override;
    function IsDoubleBufferedNeeded: Boolean; override;
    function IsTransparent: Boolean; override;

    function GetMouseTrackingBounds: TRect; override;

    property BandSize: Integer read GetBandSize;
    property BarSize: Integer read GetBarSize;
    property BorderSize: Integer read GetBorderSize;
    property DetachCaptionSelected: Boolean read FDetachCaptionSelected write SetDetachCaptionSelected;
    property DetachCaptionSize: Integer read GetDetachCaptionSize;

    property BarRect: TRect read GetBarRect;
    property ContentRect: TRect read GetContentRect;

    property ToolbarItemsBrush: HBRUSH read GetToolbarItemsBrush;

    property BottomItemControl: TdxBarItemControl read GetBottomItemControl;
    property BottomVisibleItemIndex: Integer read GetBottomVisibleItemIndex;
    property IsContextMenu: Boolean read GetIsContextMenu;
    property MaxVisibleCount: Integer read GetMaxVisibleCount;
    property NonRecent: Boolean read FNonRecent;
    property TopIndex: Integer read FTopIndex write SetTopIndex;
    property TopItemControl: TdxBarItemControl read GetTopItemControl;
    property TopVisibleItemIndex: Integer read GetTopVisibleItemIndex;
    property OnShowLeft: Integer read FOnShowLeft;
    property OnShowTop: Integer read FOnShowTop;

    property OnCloseUp: TdxBarCloseUpEvent read FOnCloseUp write FOnCloseUp;
    property OnPopup: TNotifyEvent read FOnPopup write FOnPopup;
    property OnShow: TNotifyEvent read FOnShow write FOnShow;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;

    function Kind: TdxBarKind; override;
    procedure Hide; override;
    procedure Show; override;

    property OwnerWidth: Integer read FOwnerWidth write FOwnerWidth;
    property OwnerHeight: Integer read FOwnerHeight write FOwnerHeight;
    property ParentItemControl: TdxBarItemControl read GetParentItemControl;
  end;

  TdxBarSubMenuControlViewInfo = class(TCustomdxBarControlViewInfo)
  private
    function GetBarControl: TdxBarSubMenuControl;
  public
    procedure Calculate; override;
    property BarControl: TdxBarSubMenuControl read GetBarControl;
  end;

  { TdxBarInternalSubMenuControl }

  TdxBarInternalSubMenuControl = class(TdxBarSubMenuControl)
  protected
    function GetIsCustomizing: Boolean; override;
    function IsInternal: Boolean; override;
  end;

  { TdxBarCustomizingPopup }

  TdxBarCustomizingPopup = class(TdxBarInternalSubMenuControl)
  public
    constructor Create(AOwner: TComponent); override;
  end;

  {--------------------------------------
                   Items
   --------------------------------------}

  TdxBarItemActionLink = class(TActionLink)
  protected
    FClient: TdxBarItem;
    procedure AssignClient(AClient: TObject); override;
    function IsCaptionLinked: Boolean; override;
    function IsCheckedLinked: Boolean; override;
    function IsEnabledLinked: Boolean; override;
    function IsHelpContextLinked: Boolean; override;
    function IsHintLinked: Boolean; override;
    function IsImageIndexLinked: Boolean; override;
    function IsShortCutLinked: Boolean; override;
    function IsVisibleLinked: Boolean; override;
    function IsOnExecuteLinked: Boolean; override;
    procedure SetCaption(const Value: string); override;
    procedure SetChecked(Value: Boolean); override;
    procedure SetEnabled(Value: Boolean); override;
    procedure SetHelpContext(Value: THelpContext); override;
    procedure SetHint(const Value: string); override;
    procedure SetImageIndex(Value: Integer); override;
    procedure SetShortCut(Value: TShortCut); override;
    procedure SetVisible(Value: Boolean); override;
    procedure SetOnExecute(Value: TNotifyEvent); override;
  end;

  TdxBarItemActionLinkClass = class of TdxBarItemActionLink;

  { TdxBarItemStylesData }

  TdxBarItemStyleChangeKind = (sckDrawing, sckStructure, sckNone);
  TdxBarItemStylesDataChangeEvent = procedure(AChangeKind: TdxBarItemStyleChangeKind) of object;

  TdxBarItemStylesData = class(TcxInterfacedPersistent, IcxStyleChangeListener)
  private
    FChangeEventLockCount: Integer;
    FChangeKind: TdxBarItemStyleChangeKind;
    FIsDestroying: Boolean;
    FOnChange: TdxBarItemStylesDataChangeEvent;
    FStyleCount: Integer;
    FStylesData: array of TdxBarItemStyleData;

    // IcxStyleChangeListener
    procedure StyleChanged(AStyle: TcxCustomStyle);
    procedure StyleRemoved(AStyle: TcxCustomStyle);

    procedure DoChange(AChangeKind: TdxBarItemStyleChangeKind);
    function GetStyle(AIndex: Integer): TcxStyle;
    function GetStyleReferenceCount(AStyle: TcxStyle): Integer;
    procedure InternalSetStyle(AIndex: Integer; Value: TcxStyle);
    procedure InternalStyleChanged(AIndex: Integer); overload;
    procedure InternalStyleChanged(AStyle: TcxStyle); overload;
    procedure InternalStyleRemoved(AStyle: TcxStyle);
    function IsChangeEventLocked: Boolean;
    procedure LockChangeEvent(ALock: Boolean);
    procedure SetStyle(AIndex: Integer; Value: TcxStyle);
  protected
    property IsDestroying: Boolean read FIsDestroying;
    property StyleCount: Integer read FStyleCount;
  public
    constructor Create(AStyleCount: Integer); reintroduce;
    destructor Destroy; override;
    property Styles[AIndex: Integer]: TcxStyle read GetStyle write SetStyle;
    property OnChange: TdxBarItemStylesDataChangeEvent read FOnChange
      write FOnChange;
  end;

  { TdxBarScreenTip }

  TdxBarScreenTip = class(TdxScreenTip);

  { TdxBarScreenTipRepository }

  TdxBarScreenTipRepository = class(TdxScreenTipRepository);

  { TdxBarCustomHintViewInfo }

  TdxBarCustomHintViewInfo = class(TdxCustomHintViewInfo)
  protected
    function IsScreenTip: Boolean; virtual;
    procedure SetWindowDrawParams(AWindow: TdxBarHintWindow); virtual;
  end;

  { TdxBarHintViewInfoHelper }

  TdxBarHintViewInfoHelper = class(TdxHintViewInfoHelper)
  strict private
    FBarManager: TdxBarManager;
  protected
    function GetScaleFactor: TdxScaleFactor; override;
    procedure PrepareCanvasFont(ACanvas: TCanvas); override;
  public
    constructor Create(ABarManager: TdxBarManager; const AHint, AShortCut: string; const ACursorPos: TPoint);
  end;

  { TdxBarHintViewInfo }

  TdxBarHintViewInfo = class(TdxBarCustomHintViewInfo)
  private
    FBarManager: TdxBarManager;
    FCursorPos: TPoint;
    FHint: string;
    FShortCut: string;
  protected
    procedure CreateHelper; override;
    procedure SetWindowDrawParams(AWindow: TdxBarHintWindow); override;
  public
    constructor Create(ABarManager: TdxBarManager; const AHint, AShortCut: string; const ACursorPos: TPoint);
  end;

  { TdxBarScreenTipPainter }

  TdxBarScreenTipPainter = class(TdxScreenTipPainter)
  strict private
    FPainter: TdxBarPainter;
  public
    constructor Create(APainter: TdxBarPainter);
    function GetColorPalette: IdxColorPalette; override;
    function GetDescriptionTextColor: TColor; override;
    function GetFooterLineSize: Integer; override;
    function GetTitleTextColor: TColor; override;
    procedure DrawBackground(ACanvas: TcxCanvas; const ARect: TRect); override;
    procedure DrawFooterLine(ACanvas: TcxCanvas; const ARect: TRect); override;
  end;

  { TdxBarLikeHintScreenTipViewInfoHelper }

  TdxBarLikeHintScreenTipViewInfoHelper = class(TdxScreenTipLikeHintViewInfoHelper)
  strict private
    FBarManager: TdxBarManager;
  protected
    function GetScaleFactor: TdxScaleFactor; override;
    procedure PrepareCanvasFont(ACanvas: TCanvas); override;
  public
    constructor Create(ABarManager: TdxBarManager; APainter: TdxScreenTipPainter;
      const AHint, AShortCut: string; const ACursorPos: TPoint);
  end;

  { TdxBarLikeHintScreenTipViewInfo }

  TdxBarLikeHintScreenTipViewInfo = class(TdxBarHintViewInfo)
  strict private
    FPainter: TdxScreenTipPainter;
  protected
    procedure CreateHelper; override;
    procedure DestroyHelper; override;
    function IsScreenTip: Boolean; override;
  public
    constructor Create(ABarManager: TdxBarManager; APainter: TdxBarPainter;
      const AHint, AShortCut: string; const ACursorPos: TPoint);
  end;

  { TdxBarScreenTipViewInfo }

  TdxBarScreenTipViewInfo = class(TdxBarCustomHintViewInfo)
  private
    FHint: string;
    FPainter: TdxScreenTipPainter;
    FScreenTip: TdxScreenTip;
    FShortCut: string;
  protected
    procedure CreateHelper; override;
    procedure DestroyHelper; override;
    function IsScreenTip: Boolean; override;
  public
    constructor Create(AScreenTip: TdxScreenTip; APainter: TdxBarPainter;
      const AHintText: string; AShortCut: string = '');
  end;

  { TdxBarHintWindow }

  TdxBarHintWindow = class(TcxBaseHintWindow)
  private
    FIsScreenTipWindow: Boolean;
    FViewInfo: TdxBarCustomHintViewInfo;
    procedure WMShowWindow(var Message: TWMShowWindow); message WM_SHOWWINDOW;
  protected
    procedure AdjustActivateRect(var ARect: TRect); override;
    procedure EnableRegion; override;
    function HasWindowRegion: Boolean; override;
    function GetHideHintTime: Integer; virtual;
    function GetShowHintTime: Integer; virtual;
    procedure Paint; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    function CalcHintRect(MaxWidth: Integer; const AHint: string;
      AData: Pointer): TRect; override;

    property ShowHintTime: Integer read GetShowHintTime;
    property HideHintTime: Integer read GetHideHintTime;
    property IsScreenTipWindow: Boolean read FIsScreenTipWindow write FIsScreenTipWindow;
  end;

  { TdxBarItem }

  TdxBarIsChildWindowEvent = function(Sender: TdxBarItem; AWindowHandle: THandle): Boolean of object;

  TdxBarItem = class(TdxBarComponent)
  private
    FActionLink: TdxBarItemActionLink;
    FAlign: TdxBarItemAlign;
    FCanSelect: Boolean;
    FCaption: string;
    FCategory: Integer;
    FCheckDefaults: Boolean;
    FClickItemLink: TdxBarItemLink;
    FData: TObject;
    FDescription: string;
    FGlyph: TdxSmartGlyph;
    FHelpContext: THelpContext;
    FHint: string;
    FImageIndex: Integer;
    FIsPredefined: Boolean;
    FKeyTip: string;
    FLargeGlyph: TdxSmartGlyph;
    FLargeImageIndex: Integer;
    FLinks: TList;  // the list of the ItemLinks
    FMergeKind: TdxBarItemMergeKind;
    FMergeOrder: Integer;
    FPaintStyle: TdxBarPaintStyle;
    FShortCut: TShortCut;
    FStylesData: TdxBarItemStylesData;
    FScreenTip: TdxScreenTip;
    FUnclickAfterDoing: Boolean;
    FWidth: Integer;

    FOnClick: TNotifyEvent;
    FOnCreate: TNotifyEvent;
    FOnDestroy: TNotifyEvent;
    FOnIsChildWindow: TdxBarIsChildWindowEvent;
    FOnGetScreenTip: TdxOnGetScreenTip;

    function GetAction: TBasicAction;
    function GetActiveLink: TdxBarItemLink;
    function GetActuallyVisible: Boolean;
    function GetCurItemLink: TdxBarItemLink;
    function GetFlat: Boolean;
    function GetIndex: Integer;
    function GetIsDesigning: Boolean;
    function GetIsDestroying: Boolean;
    function GetIsLoading: Boolean;
    function GetLinkCount: Integer;
    function GetLinks(Index: Integer): TdxBarItemLink;
    function GetPainterClass: TdxBarPainterClass;
    function GetVisibleForCustomization: Boolean;
    function GetVisibleForUser: Boolean;
    procedure SetAction(Value: TBasicAction);
    procedure SetAlign(Value: TdxBarItemAlign);
    procedure SetCategory(Value: Integer);
    procedure SetDescription(Value: string);
    procedure SetIndex(Value: Integer);
    procedure SetLargeGlyph(Value: TdxSmartGlyph);
    procedure SetMergeOrder(Value: Integer);
    procedure SetPaintStyle(Value: TdxBarPaintStyle);
    procedure SetShowCaption(Value: Boolean);
    procedure SetShortCut(Value: TShortCut);

    procedure DestroyLinks;
    procedure DoActionChange(Sender: TObject);
    function IsEnabledStored: Boolean;
    function IsHelpContextStored: Boolean;
    function IsImageIndexStored: Boolean;
    function IsShortCutStored: Boolean;
    function IsVisibleStored: Boolean;
    function IsOnClickStored: Boolean;
    function GetHintFromCaption: string;
    procedure OnGlyphChanged(Sender: TObject);
    procedure OnLargeGlyphChanged(Sender: TObject);
  protected
    FShowCaption: Boolean;

    procedure AssignTo(Dest: TPersistent); override;
    procedure ChangeScale(M, D: Integer); virtual;
    procedure Loaded; override;
    procedure Notification(AComponent: TComponent; Operation: TOperation); override;
    procedure ReadState(Reader: TReader); override;
    procedure SelectionChanged; override;

    function GetEnabled: Boolean; override;
    procedure SetName(const NewName: TComponentName); override;
    procedure SetEnabled(Value: Boolean); override;
    procedure SetVisible(Value: TdxBarItemVisible); override;
    procedure SetWidth(Value: Integer);

    // IdxBarSelectableItem
    function CanDelete(ADestruction: Boolean = False): Boolean; override;
    procedure ExecuteCustomizationAction(ABasicAction: TdxBarCustomizationAction); override;
    procedure GetMasterObjects(AList: TdxObjectList); override;
    function GetNextSelectableItem: IdxBarSelectableItem; override;
    function GetSelectableParent: TPersistent; override;
    function GetSupportedActions: TdxBarCustomizationActions; override;
    procedure DeleteSelection(var AReference: IdxBarSelectableItem; ADestruction: Boolean); override;
    procedure Invalidate; override;
    function IsComplex: Boolean; override;
    function SelectParentComponent: Boolean; override;

    procedure ActionChange(Sender: TObject; CheckDefaults: Boolean); dynamic;
    function CanBePlacedOn(AParentKind: TdxBarItemControlParentKind; AToolbar: TdxBar; out AErrorText: string): Boolean; virtual;
    function CanChangePaintStyle: Boolean; virtual;
    function CanClicked: Boolean; virtual;
    function CanMergeWith(AItem: TdxBarItem): Boolean;
    property CanSelect: Boolean read FCanSelect write FCanSelect default True;
    function CurImageIndexLinked: Boolean;
    procedure DrawCustomizingImage(ACanvas: TCanvas; const ARect: TRect; AState: TOwnerDrawState); virtual;
    procedure DrawCustomizingImageContent(ACanvas: TCanvas; const ARect: TRect; ASelected: Boolean); virtual;
    function GetActionLinkClass: TdxBarItemActionLinkClass; dynamic;
    function GetActionImageIndex: Integer; virtual;
    procedure SetActionImageIndex(Value: Integer); virtual;
    function GetControlClass(AIsVertical: Boolean): TdxBarItemControlClass; virtual;
    function GetHidden: Boolean; virtual;
    function GetItemLinks: TdxBarItemLinks; virtual;
    class function GetStyleCount: Integer; virtual;
    function GetStyleValue(AIndex: Integer): TcxStyle;
    function HasAccel(AItemLink: TdxBarItemLink): Boolean; virtual;
    function HasControls: Boolean;
    procedure HideControl(AControl: TdxBarItemControl); virtual;
    function InternalActuallyVisible: Boolean; virtual;
    function InternalCanMergeWith(AItem: TdxBarItem): Boolean; virtual;
    function IsHintFromCaption: Boolean;
    function IsShortCut(AShortCut: TShortCut): Boolean; virtual;
    function IsStyleColorSupported: Boolean; virtual;
    function NeedToBeHidden: Boolean; virtual;
    procedure ObjectNotification(AOperation: TOperation; AObject: TObject); virtual;
    procedure Recalculate; virtual;
    procedure ShowDefaultEventHandler;
    procedure Update; virtual;
    procedure UpdateActionLink; virtual;
    procedure UpdateEx(AParentKinds: TdxBarKinds = dxBarKindAny); virtual;
    function UseHotImages: Boolean; virtual;
    function UseLargeImages: Boolean; virtual;

    function DoIsChildWindow(AWindowHandle: THandle): Boolean;
    function DoGetScreenTip: TdxScreenTip;
    function GetCaption: string; virtual;
    function GetGlyph: TdxSmartGlyph; virtual;
    function GetHint: string; virtual;
    function GetImageIndex: Integer; virtual;
    function GetScreenTip: TdxScreenTip; virtual;
    function IsCaptionStored: Boolean; virtual;
    function IsHintStored: Boolean; virtual;
    procedure SetCaption(const Value: string); virtual;
    procedure SetGlyph(Value: TdxSmartGlyph); virtual;
    procedure SetHint(Value: string); virtual;
    procedure SetImageIndex(Value: Integer); virtual;
    procedure SetLargeImageIndex(Value: Integer); virtual;
    procedure SetScreenTip(Value: TdxScreenTip); virtual;
    procedure SetStyleValue(AIndex: Integer; Value: TcxStyle);

    // Change Group
    procedure CaptionChanged; virtual;
    procedure EnabledChanged; virtual;
    procedure GlyphChanged; virtual;
    procedure HotGlyphChanged; virtual;
    procedure InternalStyleChanged(AChangeKind: TdxBarItemStyleChangeKind);
    procedure LargeGlyphChanged; virtual;
    procedure PaintStyleChanged; virtual;
    procedure ShortCutChanged; virtual;
    procedure VisibleChanged;
    procedure WidthChanged; virtual;

    procedure CheckLinks(ASource: TCustomIniFile; const ABaseSection: string); virtual;
    function GetIniSection(const ABaseSection: string): string; virtual;
    procedure LoadFromIni(ASource: TCustomIniFile; const ABaseSection: string; AStoringKind: TdxBarStoringKind); virtual;
    procedure LoadUsageData(ASource: TCustomIniFile; const ABaseSection: string); virtual;
    procedure SaveToIni(ADestination: TCustomIniFile; const ABaseSection: string; AStoringKind: TdxBarStoringKind); virtual;

    procedure GetTextViewParams(out AViewParams: TcxViewParams);
    procedure GetViewParams(AStyle: TcxStyle; out AViewParams: TcxViewParams);

    class function GetNewCaption: string; virtual;

    property ActionLink: TdxBarItemActionLink read FActionLink write FActionLink;
    property ActionImageIndex: Integer read GetActionImageIndex write SetActionImageIndex;
    property Flat: Boolean read GetFlat;
    property Hidden: Boolean read GetHidden;
    property IsDesigning: Boolean read GetIsDesigning;
    property IsDestroying: Boolean read GetIsDestroying;
    property IsLoading: Boolean read GetIsLoading;
    property PainterClass: TdxBarPainterClass read GetPainterClass;
    property PaintStyle: TdxBarPaintStyle read FPaintStyle write SetPaintStyle default psStandard;
    property ShowCaption: Boolean read FShowCaption write SetShowCaption;
    property StylesData: TdxBarItemStylesData read FStylesData;
    property Width: Integer read FWidth write SetWidth;
    property OnCreate: TNotifyEvent read FOnCreate write FOnCreate;
    property OnIsChildWindow: TdxBarIsChildWindowEvent read FOnIsChildWindow write FOnIsChildWindow;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure AfterConstruction; override;
    procedure Assign(Source: TPersistent); override;
    procedure BeforeDestruction; override;
    procedure Click; dynamic;
    procedure DirectClick; dynamic;
    procedure DoClick; dynamic;
    function GetAddMessageName: string; virtual;
    function GetCurrentImages: TCustomImageList; virtual;
    function GetParentComponent: TComponent; override;
    function HasParent: Boolean; override;
    procedure SetParentComponent(AParent: TComponent); override;

    property ActuallyVisible: Boolean read GetActuallyVisible;
    property ClickItemLink: TdxBarItemLink read FClickItemLink;
    property CurItemLink: TdxBarItemLink read GetCurItemLink;
    property Data: TObject read FData write FData;
    property Glyph: TdxSmartGlyph read GetGlyph write SetGlyph;
    property ImageIndex: Integer read GetImageIndex write SetImageIndex stored IsImageIndexStored default -1;
    property Index: Integer read GetIndex write SetIndex;
    property IsPredefined: Boolean read FIsPredefined;
    property LargeGlyph: TdxSmartGlyph read FLargeGlyph write SetLargeGlyph;
    property LargeImageIndex: Integer read FLargeImageIndex write SetLargeImageIndex default -1;
    property LinkCount: Integer read GetLinkCount;
    property Links[Index: Integer]: TdxBarItemLink read GetLinks;
    property ShortCut: TShortCut read FShortCut write SetShortCut stored IsShortCutStored default 0;
    property UnclickAfterDoing: Boolean read FUnclickAfterDoing write FUnclickAfterDoing default False;
    property VisibleForCustomization: Boolean read GetVisibleForCustomization;
    property VisibleForUser: Boolean read GetVisibleForUser;

    property OnClick: TNotifyEvent read FOnClick write FOnClick stored IsOnClickStored;
  published
    property Action: TBasicAction read GetAction write SetAction;
    property Align: TdxBarItemAlign read FAlign write SetAlign default iaLeft;
    property Caption: string read GetCaption write SetCaption stored IsCaptionStored;
    property Category: Integer read FCategory write SetCategory;
    property Description: string read FDescription write SetDescription;
    property Enabled stored IsEnabledStored default True;
    property HelpContext: THelpContext read FHelpContext write FHelpContext stored IsHelpContextStored default 0;
    property Hint: string read GetHint write SetHint stored IsHintStored;
    property KeyTip: string read FKeyTip write FKeyTip;
    property MergeKind: TdxBarItemMergeKind read FMergeKind write FMergeKind
      default mkAdd;
    property MergeOrder: Integer read FMergeOrder write SetMergeOrder default 0;
    property Style: TcxStyle index 0 read GetStyleValue write SetStyleValue;
    property ScreenTip: TdxScreenTip read GetScreenTip write SetScreenTip;
    property Visible stored IsVisibleStored;

    property OnDestroy: TNotifyEvent read FOnDestroy write FOnDestroy;
    property OnGetScreenTip: TdxOnGetScreenTip read FOnGetScreenTip write FOnGetScreenTip;
  end;

  TdxBarLabel = class(TdxBarItem)
  public
    constructor Create(AOwner: TComponent); override;
  end;

  TdxBarSeparator = class(TdxBarLabel)
  protected
    function CanBePlacedOn(AParentKind: TdxBarItemControlParentKind;
      AToolbar: TdxBar; out AErrorText: string): Boolean; override;
    class function GetNewCaption: string; override;
    function GetSupportedActions: TdxBarCustomizationActions; override;
  published
    property ShowCaption default True;
  end;

  TdxBarWindowItem = class(TdxBarItem)
  private
    FEmptyWindow: Boolean;
    FText: string;

    FOnChange: TNotifyEvent;
    FOnCurChange: TNotifyEvent;
    FOnEnter: TNotifyEvent;
    FOnExit: TNotifyEvent;
    FOnKeyDown: TKeyEvent;
    FOnKeyPress: TKeyPressEvent;
    FOnKeyUp: TKeyEvent;

    function GetCurText: string;
    function GetFocusedItemLink: TdxBarItemLink;
    procedure SetCurText(Value: string);
  protected
    function CanClicked: Boolean; override;
    procedure Change; dynamic;
    procedure CurChange; dynamic;
    procedure DoEnter; dynamic;
    procedure DoExit; dynamic;
    function GetControlClass(AIsVertical: Boolean): TdxBarItemControlClass; override;
    function GetText: string; virtual;
    procedure KeyDown(var Key: Word; Shift: TShiftState); dynamic;
    procedure KeyPress(var Key: Char); dynamic;
    procedure KeyUp(var Key: Word; Shift: TShiftState); dynamic;
    procedure SetText(Value: string); virtual;
    property CurText: string read GetCurText write SetCurText;
    property EmptyWindow: Boolean read FEmptyWindow write FEmptyWindow;
    property Text: string read GetText write SetText;
  public
    procedure SetFocus(ACheckBarControlVisibility: Boolean = False); virtual;
    property FocusedItemLink: TdxBarItemLink read GetFocusedItemLink;
  published
    property OnChange: TNotifyEvent read FOnChange write FOnChange;
    property OnCurChange: TNotifyEvent read FOnCurChange write FOnCurChange;
    property OnEnter: TNotifyEvent read FOnEnter write FOnEnter;
    property OnExit: TNotifyEvent read FOnExit write FOnExit;
    property OnKeyDown: TKeyEvent read FOnKeyDown write FOnKeyDown;
    property OnKeyPress: TKeyPressEvent read FOnKeyPress write FOnKeyPress;
    property OnKeyUp: TKeyEvent read FOnKeyUp write FOnKeyUp;
  end;

  { TdxBarButton }

  TdxBarButtonState = (bstChecked, bstDropDown);
  TdxBarButtonStates = set of TdxBarButtonState;
  TdxBarButtonStyle = (bsDefault, bsChecked, bsDropDown, bsCheckedDropDown);

  TdxBarButtonLikeItem = class(TdxBarItem)
  private
    FGlyphLayout: TdxBarGlyphLayout;
    procedure SetGlyphLayout(Value: TdxBarGlyphLayout);
  protected
    procedure CheckLinks(ASource: TCustomIniFile; const ABaseSection: string); override;
    procedure LoadFromIni(ASource: TCustomIniFile; const ABaseSection: string; AStoringKind: TdxBarStoringKind); override;
    procedure LoadUsageData(ASource: TCustomIniFile; const ABaseSection: string); override;
    procedure SaveToIni(ADestination: TCustomIniFile; const ABaseSection: string; AStoringKind: TdxBarStoringKind); override;

    property GlyphLayout: TdxBarGlyphLayout read FGlyphLayout write SetGlyphLayout;
  end;

  TdxBarCustomButton = class(TdxBarButtonLikeItem, IdxBarLinksOwner)
  private
    FAllowAllUp: Boolean;
    FCloseSubMenuOnClick: Boolean;
    FDown: Boolean;
    FDropDownEnabled: Boolean;
    FDropDownMenu: TdxBarCustomPopupMenu;
    FGroupIndex: Integer;
    FInternalStates: TdxBarButtonStates;
    FLowered: Boolean;
    FRepeatClick: Boolean;

    function  GetButtonStyle: TdxBarButtonStyle;
    procedure SetAllowAllUp(Value: Boolean);
    procedure SetButtonStyle(Value: TdxBarButtonStyle);
    procedure SetDown(Value: Boolean);
    procedure SetDropDownEnabled(Value: Boolean);
    procedure SetDropDownMenu(Value: TdxBarCustomPopupMenu);
    procedure SetGroupIndex(Value: Integer);
    procedure SetLowered(Value: Boolean);

    function IsDownStored: Boolean;
  protected
    function CanChangePaintStyle: Boolean; override;
    procedure DoDropDown(AControl: TdxBarButtonControl; X, Y: Integer; ByMouse: Boolean); dynamic;
    function HasAccel(AItemLink: TdxBarItemLink): Boolean; override;
    procedure Notification(AComponent: TComponent; Operation: TOperation); override;
    procedure PaintStyleChanged; override;

    function GetIniSection(const ABaseSection: string): string; override;

    // IdxBarLinksOwner
    function CanContainItem(AItem: TdxBarItem; out AErrorText: string): Boolean;
    function CreateBarControl: TCustomdxBarControl;
    function IdxBarLinksOwner.GetInstance = GetComponentInstance;
    function GetItemLinks: TdxBarItemLinks; override;
    function GetImages: TCustomImageList;
    function IsLoading: Boolean;

    // IdxBarSelectableItem
    function GetSupportedActions: TdxBarCustomizationActions; override;

    class function GetNewCaption: string; override;
  public
    constructor Create(AOwner: TComponent); override;
    procedure Click; override;
    procedure DropDown(AByMouse: Boolean = False);

    property AllowAllUp: Boolean read FAllowAllUp write SetAllowAllUp default False;
    property ButtonStyle: TdxBarButtonStyle read GetButtonStyle write SetButtonStyle default bsDefault;
    property CloseSubMenuOnClick: Boolean read FCloseSubMenuOnClick write FCloseSubMenuOnClick default True;
    property DropDownEnabled: Boolean read FDropDownEnabled write SetDropDownEnabled default True;
    property GroupIndex: Integer read FGroupIndex write SetGroupIndex default 0;  // must be here
    property Down: Boolean read FDown write SetDown stored IsDownStored default False;
    property DropDownMenu: TdxBarCustomPopupMenu read FDropDownMenu write SetDropDownMenu;
    property Lowered: Boolean read FLowered write SetLowered default False;
    property RepeatClick: Boolean read FRepeatClick write FRepeatClick default False;
    property UnclickAfterDoing default True;
  end;

  TdxBarButton = class(TdxBarCustomButton)
  published
    property AllowAllUp;
    property ButtonStyle;
    property CloseSubMenuOnClick;
    property DropDownEnabled;
    property GroupIndex;  // must be here
    property Down;
    property DropDownMenu;
    property Glyph;
    property ImageIndex;
    property LargeGlyph;
    property LargeImageIndex;
    property Lowered;
    property PaintStyle;
    property RepeatClick;
    property ShortCut;
    property UnclickAfterDoing;
    property OnClick;
  end;
  TdxBarButtonClass = class of TdxBarButton;

  { TdxBarLargeButton }

  TdxBarLargeButton = class(TdxBarCustomButton)
  private
    FAutoGrayScale: Boolean;
    FHeight: Integer;
    FHotImageIndex: Integer;
    FInSyncImageIndex: Boolean;
    FHotGlyph: TdxSmartGlyph;
    FSyncImageIndex: Boolean;

    FSetImageIndex: Boolean;
    FSetLargeImageIndex: Boolean;
    FSetSyncImageIndex: Boolean;

    function IsImageIndexStored: Boolean;
    function IsLargeImageIndexStored: Boolean;
    procedure SetAutoGrayScale(Value: Boolean);
    procedure SetHeight(Value: Integer);
    procedure SetHotGlyph(Value: TdxSmartGlyph);
    procedure SetHotImageIndex(Value: Integer);
    procedure SetSyncImageIndex(Value: Boolean);

    procedure OnHotGlyphChanged(Sender: TObject);
  protected
    procedure DefineProperties(Filer: TFiler); override;
    procedure Loaded; override;
    procedure ReadImageIndex(Reader: TReader);
    procedure WriteImageIndex(Writer: TWriter);

    function GetActionImageIndex: Integer; override;
    procedure SetActionImageIndex(Value: Integer); override;

    function HasAccel(AItemLink: TdxBarItemLink): Boolean; override;
    procedure HotGlyphChanged; override;
    function IsHotImageLinked: Boolean;
    function IsLargeImageLinked: Boolean;
    procedure LargeGlyphChanged; override;
    procedure SetImageIndex(Value: Integer); override;
    procedure SetLargeImageIndex(Value: Integer); override;
    function UseHotImages: Boolean; override;
    function UseLargeImages: Boolean; override;
    procedure WidthChanged; override;

    // IdxBarSelectableItem
    function GetSupportedActions: TdxBarCustomizationActions; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  published
    // inherited from TdxBarButton
    property AllowAllUp;
    property ButtonStyle;
    property CloseSubMenuOnClick;
    property DropDownEnabled;
    property GroupIndex;  // must be here
    property Down;
    property DropDownMenu;
    property Glyph;
    property LargeGlyph;
    property Lowered;
    property PaintStyle;
    property RepeatClick;
    property ShortCut;
    property UnclickAfterDoing;
    property OnClick;

    property AutoGrayScale: Boolean read FAutoGrayScale write SetAutoGrayScale default True;
    property GlyphLayout default glTop;
    property Height: Integer read FHeight write SetHeight default 0;
    property HotGlyph: TdxSmartGlyph read FHotGlyph write SetHotGlyph;
    property HotImageIndex: Integer read FHotImageIndex write SetHotImageIndex default -1;
    property LargeImageIndex stored IsLargeImageIndexStored;
    property ShowCaption default True;
    property Width default 0;
    property ImageIndex stored False{see DefineProperties: IsImageIndexStored};
    property SyncImageIndex: Boolean read FSyncImageIndex write SetSyncImageIndex default True;
  end;

  { TdxCustomBarEdit }

  TdxCustomBarEdit = class(TdxBarWindowItem)
  strict private
    FGlyphLoaded: Boolean;
  protected
    procedure ReadState(Reader: TReader); override;

    procedure DrawCustomizingImage(ACanvas: TCanvas; const ARect: TRect; AState: TOwnerDrawState); override;
    procedure GetEditViewParams(out AViewParams: TcxViewParams);
    class function GetStyleCount: Integer; override;
    function HasAccel(AItemLink: TdxBarItemLink): Boolean; override;
    property StyleEdit: TcxStyle index 1 read GetStyleValue write SetStyleValue;
  public
    constructor Create(AOwner: TComponent); override;
  published
    property Glyph;
    property ImageIndex;
    property ShowCaption default False;
    property Width default 100;
    property OnClick;
  end;

  TdxBarEdit = class(TdxCustomBarEdit)
  private
    FMaxLength: Integer;
    FReadOnly: Boolean;

    procedure SetMaxLength(Value: Integer);
  protected
    procedure DrawInterior(ABarEditControl: TdxBarEditControl; ACanvas: TCanvas;
      R: TRect; ItemLink: TdxBarItemLink); virtual;
  public
    property CurText;
  published
    property MaxLength: Integer read FMaxLength write SetMaxLength default 0;
    property ReadOnly: Boolean read FReadOnly write FReadOnly default False;
    property StyleEdit;
    property Text;
  end;

  TCustomdxBarCombo = class;

  TdxBarCheckKeyForDropDownWindowEvent = procedure (Sender: TCustomdxBarCombo;
    Key: Word; Shift: TShiftState; var AcceptKey: Boolean) of object;
  TdxBarGetDropDownWindowEvent = procedure (Sender: TCustomdxBarCombo;
    var Window: HWND) of object;

  TCustomdxBarCombo = class(TdxBarEdit)
  private
    FOnCheckKeyForDropDownWindow: TdxBarCheckKeyForDropDownWindowEvent;
    FOnCloseUp: TNotifyEvent;
    FOnDropDown: TNotifyEvent;
    FOnGetDropDownWindow: TdxBarGetDropDownWindowEvent;
    function GetDroppedDown: Boolean;
    function GetShowEditor: Boolean;
    procedure SetDroppedDown(Value: Boolean);
    procedure SetShowEditor(Value: Boolean);
  protected
    procedure AfterDropDown; dynamic;
    procedure CheckDropDownPoint(var X, Y: Integer); virtual;
    function CheckKeyForDropDownWindow(Key: Word; Shift: TShiftState): Boolean; virtual;
    procedure CloseUp; dynamic;
    procedure DrawCustomizingImage(ACanvas: TCanvas; const ARect: TRect;
      AState: TOwnerDrawState); override;
    procedure DropDown(X, Y: Integer); dynamic;
    function GetDropDownWindow: HWND; virtual;
    procedure InitDropDownWindow; virtual;
    procedure InternalInitDropDownWindow(ADropDownWindow: TWinControl);
  public
    property DropDownWindow: HWND read GetDropDownWindow;
    property DroppedDown: Boolean read GetDroppedDown write SetDroppedDown;
  published
    property ShowEditor: Boolean read GetShowEditor write SetShowEditor default True;

    property OnCheckKeyForDropDownWindow: TdxBarCheckKeyForDropDownWindowEvent
      read FOnCheckKeyForDropDownWindow write FOnCheckKeyForDropDownWindow;
    property OnCloseUp: TNotifyEvent read FOnCloseUp write FOnCloseUp;
    property OnDropDown: TNotifyEvent read FOnDropDown write FOnDropDown;
    property OnGetDropDownWindow: TdxBarGetDropDownWindowEvent
      read FOnGetDropDownWindow write FOnGetDropDownWindow;
  end;

  TdxBarCustomCombo = class;

  TdxBarDrawItemEvent = procedure(Sender: TdxBarCustomCombo; AIndex: Integer;
    ARect: TRect; AState: TOwnerDrawState) of object;

  TdxBarMeasureItemEvent = procedure(Sender: TdxBarCustomCombo; AIndex: Integer;
    var AHeight: Integer) of object;

  TdxBarCustomCombo = class(TCustomdxBarCombo)
  private
    FDropDownCount: Integer;
    FDropDownWidth: Integer;
    FInteriorIsDrawing: Boolean;
    FItemHeight: Integer;
    FItemIndex: Integer;
    FItems: TStrings;
    FListBox: TCustomListBox;
    FSorted: Boolean;
    FOnDrawItem: TdxBarDrawItemEvent;
    FOnMeasureItem: TdxBarMeasureItemEvent;

    function GetCurItemIndex: Integer;
    function GetItemsHeight(Index: Integer): Integer;
    procedure SetCurItemIndex(Value: Integer);
    procedure SetItemIndex(Value: Integer);
    procedure SetItems(Value: TStrings);
    procedure SetSorted(Value: Boolean);

    procedure CheckLocalPos;
    procedure ItemsChanged(Sender: TObject);
    procedure ListBoxDrawItem(Control: TWinControl; Index: Integer; Rect: TRect;
      State: TOwnerDrawState);
    procedure ListBoxMeasureItem(Control: TWinControl; Index: Integer; var Height: Integer);
  protected
    FCanvas: TCanvas;
    procedure AfterDropDown; override;
    function CheckKeyForDropDownWindow(Key: Word; Shift: TShiftState): Boolean; override;
    procedure CloseUp; override;
    procedure CurChange; override;
    procedure DrawInterior(ABarEditControl: TdxBarEditControl; ACanvas: TCanvas;
      R: TRect; ItemLink: TdxBarItemLink); override;
    procedure DropDown(X, Y: Integer); override;
    function GetDropDownWindow: HWND; override;
    procedure InitDropDownWindow; override;
    procedure SetText(Value: string); override;

    procedure DrawItem(APainter: TdxBarPainter; AIndex: Integer; ARect: TRect;
      AState: TOwnerDrawState); virtual;
    function GetCanvas: TCanvas; virtual;
    function GetDropDownWidth: Integer; virtual;
    function GetNearestItemIndex(AText: string): Integer;
    function FindItemIndex(const AText: string): Integer;
    procedure MeasureItem(AIndex: Integer; var AHeight: Integer); virtual;
    procedure MeasureItemWidth(AIndex: Integer; var AWidth: Integer); virtual;

    property ListBox: TCustomListBox read FListBox;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;

    property Canvas: TCanvas read GetCanvas;
    property CurItemIndex: Integer read GetCurItemIndex write SetCurItemIndex;
    property ItemHeight: Integer read FItemHeight write FItemHeight default 0;
    property Items: TStrings read FItems write SetItems;
    property ItemsHeight[Index: Integer]: Integer read GetItemsHeight;
    property Sorted: Boolean read FSorted write SetSorted default False;
    property ItemIndex: Integer read FItemIndex write SetItemIndex;  // loading after all
  published
    property DropDownCount: Integer read FDropDownCount write FDropDownCount default 8;
    property DropDownWidth: Integer read FDropDownWidth write FDropDownWidth default 0;

    property OnDrawItem: TdxBarDrawItemEvent read FOnDrawItem write FOnDrawItem;
    property OnMeasureItem: TdxBarMeasureItemEvent read FOnMeasureItem write FOnMeasureItem;
  end;

  { TdxBarCombo }

  TdxBarCombo = class(TdxBarCustomCombo)
  published
    property ItemHeight;
    property Items;
    property Sorted;
    property ItemIndex;  // loading after all
  end;

  { TCustomdxBarSubItem }

  TCustomdxBarSubItem = class(TdxBarButtonLikeItem, IdxBarLinksOwner, IdxBarSubMenuOwner)
  private
    FBarSize: Integer;
    FDetachable: Boolean;
    FDetachingBar: TdxBar;
    FIsInternal: Boolean;
    FItemLinks: TdxBarItemLinks;

    FOnCloseUp: TNotifyEvent;
    FOnDetaching: TNotifyEvent;
    FOnPaintBar: TdxBarPaintSubMenuBarEvent;
    FOnPopup: TNotifyEvent;

    function GetDetachingBarIndex: Integer;
    function GetItemOptions: TdxBarItemOptions;
    procedure SetBarSize(Value: Integer);
    procedure SetDetachingBar(Value: Integer);
    procedure SetImages(AImages: TCustomImageList);
    procedure SetIsInternal(Value: Boolean);
    procedure SetItemLinks(Value: TdxBarItemLinks);
    procedure SetItemOptions(Value: TdxBarItemOptions);
  protected
    function CanClicked: Boolean; override;
    procedure ChangeScale(M: Integer; D: Integer); override;
    procedure DoDetaching; dynamic;
    function GetItemLinksClass: TdxBarItemLinksClass; virtual;
    procedure Loaded; override;
    procedure ObjectNotification(AOperation: TOperation; AObject: TObject); override;

    function GetIniSection(const ABaseSection: string): string; override;
    procedure LoadFromIni(ASource: TCustomIniFile; const ABaseSection: string; AStoringKind: TdxBarStoringKind); override;
    procedure SaveToIni(ADestination: TCustomIniFile; const ABaseSection: string; AStoringKind: TdxBarStoringKind); override;

    // IdxBarLinksOwner
    function CanContainItem(AItem: TdxBarItem; out AErrorText: string): Boolean;
    function CreateBarControl: TCustomdxBarControl; virtual;
    function IdxBarLinksOwner.GetInstance = GetComponentInstance;
    function GetItemLinks: TdxBarItemLinks; override;
    function GetImages: TCustomImageList;
    function IsLoading: Boolean;

    // IdxBarSelectableItem
    function GetSupportedActions: TdxBarCustomizationActions; override;

    // IdxBarSubMenuOwner
    function GetBarSize: Integer;
    procedure DoPaintBar(Canvas: TCanvas; const R: TRect); virtual;
    procedure DoPopup; dynamic;
    procedure DoCloseUp; dynamic;

    property Images: TCustomImageList read GetImages write SetImages;
    property IsInternal: Boolean read FIsInternal write SetIsInternal;
    property ItemOptions: TdxBarItemOptions read GetItemOptions write SetItemOptions;
    property OnCloseUp: TNotifyEvent read FOnCloseUp write FOnCloseUp;
    property OnPopup: TNotifyEvent read FOnPopup write FOnPopup;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    function GetDetachingBar: TdxBar;
    procedure DropDown(AByMouse: Boolean = False);

    property BarSize: Integer read GetBarSize write SetBarSize default 0;
    property Detachable: Boolean read FDetachable write FDetachable default False;
    property DetachingBar: Integer read GetDetachingBarIndex write SetDetachingBar default -1;
    property ItemLinks: TdxBarItemLinks read GetItemLinks write SetItemLinks;
    property OnDetaching: TNotifyEvent read FOnDetaching write FOnDetaching;
    property OnPaintBar: TdxBarPaintSubMenuBarEvent read FOnPaintBar write FOnPaintBar;
  end;

  TdxBarSubItem = class(TCustomdxBarSubItem)
  private
    FAllowCustomizing: Boolean;
  protected
    class function GetNewCaption: string; override;
    function InternalCanMergeWith(AItem: TdxBarItem): Boolean; override;
  public
    constructor Create(AOwner: TComponent); override;
  published
    //TCustomdxBarSubItem
    property BarSize;
    property Detachable;
    property DetachingBar;
    property Glyph;
    property ImageIndex;
    property LargeGlyph;
    property LargeImageIndex;
    property ShowCaption default True;
    property OnClick;
    property OnDetaching;
    property OnPaintBar;

    property AllowCustomizing: Boolean read FAllowCustomizing write FAllowCustomizing default True;
    property Images;
    property ItemLinks;
    property ItemOptions;
    property OnCloseUp;
    property OnPopup;
  end;

  TCustomdxBarContainerItem = class(TCustomdxBarSubItem)
  private
    FIsListPopulation: Boolean;
    FNeedClearItemList: Boolean;
    FOnGetData: TNotifyEvent;
    FItemsPopulationCount: Integer;
  protected
    function InternalActuallyVisible: Boolean; override;

    function AddListedItemLink(AItemLinks: TdxBarItemLinks; ALinkData: TObject; AIndex: Integer; AItem: TdxBarItem): TdxBarItemLink; virtual;
    procedure AddListedItemLinks(AItemLinks: TdxBarItemLinks; ALinkData: TObject; AIndex: Integer);
    procedure DeleteListedItemLinks(ALinkData: TObject); virtual;
    procedure ClearItemList; virtual;
    function HideWhenRun: Boolean; virtual;
    procedure NeedClearItemList;
    procedure PopulateListedItemLinks(AItemLinks: TdxBarItemLinks;
      ALinkData: TObject; AIndex: Integer); virtual;
    procedure PrepareListedItemLinks; virtual;

    function AllowProcessItemsChanged(AItemLinks: TObject): Boolean; virtual;
    procedure ItemsChanged(AItemLinks: TObject);
  published
    //TCustomdxBarSubItem
    property BarSize;
    property Detachable;
    property DetachingBar;
    property Glyph;
    property ImageIndex;
    property LargeGlyph;
    property LargeImageIndex;
    property ShowCaption default True;
    property OnClick;
    property OnDetaching;
    property OnPaintBar;

    property OnGetData: TNotifyEvent read FOnGetData write FOnGetData;
  end;

  { TdxBarListItem }

  TdxBarListItem = class(TCustomdxBarContainerItem)
  private
    FItemIndex: Integer;
    FItemList: TComponentList;
    FItems: TStrings;
    FShowCheck: Boolean;
    FShowNumbers: Boolean;
    function GetDataIndex: Integer;
    function GetItemList: TList;
    procedure SetDataIndex(Value: Integer);
    procedure SetItems(Value: TStrings);
    procedure ClickItem(Sender: TObject);
  protected
    procedure ClearItemList; override;
    function CreateItem(AIndex, ACurIndex: Integer): TdxBarButton; virtual;
    function GetDisplayHint(const AText: string): string; virtual;
    function GetDisplayNumber(AIndex: Integer): string; virtual;
    function GetDisplayText(AItemIndex: Integer): string; overload; virtual;
    function GetDisplayText(const AText: string): string; overload; virtual;
    function GetItemClass: TdxBarButtonClass; virtual;
    function InternalActuallyVisible: Boolean; override;
    procedure PopulateListedItemLinks(AItemLinks: TdxBarItemLinks; ALinkData: TObject; AIndex: Integer); override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Assign(Source: TPersistent); override;
    procedure DirectClick; override;

    property ItemList: TList read GetItemList;
  published
    property DataIndex: Integer read GetDataIndex write SetDataIndex stored False;
    property ItemIndex: Integer read FItemIndex write FItemIndex default -1;
    property Items: TStrings read FItems write SetItems;
    property LargeGlyph;
    property LargeImageIndex;
    property ShowCheck: Boolean read FShowCheck write FShowCheck default False;
    property ShowNumbers: Boolean read FShowNumbers write FShowNumbers default True;
  end;

  { TdxBarContainerItem }

  TdxBarContainerItem = class(TCustomdxBarContainerItem)
  protected
    function InternalActuallyVisible: Boolean; override;
    function InternalCanMergeWith(AItem: TdxBarItem): Boolean; override;
    function AllowProcessItemsChanged(AItemLinks: TObject): Boolean; override;
    function IsItemsExist: Boolean; virtual;
    procedure PopulateListedItemLinks(AItemLinks: TdxBarItemLinks; ALinkData: TObject; AIndex: Integer); override;
  public
    constructor Create(AOwner: TComponent); override;
  published
    property ItemLinks;
  end;

  { TdxBarSubMenuBackButton }

  TdxBarSubMenuBackButton = class(TdxBarButton)
  public
    constructor Create(AOwner: TComponent); override;
  end;

  {--------------------------------------
              Item's controls
   --------------------------------------}

  TdxBarSavedFont = record
    LogFont: TLogFont;
    Saved: Boolean;
  end;

  TdxBarItemControlDrawParamsClass = class of TdxBarItemControlDrawParams;
  TdxBarItemControlDrawParams = class
  strict private
    FBarItemControl: TdxBarItemControl;
    FViewSize: TdxBarItemControlViewSize;

    function GetUseRightToLeftAlignment: Boolean;
    procedure SetViewSize(Value: TdxBarItemControlViewSize);
  protected
    FCaptionRect: TRect;

    function GetScaleFactor: TdxScaleFactor; virtual;
  public
    CanSelect: Boolean;
    Canvas: TcxCanvas;
    Caption: string;
    DefaultButtonSize: TSize;
    Description: string;
    DrawSelected: Boolean;
    DroppedDown: Boolean;
    Enabled: Boolean;
    HotPartIndex: Integer;
    IsCustomizing: Boolean;
    IsDropDown: Boolean;
    IsPressed: Boolean;
    PaintType: TdxBarPaintType;
    SelectedByKey: Boolean;
    ShortCut: string;
    ViewStructure: TdxBarItemControlViewStructure;

    constructor Create(ABarItemControl: TdxBarItemControl);
    function HasIcon: Boolean; inline;
    procedure ResetCachedValues; virtual;

    property BarItemControl: TdxBarItemControl read FBarItemControl;
    property ScaleFactor: TdxScaleFactor read GetScaleFactor;
    property UseRightToLeftAlignment: Boolean read GetUseRightToLeftAlignment;
    property ViewSize: TdxBarItemControlViewSize read FViewSize write SetViewSize;
  end;

  { TdxBarButtonLikeControlDrawParams }

  TdxBarButtonLikeControlDrawParams = class(TdxBarItemControlDrawParams)
  public
    ArrowSize: TSize;
    ButtonGroup: TdxBarButtonGroupRealPosition;
    ContentOffset: TRect;
    Downed: Boolean;
    DrawDowned: Boolean;
    DropDownEnabled: Boolean;
    DroppedDownFlat: Boolean;
    GrayScale: Boolean;
    IsFlatText: Boolean;
    IsLowered: Boolean;
    IsMenuItem: Boolean;
    IsTextSelected: Boolean;
    SplitDropDown: Boolean;
  end;

  { TdxBarExtraMenuButtonControlDrawParams }

  TdxBarExtraMenuButtonControlDrawParams = class(TdxBarButtonLikeControlDrawParams)
  public
    Pin: Boolean;
  end;

  { TdxBarApplicationMenuButtonControlDrawParams }

  TdxBarApplicationMenuButtonControlDrawParams = class(TdxBarButtonLikeControlDrawParams)
  public
    ContentWidth: Integer;
  end;

  TdxBarEditLikeControlDrawParams = class(TdxBarItemControlDrawParams)
  private
    function GetBarEditControl: TdxBarEditControl;
  public
    Focused: Boolean;
    IsTransparent: Boolean;
    ViewLayout: TdxBarItemViewLayout;
    property BarEditControl: TdxBarEditControl read GetBarEditControl;
  end;

  TdxBarStaticLikeControlDrawParams = class(TdxBarItemControlDrawParams)
  private
    function GetBarStaticControl: TdxBarCustomStaticControl;
  public
    Alignment: TAlignment;
    AllowCenter: Boolean;
    BorderOffsets: TRect;
    BorderStyle: TdxBarStaticBorderStyle;
    property BarStaticControl: TdxBarCustomStaticControl read GetBarStaticControl;
  end;

  TdxBarSeparatorControlDrawParams = class(TdxBarStaticLikeControlDrawParams)
  public
    IsTop: Boolean;
  end;

  TdxBarColorComboControlDrawParams = class(TdxBarEditLikeControlDrawParams)
  public
    IsShowCustomColorButton: Boolean;
  end;

  TdxBarSpinEditDrawParams = class(TdxBarEditLikeControlDrawParams)
  public
    ArrowSize: TSize;
    ActiveButtonIndex: Integer;
  end;

  TdxBarProgressControlDrawParams = class(TdxBarStaticLikeControlDrawParams)
  public
    Smooth: Boolean;
    Position: Integer;
    Min: Integer;
    Max: Integer;
  end;

  TdxBarInPlaceSubItemControlDrawParams = class(TdxBarButtonLikeControlDrawParams)
  public
    IsExpanded: Boolean;
  end;

  TdxBarItemControlViewInfoClass = class of TdxBarItemControlViewInfo;
  TdxBarItemControlViewInfo = class(TcxInterfacedPersistent, IdxBarItemControlViewInfo)
  private
    FAllowedViewLevels: TdxBarItemViewLevels;
    FBounds: TRect;
    FColumnRowCount: Integer;
    FImageBounds: TRect;
    FMinPossibleViewLevel: TdxBarItemRealViewLevel;
    FRealPositionInButtonGroup: TdxBarButtonGroupRealPosition;
    FRow: Integer;
    FViewLevel: TdxBarItemViewLevel;
    FViewLevelForButtonGroup: TdxBarItemRealViewLevel;
    FViewLevelInfos: array [TdxBarItemRealViewLevel] of TdxBarItemCachedWidthInfo;
  protected
    FControl: TdxBarItemControl;

    // IdxBarItemControlViewInfo
    procedure CalculateFinalize;
    function GetAlign: TdxBarItemAlign;
    function GetAllowedViewLevels: TdxBarItemViewLevels;
    function GetBounds: TRect;
    function GetColumnRowCount: Integer;
    function GetDistributed: Boolean;
    function GetPosition: TdxBarItemPosition;
    function GetPositionInButtonGroup: TdxBarButtonGroupPosition;
    function GetRealPositionInButtonGroup: TdxBarButtonGroupRealPosition;
    function GetRow: Integer;
    function GetViewLevel: TdxBarItemViewLevel;
    function GetViewLevelForButtonGroup: TdxBarItemRealViewLevel;
    function GetWidth(AViewLevel: TdxBarItemRealViewLevel): Integer;
    function HasSeparator: Boolean;
    function IsPrimaryForDistribution: Boolean;
    function IsMultiColumnItemControl(ACheckCollapsed: Boolean;
      out AIMultiColumnItemControlViewInfo: IdxBarMultiColumnItemControlViewInfo): Boolean;
    procedure SetBounds(const Value: TRect);
    procedure SetColumnRowCount(Value: Integer);
    procedure SetDistributed(Value: Boolean);
    procedure SetRealPositionInButtonGroup(Value: TdxBarButtonGroupRealPosition);
    procedure SetRow(Value: Integer);
    procedure SetViewLevel(Value: TdxBarItemViewLevel);

    procedure BoundsCalculated; virtual;
  public
    constructor Create(AControl: TdxBarItemControl); reintroduce; virtual;
    destructor Destroy; override;
    procedure ResetCachedValues; virtual;

    property Bounds: TRect read GetBounds;
    property Control: TdxBarItemControl read FControl;
    property ImageBounds: TRect read FImageBounds write FImageBounds;
    property MinPossibleViewLevel: TdxBarItemRealViewLevel read FMinPossibleViewLevel;
    property RealPositionInButtonGroup: TdxBarButtonGroupRealPosition read FRealPositionInButtonGroup;
    property ViewLevel: TdxBarItemViewLevel read GetViewLevel;
  end;

  { TdxBarCachedImage }

  TdxBarCachedImage = class
  strict private
    FCachedImage: TdxGpImage;
    FCachedImageID: TdxDrawImageCacheID;
  public
    constructor Create;
    destructor Destroy; override;
    procedure Draw(DC: HDC; const ARect: TRect);
    procedure Reset;
    procedure Update(const ARect: TRect; AGlyph: TGraphic; AImages: TCustomImageList; AImageIndex: Integer;
      ADrawMode: TcxImageDrawMode; ATransparentColor: TColor; ASmoothImage, AUseLeftBottomPixelAsTransparent: Boolean;
      AColorPalette: IdxColorPalette = nil);
  end;

  { TdxBarItemControl }

  TdxBarItemControl = class(TcxIUnknownObject,
    IdxBarHintKeeper,
    IdxBarHintKeeper2,
    IdxFadingObject,
    IdxFadingObjectFadingOptions,
    IdxScaleFactor,
    IdxScreenTipProvider)
  private
    FActiveCanvas: TcxCanvas;
    FBkBrush: HBRUSH;
    FBreakingRow: Boolean;
    FChangeRecentGroup: Boolean;
    FIAccessibilityHelper: IdxBarAccessibilityHelper;
    FIsActive: Boolean;
    FIsDestroying: Boolean;
    FIsRightToLeftConverted: Boolean;
    FItemLink: TdxBarItemLink;
    FLastInRow: Boolean;
    FNonRecent: Boolean;
    FParent: TCustomdxBarControl;
    FPressed: Boolean;
    FScaleFactor: TdxScaleFactor;
    FTextSize: Integer;

    // Cached Values
    FGlyphCache: TdxBarCachedImage;
    FIconAssigned: TdxDefaultBoolean;
    FIconAssignedViewSize: TdxBarItemControlViewSize;

    function FindPartAtPos(APoint: TPoint): Integer;
    function GetAlign: TdxBarItemAlign;
    function GetBarManager: TdxBarManager; inline;
    function GetBkBrush: HBRUSH;
    function GetCanvas: TcxCanvas;
    function GetFlat: Boolean;
    function GetIAccessibilityHelper: IdxBarAccessibilityHelper;
    function GetIsFadingAvailable: Boolean;
    function GetIsSelected: Boolean;
    function GetItem: TdxBarItem; inline;
    function GetItemBarManager: TdxBarManager; inline;
    function GetItemBounds: TRect;
    function GetPainterClass: TdxBarPainterClass;
    function GetShowDescription: Boolean;
    function GetSubMenuParent: TdxBarSubMenuControl;
    function GetUnclickAfterDoing: Boolean;
    function InternalGetPossibleViewLevels: TdxBarItemViewLevels;
    procedure SetHotPartIndex(AValue: Integer);
    procedure SetPressed(Value: Boolean);

    function GetRealHeight: Integer; inline;
    function GetRealWidth: Integer; inline;
    function GetRealSize: TSize; overload;
    procedure GetRealSize(AWidth, AHeight: PInteger); overload;
  protected
    FDrawParams: TdxBarItemControlDrawParams;
    FHotPartIndex: Integer;
    FParts: array of TRect;
    FViewInfo: TdxBarItemControlViewInfo;
    FSelectedByMouse: Boolean;

    // IdxFadingObject
    function CanFade: Boolean; virtual;
    procedure DrawFadeImage; virtual;
    procedure GetFadingImages(out AFadeOutImage, AFadeInImage: TcxBitmap); virtual;

    // IdxFadingObjectFadingOptions
    function GetFadingOptions: TdxFadingOptions;

    // IdxScaleFactor
    function GetScaleFactor: TdxScaleFactor;

    // IdxBarHintKeeper
    function DoHint(var ANeedDeactivate: Boolean; out AHintText: string; out AShortCut: string): Boolean; virtual;
    function CreateHintViewInfo(const AHintText, AShortCut: string): TdxBarCustomHintViewInfo; virtual;
    function GetEnabled: Boolean; virtual;
    function GetHintPosition(const ACursorPos: TPoint; AHeight: Integer): TPoint; virtual;
    // IdxBarHintKeeper2
    function GetHintedControl: TControl;
    function IsCustomHintSupported: Boolean; virtual;
    // IdxScreenTipProvider
    function GetAction: TBasicAction;
    function GetScreenTip: TdxScreenTip;
    function IdxScreenTipProvider.GetShortCut = GetShortCutAsString;
    function GetShortCutAsString: string;
    // fading
    function FadingDrawSelected: Boolean; virtual;
    function GetFader: TdxFader; virtual;

    // Change Group
    procedure BeginGroupChanged; virtual;
    procedure CaptionChanged; virtual;
    procedure EnabledChanged; virtual;
    procedure GlyphChanged; virtual;
    procedure HotGlyphChanged; virtual;
    procedure HotPartChanged; virtual;
    procedure LargeGlyphChanged; virtual;
    procedure PaintStyleChanged; virtual;
    procedure ParentVisibleChange(AIsShowing: Boolean); virtual;
    procedure PartsChanged; virtual;
    procedure PressedChanged; virtual;
    procedure RealVisibleChanging(AVisible: Boolean); virtual;
    procedure ResetCachedValues(AFull: Boolean); virtual;
    procedure VisibleChanged; virtual;
    procedure WidthChanged; virtual;

    function UseLargeIcons: Boolean;
    function UseLargeImageSource(AViewSize: TdxBarItemControlViewSize): Boolean;
    procedure BeforeDestroyParentHandle; virtual;
    function CanBePartOfButtonGroup: Boolean; virtual;
    function CanClicked: Boolean; virtual;
    function CanCustomize: Boolean; virtual;
    function CanDeselect(ABarManager: TdxBarManager): Boolean; virtual;
    function CanHide: Boolean; virtual;
    function CanMouseSelect: Boolean; virtual;
    function CanSelect: Boolean; virtual;
    function CanShowShortCut: Boolean;
    function CanVisuallyPressed: Boolean;
    procedure CheckHotTrack(APoint: TPoint); virtual;

    // Clicking
    procedure AcceleratorClick; virtual;
    procedure Click(AByMouse: Boolean; AKey: Char = #0); virtual;
    procedure ControlActivate(AImmediately, AByMouse: Boolean); virtual;
    procedure ControlInactivate(Immediately: Boolean); virtual;
    procedure ControlClick(AByMouse: Boolean; AKey: Char = #0); virtual;
    procedure ControlUnclick(AByMouse: Boolean); virtual;
    procedure ControlGetFocus(AIsSelected: Boolean; var AProcessed: Boolean); virtual;
    procedure DblClick; dynamic;
    function DrawSelected: Boolean; virtual;
    function GetSelectableObject: TPersistent;
    function WantsDblClick: Boolean; dynamic;

    // User Events Group
    function GetCurrentCursor(const AMousePos: TPoint): TCursor; virtual;
    procedure KeyDown(var Key: Word; Shift: TShiftState); dynamic;
    procedure KeyUp(var Key: Word; Shift: TShiftState); dynamic;
    procedure KeyPress(var Key: Char); dynamic;
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer); dynamic;
    procedure MouseEnter(Shift: TShiftState; X, Y: Integer); dynamic;
    procedure MouseLeave; dynamic;
    procedure MouseMove(Shift: TShiftState; X, Y: Integer); dynamic;
    procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer); dynamic;
    function WantsKey(Key: Word): Boolean; virtual;

    function GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass; virtual;
    function GetPossibleViewLevels: TdxBarItemViewLevels; virtual;
    function GetViewLevels: TdxBarItemViewLevels;
    function GetViewStructure: TdxBarItemControlViewStructure; virtual;
    function GetDefaultViewStructure: TdxBarItemControlViewStructure; virtual;
    function GetViewSize: TdxBarItemControlViewSize; virtual;
    function GetDefaultViewSize: TdxBarItemControlViewSize; virtual;
    function GetPaintType: TdxBarPaintType; virtual;
    function GetPartCount: Integer; virtual;
    function GetViewInfoClass: TdxBarItemControlViewInfoClass; virtual;
    function GrayScale: Boolean; virtual;
    function IconAssigned: Boolean; overload; inline;
    function IconAssigned(AViewSize: TdxBarItemControlViewSize): Boolean; overload;

    procedure FrameAndFillRect(DC: HDC; var R: TRect; Enabled, Selected, Pressed: Boolean);

    function GetCaption: string; virtual;
    function GetControl: TControl; virtual;
    procedure GetDefaultTextColors(AEnabled, ASelected, AFlat: Boolean; var AColor1, AColor2: TColor); virtual;
    function GetDrawParamsClass: TdxBarItemControlDrawParamsClass; virtual;
    function GetFocused: Boolean; virtual;
    function GetHint: string; virtual;
    procedure GetHintParams(out AHintText: string; out AShortCut: string); virtual;
    function GetMenuItemSize: TdxBarMenuItemSize; virtual;
    function GetPainter: TdxBarPainter; inline;
    function GetShortCut: TShortCut; virtual;
    function GetTextAreaOffset: Integer; virtual;
    procedure GetTextColors(AEnabled, ASelected, AFlat: Boolean; var AColor1, AColor2: TColor); virtual;
    procedure SetFocused(AValue: Boolean); virtual;

    // Images
    function GetGlyph: TdxSmartGlyph; virtual;
    function GetHotImages: TCustomImageList; virtual;
    function GetImageIndex: Integer; virtual;
    function GetImages(AEnabled: Boolean; var ADrawImageEnabled: TdxDefaultBoolean): TCustomImageList; inline;
    function GetLargeGlyph: TdxSmartGlyph; virtual;
    function GetLargeImageIndex: Integer; virtual;
    function GetLargeImages(AEnabled: Boolean; var ADrawImageEnabled: TdxDefaultBoolean): TCustomImageList; inline;

    // Draw Group
    procedure CalcDrawParams(AFull: Boolean = True); virtual;
    procedure CalcParts; virtual;
    procedure CalcDrawingConsts; virtual;
    procedure DoCalcDrawingConsts; virtual;
    procedure DoPaint(ARect: TRect; PaintType: TdxBarPaintType); virtual;
    function IsTransparentOnGlass: Boolean; virtual;
    procedure CheckDrawParams;
    procedure PrepareCanvasFont(ABaseFont: HFONT; AStyle: TcxStyle; out ASavedFont: TdxBarSavedFont); virtual;
    procedure RestoreCanvasFont(const ASavedFont: TdxBarSavedFont); virtual;

    function GetOwnedBarControl: TCustomdxBarControl; virtual;

    function GetNonBufferedRect: TRect; virtual;
    function GetCaptionWidth: Integer; virtual;

    function GetCurrentImage(AViewSize: TdxBarItemControlViewSize; ASelected: Boolean; out AGlyph: TdxSmartGlyph;
      out AImages: TCustomImageList; out AImageIndex: Integer; out ADrawImageEnabled: TdxDefaultBoolean): Boolean; virtual;
    function GetCurrentImages(AEnabled, AUseLargeImages: Boolean; var ADrawImageEnabled: TdxDefaultBoolean): TCustomImageList; virtual;
    function GetDefaultGlyphSize(AViewSize: TdxBarItemControlViewSize): TSize; inline;
    function GetGlyphSize(AViewSize: TdxBarItemControlViewSize; ASelected: Boolean = False): TSize; overload;
    function GetGlyphSize(AViewSize: TdxBarItemControlViewSize;
      AGlyph: TdxSmartGlyph; AImages: TCustomImageList; AImageIndex: Integer): TSize; overload;

    function GetIndents(ADrawAreaType: TdxBarItemControlPart): TRect; virtual;
    function GetRotationDependentHeight(ASourceSize: TSize): Integer;
    function GetRotationDependentWidth(ASourceSize: TSize): Integer;
    function GetTextExtent(const AText: string): TSize;
    function GetTextHeight: Integer;
    function GetTextSize: Integer; // TODO property
    function GetTextWidth(const AText: string): Integer;

    function GetCaptionAreaWidth: Integer; virtual;
    function GetControlAreaWidth: Integer; virtual;
    function GetGlyphAreaWidth: Integer; virtual;

    function GetControlCaptionOffset: Integer; virtual;
    function GetDefaultHeight: Integer; virtual;
    function GetDefaultLargeWidth: Integer; virtual;
    function GetDefaultSmallWidth: Integer; virtual;
    function GetDefaultWidth: Integer; virtual;

    function GetDefaultHeightInSubMenu: Integer; virtual;
    function GetDefaultWidthInSubMenu: Integer; virtual;
    function GetLargeHeight: Integer; virtual;
    function GetMinHeight: Integer; virtual;
    function GetMinWidth: Integer; virtual;
    function GetSmallHeight: Integer; virtual;
    function GetWidthByViewLevel(AViewLevel: TdxBarItemRealViewLevel): Integer;
    function InternalGetDefaultHeight: Integer; virtual;
    function InternalGetDefaultWidth: Integer; virtual;

    // Ask Group
    function AllowSelectWithoutFocusing: Boolean; virtual;
    function HasHint: Boolean; virtual;
    function HasShadow: Boolean; virtual;
    function HotPartWantMouse: Boolean; virtual;
    function IsBkColorAssigned: Boolean;
    function IsChildWindow(AWnd: HWND): Boolean; virtual;
    function CanDestroyOnClick: Boolean; virtual;
    function IsDropDown: Boolean; virtual;
    function IsEditTransparent: Boolean; virtual;
    function IsExpandable: Boolean; virtual;
    function IsHiddenForCustomization: Boolean; virtual;
    function IsInvertTextColor: Boolean; virtual;
    function IsMenuItem: Boolean; virtual;
    function IsRotated: Boolean; virtual;
    function IsSelectionForbidden: Boolean;
    function MousePressed: Boolean;
    function NeedBufferedRepaint: Boolean; virtual;
    function NeedCaptureMouse: Boolean; virtual;
    function NeedUpdateWhenResize: Boolean; virtual;
    function WantMouse: Boolean;

    procedure CheckNonRecent;
    procedure UncheckNonRecent;

    // Resize Group
    procedure BeginResize(APoint: TPoint); virtual;
    function CanResize(APoint: TPoint): Boolean; virtual;
    procedure EndResize(AAllowResize: Boolean); virtual;
    procedure Resizing(APoint: TPoint); virtual;

    procedure DoCalculateParts;
    procedure DoRightToLeftConversion(const ABounds: TRect); virtual;
    procedure InternalCalculateParts;

    property Align: TdxBarItemAlign read GetAlign;
    property BkBrush: HBRUSH read GetBkBrush;
    property Canvas: TcxCanvas read GetCanvas;
    property Caption: string read GetCaption;
    property Control: TControl read GetControl;
    property IsDestroying: Boolean read FIsDestroying write FIsDestroying;
    property DrawParams: TdxBarItemControlDrawParams read FDrawParams;
    property Fader: TdxFader read GetFader;
    property Flat: Boolean read GetFlat;
    property Glyph: TdxSmartGlyph read GetGlyph;
    property Height: Integer read GetRealHeight;
    property Hint: string read GetHint;
    property HotImages: TCustomImageList read GetHotImages;
    property HotPartIndex: Integer read FHotPartIndex write SetHotPartIndex;
    property ImageIndex: Integer read GetImageIndex;
    property IsFadingAvailable: Boolean read GetIsFadingAvailable;
    property LargeGlyph: TdxSmartGlyph read GetLargeGlyph;
    property LargeImageIndex: Integer read GetLargeImageIndex;
    property LastInRow: Boolean read FLastInRow write FLastInRow;
    property MenuItemSize: TdxBarMenuItemSize read GetMenuItemSize;
    property MinHeight: Integer read GetMinHeight;
    property MinWidth: Integer read GetMinWidth;
    property NonRecent: Boolean read FNonRecent;
    property OwnedBarControl: TCustomdxBarControl read GetOwnedBarControl;
    property PossibleViewLevels: TdxBarItemViewLevels read InternalGetPossibleViewLevels;
    property Pressed: Boolean read FPressed write SetPressed;
    property ScaleFactor: TdxScaleFactor read FScaleFactor;
    property ShortCut: TShortCut read GetShortCut;
    property ShowDescription: Boolean read GetShowDescription;
    property SubMenuParent: TdxBarSubMenuControl read GetSubMenuParent;
    property TextAreaOffset: Integer read GetTextAreaOffset;
    property UnclickAfterDoing: Boolean read GetUnclickAfterDoing;
    property ViewLevels: TdxBarItemViewLevels read GetViewLevels;
    property Width: Integer read GetRealWidth;
  public
    constructor Create(AItemLink: TdxBarItemLink); virtual;
    destructor Destroy; override;
    procedure BeforeDestruction; override;

    function HasWindow: Boolean; virtual;
    function IsDroppedDown: Boolean; virtual;
    procedure Paint(ACanvas: TcxCanvas; ARect: TRect; PaintType: TdxBarPaintType);
    procedure Repaint; virtual;
    procedure Update; overload;
    procedure Update(const R: TRect); overload; virtual;
    function UseRightToLeftAlignment: Boolean;
    function UseRightToLeftReading: Boolean;
    function UseRightToLeftScrollbar: Boolean;

    property BarManager: TdxBarManager read GetBarManager;
    property Enabled: Boolean read GetEnabled;
    property Focused: Boolean read GetFocused write SetFocused;
    property IAccessibilityHelper: IdxBarAccessibilityHelper read GetIAccessibilityHelper;
    property IsActive: Boolean read FIsActive;
    property IsSelected: Boolean read GetIsSelected;
    property Item: TdxBarItem read GetItem;
    property ItemBounds: TRect read GetItemBounds;
    property ItemLink: TdxBarItemLink read FItemLink;
    property Painter: TdxBarPainter read GetPainter;
    property PainterClass: TdxBarPainterClass read GetPainterClass;
    property Parent: TCustomdxBarControl read FParent;
    property ViewInfo: TdxBarItemControlViewInfo read FViewInfo;
  end;

  TdxBarCustomStaticControl = class(TdxBarItemControl)
  private
    function GetDrawParams: TdxBarStaticLikeControlDrawParams;
  protected
    function CanClicked: Boolean; override;
    function CanSelect: Boolean; override;
    procedure DoPaint(ARect: TRect; PaintType: TdxBarPaintType); override;
    procedure DrawInterior(ARect: TRect); virtual; abstract;
    function GetDefaultViewStructure: TdxBarItemControlViewStructure; override;
    function GetDrawParamsClass: TdxBarItemControlDrawParamsClass; override;
    property DrawParams: TdxBarStaticLikeControlDrawParams read GetDrawParams;
  end;

  TdxBarSeparatorControl = class(TdxBarCustomStaticControl)
  private
    function GetDrawParams: TdxBarSeparatorControlDrawParams;
  protected
    procedure CalcDrawParams(AFull: Boolean = True); override;
    procedure DoPaint(ARect: TRect; PaintType: TdxBarPaintType); override;
    procedure GetDefaultTextColors(AEnabled, ASelected, AFlat: Boolean;
      var AColor1: TColor; var AColor2: TColor); override;
    function GetIndents(ADrawAreaType: TdxBarItemControlPart): TRect; override;

    function GetMenuItemSize: TdxBarMenuItemSize; override;
    function GetGlyphAreaWidth: Integer; override;

    function GetDefaultHeightInSubMenu: Integer; override;
    function GetDefaultWidthInSubMenu: Integer; override;
    function GetMinWidth: Integer; override;
    function InternalGetDefaultHeight: Integer; override;
    function InternalGetDefaultWidth: Integer; override;

    procedure PrepareCanvasFont(ABaseFont: HFONT; AStyle: TcxStyle;
      out ASavedFont: TdxBarSavedFont); override;
    procedure RestoreCanvasFont(const ASavedFont: TdxBarSavedFont); override;

    function GetDefaultViewStructure: TdxBarItemControlViewStructure; override;
    function GetDrawParamsClass: TdxBarItemControlDrawParamsClass; override;
    property DrawParams: TdxBarSeparatorControlDrawParams read GetDrawParams;
  end;

  TdxBarWinControl = class(TdxBarItemControl)
  private
    FInnerControlBufferedPaint: Boolean;
    FFocused: Boolean;
    FFocusing: Boolean;
    FKeyPressedInside: Integer;
    FOnGlass: Boolean;
    FWindowProcObject: TcxWindowProcLinkedObject;
    FWindowRect: TRect;

    function DoCallKeyboardHook(AWParam: WParam; ALParam: LParam): Boolean;
    function GetItem: TdxBarWindowItem;
    function GetWindowRect: TRect;
    procedure SetWindowRect(const Value: TRect);
  protected
    function CanClicked: Boolean; override;
    function CanDeselect(ABarManager: TdxBarManager): Boolean; override;
    function CanSelect: Boolean; override;
    procedure ControlInactivate(Immediately: Boolean); override;
    procedure ControlClick(AByMouse: Boolean; AKey: Char = #0); override;
    procedure ControlGetFocus(AIsSelected: Boolean; var AProcessed: Boolean); override;
    procedure EnabledChanged; override;
    function GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass; override;
    function GetFocused: Boolean; override;
    function IsChildWindow(AWnd: HWND): Boolean; override;
    function CanDestroyOnClick: Boolean; override;
    function IsWindowEnabled: Boolean;
    procedure KeyDown(var Key: Word; Shift: TShiftState); override;
    procedure KeyPress(var Key: Char); override;
    procedure KeyUp(var Key: Word; Shift: TShiftState); override;

    function ClientToParent(const APoint: TPoint): TPoint;
    function ParentToClient(const APoint: TPoint): TPoint;

    procedure CreateInnerEdit; virtual;
    procedure DestroyInnerEdit(AFullDestroy: Boolean = True); virtual;

    procedure DoEnter;
    procedure DoEscape;
    procedure DoNavigation(AShift: TShiftState);

    // MessageHandler
    function DoKeyDown(var Message: TWMKey): Boolean;
    function DoKeyPress(var Message: TWMKey): Boolean;
    function DoKeyUp(var Message: TWMKey): Boolean;
    procedure DoKillFocus(var Message: TMessage);
    procedure DoMouseDown(var Message: TWMMouse; AButton: TMouseButton;
      AShift: TShiftState);

    procedure Show; virtual;
    procedure Hide(AStoreDisplayValue: Boolean); virtual; abstract;

    procedure ActivateEdit(AByMouse: Boolean; AKey: Char = #0); virtual;
    function GetHandle: HWND; virtual; abstract;
    function GetText: string; virtual;
    function IsSysKeyDown(var Key: Word; Shift: TShiftState): Boolean; virtual;
    function IsSysKeyUp(var Key: Word; Shift: TShiftState): Boolean; virtual;
    procedure KillFocus(AHandle: THandle); dynamic;
    procedure MainWndProc(var Message: TMessage);
    function NeedFocusOnClick: Boolean; virtual;
    procedure PrepareEditWnd; virtual;
    procedure RestoreDisplayValue; virtual;
    procedure SetFocused(Value: Boolean); override;
    procedure SetText(Value: string); virtual;
    procedure StoreDisplayValue; virtual;
    procedure SysKeyDown(var Key: Word; Shift: TShiftState); virtual;
    procedure SysKeyUp(var Key: Word; Shift: TShiftState); virtual;
    procedure TransferMessage(AFromWindow: HWND; const Message: TMessage);
    procedure WndProc(var Message: TMessage); virtual;

    property InnerControlBufferedPaint: Boolean read FInnerControlBufferedPaint write FInnerControlBufferedPaint;
  public
    procedure DefaultHandler(var Message); override;
    function HasWindow: Boolean; override;
    function HandleAllocated: Boolean;
    property Handle: HWND read GetHandle;
    property Item: TdxBarWindowItem read GetItem;
    property OnGlass: Boolean read FOnGlass;
    property Text: string read GetText write SetText;
    property WindowRect: TRect read GetWindowRect write SetWindowRect;
  end;

  TdxBarButtonLikeControl = class(TdxBarItemControl)
  private
    FShowAnimation: Boolean;
    function GetDrawParams: TdxBarButtonLikeControlDrawParams;
    function GetGlyphLayout: TdxBarGlyphLayout;
  protected
    // Fading
    function CanFade: Boolean; override;
    function FadingDrawSelected: Boolean; override;
    procedure GetFadingImages(out AFadeOutImage, AFadeInImage: TcxBitmap); override;

    function ArrowWidth: Integer; virtual;
    procedure CalcDrawParams(AFull: Boolean = True); override;
    function CanActivate: Boolean; virtual;
    function CanBePartOfButtonGroup: Boolean; override;
    procedure ControlActivate(AImmediately, AByMouse: Boolean); override;
    procedure ControlInactivate(Immediately: Boolean); override;
    procedure ControlGetFocus(AIsSelected: Boolean; var AProcessed: Boolean); override;
    procedure DoPaint(ARect: TRect; PaintType: TdxBarPaintType); override;
    procedure DropDown(AByMouse: Boolean); virtual;
    function GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass; override;
    function GetDefaultLargeWidth: Integer; override;
    function GetDrawParamsClass: TdxBarItemControlDrawParamsClass; override;
    function GetLargeHeight: Integer; override;
    function GetSubMenuControl: TdxBarSubMenuControl; virtual;
    function IsFlatText: Boolean; virtual;
    function IsTextSelected: Boolean; virtual;

    procedure KeyDown(var Key: Word; Shift: TShiftState); override;
    function WantsKey(Key: Word): Boolean; override;

    procedure FinishSubMenuTracking;
    procedure StartSubMenuTracking(AActivation: Boolean);

    procedure DoCloseUp(AHadSubMenuControl: Boolean); dynamic;
    procedure DoDropDown(AByMouse: Boolean); dynamic; abstract;

    property DrawParams: TdxBarButtonLikeControlDrawParams read GetDrawParams;
  public
    destructor Destroy; override;
    property SubMenuControl: TdxBarSubMenuControl read GetSubMenuControl;
  end;

  { TdxBarButtonControl }

  TdxBarButtonControlKind = (bbckStandard, bbckDropDown, bbckDropDownButton);

  TdxBarButtonControl = class(TdxBarButtonLikeControl)
  private
    FDroppedDown: Boolean;
    function GetButtonItem: TdxBarCustomButton;
    function GetDown: Boolean;
    function GetDropDownEnabled: Boolean;
    function GetDroppedDownFlat: Boolean;
    function GetGroupIndex: Integer;
    function GetInternalStates: TdxBarButtonStates;
    function GetLowered: Boolean;
    procedure DoButtonPressTimer(Sender: TObject);
    function MouseOverArrow: Boolean;
  protected
    procedure CalcDrawParams(AFull: Boolean = True); override;
    procedure CalcParts; override;
    procedure ControlClick(AByMouse: Boolean; AKey: Char = #0); override;
    procedure ControlUnclick(ByMouse: Boolean); override;
    procedure ControlGetFocus(AIsSelected: Boolean; var AProcessed: Boolean); override;
    procedure DoCloseUp(AHadSubMenuControl: Boolean); override;
    procedure DoDropDown(AByMouse: Boolean); override;
    function DrawSelected: Boolean; override;
    procedure DropDown(AByMouse: Boolean); override;
    function FadingDrawSelected: Boolean; override;
    function GetSubMenuControl: TdxBarSubMenuControl; override;
    function IsFlatText: Boolean; override;
    function IsTextSelected: Boolean; override;
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer); override;

    function GetDefaultHeight: Integer; override;
    function GetDefaultWidth: Integer; override;
    function GetSmallHeight: Integer; override;

    function CanDestroyOnClick: Boolean; override;
    function GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass; override;
    function GetDefaultViewStructure: TdxBarItemControlViewStructure; override;
    function GetKind: TdxBarButtonControlKind; virtual;
    function GetOwnedBarControl: TCustomdxBarControl; override;
    function GetPaintStyle: TdxBarPaintStyle; virtual;
    function GetPartCount: Integer; override;
    function GetViewStructure: TdxBarItemControlViewStructure; override;
    function IsDropDown: Boolean; override;
    function IsPressed: Boolean;
    function NeedCaptureMouse: Boolean; override;
    procedure PaintStyleChanged; override;
    procedure PreparePaintStyleOnBar(var APaintStyle: TdxBarPaintStyle); virtual;

    property Down: Boolean read GetDown;
    property DropDownEnabled: Boolean read GetDropDownEnabled;
    property DroppedDown: Boolean read FDroppedDown;
    property DroppedDownFlat: Boolean read GetDroppedDownFlat; // TODO: obsolete
    property GroupIndex: Integer read GetGroupIndex;
    property InternalStates: TdxBarButtonStates read GetInternalStates;
    property Kind: TdxBarButtonControlKind read GetKind;
    property Lowered: Boolean read GetLowered;
    property PaintStyle: TdxBarPaintStyle read GetPaintStyle;
  public
    destructor Destroy; override;
    function IsDroppedDown: Boolean; override;
    property ButtonItem: TdxBarCustomButton read GetButtonItem;
  end;

  { TdxBarLargeButtonControl }

  TdxBarLargeButtonControl = class(TdxBarButtonControl)
  private
    function GetHotGlyph: TdxSmartGlyph;
    function GetItem: TdxBarLargeButton;

    function IsInheritedBehaviour: Boolean;
    function IsSizeAssigned: Boolean;
  protected
    function ArrowWidth: Integer; override;
    procedure HotGlyphChanged; override;
    procedure LargeGlyphChanged; override;

    function GetCurrentImage(AViewSize: TdxBarItemControlViewSize; ASelected: Boolean; out AGlyph: TdxSmartGlyph;
      out AImages: TCustomImageList; out AImageIndex: Integer; out ADrawImageEnabled: TdxDefaultBoolean): Boolean; override;
    function GetDefaultViewStructure: TdxBarItemControlViewStructure; override;
    function GetDefaultViewSize: TdxBarItemControlViewSize; override;
    function GetPossibleViewLevels: TdxBarItemViewLevels; override;
    function GrayScale: Boolean; override;
    function InternalGetDefaultHeight: Integer; override;
    function InternalGetDefaultWidth: Integer; override;

    function IsRotated: Boolean; override;

    procedure PreparePaintStyleOnBar(var APaintStyle: TdxBarPaintStyle); override;

    property HotGlyph: TdxSmartGlyph read GetHotGlyph;
  public
    property Item: TdxBarLargeButton read GetItem;
  end;

  TdxBarApplicationMenuButtonControl = class(TdxBarButtonLikeControl)
  private
    function GetDrawParams: TdxBarApplicationMenuButtonControlDrawParams;
  protected
    procedure CalcDrawParams(AFull: Boolean = False); override;
    procedure DoPaint(ARect: TRect; PaintType: TdxBarPaintType); override;
    procedure GetDefaultTextColors(AEnabled, ASelected, AFlat: Boolean; var AColor1, AColor2: TColor); override;
    function GetDefaultViewStructure: TdxBarItemControlViewStructure; override;
    function GetDrawParamsClass: TdxBarItemControlDrawParamsClass; override;
    function GetPaintType: TdxBarPaintType; override;
    function InternalGetDefaultWidth: Integer; override;

    procedure CaptionChanged; override;
    procedure GlyphChanged; override;
    procedure VisibleChanged; override;
    procedure WidthChanged; override;

    property DrawParams: TdxBarApplicationMenuButtonControlDrawParams read GetDrawParams;
  end;

  TdxBarCustomEditControl = class(TdxBarWinControl)
  private
    FBkBrush: TBrush;
    FEditTextSize: Integer;
    FSizingEditWidth: Integer;
    FRightBorderSizing: Boolean;
    function GetCaptionBkBrush: HBRUSH;
    function GetDrawParams: TdxBarEditLikeControlDrawParams;
    function GetEditBkBrush: HBRUSH;
    function GetEditFont: TFont;
    function GetItem: TdxCustomBarEdit;
    function LeftSizingRect: TRect;
    function RightSizingRect: TRect;
  protected
    FAreaParts: array of TRect;
    procedure CalcParts; override;
    procedure CalcDrawParams(AFull: Boolean = True); override;
    procedure CorrectFrameRect(var ARect: TRect); virtual;
    procedure DoCalcDrawingConsts; override;
    procedure DoPaint(ARect: TRect; PaintType: TdxBarPaintType); override;
    procedure DoRightToLeftConversion(const ABounds: TRect); override;
    procedure DrawFrame; virtual;
    procedure DrawTextField; virtual; abstract;
    procedure DrawEditSizingFrame(AWidth: Integer);
    function DrawSelected: Boolean; override;
    function GetDefaultViewStructure: TdxBarItemControlViewStructure; override;
    function GetDrawParamsClass: TdxBarItemControlDrawParamsClass; override;
    function GetPartCount: Integer; override;
    function GetPossibleViewLevels: TdxBarItemViewLevels; override;

    function GetCaptionAreaWidth: Integer; override;
    function GetControlAreaWidth: Integer; override;
    function GetGlyphAreaWidth: Integer; override;

    procedure CalculateAreaParts; virtual;
    function GetDefaultHeight: Integer; override;
    function GetDefaultWidth: Integer; override;
    function GetEditOffset: Integer;
    function GetEditRect: TRect; virtual;
    function GetEditTextSize: Integer; // TODO property
    function GetIndents(ADrawAreaType: TdxBarItemControlPart): TRect; override;
    function GetMinEditorWidth: Integer; virtual; abstract;
    function GetMinWidth: Integer; override;
    function GetShowCaption: Boolean; virtual;
    function GetViewLayout: TdxBarItemViewLayout;
    procedure InitEdit; virtual; abstract;
    procedure Show; override;

    procedure BeginResize(APoint: TPoint); override;
    function CanResize(APoint: TPoint): Boolean; override;
    procedure EndResize(AAllowResize: Boolean); override;
    procedure Resizing(APoint: TPoint); override;

    function HotPartWantMouse: Boolean; override;
    procedure RefreshBkBrush(var AHandle: HBRUSH); virtual;

    property CaptionBkBrush: HBRUSH read GetCaptionBkBrush;
    property DrawParams: TdxBarEditLikeControlDrawParams read GetDrawParams;
    property EditBkBrush: HBRUSH read GetEditBkBrush;
    property EditFont: TFont read GetEditFont;
    property ShowCaption: Boolean read GetShowCaption;
  public
    destructor Destroy; override;
    property Item: TdxCustomBarEdit read GetItem;
  end;

  TdxBarEditControl = class(TdxBarCustomEditControl)
  private
    FHandle: HWND;
    function GetItem: TdxBarEdit;
    function GetMaxLength: Integer;
    function GetReadOnly: Boolean;
    procedure SetLimitText;
  protected
    procedure CreateWindowHandle; virtual;
    procedure DestroyWindowHandle(ADestroyWindow: Boolean = True); virtual;
    function getWindowStyle: DWORD; virtual; // GetWindowStyle conflicts with C++ macro

    function CanDrawEditor: Boolean; virtual;
    procedure ControlClick(AByMouse: Boolean; AKey: Char = #0); override;

    procedure Hide(AStoreDisplayValue: Boolean); override;
    procedure Show; override;

    procedure CreateInnerEdit; override;
    procedure DestroyInnerEdit(AFullDestroy: Boolean = True); override;
    procedure DrawTextField; override;
    function GetHandle: HWND; override;
    function GetMinEditorWidth: Integer; override;
    function GetNonBufferedRect: TRect; override;
    procedure InitEdit; override;
    function IsTransparentOnGlass: Boolean; override;
    procedure PrepareEditWnd; override;
    procedure SetFocused(Value: Boolean); override;
    procedure SetText(Value: string); override;

    procedure WndProc(var Message: TMessage); override;

    property MaxLength: Integer read GetMaxLength;
    property ReadOnly: Boolean read GetReadOnly;
  public
    constructor Create(AItemLink: TdxBarItemLink); override;
    destructor Destroy; override;

    property Item: TdxBarEdit read GetItem;
  end;

  TCustomdxBarComboControl = class(TdxBarEditControl)
  private
    FOnPressDroppedDown: Boolean;
    FDroppedDown: Boolean;

    function GetDropDownWindow: HWND;
    function GetItem: TCustomdxBarCombo;
    function IsSpecialKey(var Key: Word; Shift: TShiftState): Boolean;
  protected
    procedure CalcDrawParams(AFull: Boolean = True); override;
    procedure CalcParts; override;
    function CanDrawEditor: Boolean; override;
    procedure ControlInactivate(Immediately: Boolean); override;
    procedure CorrectFrameRect(var ARect: TRect); override;
    procedure DrawTextField; override;
    procedure EnabledChanged; override;
    function GetPartCount: Integer; override;
    function IsChildWindow(AWnd: HWND): Boolean; override;
    function IsSysKeyDown(var Key: Word; Shift: TShiftState): Boolean; override;
    function IsSysKeyUp(var Key: Word; Shift: TShiftState): Boolean; override;
    procedure SysKeyDown(var Key: Word; Shift: TShiftState); override;
    procedure SysKeyUp(var Key: Word; Shift: TShiftState); override;
    procedure WndProc(var Message: TMessage); override;

    procedure CalcDropDownPos(out APoint: TPoint); virtual;
    procedure SetDroppedDown(Value: Boolean); virtual;

    property DropDownWindow: HWND read GetDropDownWindow;
  public
    destructor Destroy; override;
    function IsDroppedDown: Boolean; override;
    property DroppedDown: Boolean read FDroppedDown write SetDroppedDown;
    property Item: TCustomdxBarCombo read GetItem;
  end;

  TdxBarComboControl = class(TCustomdxBarComboControl)
  private
    FLocalItemIndex: Integer;
    function GetItem: TdxBarCustomCombo;
    function GetItemIndex: Integer;
    function GetItems: TStrings;
    function GetSorted: Boolean;
    procedure SetLocalItemIndex(Value: Integer);
  protected
    procedure RestoreDisplayValue; override;
    procedure SetFocused(Value: Boolean); override;
    procedure WndProc(var Message: TMessage); override;

    property ItemIndex: Integer read GetItemIndex;
    property Items: TStrings read GetItems;
    property Sorted: Boolean read GetSorted;
  public
    property Item: TdxBarCustomCombo read GetItem;
    property LocalItemIndex: Integer read FLocalItemIndex write SetLocalItemIndex;
  end;

  TdxBarSubItemControl = class(TdxBarButtonLikeControl)
  private
    function GetCaptionOffset: Integer;
    function GetItem: TCustomdxBarSubItem;
  protected
    function GetSubMenuControl: TdxBarSubMenuControl; override;
    procedure CalcDrawParams(AFull: Boolean = True); override;
    function CanActivate: Boolean; override;
    function CanClicked: Boolean; override;
    procedure ControlActivate(AImmediately, AByMouse: Boolean); override;
    procedure ControlInactivate(Immediately: Boolean); override;
    procedure ControlClick(AByMouse: Boolean; AKey: Char = #0); override;
    procedure CreateSubMenuControl; virtual;
    procedure DoCreateSubMenuControl; virtual;
    procedure DoCloseUp(AHadSubMenuControl: Boolean); override;
    procedure DoDropDown(AByMouse: Boolean); override;
    procedure DropDown(AByMouse: Boolean); override;
    function GetCollapsed: Boolean; virtual;
    procedure GetSubMenuControlPositionParams(out P: TPoint; out AOwnerWidth, AOwnerHeight: Integer); virtual;
    procedure GetSubMenuControlSingleMenuPositionParams(out P: TPoint; out AOwnerWidth, AOwnerHeight: Integer); virtual;
    function IsFlatText: Boolean; override;
    function IsTextSelected: Boolean; override;
    procedure ShowSubMenuControl;

    function GetCaptionAreaWidth: Integer; override;
    function GetControlCaptionOffset: Integer; override;

    function GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass; override;
    function GetOwnedBarControl: TCustomdxBarControl; override;
    function HasSubMenu: Boolean; virtual;
    function CanDestroyOnClick: Boolean; override;
    function IsDropDown: Boolean; override;
    function IsExpandable: Boolean; override;
    function IsMenuItem: Boolean; override;
    function IsPressed: Boolean;

    function WantsDblClick: Boolean; override;
    function WantsKey(Key: Word): Boolean; override;

    function GetPossibleViewLevels: TdxBarItemViewLevels; override;
    function GetDefaultViewStructure: TdxBarItemControlViewStructure; override;

    property CaptionOffset: Integer read GetCaptionOffset;
  public
    destructor Destroy; override;
    function IsDroppedDown: Boolean; override;
    property Item: TCustomdxBarSubItem read GetItem;
  end;

  { TdxBarContainerLinkData }

  TdxBarContainerLinkData = class
  private
    FItem: TCustomdxBarContainerItem;
    FItemLink: TdxBarItemLink;
    FItemIndex: Integer;
    FExpandedItems: TObjectList;
  public
    constructor Create;
    destructor Destroy; override;
  end;

  { TdxBarContainerItemSubMenuControl }

  TdxBarContainerItemSubMenuControlClass = class of TdxBarContainerItemSubMenuControl;
  TdxBarContainerItemSubMenuControl = class(TdxBarSubMenuControl)
  private
    FContainerItem: TCustomdxBarContainerItem;
    FContainerLinkData: TdxBarContainerLinkData;
  protected
    procedure DoCloseUp; override;
    function GetIsCustomizing: Boolean; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  end;

  { TdxBarContainerItemControl }

  TdxBarContainerItemControl = class(TdxBarSubItemControl)
  private
    function GetItem: TCustomdxBarContainerItem;
  protected
    procedure CreateSubMenuControl; override;
    procedure DoPaint(ARect: TRect; PaintType: TdxBarPaintType); override;
    function DrawSelected: Boolean; override;
    function GetCaption: string; override;
    function GetSubMenuControlClass: TdxBarContainerItemSubMenuControlClass; virtual;
    function IsExpandable: Boolean; override;
    function ShowRealCaption: Boolean;
  public
    property Item: TCustomdxBarContainerItem read GetItem;
  end;

  TdxBarSubMenuBackButtonControl = class(TdxBarButtonControl)
  protected
    procedure ControlUnclick(ByMouse: Boolean); override;
    procedure DoPaint(ARect: TRect; PaintType: TdxBarPaintType); override;
    procedure GetDefaultTextColors(AEnabled, ASelected, AFlat: Boolean; var AColor1, AColor2: TColor); override;
    procedure PrepareCanvasFont(ABaseFont: HFONT; AStyle: TcxStyle; out ASavedFont: TdxBarSavedFont); override;
    procedure RestoreCanvasFont(const ASavedFont: TdxBarSavedFont); override;
  end;

  {--------------------------------------
              Item's painters
   --------------------------------------}
  TdxBarPainter = class(TcxIUnknownObject)
  private
    procedure InternalCalculateComboParts(const ADrawParams: TdxBarEditLikeControlDrawParams; var AParts: array of TRect);
    procedure InternalDrawBarSizeGrip(DC: HDC; const R: TRect; AIsRightToLeftLayout: Boolean);
  protected
    // New
    procedure DrawToolbarContentPart(ABarControl: TdxBarControl; ACanvas: TcxCanvas); virtual;
    procedure DrawToolbarNonContentPart(ABarControl: TdxBarControl; DC: HDC); virtual;
    function GetToolbarCaptionRect(ABarControl: TdxBarControl; const ARect: TRect): TRect; virtual;
    class function IsCompoundPainting: Boolean; virtual;
    class function NeedDoubleBuffer: Boolean; virtual;

    // Common
    function AllowLargeIcons: Boolean; virtual;
    procedure DoDrawText(ADC: HDC; const AText: string; var ARect: TRect; AFormat: UINT); virtual;
    procedure DrawGlyphBorder(ABarItemControl: TdxBarItemControl; DC: HDC; ABrush: HBRUSH; NeedBorder: Boolean; R: TRect;
      PaintType: TdxBarPaintType; IsGlyphEmpty, Selected, Down, DrawDowned, ADroppedDown, IsSplit: Boolean); virtual;
    procedure DrawGlyphCheckMark(ABarItemControl: TdxBarItemControl; DC: HDC; X, Y, DoubleSize: Integer); virtual;
    procedure DrawGlyphEmptyImage(ABarItemControl: TdxBarItemControl; DC: HDC; R: TRect;
      APaintType: TdxBarPaintType; ADown: Boolean); virtual;
    class procedure DrawItemArrow(DC: HDC; R: TRect; AScaleFactor: TdxScaleFactor;
      ArrowType: TcxArrowDirection; Enabled, Selected, Flat: Boolean; AColor: TColor = clDefault); virtual;
    procedure DrawLargeItemArrow(DC: HDC; R: TRect; ArrowType: TcxArrowDirection;
      Size: Integer; Selected, Enabled, Flat: Boolean; AColor: TColor = clDefault); virtual;
    class procedure FrameFlatSelRect(DC: HDC; const R: TRect); virtual;

    function GetDefaultEnabledTextColor(ABarItemControl: TdxBarItemControl;
      ASelected, AFlat: Boolean): TColor; virtual;
    procedure GetDefaultTextColors(ABarItemControl: TdxBarItemControl;
      AEnabled, ASelected, AFlat: Boolean; var AColor1, AColor2: TColor); virtual;
    procedure GetDisabledTextColors(ABarItemControl: TdxBarItemControl;
      ASelected, AFlat: Boolean; var AColor1, AColor2: TColor); virtual;
    function GetEnabledTextColor(ABarItemControl: TdxBarItemControl;
      ASelected, AFlat: Boolean): TColor; virtual;
    function GetItemArrowColor(const ADrawParams: TdxBarButtonLikeControlDrawParams): TColor; virtual;

    class function GetFaded(ABarControl: TCustomdxBarControl): Boolean; virtual;
    class function IgnoreGlyphOpaque: Boolean; virtual;
    class function IgnoreNonRecentColor: Boolean; virtual;
    class function IsMenuItem(ABarItemControl: TdxBarItemControl): Boolean; virtual;
    class function UseTextColorForItemArrow: Boolean; virtual;

    // Hints
    class function GetBarItemControlHintPosition(ABarControl: TCustomdxBarControl;
      const AItemBounds: TRect; const ACursorPos: TPoint; AHeight: Integer): TPoint; virtual;
    function CreateHintViewInfo(ABarManager: TdxBarManager; AHintText: string; const AShortCut: string;
      AScreenTip: TdxScreenTip): TdxBarCustomHintViewInfo; virtual;
    function IsCustomHintSupported: Boolean; virtual;
    // Bar
    class function BarIsBarSmall(ABarControl: TdxBarControl; const R: TRect): Boolean; virtual;
    class function BarCaptionBkColor(ABarControl: TdxBarControl; AMainFormActive: Boolean): COLORREF; virtual;
    function BarCaptionColor(ABarControl: TdxBarControl): COLORREF; virtual;
    class function BarMarkArrowColor(ABarControl: TdxBarControl; AState: TdxBarMarkState): COLORREF; virtual;
    procedure BarDrawGrip(ABarControl: TdxBarControl; DC: HDC; R: TRect; AToolbarBrush: HBRUSH); virtual;

    // Mark
    procedure BarDrawMarkArrow(ABarControl: TdxBarControl; DC: HDC; MarkR: TRect); virtual;
    class procedure BarDrawMarkAtPos(ABarControl: TdxBarControl; DC: HDC; const ItemRect: TRect; Offset: Integer); virtual;
    procedure BarDrawMarkBackground(ABarControl: TdxBarControl; DC: HDC; ItemRect: TRect; AToolbarBrush: HBRUSH); virtual;
    procedure BarDrawMarkElements(ABarControl: TdxBarControl; DC: HDC; ItemRect: TRect); virtual;

    class procedure BarOffsetFloatingBarCaption(ABarControl: TdxBarControl; var X: Integer; var R: TRect); virtual;
    class function GetDrawMarkElementColor(ABarControl: TdxBarControl): Integer; virtual;
    // ButtonLikeControl
    procedure ButtonLikeControlCorrectCaptionParams(const ADrawParams: TdxBarButtonLikeControlDrawParams;
      var ATextBounds: TRect; const AImageBounds: TRect; out ATextAlignment, AFormat: DWORD); virtual;
    procedure ButtonLikeControlDrawCaption(const ADrawParams: TdxBarButtonLikeControlDrawParams;
      const ATextBounds: TRect; ATextAlignment: DWORD; AFormat: DWORD = 0); virtual;
    class function GetControlTextIndents: TRect; virtual;
    class function GetControlCaptionRect(const ADrawParams: TdxBarItemControlDrawParams): TRect;
    class function GetControlCaptionRectCore(const ADrawParams: TdxBarItemControlDrawParams): TRect; virtual;
    class function GetGlyphLayout(const ADrawParams: TdxBarButtonLikeControlDrawParams): TdxBarGlyphLayout; virtual;
    procedure InflateSizeForArrow(const ADrawParams: TdxBarButtonLikeControlDrawParams; var ASize: Integer); virtual;
    // ColorCombo
      // Draw
    procedure DrawDot(const ADrawParams: TdxBarEditLikeControlDrawParams; ARect: TRect); virtual;
    procedure DrawDots(const ADrawParams: TdxBarEditLikeControlDrawParams; ARect: TRect); virtual;

    // ComboControl
    class procedure ComboControlDrawArrow(const ADrawParams: TdxBarEditLikeControlDrawParams; const ARect: TRect; ASize: Integer; AColor: TColor); virtual;

    // SubMenuControl
    procedure SubMenuControlFillScrollArrow(ACanvas: TcxCanvas; ARect: TRect; AColor: TColor); virtual;
    procedure SubMenuControlDrawScrollArrow(ABarSubMenuControl: TdxBarSubMenuControl; ACanvas: TcxCanvas;
      const AArrowRect: TRect; AColor: COLORREF; AArrowDirection: TcxArrowDirection); virtual;
    procedure SubMenuControlDrawScrollBand(ABarSubMenuControl: TdxBarSubMenuControl; ACanvas: TcxCanvas; AArrowDirection: TcxArrowDirection); virtual;
    procedure SubMenuControlDrawScrollBandBackground(ABarSubMenuControl: TdxBarSubMenuControl; ACanvas: TcxCanvas; AArrowDirection: TcxArrowDirection); virtual;
    procedure SubMenuControlDrawNonRecentGroupSeparator(ABarSubMenuControl: TdxBarSubMenuControl; ACanvas: TcxCanvas; AArrowDirection: TcxArrowDirection); virtual;
    function SubMenuControlGetScrollBandBounds(ABarSubMenuControl: TdxBarSubMenuControl; AArrowDirection: TcxArrowDirection): TRect; virtual;
    function SubMenuControlGetScrollBandSize(ABarSubMenuControl: TdxBarSubMenuControl): Integer; virtual;
    class function SubMenuControlGetScrollArrowSize(ATextSize: Integer): Integer; virtual;
    procedure SubMenuControlDrawMarkContent(ABarSubMenuControl: TdxBarSubMenuControl; DC: HDC; R: TRect; ASelected: Boolean); virtual;
    procedure SubMenuControlDrawMarkBand(ABarSubMenuControl: TdxBarSubMenuControl; const AMarkRect: TRect; ASelected: Boolean); virtual;
    procedure SubMenuControlDrawMarkSelection(ABarSubMenuControl: TdxBarSubMenuControl; ADC: HDC; const AMarkRect: TRect); virtual;
    class function SubMenuControlUseScrollButtons: Boolean; virtual;
    function SubMenuControlUseSingleMenuWindowMode: Boolean; virtual;
    // Edit
    class procedure EditOffsetInteriorRect(ABarEditControl: TdxBarCustomEditControl; var R: TRect); virtual;
    // SpinEditControl
    procedure DrawSpinEditArrow(const ADrawParams: TdxBarSpinEditDrawParams; AArrowPos: TPoint; AButtonIndex: Integer); virtual;
    class procedure SpinEditControlDrawArrowByPoints(const ADrawParams: TdxBarSpinEditDrawParams;
      AStartPoint: TPoint; AColorIndex: Integer; AButtonIndex: Integer);
    // SysPanel
    class function GetSysPanelBorderColor: TColor; virtual;
    function GetLookAndFeelPainter: TcxCustomLookAndFeelPainter; virtual;
    // DateNavigator
    class procedure DateNavigatorDrawButtonCaption(DC: HDC; const R: TRect; AOffset: Integer; const ACaption: string; AOpaque: Boolean); virtual;
    //Gallery
    procedure DropDownGalleryDrawVerticalSizeGrip(DC: HDC; const R: TRect); virtual;
    function DropDownGalleryGetSizeGripRect(const ABandRect: TRect; ACorner: TdxCorner): TRect;
  public
    constructor Create(AData: TdxNativeUInt); virtual;

    // New
    procedure CalculateExtraMenuButtonParts(
      const ADrawParams: TdxBarExtraMenuButtonControlDrawParams;
      var AParts: array of TRect; const AItemRect: TRect); virtual;
    procedure CalculateButtonParts(const ADrawParams: TdxBarButtonLikeControlDrawParams;
      var AParts: array of TRect; const AItemRect: TRect); virtual;
    procedure CalculateColorComboParts(const ADrawParams: TdxBarColorComboControlDrawParams;
      var AParts, AAreaParts: array of TRect); virtual;
    procedure CalculateComboParts(const ADrawParams: TdxBarEditLikeControlDrawParams;
      var AParts, AAreaParts: array of TRect); virtual;
    procedure CalculateEditParts(const ADrawParams: TdxBarEditLikeControlDrawParams;
      var AParts, AAreaParts: array of TRect); virtual;
    procedure CalculateSpinEditParts(const ADrawParams: TdxBarSpinEditDrawParams;
      var AParts, AAreaParts: array of TRect); virtual;

    // Common
    class procedure CalculateArrowPoints(const ARect: TRect; AArrowSize: Integer; AArrowDirection: TcxArrowDirection; out P: TcxArrowPoints);
    class function GetArrowRectByPoints(const P: TcxArrowPoints; AArrowDirection: TcxArrowDirection): TRect;
    class procedure SetArrowRegion(ACanvas: TcxCanvas; AArrowDirection: TcxArrowDirection;
      P: TcxArrowPoints; AOperation: TcxRegionOperation);
    // Fading
    class function IsFadingAvailable: Boolean; virtual;
    function GetBarItemControlFadingOptions: TdxFadingOptions; virtual;

    // Sizes
    function GetToolbarContentOffsets(ABar: TdxBar; ADockingStyle: TdxBarDockingStyle;
      AScaleFactor: TdxScaleFactor; AHasSizeGrip: Boolean): TRect; virtual;
    function GetToolbarsOffsetForAutoAlign: Integer; virtual;
    function GetBorderSize: Integer; virtual;
    function GetIconAreaSize(ABarControl: TCustomdxBarControl): Integer; virtual;
    class function GetControlCaptionOffset(ABarItemControl: TdxBarItemControl): Integer; virtual;
    class function GetDefaultTextSize(ACanvas: TcxCanvas; AScaleFactor: TdxScaleFactor): Integer; virtual;
    class function GetPopupWindowBorderWidth: Integer; virtual;
    function GetSmallIconSize(AScaleFactor: TdxScaleFactor): Integer;

    procedure GetImageParams(AItemControl: TdxBarItemControl; const ADrawRect: TRect; APaintType: TdxBarPaintType;
      AViewStructure: TdxBarItemControlViewStructure; AViewSize: TdxBarItemControlViewSize;
      ACenter, ASelected, ADowned, ADrawDowned: Boolean; var AGlyphEmpty: Boolean; out AGlyph: TdxSmartGlyph;
      out AImages: TCustomImageList; out AImageIndex: Integer; out ADrawImageEnabled: Boolean; out AImageBounds: TRect);
    function GetLargeImageBounds(AItemControl: TdxBarItemControl; const AImageSize: TSize;
      const ADrawRect: TRect; APaintType: TdxBarPaintType; AViewStructure: TdxBarItemControlViewStructure): TRect; virtual;
    class function GetSmallImageBounds(AItemControl: TdxBarItemControl; const AImageSize: TSize;
      const ADrawRect: TRect; APaintType: TdxBarPaintType; AViewStructure: TdxBarItemControlViewStructure;
      ACenter, AGlyphEmpty, AStretchGlyph, ADowned, ADrawDowned: Boolean): TRect;

    class procedure DrawBackground(ABarItemControl: TdxBarItemControl; DC: HDC; const R: TRect; ABrush: HBRUSH; AOpaque: Boolean); virtual;
    class procedure DrawBackgroundFrameRect(ABarItemControl: TdxBarItemControl; DC: HDC; R: TRect; ABrush: HBRUSH; AOpaque: Boolean); virtual;
    class procedure DrawDisabledShadowRect(ABarItemControl: TdxBarItemControl; DC: HDC; R: TRect); virtual;
    procedure DrawItemBackground(ABarItemControl: TdxBarItemControl;
      ACanvas: TcxCanvas; const ASourceRect: TRect; ABrush: HBRUSH);  virtual;

    procedure DrawGlyph(ABarItemControl: TdxBarItemControl; ADC: HDC;
      ADrawRect: TRect; const AFullBounds: TRect; APaintType: TdxBarPaintType;
      AGlyphEmpty, ASelected, ADowned, ADrawDowned, ADroppedDown, ACenter, AForceUseBkBrush, AIsSplit: Boolean); overload;
    procedure DrawGlyph(ABarItemControl: TdxBarItemControl; ADC: HDC;
      ADrawRect: TRect; const AFullBounds: TRect; out AImageBounds: TRect;
      APaintType: TdxBarPaintType; AViewStructure: TdxBarItemControlViewStructure;
      AViewSize: TdxBarItemControlViewSize; AGlyphEmpty, ASelected, ADowned,
      ADrawDowned, ADroppedDown, ACenter, AForceUseBkBrush, AGrayScale, AIsSplit: Boolean);  overload; virtual;
    procedure DrawGlyphAndBkgnd(ABarItemControl: TdxBarItemControl; ADC: HDC; const R, AGlyphRect: TRect;
      APaintType: TdxBarPaintType; AGlyph: TdxSmartGlyph; AImages: TCustomImageList; AImageIndex: Integer;
      AGlyphEmpty, ASelected, ADowned, ADrawDowned, ADroppedDown, AForceUseBkBrush, AGrayScale, AIsSplit: Boolean;
      AEnabled: Boolean; AColorPalette: IdxColorPalette); virtual;
    function GetGlyphColorPalette(ABarItemControl: TdxBarItemControl; APaintType: TdxBarPaintType;
      ASelected, ADowned, ADrawDowned, ADroppedDown, AIsSplit: Boolean): IdxColorPalette; virtual;

    procedure DrawGlyphAndTextInSubMenu(const ADrawParams: TdxBarButtonLikeControlDrawParams; const R: TRect);
    procedure DrawItemBackgroundInSubMenu(const ADrawParams: TdxBarButtonLikeControlDrawParams; R: TRect); virtual;
    procedure DrawItemMultilineText(const ADrawParams: TdxBarItemControlDrawParams;
      const AText: string; const ATextRect: TRect; AAlignment: UINT; AMaxLineCount: Integer);
    procedure DrawItemText(ABarItemControl: TdxBarItemControl; ADC: HDC;
      S: string; APaintRect: TRect; AAlignment: UINT; AEnabled, ASelected, ARotated,
      AClipped, AFlatText: Boolean; AFormat: UINT = DT_SINGLELINE); virtual;
    procedure DrawItemTextInSubMenu(const ADrawParams: TdxBarButtonLikeControlDrawParams; R: TRect);
    class procedure DrawLowered(DC: HDC; var R: TRect); virtual;
    class procedure FrameAndFillRect(ABarItemControl: TdxBarItemControl; DC: HDC;
      var R: TRect; Enabled, Selected, Pressed: Boolean); virtual;
    class function GetCaptionOffsets: TRect; virtual;
    class function GlyphBkgndBrush(ABarItemControl: TdxBarItemControl;
      APaintType: TdxBarPaintType; AGlyphEmpty, ASelected, ADowned, ADrawDowned, ADroppedDown,
      AForceUseBkBrush, AGrayScale: Boolean): HBRUSH; virtual;
    class function GlyphDownShift(ABarItemControl: TdxBarItemControl): Integer; virtual;
    class function GlyphDrawDownedShift(ABarItemControl: TdxBarItemControl; ADown: Boolean): Integer; virtual;
    class function IsFlatGlyphImage: Boolean; virtual;
    class function IsFlatItemText: Boolean; virtual;
    class function IsFlatItemTextForMenu: Boolean; virtual;
    function IsCustomSelectedTextColorExists(ABarItemControl: TdxBarItemControl): Boolean; virtual;
    class function IsGlyphImageBackgroundOpaque(ABarItemControl: TdxBarItemControl;
      ADown, ADrawDowned, ASelected, AGlyphEmpty: Boolean): Boolean; virtual;
    class function IsGlyphImageHasShadow: Boolean; virtual;
    class function IsGlyphImageTransparent(ABarItemControl: TdxBarItemControl): Boolean; virtual;
    class function IsItemTextSelectedInverted: Boolean; virtual;
    class function LoweredBorderSize(ABarItemControl: TdxBarItemControl): Integer; virtual;
    class function TextAreaOffset(ABarItemControl: TdxBarItemControl): Integer; virtual;
    // BarManager
    function BarFingersSize(ABar: TdxBar): Integer;
    function BeforeFingersSize: Integer; virtual;
    class function BorderSizeX(AScaleFactor: TdxScaleFactor): Integer; virtual;
    class function BorderSizeY(AScaleFactor: TdxScaleFactor): Integer; virtual;
    class function EmptyFingersSize: Integer; virtual;
    function FingersSize(ABarControl: TdxBarControl): Integer; virtual;
    function GripperSize(ABarControl: TdxBarControl): Integer; virtual;
    class function RealButtonArrowWidth(ABarManager: TdxBarManager): Integer; virtual;
    class function RealLargeButtonArrowWidth(ABarManager: TdxBarManager): Integer; virtual;
    class function SubMenuBeginGroupIndent: Integer; virtual;
    // DockControl
    procedure DockControlFillBackground(ADockControl: TdxDockControl;
      DC: HDC; ADestR, ASourceR, AWholeR: TRect; ABrush: HBRUSH; AColor: TColor); virtual;
    class function IsNativeBackground: Boolean; virtual;
    // CustomBar
    class function BarChildrenHaveShadows(ABarControl: TCustomdxBarControl): Boolean; virtual;
    function BarHasShadow(ABarControl: TCustomdxBarControl): Boolean; virtual;
    function BarLinkedOwnerHasShadow(ABarControl: TCustomdxBarControl): Boolean; virtual;
    class function BarControlOwnerBrush(ABarManager: TdxBarManager): HBRUSH; virtual;
    class function BarDockedGetRowIndent: Integer; virtual;
    procedure BarDrawDockedBackground(ABarControl: TdxBarControl; DC: HDC;
     ADestR, ASourceR: TRect; ABrush: HBRUSH; AColor: TColor); virtual;
    procedure BarDrawFloatingBackground(ABarControl: TCustomdxBarControl; DC: HDC;
      ADestR, ASourceR: TRect; ABrush: HBRUSH; AColor: TColor); virtual;
    class procedure BarDrawOwnerLink(ABarControl: TCustomdxBarControl; DC: HDC); virtual;
    procedure BarFillParentBackground(ABarControl: TCustomdxBarControl; DC: HDC;
      const ADestR, ASourceR: TRect; ABrush: HBRUSH; AColor: TColor);
    class function BarToolbarBrush(ABarControl: TCustomdxBarControl): HBRUSH; virtual;
    class function BarToolbarBrushEx(ABarControl: TdxBarControl): HBRUSH; virtual;
    class function BarToolbarDownedBrush(ABarControl: TCustomdxBarControl): HBRUSH; virtual;
    class function BarToolbarDownedSelBrush(ABarControl: TCustomdxBarControl): HBRUSH; virtual;
    class function BarToolbarSelBrush(ABarControl: TCustomdxBarControl): HBRUSH; virtual;
    function ComboBoxArrowWidth(ABarControl: TCustomdxBarControl; cX: Integer): Integer; virtual;
    class function EditTextSize(ABarControl: TCustomdxBarControl; cY: Integer): Integer; virtual;
    class procedure GetEditTextParams(out AOffsets: TRect; out AHeightCorrection: Integer);
    class procedure GetEditTextVerticalOffsets(out ATop, ABottom: Integer); virtual;
    procedure SetWindowRgn(AHandle: THandle; const AWindowRect: TRect; ARedraw: Boolean = False); virtual;
    // Bar
    class function BarAllowHotTrack: Boolean; virtual;
    class function BarAllowQuickCustomizing: Boolean; virtual;
    function BarBeginGroupSideSize: Integer; virtual;
    function BarBeginGroupSize: Integer; virtual;
    procedure BarBorderPaintSizes(ABarControl: TdxBarControl; var R: TRect); virtual;
    class function BarBorderSize: Integer; virtual;
    procedure BarBorderSizes(ABar: TdxBar; AStyle: TdxBarDockingStyle; var R: TRect); virtual;
    class function BarCaptionAreaSize(AScaleFactor: TdxScaleFactor): Integer; virtual;
    procedure BarCaptionFillBackground(ABarControl: TdxBarControl; DC: HDC; R: TRect; AToolbarBrush: HBRUSH); virtual;
    class function BarCaptionSize(AScaleFactor: TdxScaleFactor): Integer; virtual;
    class function BarCaptionTransparent: Boolean; virtual;
    class function BarCloseButtonSize(AScaleFactor: TdxScaleFactor): TSize; virtual;
    procedure BarDrawBackground(ABarControl: TdxBarControl; ADC: HDC;
      const ADestRect, ASourceRect: TRect; ABrush: HBRUSH; AColor: TColor); virtual;
    procedure BarDrawBeginGroup(ABarControl: TCustomdxBarControl; DC: HDC;
      ABeginGroupRect: TRect; AToolbarBrush: HBRUSH; AHorz: Boolean); virtual;
    class procedure BarDrawCaptionElement(ABarControl: TdxBarControl; DC: HDC; R: TRect; AState: TdxBarMarkState); virtual;
    procedure BarDrawCloseButton(ABarControl: TdxBarControl; DC: HDC; R: TRect); virtual;
    procedure BarDrawDockedBarBorder(ABarControl: TdxBarControl; DC: HDC; R: TRect;
      AToolbarBrush: HBRUSH); virtual;
    procedure BarDrawFloatingBarBorder(ABarControl: TdxBarControl; DC: HDC;
      R, CR: TRect; AToolbarBrush: HBRUSH); virtual;
    procedure BarDrawFloatingBarCaption(ABarControl: TdxBarControl; DC: HDC;
      R, CR: TRect; AToolbarBrush: HBRUSH; AScaleFactor: TdxScaleFactor); virtual;
    procedure BarDrawMark(ABarControl: TdxBarControl; DC: HDC; MarkR: TRect); virtual;
    procedure BarDrawMarks(ABarControl: TdxBarControl; ACanvas: TcxCanvas;
      const AItemRect: TRect; AToolbarBrush: HBRUSH); virtual;
    procedure BarDrawMDIButton(ABarControl: TdxBarControl; AButton: TdxBarMDIButton;
      AState: Integer; DC: HDC; R: TRect); virtual;
    procedure BarDrawStatusBarGrip(ABarControl: TdxBarControl; DC: HDC;
      const R: TRect; AToolbarBrush: HBRUSH); virtual;
    procedure BarDrawStatusBarBorder(ABarControl: TdxBarControl; DC: HDC;
      R: TRect; AToolbarBrush: HBRUSH); virtual;
    class function BarHorSize: Integer; virtual;
    function BarMarkRect(ABarControl: TdxBarControl): TRect; virtual;
    function BarMarkItemRect(ABarControl: TdxBarControl): TRect; virtual;
    procedure BarMarkRectInvalidate(ABarControl: TdxBarControl); virtual;
    class function BarTopSize: Integer; virtual;
    class function BarBottomSize: Integer; virtual;
    class function BarUseSystemClose: Boolean; virtual;
    class function BarUseSystemNCBorder: Boolean; virtual;
    function MarkSizeX(ABarControl: TdxBarControl): Integer; virtual;
    procedure StatusBarFillBackground(ABarControl: TdxBarControl; DC: HDC;
      ADestR, ASourceR, AWholeR: TRect; ABrush: HBRUSH; AColor: TColor); virtual;
    function StatusBarBorderOffsets: TRect; virtual;
    class function StatusBarTopBorderSize: Integer; virtual;
    function StatusBarGripSize(ABarManager: TdxBarManager; AScaleFactor: TdxScaleFactor): TSize; virtual;
    // QuickCustItem
    class function BarToolbarBrushEx2(ABarControl: TdxBarControl): HBRUSH; virtual;
    class procedure DrawQuickCustItemFrame(ABarItemControl: TdxBarItemControl;
      DC: HDC; var R, ARect: TRect; Selected: Boolean); virtual;
    class procedure DrawQuickCustItemFrameSelected(ABarItemControl: TdxBarItemControl;
      DC: HDC; WholeR, R: TRect; Selected: Boolean); virtual;
    class function IsQuickControlPopupOnRight: Boolean; virtual;

    // BarItemControl
      // Sizes
    class function GetTailAreaSize(const ADrawParams: TdxBarItemControlDrawParams): Integer; virtual;
    class function ItemControlGetIndents(const ADrawParams: TdxBarItemControlDrawParams;
      ADrawAreaType: TdxBarItemControlPart): TRect; virtual;

    // ButtonControl
      // Attributes
    function ButtonControlArrowBrush(const ADrawParams: TdxBarItemControlDrawParams): HBRUSH; virtual;
      // Conditions
    function IsButtonControlArrowBackgroundOpaque(const ADrawParams: TdxBarButtonLikeControlDrawParams): Boolean; virtual;
    function IsButtonControlArrowDrawSelected(const ADrawParams: TdxBarButtonLikeControlDrawParams): Boolean; virtual;
    function IsButtonControlArrowFlat: Boolean; virtual;
    function IsDropDownRepaintNeeded: Boolean; virtual;
      // Sizes
    function GetButtonBorderHeight(AScaleFactor: TdxScaleFactor): Integer; virtual;
    function GetButtonBorderWidth(AScaleFactor: TdxScaleFactor): Integer; virtual;
    function GetButtonHeight(AIconSize, ATextSize: Integer; AScaleFactor: TdxScaleFactor): Integer; virtual;
    function GetButtonWidth(AIconSize, ATextSize: Integer; AScaleFactor: TdxScaleFactor): Integer; virtual;
    function GetButtonSize(AIconSize, ATextSize: Integer; AScaleFactor: TdxScaleFactor): TSize; virtual;
    function GetLargeButtonBorderHeight: Integer; virtual;
    function GetLargeButtonBorderWidth: Integer; virtual;
    class function GetDefaultArrowSignSize(AScaleFactor: TdxScaleFactor): TSize; virtual;
    class procedure CorrectButtonControlDefaultHeight(var DefaultHeight: Integer); virtual;
    class procedure CorrectButtonControlDefaultWidth(var DefaultWidth: Integer); virtual;
    procedure OffsetCaptionBounds(ADowned, ADrawDowned: Boolean; var R: TRect); virtual;
    class procedure OffsetEllipsisBounds(APressed: Boolean; var R: TRect); virtual;
      // Draw
    procedure DrawBackButtonControl(const ADrawParams: TdxBarButtonLikeControlDrawParams; ARect: TRect); virtual;
    procedure DrawBackButtonControlArrow(const ADrawParams: TdxBarButtonLikeControlDrawParams; ARect: TRect); virtual;
    procedure DrawBackButtonControlBackground(const ADrawParams: TdxBarButtonLikeControlDrawParams; ARect: TRect); virtual;
    procedure DrawButtonLikeControl(const ADrawParams: TdxBarButtonLikeControlDrawParams; ARect: TRect); virtual;
    procedure DrawButtonLikeControlCaption(const ADrawParams: TdxBarButtonLikeControlDrawParams; const ARect, AImageBounds: TRect); virtual;
    procedure DrawButtonControlArrow(const ADrawParams: TdxBarButtonLikeControlDrawParams; ARect: TRect); virtual;
    procedure DrawButtonControlArrowBackground(const ADrawParams: TdxBarButtonLikeControlDrawParams; var R1: TRect; ABrush: HBRUSH); virtual;
    procedure DrawSplitControlArrow(const ADrawParams: TdxBarButtonLikeControlDrawParams; ARect: TRect); virtual;
    procedure DrawAssociateControlArrow(const ADrawParams: TdxBarButtonLikeControlDrawParams; ARect: TRect); virtual;

    // ComboControl
      // Attributes
    function ComboControlArrowColor(ADrawParams: TdxBarItemControlDrawParams): TColor; virtual;
    function ComboControlButtonBrush(const ADrawParams: TdxBarItemControlDrawParams): HBRUSH; virtual;
      // Sizes
    class function ComboControlArrowOffset: Integer; virtual;
    class function ComboControlButtonOffsets(APaintType: TdxBarPaintType): TRect; virtual;
      // Draw
    procedure ComboControlDrawArrowButton(const ADrawParams: TdxBarEditLikeControlDrawParams; ARect: TRect; AInClientArea: Boolean); virtual;
    class procedure ComboControlDrawSimpleButton(const ADrawParams: TdxBarEditLikeControlDrawParams; var ARect: TRect; ABrush: HBRUSH); virtual;

    // DropDownListBox
    class function DropDownListBoxBorderSize: Integer; virtual;
    procedure DropDownListBoxDrawBorder(DC: HDC; AColor: TColor; ARect: TRect); virtual;
    // SubMenuControl
      // Conditions
    class function SubMenuControlHasBand: Boolean; virtual;
    class function SubMenuControlIsOffsetRecentGroupNeeded: Boolean; virtual;
      // Sizes
    class function SubMenuControlArrowsOffset: Integer; virtual;
    class function SubMenuControlArrowWidth(ATextSize: Integer): Integer; virtual;
    function SubMenuControlBeginGroupSize: Integer; virtual;
    class function SubMenuControlBorderSize: Integer; virtual;
    class function SubMenuControlNCBorderSize: Integer; virtual;
    class function SubMenuControlClientBorderSize: Integer; virtual;
    procedure SubMenuControlCalcDrawingConsts(ACanvas: TcxCanvas; ATextSize: Integer;
      AScaleFactor: TdxScaleFactor; out AMenuArrowWidth, AMarkSize: Integer); virtual;
    class function SubMenuControlContentRectOffset(ABarSubMenuControl: TdxBarSubMenuControl): TRect; virtual;
    class function SubMenuControlDetachCaptionAreaSize(ABarSubMenuControl: TdxBarSubMenuControl): Integer; virtual;
    class function SubMenuControlGetBandSize(ABarSubMenuControl: TdxBarSubMenuControl): Integer; virtual;
    class function SubMenuControlGetControlContentIndent(ABarSubMenuControl: TdxBarSubMenuControl): Integer; virtual;
    class function SubMenuControlInternalBorderSize: Integer; virtual;
    class function SubMenuControlInternalBorderOffset: Integer; virtual;
    class function SubMenuControlMarkArrowSize(AMarkSize: Integer): Integer; virtual;
    class function SubMenuControlNormalItemHeight(AScaleFactor: TdxScaleFactor): Integer; virtual;
      // Positions
    class function SubMenuControlGetItemIconRealRect(const AItemRect: TRect; AIconAreaSize: Integer; AIsRightToLeft: Boolean): TRect;
    class function SubMenuControlGetItemIconRect(const AItemRect: TRect; AIconAreaSize: Integer): TRect; virtual;
    class function SubMenuControlGetItemTextRealRect(const ADrawParams: TdxBarButtonLikeControlDrawParams; const AItemRect: TRect): TRect;
    class function SubMenuControlGetItemTextRect(const ADrawParams: TdxBarButtonLikeControlDrawParams; const AItemRect: TRect): TRect; virtual;
    class function SubMenuControlGetItemTextIndent(const ADrawParams: TdxBarItemControlDrawParams): Integer; virtual;
    function SubMenuControlBeginGroupRect(ABarSubMenuControl: TdxBarSubMenuControl;
      AControl: TdxBarItemControl; const AItemRect: TRect): TRect; virtual;
    class procedure SubMenuControlOffsetDetachCaptionRect(ABarSubMenuControl: TdxBarSubMenuControl; var R: TRect); virtual;
      // Draw
    procedure SubMenuControlDrawScrollButton(ABarSubMenuControl: TdxBarSubMenuControl; ACanvas: TcxCanvas; AArrowDirection: TcxArrowDirection); virtual;
    procedure SubMenuControlDrawBackground(ABarSubMenuControl: TdxBarSubMenuControl;
      ACanvas: TcxCanvas; ARect: TRect; ABrush: HBRUSH; AColor: TColor); virtual;
    procedure SubMenuControlDrawBorder(ABarSubMenuControl: TdxBarSubMenuControl;
      DC: HDC; R: TRect); virtual;
    procedure SubMenuControlDrawClientBorder(ABarSubMenuControl: TdxBarSubMenuControl;
      DC: HDC; const R: TRect; ABrush: HBRUSH); virtual;
    procedure SubMenuControlDrawDetachCaption(ABarSubMenuControl: TdxBarSubMenuControl;
      DC: HDC; R: TRect); virtual;
    procedure SubMenuControlDrawBeginGroup(ABarSubMenuControl: TdxBarSubMenuControl;
      AControl: TdxBarItemControl; ACanvas: TcxCanvas; const ABeginGroupRect: TRect); virtual;
    class procedure SubMenuControlDrawItemFrame(ABarSubMenuControl: TdxBarSubMenuControl;
      AControl: TdxBarItemControl; DC: HDC; AItemRect: TRect; AIndex: Integer); virtual;
    procedure SubMenuControlDrawSeparator(ACanvas: TcxCanvas; const ARect: TRect); virtual;
    class procedure SubMenuControlPrepareBkBrush(ABarSubMenuControl: TdxBarSubMenuControl; var ABkBrush: HBRUSH); virtual;
    class function SubMenuControlTextSize(ACanvas: TcxCanvas; AScaleFactor: TdxScaleFactor): Integer; virtual;
    class function SubMenuControlToolbarItemsBrush(ABarSubMenuControl: TdxBarSubMenuControl): HBRUSH; virtual;
    // ApplicationMenu
    function ApplicationMenuContentButtonOffsets: TRect; virtual;
    procedure ApplicationMenuDrawBackground(ABarSubMenuControl: TdxBarSubMenuControl;
      ACanvas: TcxCanvas; const R, AItemsArea: TRect); virtual;
    procedure ApplicationMenuDrawButton(const ADrawParams: TdxBarApplicationMenuButtonControlDrawParams; var R: TRect); virtual;
    function ApplicationMenuButtonTextColor(AEnabled, ASelected: Boolean): TColor; virtual;
    function ApplicationMenuGetFrameSizes: TRect; virtual;
    // SubMenuExtraControl
    function ExtraMenuButtonTextColor(AEnabled, ASelected: Boolean): TColor; virtual;
    procedure ExtraMenuControlDrawBackground(AExtraMenuControl: TCustomdxBarControl;
      ACanvas: TcxCanvas; ARect: TRect; ABrush: HBRUSH; AColor: TColor); virtual;
    procedure ExtraMenuControlDrawBeginGroup(AExtraMenuControl: TCustomdxBarControl;
      ACanvas: TcxCanvas; ABeginGroupRect: TRect; AToolbarBrush: HBRUSH; AHorz: Boolean); virtual;
    procedure ExtraMenuDrawButton(ADrawParams: TdxBarExtraMenuButtonControlDrawParams; const ARect: TRect); virtual;
    function ExtraMenuHeaderTextColor: TColor; virtual;
    function ExtraMenuPinButtonSize: Integer; virtual;
    function ExtraMenuSeparatorSize: Integer; virtual;

    // Edit
    class procedure EditDrawInterior(ABarEditControl: TdxBarEditControl;
      ABarEdit: TdxBarEdit; ACanvas: TCanvas;  R: TRect; ItemLink: TdxBarItemLink); virtual;
    procedure EditGetRealLookAndFeel(ABarManager: TdxBarManager; ALookAndFeel: TcxLookAndFeel); virtual;
    function EditGetEnabledBkColor(ABarItemControl: TdxBarCustomEditControl): COLORREF; virtual;
    function EditGetDisabledBkColor(ABarItemControl: TdxBarCustomEditControl): COLORREF; virtual;
    function EditGetBkColor(const ADrawParams: TdxBarEditLikeControlDrawParams): COLORREF; virtual;
    function EditGetEnabledTextColor: COLORREF; virtual;
    function EditGetDisabledTextColor: COLORREF; virtual;
    function EditGetTextColor(ABarItemControl: TdxBarCustomEditControl): COLORREF; virtual;

    // EditButton
      // Conditions
    function EditButtonAllowOffsetContent: Boolean; virtual;
    function EditButtonAllowCompositeFrame: Boolean; virtual;
    class function EditButtonAllowHotTrack(const ADrawParams: TdxBarItemControlDrawParams): Boolean; virtual;
    function EditButtonIsCustomBorder: Boolean; virtual;
    function EditButtonIsCustomBackground(AState: Integer): Boolean; virtual;
      // Sizes
    procedure EditButtonCorrectDefaultWidth(var ADefaultWidth: Integer); virtual;
      // Draw
    procedure EditButtonDrawBackground(const ADrawParams: TdxBarEditLikeControlDrawParams; AState: Integer;
      ARect: TRect; ABrush: HBrush); virtual;
    procedure EditButtonDrawBorder(const ADrawParams: TdxBarItemControlDrawParams;
      AState: Integer; var ADrawRect: TRect; out AContentRect: TRect); virtual;

    // CustomCombo
    class procedure CustomComboDrawItem(ABarCustomCombo: TdxBarCustomCombo;
      ACanvas: TCanvas; AIndex: Integer; ARect: TRect; AState: TOwnerDrawState;
      AInteriorIsDrawing: Boolean); virtual;
    // EditControl
    procedure DrawEditLikeControl(const ADrawParams: TdxBarEditLikeControlDrawParams; ARect: TRect); virtual;
    class function EditControlBorderOffsets(APaintType: TdxBarPaintType): TRect; virtual;
    procedure EditControlDrawBackground(const ADrawParams: TdxBarEditLikeControlDrawParams); virtual;
    procedure EditControlDrawBorder(const ADrawParams: TdxBarEditLikeControlDrawParams; var ARect: TRect); virtual;
    procedure EditControlDrawCaption(const ADrawParams: TdxBarEditLikeControlDrawParams); virtual;
    procedure EditControlDrawSelectionFrame(const ADrawParams: TdxBarEditLikeControlDrawParams; const ARect: TRect); virtual;
    procedure EditControlDrawGlyph(const ADrawParams: TdxBarEditLikeControlDrawParams); virtual;
    class function EditControlCaptionBackgroundIsOpaque(const ADrawParams: TdxBarEditLikeControlDrawParams): Boolean; virtual;
    class function EditControlCaptionRightIndentIsOpaque(const ADrawParams: TdxBarEditLikeControlDrawParams): Boolean; virtual;
    procedure EditControlDrawTextField(ABarEditControl: TdxBarEditControl;
      ACanvas: TcxCanvas; const ARect: TRect); virtual;
    function EditControlGetBackgroundColor(const ADrawParams: TdxBarItemControlDrawParams): TColor; virtual;
    function EditControlGetContentRect(APaintType: TdxBarPaintType; const ARect: TRect): TRect;
    function EditControlGetTextColor(const ADrawParams: TdxBarItemControlDrawParams): TColor; virtual;
    class function EditControlShowIconDefault(const ADrawParams: TdxBarEditLikeControlDrawParams): Boolean; virtual;
      // Select EditControl indents
    class function EditControlIndents(const ADrawParams: TdxBarEditLikeControlDrawParams;
      ADrawAreaType: TdxBarItemControlPart): TRect; virtual;
    class function EditControlCaptionLeftIndent(const ADrawParams: TdxBarEditLikeControlDrawParams): Integer;
    class function EditControlCaptionRightIndent(const ADrawParams: TdxBarEditLikeControlDrawParams): Integer;
    class function EditControlCaptionSubMenuIndent(const ADrawParams: TdxBarEditLikeControlDrawParams): Integer; virtual;
    class function EditControlCaptionSimpleIndent(const ADrawParams: TdxBarEditLikeControlDrawParams): Integer; virtual;
    class function EditControlCaptionComplexIndent(const ADrawParams: TdxBarEditLikeControlDrawParams): Integer; virtual;
    class function EditControlSubMenuGlyphIndents(const ADrawParams: TdxBarEditLikeControlDrawParams): TRect; virtual;

    class function EditControlGetRightCaptionIndentBrush(ABarEditControl: TdxBarCustomEditControl): HBRUSH; virtual;
    class function EditControlGlyphIsDrawSelected(ABarEditControl: TdxBarCustomEditControl): Boolean; virtual;
    class procedure EditControlUpdateWndText(ABarEditControl: TdxBarEditControl;
      AHandle: HWND; ANotEqual: Boolean); virtual;
    class function HasEditControlExternalFrame(APaintType: TdxBarPaintType;
      ASelected: Boolean): Boolean; virtual;

    // ColorCombo
      // Conditions
    function ColorComboHasCompleteFrame: Boolean; virtual;
    function IsCustomColorButtonVisible(const ADrawParams: TdxBarColorComboControlDrawParams): Boolean; virtual;
      // Sizes
    procedure ColorComboCorrectFrameRect(const ADrawParams: TdxBarColorComboControlDrawParams; var ARect: TRect); virtual;
    function GetDotSpaceAfter(ADotWidth: Integer): Integer; virtual;
    function GetCustomColorButtonBounds(const ADrawParams: TdxBarColorComboControlDrawParams; ARect: TRect): TRect; virtual;
    function GetCustomColorButtonWidth(APaintType: TdxBarPaintType; const ARect: TRect): Integer; virtual;
    function GetCustomColorButtonIndents(APaintType: TdxBarPaintType): TRect; virtual;
      // Draw
    procedure ColorComboDrawCustomButton(const ADrawParams: TdxBarColorComboControlDrawParams; ARect: TRect); virtual;
    procedure ColorComboDrawCustomButtonAdjacentZone(const ADrawParams: TdxBarColorComboControlDrawParams; ARect: TRect); virtual;

    // SysPanel
    procedure SysPanelCalcSize(var AClientRect, AGripRect, ACloseButtonRect: TRect;
      var Corner: TdxCorner; Combo: TdxBarItem; AllowResizing: Boolean; AScaleFactor: TdxScaleFactor); virtual;
    procedure SysPanelDraw(AHandle: HWND; AllowResizing, MouseAboveCloseButton,
      CloseButtonIsTracking: Boolean; CloseButtonRect, GripRect: TRect; Corner: TdxCorner; AScaleFactor: TdxScaleFactor); virtual;
    class function SysPanelSize(AScaleFactor: TdxScaleFactor): Integer; virtual;
    // DateNavigator
    class function IsDateNavigatorFlat: Boolean; virtual;
    procedure DateNavigatorDrawButton(ABarItem: TdxBarItem; DC: HDC; R: TRect;
      const ACaption: string; APressed: Boolean; AScaleFactor: TdxScaleFactor); virtual;
    function DateNavigatorHeaderColor: TColor; virtual;

    // SpinEditControl
    function GetSpinEditArrowPos(const ADrawParams: TdxBarSpinEditDrawParams; ARect: TRect; AButtonIndex: Integer): TPoint; virtual;
    procedure SpinEditCorrectFrameRect(const ADrawParams: TdxBarItemControlDrawParams; var ARect: TRect); virtual;
    function GetSpinEditArrowSize(AHeight: Integer): TSize; virtual;
    function GetSpinEditButtonBounds(const ADrawParams: TdxBarSpinEditDrawParams; const ARect: TRect; AButton: TdxBarSpinEditButton): TRect; virtual;
    function GetSpinEditButtonIndents(APaintType: TdxBarPaintType): TRect; virtual;
    function GetSpinEditButtonWidth(APaintType: TdxBarPaintType; const ARect: TRect): Integer; virtual;
    function GetSpinEditButtonState(const ADrawParams: TdxBarSpinEditDrawParams; AButtonIndex: Integer): TcxButtonState; virtual;
      // Draw
    procedure SpinEditControlDrawButton(const ADrawParams: TdxBarSpinEditDrawParams; ARect: TRect; AButtonIndex: Integer); virtual;
    procedure SpinEditControlDrawButtonsAdjacentZone(const ADrawParams: TdxBarSpinEditDrawParams; const ARect: TRect); virtual;
    // ProgressControl
      //  Attributes
    class function ProgressControlBarBrushColor: TColorRef; virtual;
      // Conditions
    function CanUpdateBarPartly: Boolean; virtual;
      // Sizes
    function ProgressControlBarHeight(ABarItemControl: TdxBarItemControl): Integer; virtual;
    class function ProgressControlIndent(const ADrawParams: TdxBarItemControlDrawParams): Integer; virtual;
      // Draw
    procedure ProgressControlDrawBar(const ADrawParams: TdxBarProgressControlDrawParams; BarR: TRect; ABarBrushColor: TColorRef); virtual;
    procedure ProgressControlDrawBackground(const ADrawParams: TdxBarItemControlDrawParams; var BarR: TRect); virtual;
    procedure ProgressControlDrawChunks(const ADrawParams: TdxBarItemControlDrawParams; BarR: TRect; ABarBrush: HBRUSH); virtual;
    procedure ProgressControlFillContent(const ADrawParams: TdxBarItemControlDrawParams; const R: TRect; ABarBrush: HBRUSH); virtual;
    procedure ProgressControlFillDiscreteContent(const ADrawParams: TdxBarItemControlDrawParams; const R: TRect; ABarBrush: HBRUSH); virtual;
    // ContainerControl
    class function ContainerControlSubMenuOffset: Integer; virtual;
    // InPlaceSubItemControl
      // Sizes
    class function InPlaceSubItemControlBrush: HBRUSH; virtual;
    class function InPlaceSubItemGetArrowWidth(const ADrawParams: TdxBarInPlaceSubItemControlDrawParams): Integer; virtual;
    class function InPlaceSubItemGetTextIndent: Integer; virtual;
      // Conditions
    function InPlaceSubItemControlIsFlatItemText(const ADrawParams: TdxBarInPlaceSubItemControlDrawParams): Boolean; virtual;
    function InPlaceSubItemControlIsArrowSelected(const ADrawParams: TdxBarInPlaceSubItemControlDrawParams): Boolean; virtual;
      // Draw
    procedure InPlaceSubItemControlDrawArrow(const ADrawParams: TdxBarInPlaceSubItemControlDrawParams;
      ADirection: TcxArrowDirection; ARect: TRect); virtual;
    procedure InPlaceSubItemControlDrawBackground(const ADrawParams: TdxBarInPlaceSubItemControlDrawParams; ARect: TRect); virtual;
    procedure InPlaceSubItemControlDrawInMenu(const ADrawParams: TdxBarInPlaceSubItemControlDrawParams; ARect: TRect); virtual;
    // StaticControl
    procedure DrawStaticBackground(const ADrawParams: TdxBarStaticLikeControlDrawParams; ARect: TRect); virtual;
    procedure DrawStaticBorder(const ADrawParams: TdxBarStaticLikeControlDrawParams; var ARect: TRect); virtual;
    procedure DrawStaticGlyphAndCaption(const ADrawParams: TdxBarStaticLikeControlDrawParams; const ARect: TRect); virtual;
    procedure DrawStaticLikeControl(const ADrawParams: TdxBarStaticLikeControlDrawParams; var ARect: TRect; const AIndentsRect: TRect); virtual;
    class function StaticBackgroundIsOpaque(const ADrawParams: TdxBarItemControlDrawParams): Boolean; virtual;
    function StaticControlGetBorderOffsets(AParent: TCustomdxBarControl; ABorderStyle: TdxBarStaticBorderStyle): TRect; virtual;
    // Separator
    class function SeparatorControlGetIndents(const ADrawParams: TdxBarSeparatorControlDrawParams;
      ADrawAreaType: TdxBarItemControlPart): TRect; virtual;
    procedure SeparatorControlGetTextColors(ABarItemControl: TdxBarItemControl;
      AEnabled, ASelected, AFlat: Boolean; var AColor1, AColor2: TColor); virtual;
    function SeparatorControlSeparatorSize: Integer; virtual;
    function SubMenuGetSeparatorSize: Integer; virtual;
    procedure DrawSeparatorGlyphAndCaption(const ADrawParams: TdxBarSeparatorControlDrawParams; const ARect: TRect); virtual;
    procedure DrawSeparatorControl(const ADrawParams: TdxBarSeparatorControlDrawParams; const ARect: TRect); virtual;
    procedure DrawSeparatorControlLine(ACanvas: TcxCanvas; const R: TRect); virtual;

    // Gallery
    procedure DropDownGalleryDrawBackground(DC: HDC; const R: TRect); virtual;
    procedure DropDownGalleryDrawBorder(ABarSubMenuControl: TdxBarSubMenuControl; DC: HDC; const R: TRect); virtual;
    procedure DropDownGalleryDrawBottomSizeGrip(DC: HDC; const R: TRect); virtual;
    procedure DropDownGalleryDrawBottomSizeGripEx(ABarSubMenuControl: TdxBarSubMenuControl; DC: HDC; const R: TRect); virtual;
    procedure DropDownGalleryDrawBottomSizingBand(DC: HDC; const R: TRect); virtual;
    procedure DropDownGalleryDrawBottomVerticalSizeGrip(DC: HDC; const R: TRect); virtual;
    procedure DropDownGalleryDrawFilterBand(DC: HDC; const R: TRect); virtual;
    procedure DropDownGalleryDrawGroupHeaderBackground(DC: HDC; const R: TRect); virtual;
    procedure DropDownGalleryDrawItem(DC: HDC; const R: TRect; AState: Integer; AScaleFactor: TdxScaleFactor); virtual;
    procedure DropDownGalleryDrawScrollBarBackgroundEx(ABarSubItemControl: TdxBarSubItemControl; DC: HDC; const R: TRect; AScaleFactor: TdxScaleFactor); virtual;
    procedure DropDownGalleryDrawScrollBarBackground(DC: HDC; const R: TRect; AScaleFactor: TdxScaleFactor); virtual;
    procedure DropDownGalleryDrawScrollBarPart(DC: HDC; const R: TRect;
      APart: TcxScrollBarPart; AState: TcxButtonState; AScaleFactor: TdxScaleFactor); virtual;
    procedure DropDownGalleryDrawScrollBarPartEx(ABarSubItemControl: TdxBarSubItemControl; DC: HDC; const R: TRect;
      APart: TcxScrollBarPart; AState: TcxButtonState; AScaleFactor: TdxScaleFactor); virtual;
    procedure DropDownGalleryDrawSelectionFrame(ACanvas: TcxCanvas; const R: TRect; AState: Integer); virtual;
    procedure DropDownGalleryDrawTopSizeGrip(DC: HDC; const R: TRect); virtual;
    procedure DropDownGalleryDrawTopSizeGripEx(ABarSubMenuControl: TdxBarSubMenuControl; DC: HDC; const R: TRect); virtual;
    procedure DropDownGalleryDrawTopSizingBand(DC: HDC; const R: TRect); virtual;
    procedure DropDownGalleryDrawTopVerticalSizeGrip(DC: HDC; const R: TRect); virtual;
    function DropDownGalleryGetClientBorderSize: Integer; virtual;
    function DropDownGalleryGetContentOffsets(APart: Integer): TRect; virtual;
    function DropDownGalleryGetFilterBandSeparatorColor: TColor; virtual;
    function DropDownGalleryGetFilterBandTextColor(AState: Integer): TColor; virtual;
    function DropDownGalleryGetGroupHeaderTextColor: TColor; virtual;
    function DropDownGalleryGetName: string; virtual;
    function DropDownGalleryGetNCBorderSize: Integer; virtual;
    function DropDownGalleryGetScrollBarWidth(AControlHeight: Integer; const AControlMargins: TRect): Integer; virtual;
    function DropDownGalleryGetSizingBandHeight(AIconSize, ATextSize: Integer; AScaleFactor: TdxScaleFactor): Integer; virtual;
    procedure DropDownGalleryItemGetTextColors(ABarItemControl: TdxBarItemControl; AEnabled, ASelected, AFlat: Boolean; var AColor1, AColor2: TColor); virtual;

    // ScreenTip
      // Attributes
    function ScreenTipGetColorPalette: IdxColorPalette; virtual;
    function ScreenTipGetDescriptionTextColor: TColor; virtual;
    function ScreenTipGetTitleTextColor: TColor; virtual;
      // Size
    function ScreenTipGetFooterLineSize: Integer; virtual;
      // Draw
    procedure ScreenTipDrawBackground(ACanvas: TcxCanvas; ARect: TRect); virtual;
    procedure ScreenTipDrawFooterLine(ACanvas: TcxCanvas; const ARect: TRect); virtual;
  end;

  TdxBarStandardPainter = class(TdxBarPainter)
  protected
    procedure DrawGlyphBorder(ABarItemControl: TdxBarItemControl; DC: HDC; ABrush: HBRUSH;
      NeedBorder: Boolean; R: TRect; PaintType: TdxBarPaintType; IsGlyphEmpty,
      Selected, Down, DrawDowned, ADroppedDown, IsSplit: Boolean); override;
    procedure DrawGlyphCheckMark(ABarItemControl: TdxBarItemControl; DC: HDC; X, Y, DoubleSize: Integer); override;
    class function IgnoreGlyphOpaque: Boolean; override;
    // Bar
    class function BarIsBarSmall(ABarControl: TdxBarControl; const R: TRect): Boolean; override;
    class procedure BarDrawMarkAtPos(ABarControl: TdxBarControl; DC: HDC;
      const ItemRect: TRect; Offset: Integer); override;
    procedure BarDrawMarkBackground(ABarControl: TdxBarControl; DC: HDC;
      ItemRect: TRect; AToolbarBrush: HBRUSH); override;
    // SysPanel
    function GetLookAndFeelPainter: TcxCustomLookAndFeelPainter; override;
  public
    // Common
      // Sizes
    function GetBorderSize: Integer; override;
    class function GetCaptionOffsets: TRect; override;
    class function GlyphDownShift(ABarItemControl: TdxBarItemControl): Integer; override;
    class function GlyphDrawDownedShift(ABarItemControl: TdxBarItemControl; ADown: Boolean): Integer; override;
    class function LoweredBorderSize(ABarItemControl: TdxBarItemControl): Integer; override;
      // Draw
    class procedure DrawDisabledShadowRect(ABarItemControl: TdxBarItemControl; DC: HDC;
      R: TRect); override;
    procedure DrawItemBackgroundInSubMenu(const ADrawParams: TdxBarButtonLikeControlDrawParams; R: TRect); override;
    class procedure FrameAndFillRect(ABarItemControl: TdxBarItemControl; DC: HDC;
      var R: TRect; Enabled, Selected, Pressed: Boolean); override;
    class function GlyphBkgndBrush(ABarItemControl: TdxBarItemControl;
      APaintType: TdxBarPaintType; AGlyphEmpty, ASelected, ADowned, ADrawDowned, ADroppedDown,
      AForceUseBkBrush, AGrayScale: Boolean): HBRUSH; override;
    // BarManager
    function BeforeFingersSize: Integer; override;
    function FingersSize(ABarControl: TdxBarControl): Integer; override;
    class function SubMenuBeginGroupIndent: Integer; override;
    // Custom Bar
    class procedure GetEditTextVerticalOffsets(out ATop, ABottom: Integer); override;
    // Bar
    class function BarAllowHotTrack: Boolean; override;
    class function BarAllowQuickCustomizing: Boolean; override;
    procedure BarDrawCloseButton(ABarControl: TdxBarControl; DC: HDC; R: TRect); override;
    procedure BarDrawDockedBarBorder(ABarControl: TdxBarControl; DC: HDC; R: TRect; AToolbarBrush: HBRUSH); override;
    procedure BarDrawFloatingBarBorder(ABarControl: TdxBarControl; DC: HDC;
      R, CR: TRect; AToolbarBrush: HBRUSH); override;
    procedure BarDrawMDIButton(ABarControl: TdxBarControl; AButton: TdxBarMDIButton;
      AState: Integer; DC: HDC; R: TRect); override;
    class function BarHorSize: Integer; override;
    function BarMarkItemRect(ABarControl: TdxBarControl): TRect; override;
    class function BarTopSize: Integer; override;
    class function BarBottomSize: Integer; override;
    class function BarUseSystemClose: Boolean; override;
    class function BarUseSystemNCBorder: Boolean; override;
    // ButtonControl
    procedure DrawButtonControlArrowBackground(const ADrawParams: TdxBarButtonLikeControlDrawParams;
      var R1: TRect; ABrush: HBRUSH); override;

    // ComboControl
    class procedure ComboControlDrawSimpleButton(const ADrawParams: TdxBarEditLikeControlDrawParams; var ARect: TRect; ABrush: HBRUSH); override;

    // DropDownListBox
    procedure DropDownListBoxDrawBorder(DC: HDC; AColor: TColor; ARect: TRect); override;
    // SubMenuControl
    class procedure SubMenuControlDrawItemFrame(ABarSubMenuControl: TdxBarSubMenuControl;
      AControl: TdxBarItemControl; DC: HDC; AItemRect: TRect; AIndex: Integer); override;
    class function SubMenuControlIsOffsetRecentGroupNeeded: Boolean; override;
    class function SubMenuControlContentRectOffset(ABarSubMenuControl: TdxBarSubMenuControl): TRect; override;
    class function SubMenuControlClientBorderSize: Integer; override;
    // ProgressControl
      // Conditions
    function CanUpdateBarPartly: Boolean; override;
  end;

  TdxBarEnhancedPainter = class(TdxBarStandardPainter)
  protected
    // Bar
    class procedure BarDrawMarkAtPos(ABarControl: TdxBarControl; DC: HDC;
      const ItemRect: TRect; Offset: Integer); override;
    procedure BarDrawMarkBackground(ABarControl: TdxBarControl; DC: HDC;
      ItemRect: TRect; AToolbarBrush: HBRUSH); override;
  public
    // BarManager
    function BeforeFingersSize: Integer; override;
    function FingersSize(ABarControl: TdxBarControl): Integer; override;
    class function SubMenuBeginGroupIndent: Integer; override;
    // Bar
    class function BarAllowQuickCustomizing: Boolean; override;
    procedure BarDrawDockedBarBorder(ABarControl: TdxBarControl; DC: HDC; R: TRect;
      AToolbarBrush: HBRUSH); override;
  end;

  TdxBarFlatPainter = class(TdxBarPainter)
  protected
    // Common
    procedure DrawGlyphBorder(ABarItemControl: TdxBarItemControl; ADC: HDC; ABrush: HBRUSH;
      ANeedBorder: Boolean; R: TRect; APaintType: TdxBarPaintType; AGlyphEmpty,
      ASelected, ADowned, ADrawDowned, ADroppedDown, AIsSplit: Boolean); override;
    procedure DrawGlyphCheckMark(ABarItemControl: TdxBarItemControl; DC: HDC; X, Y, DoubleSize: Integer); override;
    class procedure DrawFrameRect(ABarItemControl: TdxBarItemControl; ADC: HDC;
      const ARect: TRect; ABrush: HBRUSH; APaintType: TdxBarPaintType; ASelected, ADowned: Boolean); virtual;
    class procedure FrameFlatSelRect(DC: HDC; const R: TRect); override;
    class function GetToolbarBrush(ABarItemControl: TdxBarItemControl): HBRUSH; virtual;
    // Bar
    class function BarCaptionBkColor(ABarControl: TdxBarControl; AMainFormActive: Boolean): COLORREF; override;
    class function BarMarkArrowColor(ABarControl: TdxBarControl; AState: TdxBarMarkState): COLORREF; override;
    procedure BarDrawMarkBackground(ABarControl: TdxBarControl; DC: HDC;
      ItemRect: TRect; AToolbarBrush: HBRUSH); override;
    class procedure BarOffsetFloatingBarCaption(ABarControl: TdxBarControl; var X: Integer; var R: TRect); override;
    class function GetDrawMarkElementColor(ABarControl: TdxBarControl): Integer; override;
    // SubMenuControl
    procedure SubMenuControlDrawNonRecentGroupSeparator(ABarSubMenuControl: TdxBarSubMenuControl; ACanvas: TcxCanvas; AArrowDirection: TcxArrowDirection); override;
    procedure SubMenuControlDrawMarkSelection(ABarSubMenuControl: TdxBarSubMenuControl; ADC: HDC; const AMarkRect: TRect); override;
    // SpinEditControl
    procedure DrawSpinEditArrow(const ADrawParams: TdxBarSpinEditDrawParams; AArrowPos: TPoint; AButtonIndex: Integer); override;
    // SysPanel
    class function GetSysPanelBorderColor: TColor; override;
    function GetLookAndFeelPainter: TcxCustomLookAndFeelPainter; override;
  public
    // New
    procedure CalculateSpinEditParts(const ADrawParams: TdxBarSpinEditDrawParams;
      var AParts, AAreaParts: array of TRect); override;

    // Common
      // Sizes
    function GetBorderSize: Integer; override;
    class function GetControlCaptionOffset(ABarItemControl: TdxBarItemControl): Integer; override;
      // Draw
    procedure DrawItemBackgroundInSubMenu(const ADrawParams: TdxBarButtonLikeControlDrawParams; R: TRect); override;
    class procedure DrawLowered(DC: HDC; var R: TRect); override;
    procedure DrawStaticBorder(const ADrawParams: TdxBarStaticLikeControlDrawParams; var ARect: TRect); override;
    class procedure FrameAndFillRect(ABarItemControl: TdxBarItemControl; DC: HDC;
      var R: TRect; Enabled, Selected, Pressed: Boolean); override;
    class function GlyphBkgndBrush(ABarItemControl: TdxBarItemControl;
      APaintType: TdxBarPaintType; AGlyphEmpty, ASelected, ADowned, ADrawDowned, ADroppedDown,
      AForceUseBkBrush, AGrayScale: Boolean): HBRUSH; override;
    class function IsFlatGlyphImage: Boolean; override;
    class function IsFlatItemText: Boolean; override;
    class function IsGlyphImageBackgroundOpaque(ABarItemControl: TdxBarItemControl;
      ADown, ADrawDowned, ASelected, AGlyphEmpty: Boolean): Boolean; override;
    class function IsGlyphImageHasShadow: Boolean; override;
    class function LoweredBorderSize(ABarItemControl: TdxBarItemControl): Integer; override;
    class function StaticBorderBrush(ABarItemControl: TdxBarItemControl; ABorderStyle: TdxBarStaticBorderStyle): HBRUSH; virtual;
    class function TextAreaOffset(ABarItemControl: TdxBarItemControl): Integer; override;
    // BarManager
    function BeforeFingersSize: Integer; override;
    function FingersSize(ABarControl: TdxBarControl): Integer; override;
    class function RealButtonArrowWidth(ABarManager: TdxBarManager): Integer; override;
    class function RealLargeButtonArrowWidth(ABarManager: TdxBarManager): Integer; override;
    class function SubMenuBeginGroupIndent: Integer; override;
    // CustomBar
    class function BarChildrenHaveShadows(ABarControl: TCustomdxBarControl): Boolean; override;
    class procedure BarDrawBarControlOwner(ACustomBarControl: TCustomdxBarControl; DC: HDC;
      R: TRect; ABarControl: TCustomdxBarControl); virtual;
    class procedure BarDrawBarControlOwnerBorder(ACustomBarControl: TCustomdxBarControl;
      DC: HDC; R: TRect; ABarItemControl: TdxBarItemControl; ABarControl: TCustomdxBarControl); virtual;
    class procedure BarDrawBarControlOwnerFrame(ACustomBarControl: TCustomdxBarControl;
      DC: HDC; R: TRect); virtual;
    class procedure BarDrawBarControlOwnerLink(ACustomBarControl: TCustomdxBarControl;
      DC: HDC; R, ALinkR: TRect; ABarItemControl: TdxBarItemControl); virtual;
    class function BarToolbarBrush(ABarControl: TCustomdxBarControl): HBRUSH; override;
    class function BarToolbarBrushEx(ABarControl: TdxBarControl): HBRUSH; override;
    class function BarToolbarDownedBrush(ABarControl: TCustomdxBarControl): HBRUSH; override;
    class function BarToolbarDownedSelBrush(ABarControl: TCustomdxBarControl): HBRUSH; override;
    class function BarToolbarSelBrush(ABarControl: TCustomdxBarControl): HBRUSH; override;
    // Bar
    function BarBeginGroupSideSize: Integer; override;
    function BarBeginGroupSize: Integer; override;
    procedure BarDrawBeginGroup(ABarControl: TCustomdxBarControl; DC: HDC;
      ABeginGroupRect: TRect; AToolbarBrush: HBRUSH; AHorz: Boolean); override;
    procedure BarDrawCloseButton(ABarControl: TdxBarControl; DC: HDC; R: TRect); override;
    procedure BarDrawDockedBarBorder(ABarControl: TdxBarControl; DC: HDC; R: TRect; AToolbarBrush: HBRUSH); override;
    procedure BarDrawFloatingBarBorder(ABarControl: TdxBarControl; DC: HDC; R, CR: TRect; AToolbarBrush: HBRUSH); override;
    procedure BarDrawMark(ABarControl: TdxBarControl; DC: HDC; MarkR: TRect); override;
    procedure BarDrawMDIButton(ABarControl: TdxBarControl; AButton: TdxBarMDIButton; AState: Integer; DC: HDC; R: TRect); override;
    // QuickCustItem
    class function BarToolbarBrushEx2(ABarControl: TdxBarControl): HBRUSH; override;
    class procedure DrawQuickCustItemFrame(ABarItemControl: TdxBarItemControl;
      DC: HDC; var R, ARect: TRect; Selected: Boolean); override;
    class procedure DrawQuickCustItemFrameSelected(ABarItemControl: TdxBarItemControl;
      DC: HDC; WholeR, R: TRect; Selected: Boolean); override;
    class function IsQuickControlPopupOnRight: Boolean; override;
    // ButtonControl
      // Attributes
    function ButtonControlArrowBrush(const ADrawParams: TdxBarItemControlDrawParams): HBRUSH; override;
      // Sizes
    class procedure CorrectButtonControlDefaultHeight(var DefaultHeight: Integer); override;
    class procedure CorrectButtonControlDefaultWidth(var DefaultWidth: Integer); override;
      // Draw
    procedure DrawButtonControlArrowBackground(const ADrawParams: TdxBarButtonLikeControlDrawParams;
      var R1: TRect; ABrush: HBRUSH); override;

    // ComboControl
      // Attributes
    function ComboControlArrowColor(ADrawParams: TdxBarItemControlDrawParams): TColor; override;
    function ComboControlButtonBrush(const ADrawParams: TdxBarItemControlDrawParams): HBRUSH; override;
      // Draw
    class procedure ComboControlDrawSimpleButton(const ADrawParams: TdxBarEditLikeControlDrawParams; var ARect: TRect; ABrush: HBRUSH); override;

    // SubMenuControl
      // Sizes
    class function SubMenuControlArrowsOffset: Integer; override;
    function SubMenuControlBeginGroupRect(
      ABarSubMenuControl: TdxBarSubMenuControl; AControl: TdxBarItemControl;
      const AItemRect: TRect): TRect; override;
    function SubMenuControlBeginGroupSize: Integer; override;
    procedure SubMenuControlCalcDrawingConsts(ACanvas: TcxCanvas; ATextSize: Integer;
      AScaleFactor: TdxScaleFactor; out AMenuArrowWidth, AMarkSize: Integer); override;
    class function SubMenuControlDetachCaptionAreaSize(ABarSubMenuControl: TdxBarSubMenuControl): Integer; override;
      // Positions
    class function SubMenuControlGetItemIconRect(const AItemRect: TRect; AIconAreaSize: Integer): TRect; override;
    class function SubMenuControlGetItemTextRect(const ADrawParams: TdxBarButtonLikeControlDrawParams; const AItemRect: TRect): TRect; override;
    class function SubMenuControlGetItemTextIndent(const ADrawParams: TdxBarItemControlDrawParams): Integer; override;
      // Draw
    procedure SubMenuControlDrawBorder(ABarSubMenuControl: TdxBarSubMenuControl;
      DC: HDC; R: TRect); override;
    procedure SubMenuControlDrawClientBorder(ABarSubMenuControl: TdxBarSubMenuControl;
      DC: HDC; const R: TRect; ABrush: HBRUSH); override;
    procedure SubMenuControlDrawDetachCaption(ABarSubMenuControl: TdxBarSubMenuControl;
      DC: HDC; R: TRect); override;
    procedure SubMenuControlDrawBeginGroup(ABarSubMenuControl: TdxBarSubMenuControl;
      AControl: TdxBarItemControl; ACanvas: TcxCanvas; const ABeginGroupRect: TRect); override;
    procedure SubMenuControlDrawSeparator(ACanvas: TcxCanvas; const ARect: TRect); override;
    class function SubMenuControlGetSeparatorColor: TColor; virtual;
    class function SubMenuControlMarkArrowSize(AMarkSize: Integer): Integer; override;
    class function SubMenuControlNormalItemHeight(AScaleFactor: TdxScaleFactor): Integer; override;
    class procedure SubMenuControlOffsetDetachCaptionRect(ABarSubMenuControl: TdxBarSubMenuControl; var R: TRect); override;
    class function SubMenuControlTextSize(ACanvas: TcxCanvas; AScaleFactor: TdxScaleFactor): Integer; override;
    class function SubMenuControlToolbarItemsBrush(ABarSubMenuControl: TdxBarSubMenuControl): HBRUSH; override;
    // CustomCombo
    class procedure CustomComboDrawItem(ABarCustomCombo: TdxBarCustomCombo;
      ACanvas: TCanvas; AIndex: Integer; ARect: TRect; AState: TOwnerDrawState;
      AInteriorIsDrawing: Boolean); override;
    // EditControl
    class function EditControlBorderOffsets(APaintType: TdxBarPaintType): TRect; override;
    procedure EditControlDrawBorder(const ADrawParams: TdxBarEditLikeControlDrawParams; var ARect: TRect); override;
    procedure EditControlDrawSelectionFrame(const ADrawParams: TdxBarEditLikeControlDrawParams; const ARect: TRect); override;
    class function EditControlCaptionRightIndentIsOpaque(const ADrawParams: TdxBarEditLikeControlDrawParams): Boolean; override;
      // Select EditControl indents
    class function EditControlCaptionSubMenuIndent(const ADrawParams: TdxBarEditLikeControlDrawParams): Integer; override;
    class function EditControlCaptionSimpleIndent(const ADrawParams: TdxBarEditLikeControlDrawParams): Integer; override;
    class function EditControlCaptionComplexIndent(const ADrawParams: TdxBarEditLikeControlDrawParams): Integer; override;
    class function EditControlSubMenuGlyphIndents(const ADrawParams: TdxBarEditLikeControlDrawParams): TRect; override;

    class function EditControlGetRightCaptionIndentBrush(ABarEditControl: TdxBarCustomEditControl): HBRUSH; override;
    class function EditControlGlyphIsDrawSelected(ABarEditControl: TdxBarCustomEditControl): Boolean; override;
    class function HasEditControlExternalFrame(APaintType: TdxBarPaintType;
      ASelected: Boolean): Boolean; override;
    // ProgressControl
      // Conditions
    function CanUpdateBarPartly: Boolean; override;
    // DateNavigator
    class function IsDateNavigatorFlat: Boolean; override;
    procedure DateNavigatorDrawButton(ABarItem: TdxBarItem; DC: HDC; R: TRect;
      const ACaption: string; APressed: Boolean; AScaleFactor: TdxScaleFactor); override;
    // SpinEditControl
    procedure SpinEditControlDrawButton(const ADrawParams: TdxBarSpinEditDrawParams; ARect: TRect; AButtonIndex: Integer); override;
    // ContainerControl
    class function ContainerControlSubMenuOffset: Integer; override;
    // InPlaceSubItemControl
    function InPlaceSubItemControlIsFlatItemText(const ADrawParams: TdxBarInPlaceSubItemControlDrawParams): Boolean; override;
    function InPlaceSubItemControlIsArrowSelected(const ADrawParams: TdxBarInPlaceSubItemControlDrawParams): Boolean; override;
  end;

  TdxBarOffice11Painter = class(TdxBarFlatPainter)
  protected
    // Common
    procedure DrawGlyphBorder(ABarItemControl: TdxBarItemControl; DC: HDC; ABrush: HBRUSH;
      NeedBorder: Boolean; R: TRect; PaintType: TdxBarPaintType; IsGlyphEmpty,
      Selected, Down, DrawDowned, ADroppedDown, IsSplit: Boolean); override;
    class procedure DrawItemArrow(DC: HDC; R: TRect; AScaleFactor: TdxScaleFactor;
      ArrowType: TcxArrowDirection; Enabled, Selected, Flat: Boolean; AColor: TColor = clDefault); override;
    procedure DrawLargeItemArrow(DC: HDC; R: TRect; ArrowType: TcxArrowDirection;
      Size: Integer; Selected, Enabled, Flat: Boolean; AColor: TColor = clDefault); override;
    class procedure DrawFrameRect(ABarItemControl: TdxBarItemControl; ADC: HDC;
      const ARect: TRect; ABrush: HBRUSH; APaintType: TdxBarPaintType; ASelected, ADowned: Boolean); override;
    class procedure FrameFlatSelRect(DC: HDC; const R: TRect); override;
    class function GetBarGradientRect(ABarControl: TCustomdxBarControl): TRect;
    class procedure GetDockColors(ADockControl: TdxDockControl; var AColor1, AColor2: TColor);
    class procedure GetMarkColors(ABarControl: TdxBarControl; var AMarkColor1, AMarkColor2, AColor6, AColor9: TColor);
    class procedure GetSelectedColors(ABarItemControl: TdxBarItemControl;
      ADown, ASelected: Boolean; var AColor1, AColor2: TColor);
    class function GetToolbarBrush(ABarItemControl: TdxBarItemControl): HBRUSH; override;

    function GetDefaultEnabledTextColor(ABarItemControl: TdxBarItemControl;
      ASelected, AFlat: Boolean): TColor; override;
    procedure GetDisabledTextColors(ABarItemControl: TdxBarItemControl;
      ASelected, AFlat: Boolean; var AColor1, AColor2: TColor); override;

    class function GetFaded(ABarControl: TCustomdxBarControl): Boolean; override;
    class function IgnoreNonRecentColor: Boolean; override;
    class function IsMenuGradient(ABarItemControl: TdxBarItemControl): Boolean;
    class function IsSimpleMark(ABarControl: TdxBarControl): Boolean;
    // Bar
    class function BarCaptionBkColor(ABarControl: TdxBarControl; AMainFormActive: Boolean): COLORREF; override;
    function BarCaptionColor(ABarControl: TdxBarControl): COLORREF; override;
    class function BarMarkArrowColor(ABarControl: TdxBarControl; AState: TdxBarMarkState): COLORREF; override;
    class procedure BarDrawFingerElements(ABarControl: TCustomdxBarControl; DC: HDC;
      ARect: TRect; AHorizontal: Boolean); virtual;
    procedure BarDrawMarkBackground(ABarControl: TdxBarControl; DC: HDC;
      ItemRect: TRect; AToolbarBrush: HBRUSH); override;
    procedure BarDrawMarkElements(ABarControl: TdxBarControl; DC: HDC;
      ItemRect: TRect); override;
    // SubMenuControl
      // Sizes
    function SubMenuControlMarkBorderSize: Integer;
    function SubMenuControlMarkContentRect(const ADrawRect: TRect): TRect;
      // Draw
    procedure SubMenuControlDrawMarkContent(ABarSubMenuControl: TdxBarSubMenuControl;
      DC: HDC; R: TRect; ASelected: Boolean); override;
    // SysPanel
    function GetLookAndFeelPainter: TcxCustomLookAndFeelPainter; override;
  public
    // Common
    procedure DrawItemBackgroundInSubMenu(const ADrawParams: TdxBarButtonLikeControlDrawParams; R: TRect); override;
    class procedure FrameAndFillRect(ABarItemControl: TdxBarItemControl; DC: HDC;
      var R: TRect; Enabled, Selected, Pressed: Boolean); override;
    class function IsFlatGlyphImage: Boolean; override;
    class function IsGlyphImageHasShadow: Boolean; override;
    class function IsItemTextSelectedInverted: Boolean; override;
    class function StaticBorderBrush(ABarItemControl: TdxBarItemControl;
      ABorderStyle: TdxBarStaticBorderStyle): HBRUSH; override;
    // BarManager
    function BeforeFingersSize: Integer; override;
    class function BorderSizeX(AScaleFactor: TdxScaleFactor): Integer; override;
    class function BorderSizeY(AScaleFactor: TdxScaleFactor): Integer; override;
    class function EmptyFingersSize: Integer; override;
    // DockControl
    procedure DockControlFillBackground(ADockControl: TdxDockControl;
      DC: HDC; ADestR, ASourceR, AWholeR: TRect; ABrush: HBRUSH; AColor: TColor); override;
    class function IsNativeBackground: Boolean; override;
    // CustomBar
    class function BarControlOwnerBrush(ABarManager: TdxBarManager): HBRUSH; override;
    class procedure BarDrawBarControlOwnerFrame(ACustomBarControl: TCustomdxBarControl;
      DC: HDC; R: TRect); override;
    class procedure BarDrawBarControlOwnerLink(ACustomBarControl: TCustomdxBarControl;
      DC: HDC; R, ALinkR: TRect; ABarItemControl: TdxBarItemControl); override;
    procedure BarDrawDockedBackground(ABarControl: TdxBarControl; DC: HDC;
      ADestR, ASourceR: TRect; ABrush: HBRUSH; AColor: TColor); override;
    procedure BarDrawFloatingBackground(ABarControl: TCustomdxBarControl; DC: HDC;
      ADestR, ASourceR: TRect; ABrush: HBRUSH; AColor: TColor); override;
    class procedure BarDrawOwnerLink(ABarControl: TCustomdxBarControl; DC: HDC); override;
    function BarHasShadow(ABarControl: TCustomdxBarControl): Boolean; override;
    class function BarToolbarBrush(ABarControl: TCustomdxBarControl): HBRUSH; override;
    class function BarToolbarBrushEx(ABarControl: TdxBarControl): HBRUSH; override;
    class function BarToolbarDownedBrush(ABarControl: TCustomdxBarControl): HBRUSH; override;
    class function BarToolbarDownedSelBrush(ABarControl: TCustomdxBarControl): HBRUSH; override;
    class function BarToolbarSelBrush(ABarControl: TCustomdxBarControl): HBRUSH; override;
    function ComboBoxArrowWidth(ABarControl: TCustomdxBarControl; cX: Integer): Integer; override;
    // Bar
    class function BarBeforeFingersIndent: Integer; virtual;
    procedure BarBorderPaintSizes(ABarControl: TdxBarControl; var R: TRect); override;
    procedure BarBorderSizes(ABar: TdxBar; AStyle: TdxBarDockingStyle; var R: TRect); override;
    procedure BarDrawBeginGroup(ABarControl: TCustomdxBarControl; DC: HDC;
      ABeginGroupRect: TRect; AToolbarBrush: HBRUSH; AHorz: Boolean); override;
    class procedure BarDrawCaptionElement(ABarControl: TdxBarControl; DC: HDC;
      R: TRect; AState: TdxBarMarkState); override;
    procedure BarDrawDockedBarBorder(ABarControl: TdxBarControl; DC: HDC; R: TRect;
      AToolbarBrush: HBRUSH); override;
    procedure BarDrawFloatingBarBorder(ABarControl: TdxBarControl; DC: HDC;
      R, CR: TRect; AToolbarBrush: HBRUSH); override;
    procedure BarDrawFloatingBarCaption(ABarControl: TdxBarControl; DC: HDC;
      R, CR: TRect; AToolbarBrush: HBRUSH; AScaleFactor: TdxScaleFactor); override;
    function BarMarkRect(ABarControl: TdxBarControl): TRect; override;
    procedure BarMarkRectInvalidate(ABarControl: TdxBarControl); override;

    // SubMenuControl
      // Attributes
    class function SubMenuControlGetSeparatorColor: TColor; override;
    class function SubMenuControlToolbarItemsBrush(ABarSubMenuControl: TdxBarSubMenuControl): HBRUSH; override;
      // Conditions
    class function SubMenuControlHasBand: Boolean; override;
    class function SubMenuControlIsSingleMenuBorder(ABarSubMenuControl: TdxBarSubMenuControl): Boolean;
      // Positions
    class procedure SubMenuControlOffsetDetachCaptionRect(ABarSubMenuControl: TdxBarSubMenuControl; var R: TRect); override;
      // Sizes
    procedure SubMenuControlCalcDrawingConsts(ACanvas: TcxCanvas; ATextSize: Integer;
      AScaleFactor: TdxScaleFactor; out AMenuArrowWidth, AMarkSize: Integer); override;
    class function SubMenuControlDetachCaptionAreaSize(ABarSubMenuControl: TdxBarSubMenuControl): Integer; override;
      // Draw
    procedure SubMenuControlDrawBackground(ABarSubMenuControl: TdxBarSubMenuControl;
      ACanvas: TcxCanvas; ARect: TRect; ABrush: HBRUSH; AColor: TColor); override;
    procedure SubMenuControlDrawBorder(ABarSubMenuControl: TdxBarSubMenuControl;
      DC: HDC; R: TRect); override;
    procedure SubMenuControlDrawClientBorder(ABarSubMenuControl: TdxBarSubMenuControl;
      DC: HDC; const R: TRect; ABrush: HBRUSH); override;
    procedure SubMenuControlDrawDetachCaption(ABarSubMenuControl: TdxBarSubMenuControl;
      DC: HDC; R: TRect); override;

    // DropDownListBox
    procedure DropDownListBoxDrawBorder(DC: HDC; AColor: TColor; ARect: TRect); override;
    // QuickCustItem
    class function BarToolbarBrushEx2(ABarControl: TdxBarControl): HBRUSH; override;
    class procedure DrawQuickCustItemFrameSelected(ABarItemControl: TdxBarItemControl;
      DC: HDC; WholeR, R: TRect; Selected: Boolean); override;

    // Button Control
    function ButtonControlArrowBrush(const ADrawParams: TdxBarItemControlDrawParams): HBRUSH; override;

    // EditButton
      // Conditions
    function EditButtonIsCustomBackground(AState: Integer): Boolean; override;
      // Draw
    procedure EditButtonDrawBackground(const ADrawParams: TdxBarEditLikeControlDrawParams; AState: Integer;
      ARect: TRect; ABrush: HBrush); override;

    // EditControl
    class function EditControlBorderOffsets(APaintType: TdxBarPaintType): TRect; override;
    procedure EditControlDrawBorder(const ADrawParams: TdxBarEditLikeControlDrawParams; var ARect: TRect); override;
    class function EditControlCaptionBackgroundIsOpaque(const ADrawParams: TdxBarEditLikeControlDrawParams): Boolean; override;
      // Select EditControl indents
    class function EditControlCaptionSimpleIndent(const ADrawParams: TdxBarEditLikeControlDrawParams): Integer; override;
    class function EditControlSubMenuGlyphIndents(const ADrawParams: TdxBarEditLikeControlDrawParams): TRect; override;
    class function EditControlCaptionRightIndentIsOpaque(const ADrawParams: TdxBarEditLikeControlDrawParams): Boolean; override;
    class function EditControlShowIconDefault(const ADrawParams: TdxBarEditLikeControlDrawParams): Boolean; override;

    // ComboControl
      // Attributes
    function ComboControlArrowColor(ADrawParams: TdxBarItemControlDrawParams): TColor; override;
    function ComboControlButtonBrush(const ADrawParams: TdxBarItemControlDrawParams): HBRUSH; override;
      // Draw
    class procedure ComboControlDrawSimpleButton(const ADrawParams: TdxBarEditLikeControlDrawParams; var ARect: TRect; ABrush: HBRUSH); override;

    // ProgressControl
    class function ProgressControlIndent(const ADrawParams: TdxBarItemControlDrawParams): Integer; override;
    // DateNavigator
    procedure DateNavigatorDrawButton(ABarItem: TdxBarItem; DC: HDC; R: TRect;
      const ACaption: string; APressed: Boolean; AScaleFactor: TdxScaleFactor); override;
    function DateNavigatorHeaderColor: TColor; override;
    // InPlaceSubItemControl
    class function InPlaceSubItemControlBrush: HBRUSH; override;
    // Edit
    function EditGetDisabledBkColor(ABarItemControl: TdxBarCustomEditControl): COLORREF; override;
    function EditGetDisabledTextColor: COLORREF; override;
    // Separator
    procedure DrawSeparatorGlyphAndCaption(const ADrawParams: TdxBarSeparatorControlDrawParams; const ARect: TRect); override;
  end;

  { TdxBarXPPainter }

  TdxBarXPPainter = class(TdxBarPainter, IdxFadingPainterHelper)
  private
    class var FSelectedItemBrush: HBRUSH;

    procedure BarBeginGroupSizeInit;
    procedure BarCloseButtonSizeInit;
    procedure ButtonBorderHeightInit;
    procedure ComboBoxArrowWidthInit;
    procedure EditControlBorderOffsetsInit;
    class function GetSelectedItemBrush: HBRUSH;
    procedure GripperSizeInit;
    procedure InitParams;
    procedure ProgressControlBarHeightInit;
    procedure StatusBarGripSizeInit;
    procedure SubMenuControlBeginGroupSizeInit;

    class procedure InternalDrawBarGripSize(ACanvas: TcxCanvas; const ARect: TRect);
    class function IsArrowButtonDowned(APaintStyle: TdxBarPaintType; AIsPressed: Boolean): Boolean;
  protected
    class function NeedDoubleBuffer: Boolean; override;

    // IdxFadingPainterHelper
    function BarMarkIsOpaque: Boolean;
    procedure DrawBarMarkState(ABarControl: TdxBarControl; DC: HDC; const R: TRect; AState: TdxBarMarkState);
    procedure DrawButtonBackground(const ADrawParams: TdxBarButtonLikeControlDrawParams);

    // Common
    procedure DrawGlyphBorder(ABarItemControl: TdxBarItemControl; DC: HDC; ABrush: HBRUSH;
      NeedBorder: Boolean; R: TRect; PaintType: TdxBarPaintType; IsGlyphEmpty,
      Selected, Down, DrawDowned, ADroppedDown, IsSplit: Boolean); override;
    procedure DrawGlyphCheckMark(ABarItemControl: TdxBarItemControl; DC: HDC; X, Y, DoubleSize: Integer); override;
    class function GetFaded(ABarControl: TCustomdxBarControl): Boolean; override;
    class function IsMenuItem(ABarItemControl: TdxBarItemControl): Boolean; override;
    // Bar
    class procedure BarDrawNativeGrip(ABarControl: TdxBarControl; DC: HDC; R: TRect;
      AToolbarBrush: HBRUSH);
    procedure BarDrawMarkBackground(ABarControl: TdxBarControl; DC: HDC; ItemRect: TRect; AToolbarBrush: HBRUSH); override;
    class procedure BarOffsetFloatingBarCaption(ABarControl: TdxBarControl; var X: Integer; var R: TRect); override;

    // ColorCombo
      // Draw
    procedure DrawDot(const ADrawParams: TdxBarEditLikeControlDrawParams; ARect: TRect); override;
    // SysPanel
    function GetDefaultEnabledTextColor(ABarItemControl: TdxBarItemControl; ASelected, AFlat: Boolean): TColor; override;
    procedure GetDisabledTextColors(ABarItemControl: TdxBarItemControl; ASelected, AFlat: Boolean;
      var AColor1, AColor2: TColor); override;
    function GetLookAndFeelPainter: TcxCustomLookAndFeelPainter; override;
  public
    constructor Create(AData: TdxNativeUInt); override;

    class destructor Finalize;
    // Common
    procedure DrawItemBackgroundInSubMenu(const ADrawParams: TdxBarButtonLikeControlDrawParams; R: TRect); override;
    class function GlyphBkgndBrush(ABarItemControl: TdxBarItemControl;
      APaintType: TdxBarPaintType; AGlyphEmpty, ASelected, ADowned, ADrawDowned, ADroppedDown,
      AForceUseBkBrush, AGrayScale: Boolean): HBRUSH; override;
    class function GlyphDownShift(ABarItemControl: TdxBarItemControl): Integer; override;
    class function GlyphDrawDownedShift(ABarItemControl: TdxBarItemControl; ADown: Boolean): Integer; override;
    class function IsFlatGlyphImage: Boolean; override;
    // BarManager
    function BeforeFingersSize: Integer; override;
    function FingersSize(ABarControl: TdxBarControl): Integer; override;
    function GripperSize(ABarControl: TdxBarControl): Integer; override;
    class function RealButtonArrowWidth(ABarManager: TdxBarManager): Integer; override;
    class function RealLargeButtonArrowWidth(ABarManager: TdxBarManager): Integer; override;
    // DockControl
    procedure DockControlFillBackground(ADockControl: TdxDockControl;
      DC: HDC; ADestR, ASourceR, AWholeR: TRect; ABrush: HBRUSH; AColor: TColor); override;
    class function IsNativeBackground: Boolean; override;
    // CustomBar
//    class function BarChildrenHaveShadows(ABarControl: TCustomdxBarControl): Boolean; override;
    class function BarToolbarBrush(ABarControl: TCustomdxBarControl): HBRUSH; override;
    class function BarToolbarBrushEx(ABarControl: TdxBarControl): HBRUSH; override;
    class function BarToolbarDownedBrush(ABarControl: TCustomdxBarControl): HBRUSH; override;
    class function BarToolbarDownedSelBrush(ABarControl: TCustomdxBarControl): HBRUSH; override;
    class function BarToolbarSelBrush(ABarControl: TCustomdxBarControl): HBRUSH; override;
    function ComboBoxArrowWidth(ABarControl: TCustomdxBarControl; cX: Integer): Integer; override;
    // Bar
    function BarBeginGroupSideSize: Integer; override;
    function BarBeginGroupSize: Integer; override;
    class function BarBorderSize: Integer; override;
    procedure BarCaptionFillBackground(ABarControl: TdxBarControl; DC: HDC;
      R: TRect; AToolbarBrush: HBRUSH); override;
    class function BarCaptionTransparent: Boolean; override;
    class function BarCloseButtonSize(AScaleFactor: TdxScaleFactor): TSize; override;
    procedure BarDrawBeginGroup(ABarControl: TCustomdxBarControl; DC: HDC;
      ABeginGroupRect: TRect; AToolbarBrush: HBRUSH; AHorz: Boolean); override;
    procedure BarDrawCloseButton(ABarControl: TdxBarControl; DC: HDC; R: TRect); override;
    procedure BarDrawDockedBarBorder(ABarControl: TdxBarControl; DC: HDC; R: TRect; AToolbarBrush: HBRUSH); override;
    procedure BarDrawFloatingBarBorder(ABarControl: TdxBarControl; DC: HDC;
      R, CR: TRect; AToolbarBrush: HBRUSH); override;
    procedure BarDrawMDIButton(ABarControl: TdxBarControl; AButton: TdxBarMDIButton;
      AState: Integer; DC: HDC; R: TRect); override;
    class procedure StatusBarFillNativeBackground(ABarControl: TdxBarControl; DC: HDC;
      ADestR, ASourceR, AWholeR: TRect; ABrush: HBRUSH; AColor: TColor);
    class function StatusBarNativeGripSize(ABarManager: TdxBarManager): TSize;

    // QuickCustItem
    class function IsQuickControlPopupOnRight: Boolean; override;

    // ButtonControl
      // Conditions
    function IsButtonControlArrowFlat: Boolean; override;
      // Sizes
    function GetButtonBorderHeight(AScaleFactor: TdxScaleFactor): Integer; override;
    function GetButtonBorderWidth(AScaleFactor: TdxScaleFactor): Integer; override;
    class procedure CorrectButtonControlDefaultHeight(var DefaultHeight: Integer); override;
      // Draw
    procedure DrawButtonControlArrow(const ADrawParams: TdxBarButtonLikeControlDrawParams; R1: TRect); override;
    procedure DrawButtonControlArrowBackground(const ADrawParams: TdxBarButtonLikeControlDrawParams;
      var R1: TRect; ABrush: HBRUSH); override;

    // EditControl
    class function EditControlBorderOffsets(APaintType: TdxBarPaintType): TRect; override;
    procedure EditControlDrawBorder(const ADrawParams: TdxBarEditLikeControlDrawParams; var ARect: TRect); override;
    class function EditControlCaptionRightIndentIsOpaque(const ADrawParams: TdxBarEditLikeControlDrawParams): Boolean; override;
      // Select EditControl indents
    class function EditControlCaptionSimpleIndent(const ADrawParams: TdxBarEditLikeControlDrawParams): Integer; override;
    class function EditControlCaptionComplexIndent(const ADrawParams: TdxBarEditLikeControlDrawParams): Integer; override;
    class function EditControlSubMenuGlyphIndents(const ADrawParams: TdxBarEditLikeControlDrawParams): TRect; override;

    class function EditControlGetRightCaptionIndentBrush(ABarEditControl: TdxBarCustomEditControl): HBRUSH; override;
    // CustomCombo
    class procedure CustomComboDrawItem(ABarCustomCombo: TdxBarCustomCombo;
      ACanvas: TCanvas; AIndex: Integer; ARect: TRect; AState: TOwnerDrawState;
      AInteriorIsDrawing: Boolean); override;

    // ComboControl
      // Sizes
    class function ComboControlArrowOffset: Integer; override;
      // Draw
    procedure ComboControlDrawArrowButton(const ADrawParams: TdxBarEditLikeControlDrawParams;
      ARect: TRect; AInClientArea: Boolean); override;

    // SubMenuControl
      // Sizes
    class function SubMenuControlArrowsOffset: Integer; override;
    function SubMenuControlBeginGroupRect(
      ABarSubMenuControl: TdxBarSubMenuControl; AControl: TdxBarItemControl;
      const AItemRect: TRect): TRect; override;
    function SubMenuControlBeginGroupSize: Integer; override;
    class function SubMenuControlDetachCaptionAreaSize(ABarSubMenuControl: TdxBarSubMenuControl): Integer; override;
      // Draw
    procedure SubMenuControlDrawBeginGroup(ABarSubMenuControl: TdxBarSubMenuControl;
      AControl: TdxBarItemControl; ACanvas: TcxCanvas; const ABeginGroupRect: TRect); override;
    procedure SubMenuControlDrawSeparator(ACanvas: TcxCanvas; const ARect: TRect); override;
    procedure SubMenuControlDrawBorder(ABarSubMenuControl: TdxBarSubMenuControl;
      DC: HDC; R: TRect); override;
    procedure SubMenuControlDrawClientBorder(ABarSubMenuControl: TdxBarSubMenuControl;
      DC: HDC; const R: TRect; ABrush: HBRUSH); override;
    class procedure SubMenuControlOffsetDetachCaptionRect(ABarSubMenuControl: TdxBarSubMenuControl; var R: TRect); override;
    class function SubMenuControlToolbarItemsBrush(ABarSubMenuControl: TdxBarSubMenuControl): HBRUSH; override;

    // ColorCombo
      // Sizes
    function GetDotSpaceAfter(ADotWidth: Integer): Integer; override;
    function GetCustomColorButtonIndents(APaintType: TdxBarPaintType): TRect; override;
      // Draw
    procedure ColorComboDrawCustomButton(const ADrawParams: TdxBarColorComboControlDrawParams; ARect: TRect); override;
    procedure ColorComboDrawCustomButtonAdjacentZone(const ADrawParams: TdxBarColorComboControlDrawParams; ARect: TRect); override;

    // DateNavigator
    class function IsDateNavigatorFlat: Boolean; override;
    class procedure DateNavigatorDrawNativeButton(ABarItem: TdxBarItem;
      DC: HDC; R: TRect; const ACaption: string; APressed: Boolean);
    procedure DateNavigatorDrawButton(ABarItem: TdxBarItem; DC: HDC; R: TRect;
      const ACaption: string; APressed: Boolean; AScaleFactor: TdxScaleFactor); override;
    class function SysPanelSize(AScaleFactor: TdxScaleFactor): Integer; override;
    // SpinEditControl
    procedure SpinEditControlDrawButton(const ADrawParams: TdxBarSpinEditDrawParams; ARect: TRect; AButtonIndex: Integer); override;
    function GetSpinEditButtonIndents(APaintType: TdxBarPaintType): TRect; override;
    // ProgressControl
      // Attributes
    class function ProgressControlBarBrushColor: TColorRef; override;
      // Sizes
    function ProgressControlBarHeight(ABarItemControl: TdxBarItemControl): Integer; override;
      // Draw
    procedure ProgressControlDrawBackground(const ADrawParams: TdxBarItemControlDrawParams; var BarR: TRect); override;
    procedure ProgressControlDrawChunks(const ADrawParams: TdxBarItemControlDrawParams; BarR: TRect; ABarBrush: HBRUSH); override;
    // Edit
    function EditGetEnabledBkColor(ABarItemControl: TdxBarCustomEditControl): COLORREF; override;
    function EditGetDisabledBkColor(ABarItemControl: TdxBarCustomEditControl): COLORREF; override;
    function EditGetEnabledTextColor: COLORREF; override;
    function EditGetDisabledTextColor: COLORREF; override;
    // Separator
    function SubMenuGetSeparatorSize: Integer; override;
  end;

  { TdxBarSkinnedPainter }

  TdxBarSkinnedPainter = class(TdxBarOffice11Painter, IdxFadingPainterHelper, IdxFadingPainterHelper2)
  strict private
    FSkinnedObject: TObject;

    function GetSkin: IdxSkin;

    function GetArrowRect(const ADrawParams: TdxBarButtonLikeControlDrawParams; const ARect: TRect): TRect;
    function GetMenuButtonState(AEnabled, ASelected: Boolean): Integer;
    class function GetTextInsteadArrow(const ADrawParams: TdxBarItemControlDrawParams): string;

    class function GetMaxLineCount: Integer;
    procedure InternalDrawEditButton(const ADrawParams: TdxBarEditLikeControlDrawParams; APartIndex: Integer; ARect: TRect);
  protected
    // IdxFadingPainterHelper
    function BarMarkIsOpaque: Boolean;
    procedure DrawBarMarkState(ABarControl: TdxBarControl; DC: HDC; const R: TRect; AState: TdxBarMarkState); virtual;
    procedure DrawButtonBackground(const ADrawParams: TdxBarButtonLikeControlDrawParams); virtual;

    // Common
    function AllowLargeIcons: Boolean; override;
    procedure BarDrawMarkElements(ABarControl: TdxBarControl; DC: HDC; ItemRect: TRect); override;
    procedure DrawToolbarContentPart(ABarControl: TdxBarControl; ACanvas: TcxCanvas); override;
    procedure DrawToolbarNonContentPart(ABarControl: TdxBarControl; DC: HDC); override;
    procedure DrawToolbarNonContentPartCaption(ABarControl: TdxBarControl; DC: HDC); virtual;
    class function GetControlTextIndents: TRect; override;
    class function GetControlCaptionRectCore(const ADrawParams: TdxBarItemControlDrawParams): TRect; override;
    function SkinGetArrowID: Integer; virtual;
    function SkinGetMarkArrowID: Integer; virtual;
    function SkinGetTruncateMarkID: Integer; virtual;

    function GetDefaultEnabledTextColor(ABarItemControl: TdxBarItemControl; ASelected, AFlat: Boolean): TColor; override;
    procedure GetDisabledTextColors(ABarItemControl: TdxBarItemControl; ASelected, AFlat: Boolean; var AColor1, AColor2: TColor); override;

    function GetToolbarCaptionRect(ABarControl: TdxBarControl; const ARect: TRect): TRect; override;
    function GetToolbarSkinPart(ABarControl: TdxBarControl): Integer; virtual;
    procedure InflateSizeForArrow(const ADrawParams: TdxBarButtonLikeControlDrawParams; var ASize: Integer); override;
    class function IsCompoundPainting: Boolean; override;

    function GetButtonPartState(const ADrawParams: TdxBarButtonLikeControlDrawParams; AControlPart: Integer): Integer; virtual;
    class function GetEditPartState(const ADrawParams: TdxBarEditLikeControlDrawParams; AControlPart: Integer): Integer;
    class function GetSpinEditPartState(const ADrawParams: TdxBarSpinEditDrawParams; AControlPart: Integer): Integer;
    class function GetPartState(const ADrawParams: TdxBarItemControlDrawParams; AControlPart: Integer): Integer;
    class function GetTextPartState(const ADrawParams: TdxBarItemControlDrawParams): Integer;

    function GetBarControlState(ABarControl: TdxBarControl): Integer;

    //Hints
    function CreateHintViewInfo(ABarManager: TdxBarManager; AHintText: string;
      const AShortCut: string; AScreenTip: TdxScreenTip): TdxBarCustomHintViewInfo; override;
    function IsCustomHintSupported: Boolean; override;

    // ButtonLikeControl
    procedure DrawMultilineCaption(const ADrawParams: TdxBarItemControlDrawParams; const ATextRect: TRect);
    procedure ButtonLikeControlCorrectCaptionParams(const ADrawParams: TdxBarButtonLikeControlDrawParams;
      var ATextBounds: TRect; const AImageBounds: TRect; out ATextAlignment, AFormat: DWORD); override;
    procedure ButtonLikeControlDrawCaption(const ADrawParams: TdxBarButtonLikeControlDrawParams;
      const ATextBounds: TRect; ATextAlignment: DWORD; AFormat: DWORD = 0); override;
    procedure ButtonLikeControlDrawMenuArrow(const ADrawParams: TdxBarButtonLikeControlDrawParams;
      ADirection: TcxArrowDirection; ARect: TRect);
    class function GetGlyphLayout(const ADrawParams: TdxBarButtonLikeControlDrawParams): TdxBarGlyphLayout; override;
    // SpinEditControl
    procedure DrawSpinEditArrow(const ADrawParams: TdxBarSpinEditDrawParams; AArrowPos: TPoint; AButtonIndex: Integer); override;
    // SubMenuControl
    procedure SubMenuControlDrawMarkContent(ABarSubMenuControl: TdxBarSubMenuControl; DC: HDC; R: TRect; ASelected: Boolean); override;
    procedure SubMenuControlDrawMarkSelection(ABarSubMenuControl: TdxBarSubMenuControl; ADC: HDC; const AMarkRect: TRect); override;
    procedure SubMenuControlFillScrollArrow(ACanvas: TcxCanvas; ARect: TRect; AColor: TColor); override;
    function SubMenuControlGetScrollBandSize(ABarSubMenuControl: TdxBarSubMenuControl): Integer; override;

    class function SubMenuControlGetScrollArrowSize(ATextSize: Integer): Integer; override;
  public
    constructor Create(AData: TdxNativeUInt); override;

    procedure CalculateButtonParts(const ADrawParams: TdxBarButtonLikeControlDrawParams;
      var AParts: array of TRect; const AItemRect: TRect); override;
    procedure CalculateSpinEditParts(const ADrawParams: TdxBarSpinEditDrawParams;
      var AParts, AAreaParts: array of TRect); override;
    procedure DrawArrow(ADC: HDC; ARect: TRect; AArrowState: Integer; AScaleFactor: TdxScaleFactor); virtual;

    function GetGlyphState(ABarItemControl: TdxBarItemControl; ASelected, ADowned, ADrawDowned, ADroppedDown: Boolean): Integer; virtual;
    function GetGlyphColorPalette(ABarItemControl: TdxBarItemControl; APaintType: TdxBarPaintType;
      ASelected, ADowned, ADrawDowned, ADroppedDown, AIsSplit: Boolean): IdxColorPalette; overload; override; final;
    function GetGlyphColorPalette(ABarItemControl: TdxBarItemControl;
      APaintType: TdxBarPaintType; AState: Integer): IdxColorPalette; reintroduce; overload; virtual;

    // Common
      // Sizes
    function GetBorderSize: Integer; override;
    function GetIconAreaSize(ABarControl: TCustomdxBarControl): Integer; override;
    class function GetDefaultTextSize(ACanvas: TcxCanvas; AScaleFactor: TdxScaleFactor): Integer; override;
    function GetLargeImageBounds(AItemControl: TdxBarItemControl; const AImageSize: TSize;
      const ADrawRect: TRect; APaintType: TdxBarPaintType; AViewStructure: TdxBarItemControlViewStructure): TRect; override;

      // Draw
    procedure DrawItemBackgroundInSubMenu(const ADrawParams: TdxBarButtonLikeControlDrawParams; R: TRect); override;
    procedure DrawGlyphAndBkgnd(ABarItemControl: TdxBarItemControl; ADC: HDC; const R, AGlyphRect: TRect;
      APaintType: TdxBarPaintType; AGlyph: TdxSmartGlyph; AImages: TCustomImageList; AImageIndex: Integer;
      AGlyphEmpty, ASelected, ADowned, ADrawDowned, ADroppedDown, AForceUseBkBrush, AGrayScale, AIsSplit: Boolean;
      AEnabled: Boolean; AColorPalette: IdxColorPalette); override;
    function GetToolbarContentOffsets(ABar: TdxBar; ADockingStyle: TdxBarDockingStyle;
      AScaleFactor: TdxScaleFactor; AHasSizeGrip: Boolean): TRect; override;
    function GetToolbarsOffsetForAutoAlign: Integer; override;
    class function RealButtonArrowWidth(ABarManager: TdxBarManager): Integer; override;
    class function LoweredBorderSize(ABarItemControl: TdxBarItemControl): Integer; override;
    // Fading
    function GetBarItemControlFadingOptions: TdxFadingOptions; override;

    // CustomBar
    function BarLinkedOwnerHasShadow(ABarControl: TCustomdxBarControl): Boolean; override;
    procedure BarDrawBackground(ABarControl: TdxBarControl; ADC: HDC;
      const ADestRect, ASourceRect: TRect; ABrush: HBRUSH; AColor: TColor); override;
    procedure BarDrawDockedBackground(ABarControl: TdxBarControl; DC: HDC;
      ADestR, ASourceR: TRect; ABrush: HBRUSH; AColor: TColor); override;
    function ComboBoxArrowWidth(ABarControl: TCustomdxBarControl; cX: Integer): Integer; override;
    procedure SetWindowRgn(AHandle: THandle; const AWindowRect: TRect; ARedraw: Boolean = False); override;
    // Bar
    procedure BarDrawBeginGroup(ABarControl: TCustomdxBarControl; DC: HDC;
      ABeginGroupRect: TRect; AToolbarBrush: HBRUSH; AHorz: Boolean); override;
    // Sizes
    class function GetTailAreaSize(const ADrawParams: TdxBarItemControlDrawParams): Integer; override;

    // ButtonControl
      // Sizes
    class function GetDefaultArrowSignSize(AScaleFactor: TdxScaleFactor): TSize; override;
    function GetButtonBorderHeight(AScaleFactor: TdxScaleFactor): Integer; override;
    function GetButtonBorderWidth(AScaleFactor: TdxScaleFactor): Integer; override;
    function GetButtonHeight(AIconSize, ATextSize: Integer; AScaleFactor: TdxScaleFactor): Integer; override;
    function GetButtonWidth(AIconSize, ATextSize: Integer; AScaleFactor: TdxScaleFactor): Integer; override;
    function GetLargeButtonBorderHeight: Integer; override;
    function GetLargeButtonBorderWidth: Integer; override;
    class procedure CorrectButtonControlDefaultHeight(var DefaultHeight: Integer); override;
      // Draw
    procedure DrawBackButtonControlArrow(const ADrawParams: TdxBarButtonLikeControlDrawParams; ARect: TRect); override;
    procedure DrawButtonLikeControl(const ADrawParams: TdxBarButtonLikeControlDrawParams; ARect: TRect); override;
    procedure DrawButtonControlArrow(const ADrawParams: TdxBarButtonLikeControlDrawParams;
      R1: TRect); override;
    procedure DrawSplitControlArrow(const ADrawParams: TdxBarButtonLikeControlDrawParams; ARect: TRect); override;
    procedure DrawAssociateControlArrow(const ADrawParams: TdxBarButtonLikeControlDrawParams; ARect: TRect); override;

    // DropDownListBox
    procedure DropDownListBoxDrawBorder(DC: HDC; AColor: TColor; ARect: TRect); override;

    // SubMenuControl
      // Conditions
    class function SubMenuControlHasBand: Boolean; override;
      // Sizes
    class function SubMenuControlArrowWidth(ATextSize: Integer): Integer; override;
    function SubMenuControlBeginGroupSize: Integer; override;
    class function SubMenuControlNCBorderSize: Integer; override;
    class function SubMenuControlClientBorderSize: Integer; override;
    class function SubMenuControlDetachCaptionAreaSize(ABarSubMenuControl: TdxBarSubMenuControl): Integer; override;
    class function SubMenuControlGetBandSize(ABarSubMenuControl: TdxBarSubMenuControl): Integer; override;
    class function SubMenuControlNormalItemHeight(AScaleFactor: TdxScaleFactor): Integer; override;
    class function SubMenuControlTextIndent: Integer;
    class function SubMenuControlInternalBorderSize: Integer; override;
    class function SubMenuControlInternalBorderOffset: Integer; override;
    class function SubMenuControlTextSize(ACanvas: TcxCanvas; AScaleFactor: TdxScaleFactor): Integer; override;
      // Positions
    class function SubMenuControlGetItemIconRect(const AItemRect: TRect; AIconAreaSize: Integer): TRect; override;
    class function SubMenuControlGetItemTextIndent(const ADrawParams: TdxBarItemControlDrawParams): Integer; override;
      // Draw
    procedure SubMenuControlDrawScrollBandBackground(ABarSubMenuControl: TdxBarSubMenuControl; ACanvas: TcxCanvas; AArrowDirection: TcxArrowDirection); override;
    procedure SubMenuControlDrawScrollButton(ABarSubMenuControl: TdxBarSubMenuControl; ACanvas: TcxCanvas; AArrowDirection: TcxArrowDirection); override;
    procedure SubMenuControlDrawBackground(ABarSubMenuControl: TdxBarSubMenuControl;
      ACanvas: TcxCanvas; ARect: TRect; ABrush: HBRUSH; AColor: TColor); override;
    procedure SubMenuControlDrawBeginGroup(ABarSubMenuControl: TdxBarSubMenuControl;
      AControl: TdxBarItemControl; ACanvas: TcxCanvas; const ABeginGroupRect: TRect); override;
    procedure SubMenuControlDrawSeparator(ACanvas: TcxCanvas; const ARect: TRect); override;
    procedure SubMenuControlDrawBorder(ABarSubMenuControl: TdxBarSubMenuControl;
      DC: HDC; R: TRect); override;
    procedure SubMenuControlDrawClientBorder(ABarSubMenuControl: TdxBarSubMenuControl;
      DC: HDC; const R: TRect; ABrush: HBRUSH); override;
    procedure SubMenuControlDrawDetachCaption(ABarSubMenuControl: TdxBarSubMenuControl;
      DC: HDC; R: TRect); override;
    procedure SubMenuControlDrawItemBackground(ABarSubMenuControl: TdxBarSubMenuControl;
      ACanvas: TcxCanvas; AItemRect: TRect);

    // ApplicationMenu
      // Sizes
    function ApplicationMenuButtonTextColor(AEnabled, ASelected: Boolean): TColor; override;
    function ApplicationMenuContentButtonOffsets: TRect; override;
    function ApplicationMenuGetFrameSizes: TRect; override;
      // Draw
    procedure ApplicationMenuDrawBackground(ABarSubMenuControl: TdxBarSubMenuControl;
      ACanvas: TcxCanvas; const R, AItemsArea: TRect); override;
    procedure ApplicationMenuDrawButton(const ADrawParams: TdxBarApplicationMenuButtonControlDrawParams; var R: TRect); override;

    // ExtraMenuControl
    function ExtraMenuButtonTextColor(AEnabled, ASelected: Boolean): TColor; override;
    procedure ExtraMenuControlDrawBackground(AExtraMenuControl: TCustomdxBarControl;
      ACanvas: TcxCanvas; ARect: TRect; ABrush: HBRUSH; AColor: TColor); override;
    procedure ExtraMenuControlDrawBeginGroup(AExtraMenuControl: TCustomdxBarControl;
      ACanvas: TcxCanvas; ABeginGroupRect: TRect; AToolbarBrush: HBRUSH; AHorz: Boolean); override;
    procedure ExtraMenuControlDrawItemBackground(AExtraMenuControl: TCustomdxBarControl;
      ACanvas: TcxCanvas; AItemRect: TRect);
    procedure ExtraMenuDrawButton(ADrawParams: TdxBarExtraMenuButtonControlDrawParams; const ARect: TRect); override;
    procedure ExtraMenuDrawPinButton(ADrawParams: TdxBarExtraMenuButtonControlDrawParams; const ARect: TRect); virtual;
    function ExtraMenuHeaderTextColor: TColor; override;
    function ExtraMenuPinButtonSize: Integer; override;

    // EditButton
      // Conditions
    function EditButtonAllowOffsetContent: Boolean; override;
    function EditButtonAllowCompositeFrame: Boolean; override;
    class function EditButtonAllowHotTrack(const ADrawParams: TdxBarItemControlDrawParams): Boolean; override;
    function EditButtonIsCustomBorder: Boolean; override;
    function EditButtonIsCustomBackground(AState: Integer): Boolean; override;
      // Sizes
    procedure EditButtonCorrectDefaultWidth(var ADefaultWidth: Integer); override;
      // Draw
    procedure EditButtonDrawBackground(const ADrawParams: TdxBarEditLikeControlDrawParams; AState: Integer;
      ARect: TRect; ABrush: HBrush); override;
    procedure EditButtonDrawBorder(const ADrawParams: TdxBarItemControlDrawParams;
      AState: Integer; var ADrawRect: TRect; out AContentRect: TRect); override;

    // EditControl
    class function EditControlCaptionBackgroundIsOpaque(const ADrawParams: TdxBarEditLikeControlDrawParams): Boolean; override;
    class function EditControlCaptionRightIndentIsOpaque(const ADrawParams: TdxBarEditLikeControlDrawParams): Boolean; override;
    procedure EditControlDrawBorder(const ADrawParams: TdxBarEditLikeControlDrawParams; var ARect: TRect); override;
    procedure EditControlDrawCaption(const ADrawParams: TdxBarEditLikeControlDrawParams); override;
    procedure EditControlDrawSelectionFrame(const ADrawParams: TdxBarEditLikeControlDrawParams; const ARect: TRect); override;
    procedure EditControlDrawBackground(const ADrawParams: TdxBarEditLikeControlDrawParams); override;
    function EditGetEnabledTextColor: Cardinal; override;
    function EditGetDisabledTextColor: Cardinal; override;
    function EditGetBkColor(const ADrawParams: TdxBarEditLikeControlDrawParams): COLORREF; override;
    procedure EditGetRealLookAndFeel(ABarManager: TdxBarManager; ALookAndFeel: TcxLookAndFeel); override;
    class function EditControlShowIconDefault(const ADrawParams: TdxBarEditLikeControlDrawParams): Boolean; override;

    // ComboControl
      // Sizes
    class function ComboControlArrowOffset: Integer; override;
    class function ComboControlButtonOffsets(APaintType: TdxBarPaintType): TRect; override;
      // Draw
    procedure ComboControlDrawArrowButton(const ADrawParams: TdxBarEditLikeControlDrawParams;
      ARect: TRect; AInClientArea: Boolean); override;

    // ColorCombo
      // Conditions
    function ColorComboHasCompleteFrame: Boolean; override;
      // Sizes
    function GetCustomColorButtonWidth(APaintType: TdxBarPaintType; const ARect: TRect): Integer; override;
    function GetCustomColorButtonIndents(APaintType: TdxBarPaintType): TRect; override;
      // Draw
    procedure ColorComboDrawCustomButton(const ADrawParams: TdxBarColorComboControlDrawParams; ARect: TRect); override;
    procedure ColorComboDrawCustomButtonAdjacentZone(const ADrawParams: TdxBarColorComboControlDrawParams; ARect: TRect); override;

    // DateNavigator
    function DateNavigatorHeaderColor: TColor; override;
    // InPlaceSubItemControl
      //Sizes
    class function InPlaceSubItemGetArrowWidth(const ADrawParams: TdxBarInPlaceSubItemControlDrawParams): Integer; override;
      //Draw
    procedure InPlaceSubItemControlDrawArrow(const ADrawParams: TdxBarInPlaceSubItemControlDrawParams;
      ADirection: TcxArrowDirection; ARect: TRect); override;
    procedure InPlaceSubItemControlDrawBackground(const ADrawParams: TdxBarInPlaceSubItemControlDrawParams; ARect: TRect); override;
    // ProgressControl
      // Conditions
    function CanUpdateBarPartly: Boolean; override;
      // Draw
    procedure ProgressControlDrawBackground(const ADrawParams: TdxBarItemControlDrawParams; var R: TRect); override;
    procedure ProgressControlFillContent(const ADrawParams: TdxBarItemControlDrawParams; const R: TRect; ABarBrush: HBRUSH); override;
    procedure ProgressControlFillDiscreteContent(const ADrawParams: TdxBarItemControlDrawParams; const R: TRect; ABarBrush: HBRUSH); override;
    // SpinEditControl
    function GetSpinEditArrowPos(const ADrawParams: TdxBarSpinEditDrawParams; ARect: TRect; AButtonIndex: Integer): TPoint; override;
    procedure SpinEditCorrectFrameRect(const ADrawParams: TdxBarItemControlDrawParams; var ARect: TRect); override;
    function GetSpinEditArrowSize(AHeight: Integer): TSize; override;
    function GetSpinEditButtonBounds(const ADrawParams: TdxBarSpinEditDrawParams; const ARect: TRect; AButton: TdxBarSpinEditButton): TRect; override;
    procedure SpinEditControlDrawButton(const ADrawParams: TdxBarSpinEditDrawParams; ARect: TRect; AButtonIndex: Integer); override;
    procedure SpinEditControlDrawButtonsAdjacentZone(const ADrawParams: TdxBarSpinEditDrawParams; const ARect: TRect); override;
    procedure SpinEditControlDrawButtonsExternalFrame(const ADrawParams: TdxBarSpinEditDrawParams; ARect: TRect);
    function GetSpinEditButtonIndents(APaintType: TdxBarPaintType): TRect; override;
    function GetSpinEditButtonWidth(APaintType: TdxBarPaintType; const ARect: TRect): Integer; override;
    // Static
    procedure DrawStaticBorder(const ADrawParams: TdxBarStaticLikeControlDrawParams; var ARect: TRect); override;
    class function StaticBackgroundIsOpaque(const ADrawParams: TdxBarItemControlDrawParams): Boolean; override;
    // Separator
    procedure SeparatorControlGetTextColors(ABarItemControl: TdxBarItemControl;
      AEnabled, ASelected, AFlat: Boolean; var AColor1, AColor2: TColor); override;
    function SeparatorControlSeparatorSize: Integer; override;
    procedure DrawSeparatorControlLine(ACanvas: TcxCanvas; const R: TRect); override;
    procedure DrawSeparatorGlyphAndCaption(const ADrawParams: TdxBarSeparatorControlDrawParams; const ARect: TRect); override;

    // Gallery
    procedure DropDownGalleryDrawBackground(DC: HDC; const R: TRect); override;
    procedure DropDownGalleryDrawBorder(ABarSubMenuControl: TdxBarSubMenuControl; DC: HDC; const R: TRect); override;
    procedure DropDownGalleryDrawBottomSizeGrip(DC: HDC; const R: TRect); override;
    procedure DropDownGalleryDrawBottomSizeGripEx(ABarSubMenuControl: TdxBarSubMenuControl; DC: HDC; const R: TRect); override;
    procedure DropDownGalleryDrawBottomSizingBand(DC: HDC; const R: TRect); override;
    procedure DropDownGalleryDrawBottomVerticalSizeGrip(DC: HDC; const R: TRect); override;
    procedure DropDownGalleryDrawFilterBand(DC: HDC; const R: TRect); override;
    procedure DropDownGalleryDrawGroupHeaderBackground(DC: HDC; const R: TRect); override;
    procedure DropDownGalleryDrawItem(DC: HDC; const R: TRect; AState: Integer; AScaleFactor: TdxScaleFactor); override;
    procedure DropDownGalleryDrawScrollBarBackground(DC: HDC; const R: TRect; AScaleFactor: TdxScaleFactor); override;
    procedure DropDownGalleryDrawScrollBarBackgroundEx(ABarSubItemControl: TdxBarSubItemControl; DC: HDC;
      const R: TRect; AScaleFactor: TdxScaleFactor); override;
    procedure DropDownGalleryDrawScrollBarPartEx(ABarSubItemControl: TdxBarSubItemControl; DC: HDC; const R: TRect;
      APart: TcxScrollBarPart; AState: TcxButtonState; AScaleFactor: TdxScaleFactor); override;
    procedure DropDownGalleryDrawSelectionFrame(ACanvas: TcxCanvas; const R: TRect; AState: Integer); override;
    procedure DropDownGalleryDrawTopSizeGrip(DC: HDC; const R: TRect); override;
    procedure DropDownGalleryDrawTopSizeGripEx(ABarSubMenuControl: TdxBarSubMenuControl; DC: HDC; const R: TRect); override;
    procedure DropDownGalleryDrawTopSizingBand(DC: HDC; const R: TRect); override;
    procedure DropDownGalleryDrawTopVerticalSizeGrip(DC: HDC; const R: TRect); override;
    procedure DropDownGalleryItemGetTextColors(ABarItemControl: TdxBarItemControl; AEnabled, ASelected, AFlat: Boolean; var AColor1, AColor2: TColor); override;
    function DropDownGalleryGetClientBorderSize: Integer; override;
    function DropDownGalleryGetContentOffsets(APart: Integer): TRect; override;
    function DropDownGalleryGetFilterBandSeparatorColor: TColor; override;
    function DropDownGalleryGetFilterBandTextColor(AState: Integer): TColor; override;
    function DropDownGalleryGetGroupHeaderTextColor: TColor; override;
    function DropDownGalleryGetName: string; override;
    function DropDownGalleryGetNCBorderSize: Integer; override;

    // ScreenTip
      // Draw
    function ScreenTipGetDescriptionTextColor: TColor; override;
    function ScreenTipGetTitleTextColor: TColor; override;
    procedure ScreenTipDrawBackground(ACanvas: TcxCanvas; ARect: TRect); override;
    procedure ScreenTipDrawFooterLine(ACanvas: TcxCanvas; const ARect: TRect); override;

    property Skin: IdxSkin read GetSkin;
    property SkinnedObject: TObject read FSkinnedObject;
  end;

  TRegItemRecord = class
  public
    FItemClass: TdxBarItemClass;
    FItemControlClass: TdxBarItemControlClass;
    FVisible: Boolean;
    constructor Create(AItemClass: TdxBarItemClass; AItemControlClass: TdxBarItemControlClass;
      AVisible: Boolean);
  end;

  TdxBarItemList = class(TList)
  private
    function GetItem(Index: Integer): TRegItemRecord;
    function GetItemClass(Index: Integer): TdxBarItemClass;
    function GetVisibleItemCount: Integer;
    function GetVisibleItemClass(Index: Integer): TdxBarItemClass;
  protected
    procedure Register(AItemClass: TdxBarItemClass;
      AItemControlClass: TdxBarItemControlClass; AVisible: Boolean);
    procedure Unregister(AItemClass: TdxBarItemClass); overload;
    procedure Unregister(Index: Integer); overload;
  public
    destructor Destroy; override;

    property Items[Index: Integer]: TRegItemRecord read GetItem; default;
    property ItemClass[Index: Integer]: TdxBarItemClass read GetItemClass;
    property VisibleItemCount: Integer read GetVisibleItemCount;
    property VisibleItemClass[Index: Integer]: TdxBarItemClass read GetVisibleItemClass;
  end;

  TdxBarManagerFormKind = (fkMain, fkMainOrMDIChild, fkAny);

  { TdxCustomQuickCustItemControl }

  TdxCustomQuickCustItemControl = class(TdxBarButtonControl)
  protected
    procedure DoPaint(ARect: TRect; PaintType: TdxBarPaintType); override;
    function GetDefaultWidth: Integer; override;
    function IsDowned: Boolean; virtual; abstract;
  end;

  { TdxBarQuickCustItem }

  TdxBarQuickCustItem = class(TdxBarCustomButton)
  public
    procedure DoClick; override;
  end;

  { TdxBarQuickCustItemControl }

  TdxBarQuickCustItemControl = class(TdxCustomQuickCustItemControl)
  private
    function GetLinkedItemLink: TdxBarItemLink;
  protected
    procedure ControlUnclick(ByMouse: Boolean); override;
    function GetCaption: string; override;
    function GetGlyph: TdxSmartGlyph; override;
    function GetImageIndex: Integer; override;
    function GetCurrentImages(AEnabled, AUseLargeImages: Boolean; var ADrawImageEnabled: TdxDefaultBoolean): TCustomImageList; override;
    function GetLargeGlyph: TdxSmartGlyph; override;
    function GetLargeImageIndex: Integer; override;
    function IsDowned: Boolean; override;
    function GetHint: string; override;
    function GetShortCut: TShortCut; override;
    function CanDestroyOnClick: Boolean; override;
    property LinkedItemLink: TdxBarItemLink read GetLinkedItemLink;
  end;

  { TdxBarPopupControl }

  TdxBarPopupControl = class(TdxBarControl)
  strict private
    FInternalBar: TdxBar;
    FMasterBar: TdxBar;
    FHidingTimer: TcxTimer;
    FInternalItems: TList;
    FOnCloseUp: TNotifyEvent;

    procedure HidingTimerHandler(Sender: TObject);
    procedure WMNCHitTest(var Message: TWMNCHitTest); message WM_NCHITTEST;
  protected
    procedure WindowPosChanged(var Message: TWMWindowPosChanged); override;

    function CanMoving: Boolean; override;
    function GetMasterBar: TdxBar; override;
    procedure DoBeforeCaptionButtonClick; override;
    procedure DoHideAll(AReason: TdxBarCloseUpReason); override;
    function IsInternal: Boolean; override;
    function IsPopup: Boolean; override;
    function HasCloseButton: Boolean; override;
    function NeedHideOnClick: Boolean; override;
    procedure SetLayeredAttributes; override;

    procedure InitializeForPopup(AParentBarControl: TdxBarControl; ABar: TdxBar); virtual;

    function AllowResize: Boolean; virtual;
    function GetPopupSize: TSize; virtual;
    function GetPopupPosition(const ASize: TSize; const AOwnerRect: TRect; APopupDirection: TXDirection): TPoint; virtual;
    procedure CorrectPopupPosition(var APosition: TPoint; const ASize: TSize; const AOwnerRect, AWorkArea: TRect); virtual;
    function LockHotTrackWhenPopup: Boolean; virtual;
    function IgnoreClickAreaWhenHidePopup: TRect; virtual;

    function AlwaysTrackMouse: Boolean; virtual;
    procedure TrackMouse; virtual;

    property InternalItems: TList read FInternalItems;
    property OnCloseUp: TNotifyEvent read FOnCloseUp write FOnCloseUp;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Hide; override;
    procedure CloseUp; virtual;
    procedure Popup(const AOwnerRect: TRect); virtual;
    procedure PopupEx(const AOwnerRect: TRect; APopupDirection: TXDirection);

    procedure StartHidingTimer;
  end;

  { TdxBarQuickControl }

  TdxBarQuickControl = class(TdxBarPopupControl)
  private
    function GetParentBar: TdxBarControl;
    procedure SetParentBar(Value: TdxBarControl);
    procedure WMNCPaint(var Message: TMessage); message WM_NCPAINT;
    procedure WMRButtonDown(var Message: TWMRButtonDown); message WM_RBUTTONDOWN;
  protected
    procedure InitializeForPopup(AParentBarControl: TdxBarControl; ABar: TdxBar); override;
    procedure Paint; override;

    function GetParentForm: TCustomForm; override;
    function GetPopupSize: TSize; override;
    function GetPopupPosition(const ASize: TSize; const AOwnerRect: TRect; APopupDirection: TXDirection): TPoint; override;
    procedure CorrectPopupPosition(var APosition: TPoint; const ASize: TSize; const AOwnerRect, AWorkArea: TRect); override;
    function GetToolbarBrush: HBRUSH; override;
    function HasCaption: Boolean; override;
    function IsLinkedToOwner: Boolean; override;
    function IsPopup: Boolean; override;
    function LockHotTrackWhenPopup: Boolean; override;
    function NeedShowGlyphAndCheckForItem: Boolean; override;
    function GetOwnerControl: TWinControl; override;

    property ParentBar: TdxBarControl read GetParentBar write SetParentBar;
  public
    function Kind: TdxBarKind; override;
    procedure Popup(const AOwnerRect: TRect); override;
  end;

  TdxBarKeyTipsShowingState = record
    ActiveContainer: IdxBarAccessibilityHelper;
    KeyTipsData: TdxObjectList;
    TypingString: string;
  end;

  { TdxBarNavigationController }

  TdxBarNavigationController = class
  private
    FHandleKey: Boolean;
    FKeyTipsShowingState: TdxBarKeyTipsShowingState;
    FKeyTipsWaitingRootObject: IdxBarAccessibilityHelper;
    FKeyTipsWaitingTimer: TcxTimer;
    FNavigationMode: Boolean;
    FSelectedObject: IdxBarAccessibilityHelper;
    FSelectedObjectParent: IdxBarAccessibilityHelper;
    FSingleMenuBackButton: TdxBarItem;
    FSingleMenuCaption: TdxBarItem;

    procedure DestroyKeyTipsWaitingTimer;
    function GetActiveBarControl: TCustomdxBarControl;
    function GetKeyFromKeyCode(AKey: Word): string;
    function GetKeyTipsHandlingMode: Boolean;
    function GetSelectedObject: IdxBarAccessibilityHelper;
    function GetSelectedObjectParent: IdxBarAccessibilityHelper;
    procedure HandleKeyTipKey(AKey: Word; AShift: TShiftState);
    function IsKeyTipsKey(AKey: Word; AShift: TShiftState; out AIsKeyAcceptable: Boolean; out AOnExecute: TNotifyEvent): Boolean; overload;
    function IsKeyTipsKey(AKey: Word; AShift: TShiftState; out AIsKeyAcceptable: Boolean): Boolean; overload;
    function IsNavigationControllerKey(AKey: Word): Boolean;
    procedure KeyTipsEscapeHandler;
    procedure KeyTipsWaitingTimerHandler(Sender: TObject);
    procedure StopKeyTipsHandlingMode;
  protected
    procedure ResetNavigationMode;
  public
    destructor Destroy; override;
    procedure BeginKeyTipsWaiting(ARootObject: IdxBarAccessibilityHelper);
    procedure ChangeSelectedObject(ASetFocus: Boolean; ANewSelectedObject: IdxBarAccessibilityHelper;
      APrevSelectedObject: IdxBarAccessibilityHelper = nil);
    procedure EndKeyTipsWaiting(AShowKeyTipWindows: Boolean);
    procedure HandleKey(AKey: Word; AShift: TShiftState; ASelectedObjectParent: IdxBarAccessibilityHelper = nil;
      ASelectedObject: IdxBarAccessibilityHelper = nil);
    function IsKeyTipsKey(AKey: Word; AShift: TShiftState): Boolean; overload;
    function IsKeyTipsWaiting: Boolean;
    function IsNavigationBarControl(ABarControl: TCustomdxBarControl): Boolean;
    function IsNavigationKey(AKey: Word): Boolean;
    function NeedsKey(AKey: Word; AShift: TShiftState): Boolean;
    procedure PrepareNewSingleMenuLevel(AItemLinks: TdxBarItemLinks; const AParentKind: TdxBarKind);
    procedure RestorePreviousSingleMenuLevel(AParentItemControl: TdxBarItemControl; const AParentKind: TdxBarKind);
    procedure SelectDefaultObject(ARootObject: IdxBarAccessibilityHelper);
    procedure SetKeyTipsShowingState(AActiveKeyTipContainer: IdxBarAccessibilityHelper; const AKeyTipsTypingString: string);
    procedure StopKeyboardHandling;
    procedure UnassignObject(AObject: IdxBarAccessibilityHelper);
    procedure UnselectAssignedSelectedObject;
    function UseSingleMenuWindowMode(AItemControl: TdxBarItemControl): Boolean;

    property ActiveKeyTipContainer: IdxBarAccessibilityHelper read FKeyTipsShowingState.ActiveContainer; // TODO Remove this property
    property AssignedSelectedObject: IdxBarAccessibilityHelper read FSelectedObject;
    property AssignedSelectedObjectParent: IdxBarAccessibilityHelper read FSelectedObjectParent;
    property KeyTipsHandlingMode: Boolean read GetKeyTipsHandlingMode;
    property NavigationMode: Boolean read FNavigationMode;
    property SelectedObject: IdxBarAccessibilityHelper read GetSelectedObject write FSelectedObject;
    property SelectedObjectParent: IdxBarAccessibilityHelper read GetSelectedObjectParent write FSelectedObjectParent;
  end;

procedure BarAccessibilityHelperOwnerObjectDestroyed(var AIHelper: IdxBarAccessibilityHelper);
function GetAccessibilityHelper(AObject: TObject): IdxBarAccessibilityHelper;
function GetKeyTipContainerParent(AContainer: IdxBarAccessibilityHelper): IdxBarAccessibilityHelper;
function GetNextAccessibleObject(ASelectedObject: TdxBarAccessibilityHelper; AObjects: TList;
  ADirection: TcxAccessibilityNavigationDirection; ACycleHorizontally: Boolean): TdxBarAccessibilityHelper;
function GetRootAccessibleObject(AParentWnd: HWND): IdxBarAccessibilityHelper;

function BarDesignController: TdxBarDesignController;
function BarNavigationController: TdxBarNavigationController;
function RegdxItemList: TdxBarItemList;
procedure dxBarRegisterItem(AItemClass: TdxBarItemClass; AItemControlClass: TdxBarItemControlClass; AVisible: Boolean);
procedure dxBarUnregisterItem(AItemClass: TdxBarItemClass);
procedure dxBarDesignerModified(ABarManager: TdxBarManager);
function dxBarCreateScreenTipViewInfo(ABarManager: TdxBarManager; AHintText: string; const
  AShortCut: string; AScreenTip: TdxScreenTip; APainter: TdxBarPainter): TdxBarCustomHintViewInfo;
function dxBarFlatPainter: TdxBarFlatPainter;

function ActiveBarControl: TCustomdxBarControl;
function BarGetMouseWheelReceiver: TdxBarMouseWheelEventReceiver;
function VisibleTodxBarVisible(Value: Boolean): TdxBarItemVisible;
function GetBarControlClass(AToolbar: TdxBar): TdxBarControlClass;
function GetBarManagerByComponent(AComponent: TComponent): TdxBarManager;
function GetBarManagerByForm(AForm: TCustomForm): TdxBarManager;
function GetBarManagerForComponent(AComponent: TComponent): TdxBarManager;
function GetParentBarForBar(Value: TCustomdxBarControl): TCustomdxBarControl;

function GetAccelPos(var AText: string; AModifyString: Boolean = False): Integer;
function GetWorkArea(const P: TPoint): TRect;
function GetTextOf(const S: string): string;

procedure DrawItemArrow(DC: HDC; R: TRect; AArrowType: TcxArrowDirection; AScaleFactor: TdxScaleFactor;
  AEnabled, ASelected, AFlat: Boolean; AColor: TColor = clDefault); overload;
procedure DrawItemArrow(ADC: HDC; R: TRect; AScaleFactor: TdxScaleFactor;
  ADownArrow, AEnabled, ASelected, AFlat: Boolean; AColor: TColor = clDefault); overload;
procedure DrawItemArrow(ADC: HDC; R: TRect;
  ADownArrow, AEnabled, ASelected, AFlat: Boolean; AColor: TColor = clDefault); overload;
procedure DrawItemArrow(DC: HDC; R: TRect; AArrowType: TcxArrowDirection;
  AEnabled, ASelected, AFlat: Boolean; AColor: TColor = clDefault); overload;
procedure DrawLargeItemArrow(DC: HDC; R: TRect; AArrowType: TcxArrowDirection; ASize: Integer; ASelected, AEnabled, AFlat: Boolean; AColor: TColor = clDefault);

procedure FrameFlatSelRect(DC: HDC; const R: TRect);
procedure DrawVerticalGradient(Canvas: TCanvas; const ARect: TRect; FromR, ToR, FromG, ToG, FromB, ToB: Byte);
procedure TransparentDraw(DrawDC: HDC; const R: TRect; AGlyph: TGraphic; AEnabled: Boolean = True); overload;
procedure TransparentDraw(DrawDC: HDC; Brush: HBRUSH; const FullRect, R: TRect; AGlyph: TGraphic; AImages: TCustomImageList;
  AImageIndex: Integer; AImageListBkColor: TColor; AEnabled, AGrayScale, AFlat, ASelected, ADown, APressed, AShadow, AFaded: Boolean;
  ASmoothImage: Boolean = False; AUseLeftBottomPixelAsTransparent: Boolean = True; AColorPalette: IdxColorPalette = nil); overload;
procedure TransparentDraw(ABarItemControl: TdxBarItemControl; DrawDC: HDC; Brush: HBRUSH; const FullRect, R: TRect;
  AGlyph: TGraphic; AImages: TCustomImageList; AImageIndex: Integer; AImageListBkColor: TColor;
  AEnabled, AGrayScale, AFlat, ASelected, ADown, APressed, AShadow, AFaded: Boolean; ASmoothImage: Boolean = False;
  AUseLeftBottomPixelAsTransparent: Boolean = True; AColorPalette: IdxColorPalette = nil); overload;

function CloneFont(AFontHandle: HFONT): HFONT;
procedure FillRectByBitmap(DC: HDC; ADestR, ASourceR: TRect; ABitmap: TBitmap);
procedure RestoreClipRgn(DC: HDC; var AClipRgn: HRGN; var AClipRgnExists: Boolean);
procedure SaveClipRgn(DC: HDC; var AClipRgn: HRGN; var AClipRgnExists: Boolean);

procedure AfterDrawBackground(ADC: HDC; APrevWindowOrg: TPoint);
function BeforeDrawBackground(ASourceControl, ADestinationControl: TWinControl;
  ADC: HDC; var ARect: TRect; out APrevWindowOrg: TPoint): TPoint;

procedure ProcessMouseMessages;
procedure ProcessPaintMessages;

function LeftButtonPressed: Boolean;
function RightButtonPressed: Boolean;

function IsAncestorComponentDifferencesDetection(AComponent: TComponent): Boolean;
function IsApplicationActive: Boolean;
function dxKillTimer(AWindowHandle: HWND; var ATimerID: DWORD): Boolean;
function dxBarMessageBox(AText: string; AFlags: Integer): Integer;
procedure dxBarFrameRect(ADC: HDC; ARect: TRect; AColor: Integer);
procedure dxBarFocusRect(ADC: HDC; ARect: TRect);

function dxFindVCLControl(Wnd: HWND): TWinControl;
function dxHasAsParent(Wnd: HWND; ParentWnd: HWND): Boolean;
function dxBarGetParentPopupWindow(AControl: TWinControl; ACheckParentBars: Boolean): TcxCustomPopupWindow;
function dxBarGetControlForm(AControl: TWinControl; AFormKind: TdxBarManagerFormKind): TCustomForm;
function dxBarHasPopupWindowAbove(ABarControl: TCustomdxBarControl;
  AIgnoreSelectedControl: Boolean): Boolean;

function IsSelectableItem(AObject: TObject): Boolean; overload;
function IsSelectableItem(AObject: TObject;
  out ASelectableItem: IdxBarSelectableItem): Boolean; overload;
function GetSelectableItem(AObject: TObject): IdxBarSelectableItem;
procedure CleanSelectableItems(AItems: TdxObjectList);

function GetMaxViewLevel(AViewLevels: TdxBarItemViewLevels): TdxBarItemRealViewLevel;
function GetMinViewLevel(AViewLevels: TdxBarItemViewLevels): TdxBarItemRealViewLevel;
function GetNextViewLevel(AViewLevels: TdxBarItemViewLevels;
  AViewLevel: TdxBarItemRealViewLevel): TdxBarItemRealViewLevel;
procedure BarDrawSizeGrip(DC: HDC; R: TRect);

procedure dxBarPopup(APopup: TPopupMenu; AOwner: TWinControl; X, Y: Integer);

type
  TdxBarGetRootAccessibleObjectFunc = function(AParentWnd: HWND): IdxBarAccessibilityHelper;

var
  dxBarGetRootAccessibleObject: TdxBarGetRootAccessibleObjectFunc;
  dxBarHintKeeper: IdxBarHintKeeper;
  dxBarHintWindowClass: TdxBarHintWindowClass = TdxBarHintWindow;
  dxBarLockMainFormOnMergingMDIChildForm: Boolean = True;
  dxBarMakeInactiveImagesDingy: Boolean = True;
  dxBarManagerList: TdxBarManagerList;
  dxBarPlaySound: Boolean = True;
  dxBarSkinPainterClass: TdxBarPainterClass = TdxBarStandardPainter;
  FHintWindow: THintWindow;
  FOnRegisterBarManager: TcxNotifyProcedure;
  FOnUnregisterBarManager: TcxNotifyProcedure;
  PatternBrush: HBRUSH;

const
  dxBarManagerTempCategoryIndex = -1000;
  dxBarCustomizingPopupPaintStyleGroupIndex = -1000;

  dxBarNonRecentlyUsedItemsColorDelta: Integer = 20;
  dxBarFlatToolbarsColorDelta: Integer = 20;

  dxBarWaitForSubMenuTime: Integer = 400;

  // TdxBarItemControl
  icpNone = -1;
  icpNonClient = 100;
  icpControl = 0;
  // TdxBarEditControlPart
  ecpEdit = 0;
  ecpIcon = 1;
  ecpText = 2;
  ecpHeaderParts = [ecpIcon, ecpText, icpNonClient];
  // TdxBarComboControlPart
  ccpDropButton = 3;
  // TdxBarColorComboControl
  clcpCustomColorButton = 4;
  // TdxBarButtonControlPart
  bcpButton = 0;
  bcpDropButton = 1;
  //TdxBarSpinEditControl
  secButtonUp = 3;
  secButtonDown = 4;
  //TdxBarExtraPaneButtonControl
  epbcpButton = 0;
  epbcpPinButton = 1;

  dxBarDefaultStyle = {$IFDEF USENATIVELOOKANDFEELASDEFAULT}bmsUseLookAndFeel{$ELSE}bmsEnhanced{$ENDIF};

implementation

{$R dxBar.res}

uses
  CommCtrl, MMSystem, Registry, Math, StrUtils,
  cxLibraryConsts, dxAnimation, dxUxTheme, dxThemeConsts, dxOffice11,
  dxBarSkinConsts, dxBarAccessibility, cxDWMApi, dxHooks, dxGDIPlusAPI,
  dxBarCustForm, dxBarPopupMenuEd, dxBarCustomCustomizationForm, dxBarConverter,
  dxBarStrs, dxBarNameEd, dxDPIAwareUtils, dxSkinsdxBarPainter;

const
  MAPVK_VK_TO_VSC    = 0;
  MAPVK_VSC_TO_VK    = 1;
  MAPVK_VK_TO_CHAR   = 2;
  MAPVK_VSC_TO_VK_EX = 3;

  dxBarButtonBorderWidth = 7;
  dxBarButtonBorderHeight = 6;

  dxBarEmptySubMenuControlContentWidth = 100;

  dxBarFingerSize = 3;
  dxBarHorSize = 4;
  dxBarTopSize = 2;
  dxBarBottomSize = 1;
  dxBarFlatBorderSize = 3;

  dxBarFloatToolbarMinWidth = 51;

  DefaultGlyphSize = 16;
  InsertZone = 10;
  MarkSizeArrowY = 4;
  MarkSizeArrowX = 2 * MarkSizeArrowY - 1;
  MakeBeginGroupDragSize = 4;
  MinToolbarSize = 2 + 19 + 2;
  FloatToolbarMarkIndent = 1;
  MenuSeparatorSize = 2;

  HintOffset = 20;

  MinEditWidth = 20;
  EditSizingZoneSize = 7;

  MinDockSize = 3;
  DetachAreaDelta = 15;

  dxBarWaitForShowHintTime = 1000;
  dxBarWaitForHideHintTime = 10000;
  dxBarHiddedHintLifeTime = 400;
  dxBarScrollMenuTime = 80;
  dxBarSmoothScrollMenuTime = dxBarScrollMenuTime + 120;
  dxBarSlowExpandMenuTime = 4000;
  dxBarWaitForKeyTipsTime = 500;

  MDIButtonStyles: array[TdxBarMDIButton] of Integer = (DFCS_CAPTIONMIN, DFCS_CAPTIONRESTORE, DFCS_CAPTIONCLOSE);

  ListItemSeparator = '-';

  DefaultViewParams: TcxViewParams = (
    Bitmap: nil;
    Color: clDefault;
    Font: nil;
    TextColor: clDefault
  );

type
  TdxSmartGlyphAccess = class(TdxSmartGlyph);
  TControlAccess = class(TControl);
  TWinControlAccess = class(TWinControl);
  TCustomFormAccess = class(TCustomForm);

  TdxBarXPPainterParams = record
    BarBeginGroupSize: Integer;
    BarCloseButtonSize: TSize;
    ButtonBorderHeight: Integer;
    ComboBoxArrowWidth: Integer;
    EditControlBorderOffsets: TRect;
    GripperSize: Integer;
    ProgressControlBarHeight: Integer;
    SubMenuControlBeginGroupSize: Integer;
    StatusBarGripSize: TSize;
  end;

var
  FUnitIsFinalized: Boolean;
  FApplicationActive: Boolean = True;
  FApplicationDeactivation: Boolean;
  FMergingWith: TdxBar;
  FUser32DLL: HMODULE;
  FdxBarXPPainterParams: TdxBarXPPainterParams;

  FBarControls: TList;
  FBarDesignController: TdxBarDesignController;
  FBarFlatPainter: TdxBarFlatPainter;
  FBarNavigationController: TdxBarNavigationController;
  FRegdxItemList: TdxBarItemList;

  FActiveBarControl: TCustomdxBarControl;

  FIsMDIButtonPressed, FIsMouseOverMDIButton: Boolean;
  FPressedMDIButton, FSelectedMDIButton: TdxBarMDIButton;

  ResettingToolbar: Boolean;

  ShowFullMenus: Boolean;

  BitsPerPixel: Integer;

{ blending }

type
  TSetLayeredWindowAttributes = function (Hwnd: THandle; crKey: COLORREF; bAlpha: Byte; dwFlags: DWORD): Boolean; stdcall;

var
  SetLayeredWindowAttributes: TSetLayeredWindowAttributes = nil;

function GetBarManagerByHandle(AWnd: HWND): TdxBarManager; forward;

procedure BarAccessibilityHelperOwnerObjectDestroyed(
  var AIHelper: IdxBarAccessibilityHelper);
begin
  if AIHelper <> nil then
    AIHelper.OwnerObjectDestroyed;
  AIHelper := nil;
end;

function GetAccessibilityHelper(AObject: TObject): IdxBarAccessibilityHelper;
begin
  Supports(AObject, IdxBarAccessibilityHelper, Result);
end;

function GetKeyTipContainerParent(
  AContainer: IdxBarAccessibilityHelper): IdxBarAccessibilityHelper;
var
  AParentObject: TdxBarAccessibilityHelper;
begin
  Result := nil;
  AParentObject := AContainer.GetBarHelper;
  if AParentObject.ParentForKeyTip = nil then
    Exit;
  repeat
    AParentObject := AParentObject.ParentForKeyTip;
  until AParentObject.IsKeyTipContainer or (AParentObject.ParentForKeyTip = nil);
  Result := AParentObject;
end;

function GetNextAccessibleObject(ASelectedObject: TdxBarAccessibilityHelper;
  AObjects: TList; ADirection: TcxAccessibilityNavigationDirection;
  ACycleHorizontally: Boolean): TdxBarAccessibilityHelper;

  procedure CalcRectCenter(const R: TRect; out X, Y: Extended);
  begin
    X := R.Left + (R.Right - R.Left) / 2;
    Y := R.Top + (R.Bottom - R.Top) / 2;
  end;

  procedure CalcDistance(const R1, R2: TRect; out AAngle, ADistance: Extended);
  var
    AAngle1, AAngle2, X1, X2, Y1, Y2: Extended;
  begin
    CalcRectCenter(R1, X1, Y1);
    CalcRectCenter(R2, X2, Y2);

    AAngle1 := RadToDeg(ArcTan2(Y2 - Y1, X2 - X1));
    if AAngle1 < 0 then
      AAngle1 := AAngle1 + 360;
    case ADirection of
      andLeft:
        AAngle1 := AAngle1 - 180;
      andUp:
        AAngle1 := AAngle1 - 270;
      andDown:
        AAngle1 := AAngle1 - 90;
    end;
    if AAngle1 < 0 then
      AAngle2 := AAngle1 + 360
    else
      AAngle2 := AAngle1 - 360;
    if AAngle1 < 0 then
      AAngle1 := -AAngle1;
    if AAngle2 < 0 then
      AAngle2 := -AAngle2;
    AAngle := Min(AAngle1, AAngle2);

    case ADirection of
      andLeft:
        ADistance := R1.Left - R2.Right;
      andUp:
        ADistance := R1.Top - R2.Bottom;
      andRight:
        ADistance := R2.Left - R1.Right;
      andDown:
        ADistance := R2.Top - R1.Bottom;
    end;
  end;

var
  AAngle, ADistance, AMinAngle, AMinDistance: Extended;
  ANearestObject: TdxBarAccessibilityHelper;
  I: Integer;
  R, R1, R2: TRect;
begin
  if ADirection in [andPrev, andNext] then
  begin
    Result := nil; // TODO
    Exit;
  end;

  AMinAngle := 0;
  AMinDistance := 0;
  ANearestObject := nil;
  R1 := ASelectedObject.GetScreenBounds(cxAccessibleObjectSelfID);

  for I := 0 to AObjects.Count - 1 do
  begin
    R := TdxBarAccessibilityHelper(AObjects[I]).GetScreenBounds(cxAccessibleObjectSelfID);
    CalcDistance(R1, R, AAngle, ADistance);
    if (ADistance >= 0) and ((ANearestObject = nil) or (ADistance < AMinDistance) or (ADistance = AMinDistance) and (AAngle < AMinAngle)) then
    begin
      ANearestObject := TdxBarAccessibilityHelper(AObjects[I]);
      AMinAngle := AAngle;
      AMinDistance := ADistance;
    end;
  end;

  if (ANearestObject = nil) and (ADirection in [andLeft, andRight]) and ACycleHorizontally then
  begin
    R2 := R1;
    case ADirection of
      andLeft:
        begin
          OffsetRect(R2, -R2.Right, 0);
          OffsetRect(R2, cxMaxRectSize, 0);
        end;
      andRight:
        begin
          OffsetRect(R2, -R2.Left, 0);
          OffsetRect(R2, -cxMaxRectSize, 0);
        end;
    end;
    for I := 0 to AObjects.Count - 1 do
    begin
      R := TdxBarAccessibilityHelper(AObjects[I]).GetScreenBounds(cxAccessibleObjectSelfID);
      CalcDistance(R2, R, AAngle, ADistance);
      if (ADistance >= 0) and ((ANearestObject = nil) or (ADistance < AMinDistance) or (ADistance = AMinDistance) and (AAngle < AMinAngle)) then
      begin
        ANearestObject := TdxBarAccessibilityHelper(AObjects[I]);
        AMinAngle := AAngle;
        AMinDistance := ADistance;
      end;
    end;
  end;

  if ANearestObject <> nil then
    Result := ANearestObject
  else
    Result := nil;
end;

function GetRootAccessibleObject(AParentWnd: HWND): IdxBarAccessibilityHelper;
var
  ABarManager: TdxBarManager;
begin
  Result := nil;
  if ActiveBarControl <> nil then
    Result := ActiveBarControl.GetIAccessibilityHelper;
  if (Result = nil) and Assigned(dxBarGetRootAccessibleObject) then
    Result := dxBarGetRootAccessibleObject(AParentWnd);
  if Result = nil then
  begin
    ABarManager := GetBarManagerByHandle(AParentWnd);
    if (ABarManager <> nil) and (ABarManager.MainMenuControl <> nil) then
      Result := ABarManager.MainMenuControl.IAccessibilityHelper;
  end;
end;

procedure HandleKeyTipsEscape(AActiveKeyTipContainer: IdxBarAccessibilityHelper);
begin
  AActiveKeyTipContainer.GetBarHelper.KeyTipsEscapeHandler;
end;

function GetLinksOwner(AObject: TObject): IdxBarLinksOwner;
begin
  Supports(AObject, IdxBarLinksOwner, Result);
end;

function GetChildWindowVCLParent(AWnd: HWND): TWinControl;
begin
  Result := nil;
  while (Result = nil) and (AWnd <> 0) and IsChildClassWindow(AWnd) do
  begin
    AWnd := GetParent(AWnd);
    Result := FindControl(AWnd);
  end;
end;

function IsAncestorComponentDifferencesDetection(AComponent: TComponent): Boolean;
begin
  Result := (AComponent.ComponentState * [csLoading, csReading, csAncestor] = [csLoading, csAncestor]);
end;

function IsTextCharForKeyTip(AKey: Word): Boolean;
var
  ARes: UINT;
begin
  ARes := MapVirtualKey(AKey, MAPVK_VK_TO_CHAR);
  Result := ((ARes and $FFFF0000) = 0) and (Char(ARes) <> ' ') and
    IsTextChar(Char(ARes));
end;

function BarNavigationController: TdxBarNavigationController;
begin
  Result := FBarNavigationController;
end;

procedure SendCancelMode;
var
  AActiveControl: TWinControl;
begin
  AActiveControl := FindControl(GetActiveWindow);
  if AActiveControl is TCustomForm then
    TCustomForm(AActiveControl).SendCancelMode(nil);
end;

procedure SetActiveWindow(AWindowHandle: HWND);
begin
  Windows.SetActiveWindow(FindFirstNonChildParentWindow(AWindowHandle));
end;

// null reference routines
procedure RepaintItemControl(AItemControl: TdxBarItemControl); overload;
begin
  if AItemControl <> nil then
    AItemControl.Repaint;
end;

procedure RepaintItemControl(AItemLink: TdxBarItemLink); overload;
begin
  if AItemLink <> nil then
    RepaintItemControl(AItemLink.Control);
end;

function GetControlByLink(AItemLink: TdxBarItemLink): TdxBarItemControl;
begin
  if AItemLink <> nil then
    Result := AItemLink.Control
  else
    Result := nil;
end;

function GetLinkByControl(AItemControl: TdxBarItemControl): TdxBarItemLink; inline;
begin
  if AItemControl <> nil then
    Result := AItemControl.ItemLink
  else
    Result := nil;
end;

function GetItemByControl(AItemControl: TdxBarItemControl): TdxBarItem; inline;
begin
  if AItemControl <> nil then
    Result := AItemControl.Item
  else
    Result := nil;
end;

function GetItemByLink(AItemLink: TdxBarItemLink): TdxBarItem; inline;
begin
  if AItemLink <> nil then
    Result := AItemLink.Item
  else
    Result := nil;
end;

function GetObjectByObjectLink(AObjectLink: TcxObjectLink): TObject; inline;
begin
  if AObjectLink <> nil then
    Result := AObjectLink.Ref
  else
    Result := nil;
end;

function GetOwnedLinks(AObject: TObject): TdxBarItemLinks;
begin
  if GetLinksOwner(AObject) <> nil then
    Result := GetLinksOwner(AObject).GetItemLinks
  else
    Result := nil;
end;

function GetActiveForm: TCustomForm;
var
  AControl: TWinControl;
begin
  Result := nil;
  AControl := FindControl(GetActiveWindow);
  if (AControl is TCustomForm) and IsWindowEnabledEx(AControl.Handle) then
  begin
    Result := TCustomForm(AControl);
    if IsMDIForm(Result) and (TCustomFormAccess(Result).ActiveMDIChild <> nil) then
      Result := TCustomFormAccess(Result).ActiveMDIChild;
  end;
end;

function GetInstance(ASelectedItem: IdxBarSelectableItem): TPersistent;
begin
  if ASelectedItem <> nil then
    Result := ASelectedItem.GetInstance
  else
    Result := nil;
end;

function GetSubItemButtonByButtonCaption(ASubItem: TdxBarSubItem; const ACaption: string): TdxBarCustomButton;
var
  I: Integer;
begin
  Result := nil;
  for I := 0 to ASubItem.ItemLinks.Count - 1 do
    if TdxBarCustomButton(ASubItem.ItemLinks[I].Item).Caption = ACaption then
      Result := TdxBarCustomButton(ASubItem.ItemLinks[I].Item);
end;

procedure KillBeep(AWnd: HWND);
begin
  dxMessagesController.KillMessages(AWnd, WM_CHAR, WM_CHAR);
end;

function GetBarControlClass(AToolbar: TdxBar): TdxBarControlClass;
begin
  if AToolbar.Control <> nil then
    Result := TdxBarControlClass(AToolbar.Control.ClassType)
  else
    Result := AToolbar.GetControlClass;
end;

function GetBarManagerByComponent(AComponent: TComponent): TdxBarManager;
var
  I: Integer;
begin
  Result := nil;

  if AComponent is TdxBarManager then
    Result := TdxBarManager(AComponent)
  else
  begin

{ B33023
    if AExtended and (AComponent is TCustomForm) and (TCustomForm(AComponent).Parent = nil) then
    begin
      if Assigned(cxControls.cxGetParentFormForDocking) then
        AComponent := cxControls.cxGetParentFormForDocking(TCustomForm(AComponent));
    end;
}

    if (AComponent <> nil) and (dxBarManagerList <> nil) then
      for I := 0 to dxBarManagerList.Count - 1 do
        if dxBarManagerList[I].Owner = AComponent then
        begin
          Result := dxBarManagerList[I];
          Break;
        end;
  end;
end;

function GetBarManagerByForm(AForm: TCustomForm): TdxBarManager;
begin
  Result := GetBarManagerByComponent(AForm);
end;

function GetWinControlOwner(AComponent: TComponent): TWinControl;
begin
  while (AComponent <> nil) and not (AComponent is TWinControl) do
    AComponent := AComponent.Owner;
  Result := TWinControl(AComponent)
end;

function GetBarManagerForComponent(AComponent: TComponent): TdxBarManager;
var
  AControl: TWinControl;
begin
  Result := nil;
  AControl := GetWinControlOwner(AComponent);
  if (AControl <> nil) and AControl.HandleAllocated then
    repeat
      Result := GetBarManagerByComponent(AControl);
      AControl := GetChildWindowVCLParent(AControl.Handle);
    until (Result <> nil) or (AControl = nil);
end;

function dxBarGetControlForm(AControl: TWinControl; AFormKind: TdxBarManagerFormKind): TCustomForm;

  function CheckForm(AForm: TCustomForm): Boolean;
  begin
    Result := (AForm <> nil) and ((AFormKind = fkAny) or
      (AFormKind = fkMainOrMDIChild) and IsMDIChild(AForm));
  end;

  function IsWinObjectAssigned(AWnd: THandle; AControl: TWinControl): Boolean;
  begin
    Result := (AWnd <> 0) or (AControl <> nil);
  end;

  procedure GetParentWinObject(var AWnd: THandle; var AControl: TWinControl);
  begin
    if AWnd <> 0 then
    begin
      AWnd := GetParent(AWnd);
      dxTestCheck(AControl = nil, 'GetParentWinObject fails');
    end
    else
    begin
      if AControl.Parent <> nil then
        AControl := AControl.Parent
      else
      begin
        AWnd := GetParent(TWinControlAccess(AControl).WindowHandle);
        AControl := nil;
      end;
    end;
  end;

  function IsChildWinObject(AWnd: THandle; AControl: TWinControl): Boolean;
  begin
    if AWnd <> 0 then
      Result := IsChildClassWindow(AWnd)
    else
      Result := (AControl.Parent <> nil) or (AControl.ParentWindow <> 0) or (AControl is TCustomForm) and (TCustomFormAccess(AControl).FormStyle = fsMDIChild);
  end;

var
  AWnd: THandle;
  ACurrentForm: TCustomForm;
begin
  Result := nil;
  AWnd := 0;
  while IsWinObjectAssigned(AWnd, AControl) do
  begin
    if (AControl is TCustomForm) or (AControl = nil) and (FindControl(AWnd) is TCustomForm) then
    begin
      if AControl <> nil then
        ACurrentForm := AControl as TCustomForm
      else
        ACurrentForm := (FindControl(AWnd)) as TCustomForm;
      Result := ACurrentForm;
    end
    else
      ACurrentForm := nil;
    if not IsChildWinObject(AWnd, AControl) or CheckForm(ACurrentForm) then
      Break;
    GetParentWinObject(AWnd, AControl);
  end;
end;

function GetComponentForm(AComponent: TComponent): TCustomForm;
var
  AControl: TWinControl;
begin
  AControl := GetWinControlOwner(AComponent);
  if AControl <> nil then
    Result := dxBarGetControlForm(AControl, fkAny)
  else
    Result := nil;
end;

function GetBarManagerForm(ABarManager: TdxBarManager;
  AFormKind: TdxBarManagerFormKind): TCustomForm;
begin
  Result := dxBarGetControlForm(ABarManager.Owner, AFormKind);
end;

function IsBarManagerOwner(ABarManager: TdxBarManager;
  AOwnerHandle: HWND): Boolean;
var
  AWnd: HWND;
begin
  Result := False;
  if ABarManager.Owner.HandleAllocated then
  begin
    AWnd := ABarManager.Owner.Handle;
    while (AWnd <> AOwnerHandle) and IsChildClassWindow(AWnd) do
      AWnd := GetParent(AWnd);
    Result := AWnd = AOwnerHandle;
  end;
end;

function GetWinControl(AControl: TControl): TWinControl;
begin
  if AControl is TWinControl then
    Result := TWinControl(AControl)
  else
    Result := AControl.Parent;
end;

function IsChildControl(AParentControl: TWinControl; AChildWnd: THandle): Boolean; overload;
begin
  Result := AParentControl.HandleAllocated and IsChildEx(AParentControl.Handle, AChildWnd);
end;

function IsChildControl(AParentControl: TWinControl; AChildControl: TControl): Boolean; overload;
var
  AParent: TWinControl;
  AChildWinControl: TWinControl;
begin
  AChildWinControl := GetWinControl(AChildControl);
  if AParentControl.HandleAllocated and AChildWinControl.HandleAllocated then
    Result := IsChildEx(AParentControl.Handle, AChildWinControl.Handle)
  else
  begin
    AParent := AChildWinControl;
    while (AParent <> nil) and (AParent <> AParentControl) do
      AParent := AParent.Parent;
    Result := AParent = AParentControl;
  end;
end;

function IsControlUnderBarManager(ABarManager: TdxBarManager;
  AControl: TControl): Boolean;
begin
  Result := IsChildControl(ABarManager.Owner, AControl);
end;

function dxBarGetParentPopupWindow(AControl: TWinControl; ACheckParentBars: Boolean): TcxCustomPopupWindow;

  function InternalGetParent(AWnd: HWND): HWND;
  var
    AControl: TWinControl;
  begin
    Result := 0;
    if IsChildClassWindow(AWnd) then
      Result := GetParent(AWnd)
    else
      if ACheckParentBars then
      begin
        AControl := FindControl(AWnd);
        if (AControl is TCustomdxBarControl) and
          (TCustomdxBarControl(AControl).ParentBar <> nil) and TCustomdxBarControl(AControl).ParentBar.HandleAllocated then
          Result := TCustomdxBarControl(AControl).ParentBar.Handle;
      end;
  end;

var
  AParentWnd, AWnd: HWND;
begin
  Result := nil;
  if not AControl.HandleAllocated or (csDestroying in AControl.ComponentState) then
    Exit;

  AWnd := AControl.Handle;
  repeat
    AParentWnd := InternalGetParent(AWnd);
    if AParentWnd = 0 then
      Break;
    AWnd := AParentWnd;
  until False;
  if (AWnd <> AControl.Handle) and (FindControl(AWnd) is TcxCustomPopupWindow) then
    Result := TcxCustomPopupWindow(FindControl(AWnd));
end;
// Temp methods

function EnumToStringArray(ATypeInfo: PTypeInfo): TStringDynArray;
var
  ATypeData: PTypeData;
  AList: TStringList;
  I: Integer;
begin
  ATypeData := GetTypeData(ATypeInfo);
  AList := TStringList.Create;
  try
    for I := ATypeData.MinValue to ATypeData.MaxValue do
      AList.Add(GetEnumName(ATypeInfo, I));
//    AList.Sort;
    SetLength(Result, AList.Count);
    for I := 0 to High(Result) do
      Result[I] := AList[I];
  finally
    AList.Free;
  end;
end;

function SetToStringArray(ATypeInfo: PTypeInfo): TStringDynArray;
begin
  Result := EnumToStringArray(GetTypeData(ATypeInfo).CompType^);
end;

procedure DeleteGDIObject(var AGDIObject);
begin
  if HGDIOBJ(AGDIObject) <> 0 then
  begin
    DeleteObject(HGDIOBJ(AGDIObject));
    HGDIOBJ(AGDIObject) := 0;
  end;
end;

procedure ReverseGDIObject(ADC: HDC; APrevGDIObject: HGDIOBJ);
begin
  DeleteObject(SelectObject(ADC, APrevGDIObject));
end;

procedure PolygonByColor(ADC: HDC; var APoints: array of TPoint; APenColor, ABrushColor: COLORREF);
var
  APrevBrush, APrevPen: HGDIOBJ;
begin
  APrevPen := SelectObject(ADC, CreatePen(PS_SOLID, 1, APenColor));
  APrevBrush := SelectObject(ADC, CreateSolidBrush(ABrushColor));
  Polygon(ADC, APoints, Length(APoints));
  ReverseGDIObject(ADC, APrevBrush);
  ReverseGDIObject(ADC, APrevPen);
end;

procedure RoundRectByColor(ADC: HDC; const R: TRect; AWidth, AHeight: Integer; APenColor, ABrushColor: TColor);
var
  APrevBrush, APrevPen: HGDIOBJ;
  ALogBrush: LOGBRUSH;
begin
  ZeroMemory(@ALogBrush, SizeOf(ALogBrush));
  if ABrushColor = clNone then
    ALogBrush.lbStyle := BS_NULL
  else
    ALogBrush.lbColor := ColorToRGB(ABrushColor);

  APrevBrush := SelectObject(ADC, CreateBrushIndirect(ALogBrush));
  APrevPen := SelectObject(ADC, CreatePen(PS_SOLID, 1, ColorToRGB(APenColor)));
  RoundRect(ADC, R.Left, R.Top, R.Right, R.Bottom, AWidth, AHeight);
  ReverseGDIObject(ADC, APrevBrush);
  ReverseGDIObject(ADC, APrevPen);
end;

procedure ExcludeFrameRegion(ACanvas: TcxCanvas; AFrameRect, AContentRect: TRect);
var
  ARegion: TcxRegion;
begin
  ARegion := TcxRegion.Create(AFrameRect);
  ARegion.Combine(AContentRect, roSubtract);
  ACanvas.SetClipRegion(ARegion, roSubtract);
end;

procedure DestroyWindowHandle(var AWindowHandle: HWND; ADestroyWindow: Boolean = True);
begin
  if AWindowHandle <> 0 then
  begin
    if ADestroyWindow then
      Windows.DestroyWindow(AWindowHandle);
    AWindowHandle := 0;
  end;
end;

function dxKillTimer(AWindowHandle: HWND; var ATimerID: DWORD): Boolean;
begin
  Result := (ATimerID <> 0) and KillTimer(AWindowHandle, ATimerID);
  if Result then
    ATimerID := 0;
end;

function IsAnotherApplicationWindow(AWnd: HWND): Boolean;
var
  AProcessId: Cardinal;
begin
  GetWindowThreadProcessId(AWnd, @AProcessId);
  Result := (AWnd = 0) or (AProcessId <> GetCurrentProcessId);
end;

function IsPopupMenuShowed: Boolean;
var
  ABarManager: TdxBarManager;
  I, J: Integer;
begin
  Result := False;
  for I := 0 to dxBarManagerList.Count - 1 do
  begin
    ABarManager := dxBarManagerList[I];
    if not ABarManager.IsDestroying then
      for J := 0 to ABarManager.FPopupMenus.Count - 1 do
      begin
        if TdxBarPopupMenu(ABarManager.FPopupMenus[J]).FPopupMenuVisible then
          Exit(True);
      end;
  end;
end;

function GetSectionDelimiter(AStoringKind: TdxBarStoringKind): string;
begin
  if AStoringKind = skIni then
    Result := '.'
  else
    Result := '\';
end;

function GetShortCutFromMessageData(AWParam: WPARAM; ALParam: LPARAM): TShortCut;
const
  AltMask = $20000000;
begin
  Result := Byte(AWParam);
  if Result <> 0 then
  begin
    if GetKeyState(VK_SHIFT) < 0 then
      Inc(Result, scShift);
    if GetKeyState(VK_CONTROL) < 0 then
      Inc(Result, scCtrl);
    if ALParam and AltMask <> 0 then
      Inc(Result, scAlt);
  end;
end;

{ global methods }

function BarDesignController: TdxBarDesignController;
begin
  if (FBarDesignController = nil) and not FUnitIsFinalized then
    FBarDesignController := TdxBarDesignController.Create;
  Result := FBarDesignController;
end;

function RegdxItemList: TdxBarItemList;
begin
  if (FRegdxItemList = nil) and not FUnitIsFinalized then
    FRegdxItemList := TdxBarItemList.Create;
  Result := FRegdxItemList;
end;

procedure dxBarRegisterItem(AItemClass: TdxBarItemClass;
  AItemControlClass: TdxBarItemControlClass; AVisible: Boolean);
begin
  RegdxItemList.Register(AItemClass, AItemControlClass, AVisible);
end;

procedure dxBarUnregisterItem(AItemClass: TdxBarItemClass);
begin
  RegdxItemList.Unregister(AItemClass);
end;

procedure AddBarControl(ABarControl: TCustomdxBarControl);
begin
  if FBarControls <> nil then
    FBarControls.Add(ABarControl);
end;

procedure RemoveBarControl(ABarControl: TCustomdxBarControl);
begin
  if FBarControls <> nil then
    FBarControls.Remove(ABarControl);
end;

function BarControlExists(ABarControl: TCustomdxBarControl): Boolean;
begin
  Result := (ABarControl <> nil) and (FBarControls <> nil) and
    (FBarControls.IndexOf(ABarControl) <> -1);
end;

procedure dxBarDesignerModified(ABarManager: TdxBarManager);
begin
  if ABarManager <> nil then ABarManager.DesignerModified;
end;

function dxBarCreateScreenTipViewInfo(ABarManager: TdxBarManager; AHintText: string; const AShortCut: string; AScreenTip: TdxScreenTip;
  APainter: TdxBarPainter): TdxBarCustomHintViewInfo;
begin
  if (AScreenTip <> nil) and AScreenTip.Collection.Repository.ShowDescription then
    Result := TdxBarScreenTipViewInfo.Create(AScreenTip, APainter, AHintText, AShortCut)
  else
  begin
    if (AScreenTip <> nil) and not AScreenTip.UseHintAsHeader and (AScreenTip.Header.Text <> '') then
      AHintText := AScreenTip.Header.Text;
    Result := TdxBarLikeHintScreenTipViewInfo.Create(ABarManager, APainter, AHintText, AShortCut, GetMouseCursorPos);
  end;
end;

function dxBarFlatPainter: TdxBarFlatPainter;
begin
  if FBarFlatPainter = nil then
    FBarFlatPainter := TdxBarFlatPainter.Create(0);
  Result := FBarFlatPainter;
end;

function dxBarCreateBitmap(AOnChangeProc: TNotifyEvent): TBitmap;
begin
  Result := cxCreateBitmap(0, 0, cxDoubleBufferedBitmapPixelFormat);
  Result.OnChange := AOnChangeProc;
end;

function dxBarCreateSmartGlyph(AChangeEventHandler: TNotifyEvent): TdxSmartGlyph;
begin
  Result := TdxSmartGlyph.Create;
  TdxSmartGlyphAccess(Result).FTransparent := False;
  TdxSmartGlyphAccess(Result).OnChange := AChangeEventHandler;
end;

function ActiveBarControl: TCustomdxBarControl;
begin
  Result := FActiveBarControl;
end;

function ActiveBarManager: TdxBarManager;
begin
  if ActiveBarControl <> nil then
    Result := ActiveBarControl.BarManager
  else
    Result := nil;
end;

function IsActiveBarControlAccessible: Boolean;
begin
  Result := (ActiveBarControl <> nil) and ActiveBarControl.HandleAllocated and IsWindowEnabledEx(ActiveBarControl.Handle);
end;

function VisibleTodxBarVisible(Value: Boolean): TdxBarItemVisible;
begin
  if Value then
    Result := ivAlways
  else
    Result := ivNever;
end;

function GetBarManagerByHandle(AWnd: HWND): TdxBarManager;
begin
  Result := GetBarManagerByComponent(FindControl(AWnd));
end;

function GetParentBarOrSubMenuForBar(Value: TCustomdxBarControl): TCustomdxBarControl;
begin
  Result := Value;
  while (Result <> nil) and not Result.IsDestroying do
    if (Result.ParentBar = nil) or Result.IsInternal and not Result.ParentBar.IsInternal then
      Break
    else
      Result := Result.ParentBar;
end;

function GetParentBarForBar(Value: TCustomdxBarControl): TCustomdxBarControl;
begin
  Result := GetParentBarOrSubMenuForBar(Value);
  if Result is TdxBarSubMenuControl then Result := nil;
end;

function GetAccelPos(var AText: string; AModifyString: Boolean = False): Integer;
var
  I: Integer;
begin
  Result := 0;
  I := 1;
  while I < Length(AText) do
  begin
    if AText[I] = '&' then
    begin
      if AModifyString then
        Delete(AText, I, 1)
      else
        Inc(I);
      if AText[I] <> '&' then
        Result := I;
    end;
    Inc(I);
  end;
end;

function GetParentBarOrSubMenuForControl(Value: TdxBarItemControl): TCustomdxBarControl;
begin
  if Value = nil then
    Result := nil
  else
    Result := GetParentBarOrSubMenuForBar(Value.Parent);
end;

function GetParentBarForControl(Value: TdxBarItemControl): TCustomdxBarControl;
begin
  Result := GetParentBarOrSubMenuForControl(Value);
  if Result is TdxBarSubMenuControl then Result := nil;
end;

function dxFindVCLControl(Wnd: HWND): TWinControl;
begin
  repeat
    Result := FindControl(Wnd);
    Wnd := GetParent(Wnd);
  until (Result <> nil) or (Wnd = 0);
end;

function dxHasAsParent(Wnd: HWND; ParentWnd: HWND): Boolean;
begin
  Result := IsOwner(ParentWnd, Wnd);
end;

function dxBarHasPopupWindowAbove(ABarControl: TCustomdxBarControl;
  AIgnoreSelectedControl: Boolean): Boolean;

  function GetItemControlScreenBounds(AItemControl: TdxBarItemControl): TRect;
  begin
    Result := AItemControl.ViewInfo.Bounds;
    Result.TopLeft := AItemControl.Parent.ClientToScreen(Result.TopLeft);
    Result.BottomRight := AItemControl.Parent.ClientToScreen(Result.BottomRight);
  end;

var
  AActiveBarControl: TCustomdxBarControl;
begin
  AActiveBarControl := ActiveBarControl;
  if (AActiveBarControl = nil) and (BarDesignController.QuickControl <> nil) then
    AActiveBarControl := BarDesignController.QuickControl;
  Result := (AActiveBarControl <> nil) and
    (
      (AActiveBarControl.SelectedControl <> nil) and AActiveBarControl.SelectedControl.IsDroppedDown and
      (
        not AIgnoreSelectedControl or
        not PtInRect(GetItemControlScreenBounds(AActiveBarControl.SelectedControl), GetMouseCursorPos)
      )
      or
      (AActiveBarControl <> ABarControl) and (AActiveBarControl.ParentBar <> nil)
    );
end;

function GetShortCutToHint(AShortCut: TShortCut; AIsRightToLeft: Boolean): string;
begin
  Result := ShortCutToText(AShortCut);
  if Result <> '' then
    if AIsRightToLeft then
      Result := '(' + Result + ') '
    else
      Result := ' (' + Result + ')';
end;

function GetTextOf(const S: string): string;
begin
  Result := RemoveAccelChars(S, False);
end;

procedure DrawItemArrow(DC: HDC; R: TRect; AArrowType: TcxArrowDirection;
  AEnabled, ASelected, AFlat: Boolean; AColor: TColor = clDefault);
begin
  DrawItemArrow(DC, R, AArrowType = adDown, AEnabled, ASelected, AFlat, AColor);
end;

procedure DrawItemArrow(DC: HDC; R: TRect; AArrowType: TcxArrowDirection;
  AScaleFactor: TdxScaleFactor; AEnabled, ASelected, AFlat: Boolean; AColor: TColor = clDefault);
begin
  DrawItemArrow(DC, R, dxSystemScaleFactor, AArrowType = adDown, AEnabled, ASelected, AFlat, AColor);
end;

procedure DrawItemArrow(ADC: HDC; R: TRect; ADownArrow, AEnabled, ASelected, AFlat: Boolean; AColor: TColor = clDefault);
begin
  DrawItemArrow(ADC, R, dxSystemScaleFactor, ADownArrow, AEnabled, ASelected, AFlat, AColor);
end;

procedure DrawItemArrow(ADC: HDC; R: TRect; AScaleFactor: TdxScaleFactor;
  ADownArrow, AEnabled, ASelected, AFlat: Boolean; AColor: TColor = clDefault);
var
  AArrowType: TcxArrowDirection;
  ASize: Integer;
begin
  if ADownArrow then
  begin
    AArrowType := adDown;
    ASize := R.Right - R.Left - AScaleFactor.Apply(8);
  end
  else
  begin
    AArrowType := adRight;
    ASize := R.Bottom - R.Top - AScaleFactor.Apply(6)
  end;
  ASize := Max((ASize - AScaleFactor.Apply(1)) div 2 + Byte(ASize mod 2 <> 0), AScaleFactor.Apply(3));
  DrawLargeItemArrow(ADC, R, AArrowType, ASize, ASelected, AEnabled, AFlat, AColor);
end;

procedure DrawLargeItemArrow(DC: HDC; R: TRect; AArrowType: TcxArrowDirection;
  ASize: Integer; ASelected, AEnabled, AFlat: Boolean; AColor: TColor = clDefault);
var
  X, Y: Integer;

  procedure DrawEnabled(AColor: COLORREF);
  var
    P: array[1..3] of TPoint;
  begin
    case AArrowType of
      adDown:
        begin
          X := (R.Left + R.Right - (2 * ASize - 1)) div 2;
          Y := (R.Top + R.Bottom - ASize) div 2;
          P[1] := Point(X, Y);
          P[2] := Point(X + 2 * ASize - 2, Y);
          P[3] := Point(X + ASize - 1, Y + ASize - 1);
        end;
      adLeft:
        begin
          X := (R.Left + R.Right + ASize) div 2;
          Y := (R.Top + R.Bottom - (2 * ASize - 1)) div 2;
          P[1] := Point(X, Y);
          P[2] := Point(X, Y + 2 * ASize - 2);
          P[3] := Point(X - ASize + 1, Y + ASize - 1);
        end;
    else //adRight, adTop
      begin
        X := (R.Left + R.Right - ASize) div 2;
        Y := (R.Top + R.Bottom - (2 * ASize - 1)) div 2;
        P[1] := Point(X, Y);
        P[2] := Point(X, Y + 2 * ASize - 2);
        P[3] := Point(X + ASize - 1, Y + ASize - 1);
      end;
    end;
    PolygonByColor(DC, P, AColor, AColor);
  end;

  procedure DrawDisabled;
  var
    Pen: HPEN;
  begin
    Pen := SelectObject(DC, CreatePen(PS_SOLID, 1, GetSysColor(COLOR_BTNHIGHLIGHT)));
    case AArrowType of
      adDown:
        begin
          MoveToEx(DC, X + ASize, Y + ASize - 1, nil);
          LineTo(DC, X + 2 * ASize - 1, Y);
          MoveToEx(DC, X + ASize, Y + ASize, nil);
          LineTo(DC, X + 2 * ASize, Y);
        end;
      adLeft:
        begin
          MoveToEx(DC, X - 1, Y + 1, nil);
          LineTo(DC, X - 1, Y + 2 * ASize - 1);
          MoveToEx(DC, X, Y, nil);
          LineTo(DC, X, Y + 2 * ASize);
        end;
    else //adRight, adTop
      begin
        MoveToEx(DC, X + ASize - 1, Y + ASize, nil);
        LineTo(DC, X, Y + 2 * ASize - 1);
        MoveToEx(DC, X + ASize, Y + ASize, nil);
        LineTo(DC, X, Y + 2 * ASize);
      end;
    end;
    ReverseGDIObject(DC, Pen);
  end;

begin
  if AColor = clDefault then
    if AEnabled then
      if ASelected then
      begin
        if IsHighContrastWhite then
          AColor := clBtnFace // White
        else
          AColor := clHighLightText;
      end
      else
        AColor := clBtnText
    else
      AColor := clBtnShadow;

  DrawEnabled(ColorToRGB(AColor));
  if not AEnabled and not AFlat then
    DrawDisabled;
end;

procedure FrameFlatSelRect(DC: HDC; const R: TRect);
begin
  FrameRect(DC, R, GetSysColorBrush(COLOR_HIGHLIGHT));
end;

{ items global functions }

function GetWorkArea(const P: TPoint): TRect;
begin
  Result := GetDesktopWorkArea(P);
end;

procedure CheckEditWidth(var AWidth: Integer; AMinWidth: Integer);
begin
  if AWidth < AMinWidth then
    AWidth := AMinWidth;
end;

procedure RefreshDeviceConsts;
var
  DC: Integer;
begin
  DC := GetDC(0);
  try
    BitsPerPixel := GetDeviceCaps(DC, BITSPIXEL);
  finally
    ReleaseDC(0, DC);
  end;
end;

procedure CreatePatternBrush;
var
  Pattern: TBitmap;
  X, Y: Integer;
begin
  if FUnitIsFinalized then
    Exit;
  Pattern := TBitmap.Create;
  with Pattern, Canvas do
  begin
    Width := 8;
    Height := 8;
    Brush.Color := GetSysColor(COLOR_BTNHIGHLIGHT);
    FillRect(Rect(0, 0, Width, Height));
    for Y := 0 to 7 do
      for X := 0 to 7 do
        if (Y mod 2) = (X mod 2) then
          Pixels[X, Y] := GetSysColor(COLOR_BTNFACE);
  end;
  DeleteGDIObject(PatternBrush);
  PatternBrush := Windows.CreatePatternBrush(Pattern.Handle);
  Pattern.Free;
end;

procedure DrawVerticalGradient(Canvas: TCanvas; const ARect: TRect;
  FromR, ToR, FromG, ToG, FromB, ToB: Byte);
begin
  FillGradientRect(Canvas.Handle, ARect, RGB(FromR, FromG, FromB), RGB(ToR, ToG, ToB), False);
end;

procedure DrawDisablingHatch(ADC: HDC; const ARect: TRect);
begin
  cxDrawHatch(ADC, ARect, clBlack, clBtnFace, 2, 20, 170);
end;

procedure TransparentDraw(DrawDC: HDC; const R: TRect; AGlyph: TGraphic; AEnabled: Boolean = True);
begin
  cxDrawImage(DrawDC, R, R, AGlyph, nil, -1, EnabledImageDrawModeMap[AEnabled]);
end;

procedure TransparentDraw(DrawDC: HDC; Brush: HBRUSH; const FullRect, R: TRect; AGlyph: TGraphic; AImages: TCustomImageList;
  AImageIndex: Integer; AImageListBkColor: TColor; AEnabled, AGrayScale, AFlat, ASelected, ADown, APressed, AShadow, AFaded: Boolean;
  ASmoothImage: Boolean = False; AUseLeftBottomPixelAsTransparent: Boolean = True; AColorPalette: IdxColorPalette = nil);
begin
  TransparentDraw(nil, DrawDC, Brush, FullRect, R, AGlyph, AImages, AImageIndex, AImageListBkColor, AEnabled, AGrayScale,
    AFlat, ASelected, ADown, APressed, AShadow, AFaded, ASmoothImage, AUseLeftBottomPixelAsTransparent, AColorPalette);
end;

procedure TransparentDraw(ABarItemControl: TdxBarItemControl; DrawDC: HDC; Brush: HBRUSH;
  const FullRect, R: TRect; AGlyph: TGraphic; AImages: TCustomImageList; AImageIndex: Integer; AImageListBkColor: TColor;
  AEnabled, AGrayScale, AFlat, ASelected, ADown, APressed, AShadow, AFaded: Boolean; ASmoothImage: Boolean = False;
  AUseLeftBottomPixelAsTransparent: Boolean = True; AColorPalette: IdxColorPalette = nil);

  function GetDrawMode: TcxImageDrawMode;
  begin
    Result := idmNormal;
    if AEnabled or AFaded then
    begin
      if not AEnabled then
        Result := idmFaded
      else
        if AGrayScale then
          Result := idmGrayScale
        else
          if AFlat then
          begin
            if not ASelected and not ADown and dxBarMakeInactiveImagesDingy and (BitsPerPixel > 8) then
              Result := idmDingy
            else
              if AShadow and ASelected and not APressed {and not ADown} then
                Result := idmShadowed;
          end;
    end
    else
      Result := idmDisabled;
  end;

var
  ADrawMode: TcxImageDrawMode;
begin
  if IsGlyphAssigned(AGlyph) then
    AImageListBkColor := clNone;

  ADrawMode := GetDrawMode;
  if (ABarItemControl <> nil) and ABarItemControl.BarManager.ImageOptions.CacheGlyphs and (ADrawMode <> idmShadowed) then
  begin
    if Brush <> 0 then
      FillRect(DrawDC, FullRect, Brush);

    ABarItemControl.FGlyphCache.Update(R, AGlyph, AImages, AImageIndex, ADrawMode,
      AImageListBkColor, ASmoothImage, AUseLeftBottomPixelAsTransparent, AColorPalette);
    ABarItemControl.FGlyphCache.Draw(DrawDC, R);
  end
  else
    cxDrawImage(DrawDC, R, FullRect, AGlyph, AImages, AImageIndex, ADrawMode,
      ASmoothImage, Brush, AImageListBkColor, AUseLeftBottomPixelAsTransparent, AColorPalette);
end;

procedure ProcessMouseMessages;
var
  Msg: TMsg;
begin
  while PeekMessage(Msg, 0, WM_MOUSEFIRST, WM_MOUSELAST, PM_NOREMOVE) do
  begin
    case Integer(GetMessage(Msg, 0, WM_MOUSEFIRST, WM_MOUSELAST)) of
      -1: Break;
      0: begin
           PostQuitMessage(Msg.wParam);
           Break;
         end;
    end;
    DispatchMessage(Msg);
  end;
end;

procedure ProcessPaintMessages;
var
  Msg: TMsg;
begin
  while PeekMessage(Msg, 0, WM_PAINT, WM_PAINT, PM_REMOVE) do
    DispatchMessage(Msg);
end;

type
  TPlaySoundType = (psMenuPopup, psMenuCommand, psStopPlay);

procedure PlaySound(APlaySoundType: TPlaySoundType);
const
  PlaySounds: array[TPlaySoundType] of PChar = ('MenuPopup', 'MenuCommand', nil);
begin
  if dxBarPlaySound then
    MMSystem.PlaySound(PlaySounds[APlaySoundType], 0, SND_ALIAS or SND_ASYNC or SND_NODEFAULT or SND_NOWAIT);
end;

procedure InitMMSystem;
begin
  PlaySound(psStopPlay);
end;

procedure dxBlendAnimateWindow(AWnd: HWND; AAnimationTime: Integer);
const
  ShowFlags = SWP_NOZORDER or SWP_NOMOVE or SWP_NOSIZE or SWP_NOACTIVATE or SWP_SHOWWINDOW;
var
  ACurrentTime: Int64;
  AExStyle: TdxNativeInt;
  AFinishTime: Int64;
  AStartTime: Int64;
begin
  if Assigned(SetLayeredWindowAttributes) and (AAnimationTime > 0) then
  begin
    AExStyle := dxSetWindowStyle(AWnd, WS_EX_LAYERED, cxControls.soAdd, wsiExStyle);
    try
      SetLayeredWindowAttributes(AWnd, 0, 0, LWA_ALPHA);
      SetWindowPos(AWnd, 0, 0, 0, 0, 0, ShowFlags);

      AStartTime := dxGetExactTickCount;
      AFinishTime := AStartTime + dxTimeToTickCount(AAnimationTime);
      repeat
        ACurrentTime := Min(dxGetExactTickCount, AFinishTime);
        SetLayeredWindowAttributes(AWnd, 0, Trunc(MaxByte * (ACurrentTime - AStartTime) / (AFinishTime - AStartTime)), LWA_ALPHA);
        ProcessPaintMessages;
      until ACurrentTime = AFinishTime;
    finally
      dxSetWindowStyle(AWnd, AExStyle, soSet, wsiExStyle);
    end;
  end
  else
    SetWindowPos(AWnd, 0, 0, 0, 0, 0, ShowFlags);
end;

function CreateToolbarCaptionFontHandle(AFont: TFont; AUseSystemFont: Boolean; AScaleFactor: TdxScaleFactor): HFont;
var
  ALogFont: TLogFont;
begin
  ALogFont := dxSystemInfo.NonClientMetrics.lfSmCaptionFont;
  if not AUseSystemFont then
  begin
    ALogFont.lfHeight := Min(-11, ALogFont.lfHeight);
    StrPLCopy(ALogFont.lfFaceName, AFont.Name, LF_FACESIZE);
  end;
  ALogFont.lfHeight := AScaleFactor.Apply(ALogFont.lfHeight, dxSystemScaleFactor);
  Result := CreateFontIndirect(ALogFont);
end;

procedure CreateEditFontHandle(AFont: TFont; var AEditFont: TFont; AScaled: Boolean; AScaleFactor: TdxScaleFactor);
var
  ALogFont: TLogFont;
  ASystemLogFont: TLogFont;
begin
  if AScaled then
  begin
    dxSystemInfo.GetParameter(SPI_GETICONTITLELOGFONT, ASystemLogFont);
    dxGetFontData(AFont.Handle, ALogFont);
    ALogFont.lfHeight := AScaleFactor.Apply(Min(-11, ASystemLogFont.lfHeight), dxSystemScaleFactor);
    AEditFont.Handle := CreateFontIndirect(ALogFont);
  end
  else
    AEditFont.Handle := CloneFont(AFont.Handle);
end;

function CloneFont(AFontHandle: HFONT): HFONT;
begin
  Result := CreateFontIndirect(dxGetFontData(AFontHandle));
end;

procedure RestoreClipRgn(DC: HDC; var AClipRgn: HRGN; var AClipRgnExists: Boolean);
begin
  if AClipRgnExists then
    SelectClipRgn(DC, AClipRgn)
  else
    SelectClipRgn(DC, 0);
  DeleteObject(AClipRgn);
end;

procedure SaveClipRgn(DC: HDC; var AClipRgn: HRGN; var AClipRgnExists: Boolean);
begin
  AClipRgn := CreateRectRgn(0, 0, 0, 0);
  AClipRgnExists := GetClipRgn(DC, AClipRgn) = 1;
end;

procedure AddClipRect(DC: HDC; const R: TRect);
var
  ARgn: HRGN;
begin
  with R do
    ARgn := CreateRectRgn(Left, Top, Right, Bottom);
  ExtSelectClipRgn(DC, ARgn, RGN_OR);
  DeleteObject(ARgn);
end;

procedure ExcludeRect(var MainRgn: HRGN; const R: TRect);
var
  TempRgn: HRGN;
begin
  TempRgn := CreateRectRgnIndirect(R);
  CombineRgn(MainRgn, MainRgn, TempRgn, RGN_DIFF);
  DeleteObject(TempRgn);
end;

procedure FillBackgroundRect(DC: HDC; ADestR, ASourceR: TRect; ABrush: HBRUSH; AColor: TColor; AGraphic: TGraphic);
var
  ABrushExist: Boolean;
  ABitmap: TBitmap;
begin
  if (AGraphic <> nil) and not AGraphic.Empty then
  begin
    ABitmap :=  cxGetAsBitmap(AGraphic);
    try
      FillRectByBitmap(DC, ADestR, ASourceR, ABitmap)
    finally
      ABitmap.Free;
    end;
  end
  else
  begin
    ABrushExist := ABrush <> 0;
    if not ABrushExist then
      ABrush := CreateSolidBrush(ColorToRGB(AColor));
    FillRect(DC, ADestR, ABrush);
    if not ABrushExist then
      DeleteObject(ABrush);
  end;
end;

procedure FillRectByBitmap(DC: HDC; ADestR, ASourceR: TRect; ABitmap: TBitmap);
var
  W, H, RW, RH: Integer;
  I, J, XStart, XEnd, YStart, YEnd, X, Y: Integer;
  AClipRgn: HRGN;
  AClipRgnExists: Boolean;
begin
  W := ABitmap.Width;
  H := ABitmap.Height;
  RW := ASourceR.Right - ASourceR.Left;
  RH := ASourceR.Bottom - ASourceR.Top;
  if (W = 0) or (H = 0) or (RW = 0) or (RH = 0) then Exit;
  XStart := ASourceR.Left div W;
  XEnd := (ASourceR.Right - 1) div W;
  YStart := ASourceR.Top div H;
  YEnd := (ASourceR.Bottom - 1) div H;
  SaveClipRgn(DC, AClipRgn, AClipRgnExists);
  with ADestR do
    IntersectClipRect(DC, Left, Top, Right, Bottom);
  for J := YStart to YEnd do
    for I := XStart to XEnd do
    begin
      Y := J * H - (ASourceR.Top - ADestR.Top);
      X := I * W - (ASourceR.Left - ADestR.Left);
      BitBlt(DC, X, Y, W, H, ABitmap.Canvas.Handle, 0, 0, SRCCOPY);
    end;
  RestoreClipRgn(DC, AClipRgn, AClipRgnExists);
end;

procedure AfterDrawBackground(ADC: HDC; APrevWindowOrg: TPoint);
begin
  SetWindowOrgEx(ADC, APrevWindowOrg.X, APrevWindowOrg.Y, nil);
end;

function BeforeDrawBackground(ASourceControl, ADestinationControl: TWinControl;
  ADC: HDC; var ARect: TRect; out APrevWindowOrg: TPoint): TPoint;
begin
  Result := cxNullPoint;
  if (ASourceControl <> nil) and ASourceControl.HandleAllocated and
     (ADestinationControl <> nil) and ADestinationControl.HandleAllocated
  then
    Result := dxMapWindowPoint(ASourceControl.Handle, ADestinationControl.Handle, Result);
  OffsetWindowOrgEx(ADC, Result.X, Result.Y, APrevWindowOrg);
  ARect := cxRectOffset(ARect, Result);
end;

{ test of mouse keys pressing }

function IsMouseButtonPressed(AButton, ASwapButton: Integer): Boolean;
begin
  if GetSystemMetrics(SM_SWAPBUTTON) = 0 then
    Result := GetAsyncKeyState(AButton) < 0
  else
    Result := GetAsyncKeyState(ASwapButton) < 0;
end;

function LeftButtonPressed: Boolean;
begin
  Result := IsMouseButtonPressed(VK_LBUTTON, VK_RBUTTON);
end;

function RightButtonPressed: Boolean;
begin
  Result := IsMouseButtonPressed(VK_RBUTTON, VK_LBUTTON);
end;

function IsApplicationActive: Boolean;
begin
  Result := FApplicationActive and not FApplicationDeactivation and (GetActiveWindow <> 0);
end;

procedure dxFreeAndNilObjectLink(var ALink: TcxObjectLink);
var
  ATempLink: TcxObjectLink;
begin
  if ALink <> nil then
  begin
    ATempLink := ALink;
    ALink := nil;
    cxRemoveObjectLink(ATempLink);
  end;
end;

function dxBarMessageBox(AText: string; AFlags: Integer): Integer;
begin
  Result := Application.MessageBox(PChar(AText), PChar(Application.Title), AFlags);
end;

procedure dxBarFrameRect(ADC: HDC; ARect: TRect; AColor: Integer);
begin
  FrameRect(ADC, ARect, GetSysColorBrush(AColor));
  InflateRect(ARect, -1, -1);
  FrameRect(ADC, ARect, GetSysColorBrush(AColor));
end;

procedure dxBarFocusRect(ADC: HDC; ARect: TRect);

  procedure InternalSetPixel(X, Y: Integer);
  begin
    if (X + Y) mod 2 = 0 then
      SetPixel(ADC, X, Y, ColorToRGB(clBtnText));
  end;

  procedure InternalDrawFocusRect;
  var
    I: Integer;
  begin
    for I := ARect.Left to ARect.Right - 1 do
    begin
      InternalSetPixel(I, ARect.Top);
      InternalSetPixel(I, ARect.Bottom - 1);
    end;
    for I := ARect.Top to ARect.Bottom - 1 do
    begin
      InternalSetPixel(ARect.Left, I);
      InternalSetPixel(ARect.Right - 1, I);
    end;
  end;

begin
  InternalDrawFocusRect;
  InflateRect(ARect, -1, -1);
  InternalDrawFocusRect;
end;

function IsSelectableItem(AObject: TObject): Boolean;
var
  ASelectableItem: IdxBarSelectableItem;
begin
  Result := IsSelectableItem(AObject, ASelectableItem);
end;

function IsSelectableItem(AObject: TObject;
  out ASelectableItem: IdxBarSelectableItem): Boolean;
var
  ATempSelectableItem: IdxBarSelectableItem;
begin
  Result := Supports(AObject, IdxBarSelectableItem, ATempSelectableItem);
  if Result then
    ASelectableItem := ATempSelectableItem;
end;

function GetSelectableItem(AObject: TObject): IdxBarSelectableItem;
begin
  if not IsSelectableItem(AObject, Result) then
    Result := nil;
end;

procedure CleanSelectableItems(AItems: TdxObjectList);
var
  I: Integer;
begin
  for I := AItems.Count - 1 downto 0 do
    if not IsSelectableItem(AItems[I]) then
      AItems.Delete(I);
end;

function GetMaxViewLevel(AViewLevels: TdxBarItemViewLevels): TdxBarItemRealViewLevel;
begin
  for Result := Low(TdxBarItemRealViewLevel) to High(TdxBarItemRealViewLevel) do
    if Result in AViewLevels then
      Break;
end;

function GetMinViewLevel(AViewLevels: TdxBarItemViewLevels): TdxBarItemRealViewLevel;
begin
  for Result := High(TdxBarItemRealViewLevel) downto Low(TdxBarItemRealViewLevel) do
    if Result in AViewLevels then
      Break;
end;

function GetNextViewLevel(AViewLevels: TdxBarItemViewLevels;
  AViewLevel: TdxBarItemRealViewLevel): TdxBarItemRealViewLevel;
begin
  for Result := Succ(AViewLevel) to High(TdxBarItemRealViewLevel) do
    if Result in AViewLevels then
      Break;
end;

procedure BarDrawSizeGrip(DC: HDC; R: TRect);
const
  ROP_DSPDxax = $00E20746;
var
  APrevBitmap, ATempBitmap, AMaskBitmap: HBITMAP;
  TempDC, MDC, MaskDC: HDC;
  W, H: Integer;
  APrevBkColor: COLORREF;
begin
  W := R.Right - R.Left;
  H := R.Bottom - R.Top;
  TempDC := CreateCompatibleDC(DC);
  ATempBitmap := SelectObject(TempDC, CreateCompatibleBitmap(DC, W, H));
  try
    BitBlt(TempDC, 0, 0, W, H, DC, R.Left, R.Top, SRCCOPY); // 1
    MDC := CreateCompatibleDC(DC);
    APrevBitmap := SelectObject(MDC, CreateCompatibleBitmap(DC, W, H));
    DrawFrameControl(MDC, Rect(0, 0, W, H), DFC_SCROLL, DFCS_SCROLLSIZEGRIP); // 2

    MaskDC := CreateCompatibleDC(DC);
    AMaskBitmap := SelectObject(MaskDC, CreateBitmap(W, H, 1, 1, nil));
    try
      APrevBkColor := SetBkColor(MDC, ColorToRGB(clBtnFace)); //!
      BitBlt(MaskDC, 0, 0, W, H, MDC, 0, 0, SRCCOPY);
      SetBkColor(MDC, APrevBkColor);

      BitBlt(TempDC, 0, 0, W, H, MaskDC, 0, 0, MERGEPAINT);
      BitBlt(MDC, 0, 0, W, H, MaskDC, 0, 0, SRCPAINT);
      BitBlt(TempDC, 0, 0, W, H, MDC, 0, 0, SRCAND);
    finally
      DeleteObject(SelectObject(MaskDC, AMaskBitmap));
      DeleteDC(MaskDC);
    end;

    DeleteObject(SelectObject(MDC, APrevBitmap));
    DeleteDC(MDC);

    BitBlt(DC, R.Left, R.Top, W, H, TempDC, 0, 0, SRCCOPY);
  finally
    DeleteObject(SelectObject(TempDC, ATempBitmap));
    DeleteDC(TempDC);
  end;
end;

procedure dxBarPopup(APopup: TPopupMenu; AOwner: TWinControl; X, Y: Integer);
var
  ABarManager: TdxBarManager;
  ABarPopup: TdxBarPopupMenu;
  ALookAndFeel: IcxLookAndFeelContainer;
begin
  ABarManager := TdxBarManager.Create(AOwner);
  ABarPopup := TdxBarPopupMenu.Create(AOwner);
  try
    ABarManager.ImageOptions.SmoothGlyphs := True;
    ABarManager.Style := bmsUseLookAndFeel;
    if Supports(AOwner, IcxLookAndFeelContainer, ALookAndFeel) then
      ABarManager.LookAndFeel := ALookAndFeel.GetLookAndFeel;
    dxBarConvertPopupMenu(APopup, ABarPopup);
    ABarPopup.Popup(X, Y);
  finally
    ABarPopup.Free;
    ABarManager.Free;
  end;
end;

{ XP routines }

function ThemeEditState(ABarEditControl: TdxBarWinControl(*TdxBarEditControl*)): Integer; // TODO ReadOnly
begin
  if not ABarEditControl.Enabled then
    Result := ETS_DISABLED
  else
//    if ABarEditControl.ReadOnly then
//      Result := ETS_READONLY
//    else
      Result := ETS_NORMAL;
end;

function ThemeEditColor(ATheme: TdxTheme; AEditState: Integer): COLORREF;
begin
  Result := GetSysColor(COLOR_WINDOW);
  if AEditState = ETS_DISABLED then
  begin
    if FAILED(GetThemeColor(ATheme, EP_EDITTEXT, AEditState, TMT_FILLCOLOR, Result)) then
      Result := GetSysColor(COLOR_WINDOW);
  end;
end;

function ThemeEditTextColor(ATheme: TdxTheme; AEditState: Integer): COLORREF;
begin
  if FAILED(GetThemeColor(ATheme, EP_EDITTEXT, AEditState, TMT_TEXTCOLOR, Result)) then
  begin
    if AEditState = ETS_DISABLED then
      Result := GetSysColor(COLOR_GRAYTEXT)
    else
      Result := GetSysColor(COLOR_WINDOWTEXT);
  end;
end;

function ThemeToolbarColor: COLORREF;
var
  ATheme: TdxTheme;
begin
  ATheme := OpenTheme(totToolbar);
  if FAILED(GetThemeColor(ATheme, 0, 0, TMT_FILLCOLOR, Result)) then
    Result := COLOR_BTNFACE;
end;

function ThemeCloseButtonSize: TSize;
var
  ATheme: TdxTheme;
begin
  ATheme := OpenTheme(totWindow);
  GetThemePartSize(ATheme, 0, WP_SMALLCLOSEBUTTON, CBS_NORMAL, TS_TRUE, Result);
end;

procedure ThemeDrawCloseButton(DC: HDC; var R: TRect; ASelected, APressed: Boolean;
  ACorner: TdxCorner);
const
  ButtonStates: array [TdxBarMarkState] of Integer = (CBS_NORMAL, CBS_HOT, CBS_PUSHED);
var
  ATheme: TdxTheme;
  AState, X: Integer;
  ASize: TSize;
begin
  ATheme := OpenTheme(totWindow);
  if APressed then
    AState := CBS_PUSHED
  else
    if ASelected then
      AState := CBS_HOT
    else
      AState := CBS_NORMAL;
  ASize := ThemeCloseButtonSize;
  if (R.Bottom - R.Top) > ASize.cy then
    X := ((R.Bottom - R.Top) - ASize.cy) div 2
  else
    X := 0;
  if ACorner in [coTopRight, coBottomRight] then
  begin
    Inc(R.Left, X);
    R.Right := R.Left + ASize.cx;
  end
  else
  begin
    Dec(R.Right, X);
    R.Left := R.Right - ASize.cx;
  end;
  Inc(R.Top, X);
  R.Bottom := R.Top + ASize.cy;
  FillRect(DC, R, GetSysColorBrush(COLOR_BTNFACE));
  DrawThemeBackground(ATheme, DC, WP_SMALLCLOSEBUTTON, AState, R);
end;

function ThemeSizeGripSize: TSize;
const
  Offset = 2; // !
var
  ATheme: TdxTheme;
begin
  ATheme := OpenTheme(totScrollBar);
  GetThemePartSize(ATheme, 0, SBP_SIZEBOX, SZB_RIGHTALIGN, TS_TRUE, Result);
  Result.cx := Result.cx + Offset;
  Result.cy := Result.cy + Offset;
end;

procedure ThemeDrawSizeGrip(DC: HDC; var R: TRect; ACorner: TdxCorner);
const
  AOffset = 2; // !
  ADelta = 1;
var
  ATheme: TdxTheme;
  AMirrorX, AMirrorY: Boolean;
  R1: TRect;
  AScrollBarSize: TSize;
  APrevBitmap: HBITMAP;
  MDC: HDC;
  X, Y: Integer;
begin
  ATheme := OpenTheme(totScrollBar);
  AScrollBarSize := ThemeSizeGripSize;

  with R do
  begin
    if ACorner in [coTopRight, coBottomRight] then
      Left := Right - AScrollBarSize.cx - ADelta
    else
      Right := Left + AScrollBarSize.cx + ADelta;
    if ACorner in [coBottomLeft, coBottomRight] then
      Top := Bottom - AScrollBarSize.cy
    else
      Bottom := Top + AScrollBarSize.cy;
    AMirrorX := ACorner in [coTopLeft, coBottomLeft];
    AMirrorY := ACorner in [coTopLeft, coTopRight];
  end;

  FillRect(DC, R, GetSysColorBrush(COLOR_BTNFACE));

  R1 := R;
  with R1 do
  begin
    if AMirrorX then
      Dec(Right, AOffset)
    else
      Inc(Left, AOffset);
    if AMirrorY then
      Dec(Bottom, AOffset)
    else
      Inc(Top, AOffset);
  end;

  X := R1.Left;
  Y := R1.Top;
  OffsetRect(R1, -R1.Left, -R1.Top);
  MDC := CreateCompatibleDC(DC);
  APrevBitmap := SelectObject(MDC, CreateCompatibleBitmap(DC, R1.Right, R1.Bottom));
  FillRect(MDC, R1, COLOR_BTNFACE + 1);
  DrawThemeBackground(ATheme, MDC, SBP_SIZEBOX, SZB_RIGHTALIGN, R1);
  StretchBlt(DC, X, Y, R1.Right, R1.Bottom,
    MDC, Byte(AMirrorX) * (R1.Right - 1), Byte(AMirrorY) * (R1.Bottom - 1),
    (2 * Byte(not AMirrorX) - 1) * R1.Right,
    (2 * Byte(not AMirrorY) - 1) * R1.Bottom, SRCCOPY);
  DeleteObject(SelectObject(MDC, APrevBitmap));
  DeleteDC(MDC);
end;

{ TdxBarDropDownListBox }

type
  TdxBarDropDownListBox = class(TCustomListBox)
  private
    FCombo: TdxBarCustomCombo;
    FWaitForCapture: Boolean;

    function GetPainter: TdxBarPainter;
    procedure WMCaptureChanged(var Message: TMessage); message WM_CAPTURECHANGED;
    procedure WMEraseBkgnd(var Message: TWMEraseBkgnd); message WM_ERASEBKGND;
    procedure WMLButtonUp(var Message: TWMLButtonUp); message WM_LBUTTONUP;
    procedure WMNCCalcSize(var Message: TWMNCCalcSize); message WM_NCCALCSIZE;
    procedure WMNCPaint(var Message: TWMNCPaint); message WM_NCPAINT;
  protected
    procedure Click; override;
    procedure CreateParams(var Params: TCreateParams); override;
    procedure CreateWnd; override;
    procedure KeyDown(var Key: Word; Shift: TShiftState); override;
    procedure MouseMove(Shift: TShiftState; X, Y: Integer); override;
    property Painter: TdxBarPainter read GetPainter;
  public
    constructor Create(AOwner: TComponent); override;
    property OnDrawItem;
    property OnMeasureItem;
  end;

constructor TdxBarDropDownListBox.Create(AOwner: TComponent);
begin
  inherited;
  BorderStyle := bsNone;
  Style := lbOwnerDrawVariable;
  Visible := False;
end;

function TdxBarDropDownListBox.GetPainter: TdxBarPainter;
begin
  Result := TCustomdxBarControl(Parent).Painter;
end;

procedure TdxBarDropDownListBox.WMCaptureChanged(var Message: TMessage);
begin
  inherited;
  FWaitForCapture := False;
end;

procedure TdxBarDropDownListBox.WMEraseBkgnd(var Message: TWMEraseBkgnd);
begin
  Message.Result := 1;
end;

procedure TdxBarDropDownListBox.WMLButtonUp(var Message: TWMLButtonUp);
var
  ACombo: TdxBarCustomCombo;
  AItemIndex: Integer;
  AItemLink, RealItemLink: TdxBarItemLink;
begin
  inherited;
  if FWaitForCapture then
  begin
    ReleaseCapture;
    Exit;
  end;
  ACombo := FCombo;
  AItemIndex := ItemIndex;
  AItemLink := ACombo.CurItemLink;
  RealItemLink := AItemLink.RealItemLink;

  ACombo.DroppedDown := False;
  if RealItemLink <> nil then
    RealItemLink.BringToTopInRecentList(True);
  AItemLink.BarControl.HideAll(bcrEnter);
  if AItemIndex > -1 then
    ACombo.ItemIndex := AItemIndex;
end;

procedure TdxBarDropDownListBox.WMNCCalcSize(var Message: TWMNCCalcSize);
var
  ABorderSize: Integer;
begin
  inherited;
  ABorderSize := Painter.DropDownListBoxBorderSize;
  InflateRect(Message.CalcSize_Params.rgrc[0], -ABorderSize, -ABorderSize);
end;

procedure TdxBarDropDownListBox.WMNCPaint(var Message: TWMNCPaint);
var
  ARect: TRect;
  ADC: HDC;
begin
  inherited;
  ARect := cxGetWindowRect(Self);
  OffsetRect(ARect, -ARect.Left, -ARect.Top);
  ADC := GetWindowDC(Handle);
  cxPaintCanvas.BeginPaint(ADC);
  try
    cxPaintCanvas.ExcludeClipRect(cxRectInflate(ARect,
      -Painter.DropDownListBoxBorderSize, -Painter.DropDownListBoxBorderSize));
    Painter.DropDownListBoxDrawBorder(ADC, Color, ARect);
  finally
    cxPaintCanvas.EndPaint;
    ReleaseDC(Handle, ADC);
  end;
end;

procedure TdxBarDropDownListBox.Click;
begin
  if ItemIndex > -1 then
    TdxBarComboControl(FCombo.CurItemLink.Control).LocalItemIndex := ItemIndex;
end;

procedure TdxBarDropDownListBox.CreateParams(var Params: TCreateParams);
begin
  inherited;
  with Params do
  begin
    ExStyle := WS_EX_TOOLWINDOW or WS_EX_TOPMOST;
    AddBiDiModeExStyle(ExStyle);
    WindowClass.Style := WindowClass.Style or CS_SAVEBITS;
  end;
end;

procedure TdxBarDropDownListBox.CreateWnd;
begin
  inherited CreateWnd;
  Windows.SetParent(Handle, 0);
  CallWindowProc(DefWndProc, Handle, WM_SETFOCUS, 0, 0);
end;

procedure TdxBarDropDownListBox.KeyDown(var Key: Word; Shift: TShiftState);
begin
  if (ItemIndex = -1) and (Items.Count > 0) then
    ItemIndex := TopIndex;
  inherited;
end;

procedure TdxBarDropDownListBox.MouseMove(Shift: TShiftState; X, Y: Integer);
var
  I: Integer;
begin
  if (GetCapture = Handle) and FWaitForCapture and PtInRect(ClientRect, Point(X, Y)) then
  begin
    FWaitForCapture := False;
    CallWindowProc(DefWndProc, Handle, WM_LBUTTONDOWN, 0, MAKELPARAM(X, Y));
  end;
  inherited;
  I := ItemAtPos(Point(X, Y), True);
  if (0 <= I) and (I <= Items.Count - 1) then
    ItemIndex := I;
end;

procedure TdxCustomQuickCustItemControl.DoPaint(ARect: TRect; PaintType: TdxBarPaintType);
var
  AFullRect, R: TRect;
  ADC: HDC;
  ASelected: Boolean;
begin
  AFullRect := ARect;
  R := ARect;
  ASelected := IsSelected;
  ADC := Canvas.Handle;
  Painter.DrawQuickCustItemFrame(Self, ADC, R, ARect, ASelected);
  inherited;
  Painter.DrawGlyph(Self, ADC, R, cxEmptyRect, ptMenu, True, ASelected, IsDowned, False, False, True, False, False);
  Painter.DrawQuickCustItemFrameSelected(Self, ADC, AFullRect, R, ASelected);
end;

{ TdxBarContainerLinkData }

constructor TdxBarContainerLinkData.Create;
begin
  inherited Create;
  FExpandedItems := TObjectList.Create;
end;

destructor TdxBarContainerLinkData.Destroy;
begin
  FreeAndNil(FExpandedItems);
  inherited;
end;

{ TdxCustomQuickCustItemControl }

function TdxCustomQuickCustItemControl.GetDefaultWidth: Integer;
begin
  Result := inherited GetDefaultWidth + GetDefaultHeight;
end;

procedure TdxBarQuickCustItem.DoClick;
var
  ItemLink: TdxBarItemLink;
begin
  inherited;
  ItemLink := TdxBarItemLink(ClickItemLink.Data);
  with ItemLink do
    Visible := not Visible;
end;

function TdxBarQuickCustItemControl.GetLinkedItemLink: TdxBarItemLink;
begin
  Result := TdxBarItemLink(FItemLink.Data);
end;

procedure TdxBarQuickCustItemControl.ControlUnclick(ByMouse: Boolean);
begin
  inherited;
  Repaint;
end;

function TdxBarQuickCustItemControl.GetCaption: string;
begin
  Result := LinkedItemLink.Caption;
end;

function TdxBarQuickCustItemControl.GetGlyph: TdxSmartGlyph;
begin
  Result := LinkedItemLink.Glyph;
end;

function TdxBarQuickCustItemControl.GetImageIndex: Integer;
begin
  Result := LinkedItemLink.Item.ImageIndex;
end;

function TdxBarQuickCustItemControl.GetCurrentImages(
  AEnabled, AUseLargeImages: Boolean; var ADrawImageEnabled: TdxDefaultBoolean): TCustomImageList;
begin
  Result := LinkedItemLink.Item.GetCurrentImages;
end;

function TdxBarQuickCustItemControl.GetLargeGlyph: TdxSmartGlyph;
begin
  Result := LinkedItemLink.Item.LargeGlyph;
end;

function TdxBarQuickCustItemControl.GetLargeImageIndex: Integer;
begin
  Result := LinkedItemLink.Item.LargeImageIndex;
end;

function TdxBarQuickCustItemControl.IsDowned: Boolean;
begin
  Result := LinkedItemLink.Visible;
end;

function TdxBarQuickCustItemControl.GetHint: string;
begin
  Result := LinkedItemLink.Item.Hint;
end;

function TdxBarQuickCustItemControl.GetShortCut: TShortCut;
begin
  Result := LinkedItemLink.Item.ShortCut;
end;

function TdxBarQuickCustItemControl.CanDestroyOnClick: Boolean;
begin
  Result := False;
end;

{ TdxBarQuickCustExtButton and TdxBarQuickCustExtButtonControl }

type
  TdxBarQuickCustExtButton = class(TdxBarCustomButton);

  TdxBarQuickCustExtButtonControl = class(TdxCustomQuickCustItemControl)
  protected
    function GetTextAreaOffset: Integer; override;
    function IsDowned: Boolean; override;
  end;

function TdxBarQuickCustExtButtonControl.GetTextAreaOffset: Integer;
begin
  Result := inherited GetTextAreaOffset + GetDefaultHeight;
end;

function TdxBarQuickCustExtButtonControl.IsDowned: Boolean;
begin
  Result := False;
end;

{ TdxBarQuickAccessItem and TdxBarQuickAccessSubControl }

type
  TdxBarQuickAccessItem = class(TdxBarSubItem)
  protected
    function CreateBarControl: TCustomdxBarControl; override;
  public
    constructor Create(AOwner: TComponent); override;
  end;

  TdxBarQuickAccessSubControl = class(TdxBarSubMenuControl)
  protected
    function NeedShowGlyphAndCheckForItem: Boolean; override;
  end;

constructor TdxBarQuickAccessItem.Create(AOwner: TComponent);
begin
  inherited;
  ItemLinks.Internal := True;
end;

function TdxBarQuickAccessItem.CreateBarControl: TCustomdxBarControl;
begin
  Result := TdxBarQuickAccessSubControl.Create(BarManager)
end;

function TdxBarQuickAccessSubControl.NeedShowGlyphAndCheckForItem: Boolean;
begin
  Result := True;
end;

{ TdxBarPopupControl }

constructor TdxBarPopupControl.Create(AOwner: TComponent);
begin
  inherited;
  FInternalItems := TComponentList.Create;
end;

destructor TdxBarPopupControl.Destroy;
begin
  FreeAndNil(FHidingTimer);
  FreeAndNil(FInternalItems);
  inherited;
  if (FInternalBar <> nil) and not (csDestroying in FInternalBar.ComponentState) then
    FreeAndNil(FInternalBar);
end;

procedure TdxBarPopupControl.Hide;
begin
  CloseUp;
end;

procedure TdxBarPopupControl.CloseUp;
begin
  ParentBar.MarkState := msNone;
end;

procedure TdxBarPopupControl.Popup(const AOwnerRect: TRect);
var
  APopupDirection: TXDirection;
begin
  APopupDirection := xdRight;
  if UseRightToLeftAlignment then
    case APopupDirection of
      xdLeft:
        APopupDirection := xdRight;
    else
      APopupDirection := xdLeft;
    end;
  PopupEx(AOwnerRect, APopupDirection);
end;

procedure TdxBarPopupControl.PopupEx(const AOwnerRect: TRect; APopupDirection: TXDirection);
var
  ASize: TSize;
  P: TPoint;
begin
  ASize := GetPopupSize;
  P := GetPopupPosition(ASize, AOwnerRect, APopupDirection);
  CorrectPopupPosition(P, ASize, AOwnerRect, GetWorkArea(P));
  SetWindowPos(Handle, HWND_TOP, P.X, P.Y, ASize.cx, ASize.cy, SWP_NOACTIVATE);
  ShowWindow(Handle, SW_SHOWNOACTIVATE);
end;

procedure TdxBarPopupControl.StartHidingTimer;
begin
  FHidingTimer.Enabled := True;
end;

procedure TdxBarPopupControl.WindowPosChanged(var Message: TWMWindowPosChanged);
begin
  inherited;
  if IsPopup and (Message.WindowPos^.flags and SWP_HIDEWINDOW <> 0) and not IsDestroying then
    CloseUp;
end;

function TdxBarPopupControl.CanMoving: Boolean;
begin
  Result := False;
end;

function TdxBarPopupControl.GetMasterBar: TdxBar;
begin
  if FMasterBar <> nil then
    Result := FMasterBar
  else
    Result := inherited GetMasterBar;
end;

procedure TdxBarPopupControl.DoBeforeCaptionButtonClick;
begin
  if IsPopup then
    CloseUp;
end;

procedure TdxBarPopupControl.DoHideAll(AReason: TdxBarCloseUpReason);
var
  ALinkSelf: TcxObjectLink;
begin
  ALinkSelf := cxAddObjectLink(Self);
  try
    inherited;
    if (ALinkSelf.Ref <> nil) and IsPopup then
    begin
      if LeftButtonPressed and PtInRect(IgnoreClickAreaWhenHidePopup, GetMouseCursorPos) then
        ParentBar.FIgnoreMouseClick := True;
      CloseUp;
    end;
  finally
    cxRemoveObjectLink(ALinkSelf);
  end;
end;

function TdxBarPopupControl.IsPopup: Boolean;
begin
  Result := False;
end;

function TdxBarPopupControl.HasCloseButton: Boolean;
begin
  Result := False;
end;

function TdxBarPopupControl.NeedHideOnClick: Boolean;
begin
  Result := IsPopup;
end;

function TdxBarPopupControl.IsInternal: Boolean;
begin
  Result := IsPopup;
end;

procedure TdxBarPopupControl.SetLayeredAttributes;
begin
//do nothing
end;

function TdxBarPopupControl.AlwaysTrackMouse: Boolean;
begin
  Result := False;
end;

procedure TdxBarPopupControl.TrackMouse;
begin
// do nothing
end;

function TdxBarPopupControl.AllowResize: Boolean;
begin
  Result := False;
end;

function TdxBarPopupControl.GetPopupSize: TSize;
begin
  Result := cxNullSize;
end;

function TdxBarPopupControl.GetPopupPosition(const ASize: TSize; const AOwnerRect: TRect; APopupDirection: TXDirection): TPoint;
begin
  case APopupDirection of
    xdLeft: Result := Point(AOwnerRect.Right - ASize.cx, AOwnerRect.Bottom);
    xdRight: Result := Point(AOwnerRect.Left, AOwnerRect.Bottom);
  end;
end;

procedure TdxBarPopupControl.CorrectPopupPosition(var APosition: TPoint; const ASize: TSize; const AOwnerRect, AWorkArea: TRect);
begin
  if APosition.X < AWorkArea.Left then APosition.X := AWorkArea.Left;
  if APosition.X + ASize.cx > AWorkArea.Right then APosition.X := AWorkArea.Right - ASize.cx;
  if APosition.Y + ASize.cy > AWorkArea.Bottom then APosition.Y := AOwnerRect.Top - ASize.cy;
end;

function TdxBarPopupControl.LockHotTrackWhenPopup: Boolean;
begin
  Result := True;
end;

function TdxBarPopupControl.IgnoreClickAreaWhenHidePopup: TRect;
begin
  Result := dxMapWindowRect(ParentBar.Handle, 0, ParentBar.MarkRect);
end;

procedure TdxBarPopupControl.InitializeForPopup(AParentBarControl: TdxBarControl; ABar: TdxBar);
begin
  InitializeForDock(ABar);

  FMasterBar := ABar;
  ParentBar := AParentBarControl;

  FInternalBar := BarDesignController.AddInternalBar(BarManager);
  Bar := FInternalBar;
  Bar.UseOwnFont := False;

  ItemLinks := Bar.ItemLinks;
  ItemLinks.BarControl := Self;
  ItemLinks.Internal := True;

  FHidingTimer := cxCreateTimer(HidingTimerHandler, 200, False);
end;

procedure TdxBarPopupControl.HidingTimerHandler(Sender: TObject);
begin
  FHidingTimer.Enabled := False;

  if (BarManager.SelectedItem <> nil) and (GetParentBarForControl(BarManager.SelectedItem) <> Self) then
    CloseUp;
end;

procedure TdxBarPopupControl.WMNCHitTest(var Message: TWMNCHitTest);
begin
  inherited;
  if not AllowResize then
  begin
    with Message do
      if Result <> HTCLIENT then Result := HTBORDER;
    FHitTest := HTCLIENT;
  end;
end;

{ TdxBarQuickControl }

function TdxBarQuickControl.GetParentBar: TdxBarControl;
begin
  Result := inherited ParentBar as TdxBarControl;
end;

procedure TdxBarQuickControl.SetParentBar(Value: TdxBarControl);
begin
  inherited ParentBar := Value;
end;

procedure TdxBarQuickControl.WMNCPaint(var Message: TMessage);
var
  DC: HDC;
begin
  inherited;
  DC := GetWindowDC(Handle);
  Painter.BarDrawOwnerLink(Self, DC);
  ReleaseDC(Handle, DC);
end;

procedure TdxBarQuickControl.WMRButtonDown(var Message: TWMRButtonDown);
begin
  with TMessage(Message) do
    Result := DefWindowProc(Handle, Msg, wParam, lParam);
end;

procedure TdxBarQuickControl.InitializeForPopup(AParentBarControl: TdxBarControl; ABar: TdxBar);
begin
  inherited;
  OwnerBounds := ParentBar.MarkScreenRect;
end;

procedure TdxBarQuickControl.Paint;
begin
  DoPaint;
end;

function TdxBarQuickControl.GetParentForm: TCustomForm;
begin
  if ParentBar <> nil then
    Result := ParentBar.GetParentForm
  else
    Result := inherited GetParentForm;
end;

function TdxBarQuickControl.GetPopupSize: TSize;
begin
  Result := GetSizeForWidth(dsNone, 0);
  with Painter.GetToolbarContentOffsets(Bar, DockingStyle, ScaleFactor, False) do
  begin
    Inc(Result.cx, Left + Right);
    Inc(Result.cy, Top + Bottom);
  end;
end;

function TdxBarQuickControl.GetPopupPosition(const ASize: TSize; const AOwnerRect: TRect; APopupDirection: TXDirection): TPoint;
begin
  if ParentBar.IsRealVertical then
    Result := Point(AOwnerRect.Right, AOwnerRect.Top)
  else
    Result := inherited GetPopupPosition(ASize, AOwnerRect, APopupDirection);
end;

procedure TdxBarQuickControl.CorrectPopupPosition(var APosition: TPoint; const ASize: TSize; const AOwnerRect, AWorkArea: TRect);
begin
  if ParentBar.IsRealVertical then
  begin
    if APosition.X + ASize.cx > AWorkArea.Right then APosition.X := AOwnerRect.Left - ASize.cx;
    if APosition.Y < AWorkArea.Top then APosition.Y := AWorkArea.Top;
    if APosition.Y + ASize.cy > AWorkArea.Bottom then APosition.Y := AWorkArea.Bottom - ASize.cy;
  end
  else
    inherited;
end;

function TdxBarQuickControl.GetToolbarBrush: HBRUSH;
begin
  Result := Painter.BarToolbarBrushEx2(Self);
end;

function TdxBarQuickControl.HasCaption: Boolean;
begin
  Result := False;
end;

function TdxBarQuickControl.IsLinkedToOwner: Boolean;
begin
  Result := inherited IsLinkedToOwner(* or
    ((ParentBar <> nil) and (ParentBar.FQuickPopup = Self))*);
end;

function TdxBarQuickControl.IsPopup: Boolean;
begin
  Result := True;
end;

function TdxBarQuickControl.LockHotTrackWhenPopup: Boolean;
begin
  Result := False;
end;

function TdxBarQuickControl.NeedShowGlyphAndCheckForItem: Boolean;
begin
  Result := True;
end;

function TdxBarQuickControl.GetOwnerControl: TWinControl;
begin
  Result := ParentBar;
end;

function TdxBarQuickControl.Kind: TdxBarKind;
begin
  Result := bkBarQuickControl;
end;

procedure TdxBarQuickControl.Popup(const AOwnerRect: TRect);

  function GetDirection: TXDirection;
  begin
    if (ParentBar.DockingStyle = dsNone) and Painter.IsQuickControlPopupOnRight then
      Result := xdRight
    else
      Result := xdLeft;
    if UseRightToLeftAlignment then
      case Result of
        xdLeft:
          Result := xdRight;
      else
        Result := xdLeft;
      end;
  end;

begin
  PopupEx(AOwnerRect, GetDirection);
end;

{ TdxBarManagerCategories }

type
  TdxBarCategoryData = class
  public
    ItemsVisible, LoadedItemsVisible: TdxBarItemVisible;
    Visible: Boolean;
  end;

  TdxBarManagerCategories = class(TStringList)
  private
    FMoving: Boolean;
    FOwner: TdxBarManager;
    function GetItemsVisible(AIndex: Integer): TdxBarItemVisible;
    function GetVisible(AIndex: Integer): Boolean;
    procedure SetItemsVisible(AIndex: Integer; AValue: TdxBarItemVisible);
    procedure SetVisible(AIndex: Integer; AValue: Boolean);

    function NeedStoreItemsVisibilities(AAncestor: TPersistent): Boolean;
    function NeedStoreVisibilities(AAncestor: TPersistent): Boolean;
    procedure ReadItemsVisibilities(Reader: TReader);
    procedure ReadVisibilities(Reader: TReader);
    procedure WriteItemsVisibilities(Writer: TWriter);
    procedure WriteVisibilities(Writer: TWriter);

    procedure ChangeCategory(OldCategory, NewCategory: Integer);
    function IsIndexValid(AIndex: Integer): Boolean;
    procedure ListChanged(Sender: TObject);
    procedure QuickSort(ALeftBound, ARightBound: Integer; ACompareFunction: TStringListSortCompare);
  protected
    procedure ClearObject(AIndex: Integer);
    procedure ClearObjects;
    procedure DefineProperties(Filer: TFiler); override;
    //
    property Owner: TdxBarManager read FOwner;
  public
    constructor Create(AOwner: TdxBarManager);
    destructor Destroy; override;
    procedure Clear; override;
    procedure CustomSort(Compare: TStringListSortCompare); override;
    procedure Delete(Index: Integer); override;
    procedure Insert(Index: Integer; const S: string); override;
    procedure Exchange(Index1, Index2: Integer); override;
    procedure Move(CurIndex, NewIndex: Integer); override;
    //
    property ItemsVisible[AIndex: Integer]: TdxBarItemVisible read GetItemsVisible write SetItemsVisible;
    property Visible[AIndex: Integer]: Boolean read GetVisible write SetVisible;
  end;

constructor TdxBarManagerCategories.Create(AOwner: TdxBarManager);
begin
  inherited Create;
  FOwner := AOwner;
  if not Owner.IsLoading then
    Add(cxGetResourceString(@dxSBAR_DEFAULTCATEGORYNAME));
  OnChange := ListChanged;
end;

destructor TdxBarManagerCategories.Destroy;
begin
  ClearObjects;
  inherited;
end;

procedure TdxBarManagerCategories.Clear;
begin
  ClearObjects;
  inherited;
end;

procedure TdxBarManagerCategories.CustomSort(Compare: TStringListSortCompare);
begin
  if not Sorted and (Count > 1) then
  begin
    BeginUpdate;
    try
      QuickSort(0, Count - 1, Compare);
    finally
      EndUpdate;
    end;
  end;
end;

procedure TdxBarManagerCategories.ListChanged(Sender: TObject);
begin
  Owner.DesignerModified;
end;

procedure TdxBarManagerCategories.ChangeCategory(OldCategory, NewCategory: Integer);
var
  AList: TList;
  I: Integer;
begin
  if IsIndexValid(OldCategory) and (NewCategory > -1) then
  begin
    AList := TList.Create;
    try
      Owner.GetAllItemsByCategory(OldCategory, AList);
      for I := 0 to AList.Count - 1 do
        TdxBarItem(AList[I]).FCategory := NewCategory;
    finally
      AList.Free;
    end;
  end;
end;

procedure TdxBarManagerCategories.QuickSort(ALeftBound, ARightBound: Integer;
  ACompareFunction: TStringListSortCompare);
var
  ALeftIndex, ARightIndex, AMiddleIndex: Integer;
begin
  repeat
    ALeftIndex := ALeftBound;
    ARightIndex := ARightBound;
    AMiddleIndex := (ALeftBound + ARightBound) div 2;
    repeat
      while ACompareFunction(Self, ALeftIndex, AMiddleIndex) < 0 do
        Inc(ALeftIndex);
      while ACompareFunction(Self, ARightIndex, AMiddleIndex) > 0 do
        Dec(ARightIndex);
      if ALeftIndex <= ARightIndex then
      begin
        Exchange(ALeftIndex, ARightIndex);
        if AMiddleIndex = ALeftIndex then
          AMiddleIndex := ARightIndex
        else
          if AMiddleIndex = ARightIndex then
            AMiddleIndex := ALeftIndex;
        Inc(ALeftIndex);
        Dec(ARightIndex);
      end;
    until ALeftIndex > ARightIndex;
    if ALeftBound < ARightIndex then
      QuickSort(ALeftBound, ARightIndex, ACompareFunction);
    ALeftBound := ALeftIndex;
  until ALeftIndex >= ARightBound;
end;

function TdxBarManagerCategories.NeedStoreItemsVisibilities(AAncestor: TPersistent): Boolean;
var
  I: Integer;
begin
  Result := True;
  if (AAncestor is TdxBarManagerCategories) and (TdxBarManagerCategories(AAncestor).Count = Count) then
  begin
    Result := False;
    for I := 0 to Count - 1 do
    begin
      Result := ItemsVisible[I] <> TdxBarManagerCategories(AAncestor).ItemsVisible[I];
      if Result then Break;
    end;
  end;
end;

function TdxBarManagerCategories.NeedStoreVisibilities(AAncestor: TPersistent): Boolean;
var
  I: Integer;
begin
  Result := True;
  if (AAncestor is TdxBarManagerCategories) and (TdxBarManagerCategories(AAncestor).Count = Count) then
  begin
    Result := False;
    for I := 0 to Count - 1 do
    begin
      Result := Visible[I] <> TdxBarManagerCategories(AAncestor).Visible[I];
      if Result then Break;
    end;
  end;
end;

procedure TdxBarManagerCategories.ReadItemsVisibilities(Reader: TReader);
var
  AIndex: Integer;
  AValue: Integer;
begin
  Reader.ReadListBegin;
  try
    BeginUpdate;
    try
      AIndex := 0;
      while not Reader.EndOfList do
      begin
        AValue := Reader.ReadInteger;
        if AIndex < Count then
          ItemsVisible[AIndex] := TdxBarItemVisible(AValue);
        Inc(AIndex);
      end;
    finally
      EndUpdate;
    end;
  finally
    Reader.ReadListEnd;
  end;
end;

procedure TdxBarManagerCategories.ReadVisibilities(Reader: TReader);
var
  AIndex: Integer;
  AValue: Boolean;
begin
  Reader.ReadListBegin;
  try
    BeginUpdate;
    try
      AIndex := 0;
      while not Reader.EndOfList do
      begin
        AValue := Reader.ReadBoolean;
        if AIndex < Count then
          Visible[AIndex] := AValue;
        Inc(AIndex);
      end;
    finally
      EndUpdate;
    end;
  finally
    Reader.ReadListEnd;
  end;
end;

procedure TdxBarManagerCategories.WriteItemsVisibilities(Writer: TWriter);
var
  I: Integer;
begin
  Writer.WriteListBegin;
  try
    for I := 0 to Count - 1 do
      Writer.WriteInteger(LongInt(ItemsVisible[I]));
  finally
    Writer.WriteListEnd;
  end;
end;

procedure TdxBarManagerCategories.WriteVisibilities(Writer: TWriter);
var
  I: Integer;
begin
  Writer.WriteListBegin;
  try
    for I := 0 to Count - 1 do
      Writer.WriteBoolean(Visible[I]);
  finally
    Writer.WriteListEnd;
  end;
end;

function TdxBarManagerCategories.IsIndexValid(AIndex: Integer): Boolean;
begin
  Result := (0 <= AIndex) and (AIndex < Count);
end;

procedure TdxBarManagerCategories.ClearObject(AIndex: Integer);
begin
  if Objects[AIndex] <> nil then
  begin
    Objects[AIndex].Free;
    Objects[AIndex] := nil;
  end;
end;

procedure TdxBarManagerCategories.ClearObjects;
var
  I: Integer;
begin
  for I := 0 to Count - 1 do
    ClearObject(I);
end;

procedure TdxBarManagerCategories.DefineProperties(Filer: TFiler);
begin
  inherited DefineProperties(Filer);
  Filer.DefineProperty('ItemsVisibles', ReadItemsVisibilities,
    WriteItemsVisibilities, NeedStoreItemsVisibilities(Filer.Ancestor));
  Filer.DefineProperty('Visibles', ReadVisibilities,
    WriteVisibilities, NeedStoreVisibilities(Filer.Ancestor));
end;

procedure TdxBarManagerCategories.Delete(Index: Integer);

  procedure DeleteCategoryItems;
  var
    AList: TObjectList;
  begin
    AList := TObjectList.Create;
    try
      Owner.GetAllItemsByCategory(Index, AList);
    finally
      AList.Free;
    end;
  end;

var
  I: Integer;
begin
  if FMoving then
    inherited
  else
  begin
    if IsIndexValid(Index) then
    begin
      DeleteCategoryItems;
      for I := Index + 1 to Count - 1 do
        ChangeCategory(I, I - 1);
      ClearObject(Index);
      inherited;
    end;
    if Count = 0 then
      Add(cxGetResourceString(@dxSBAR_DEFAULTCATEGORYNAME));
  end;
end;

procedure TdxBarManagerCategories.Insert(Index: Integer; const S: string);
var
  I: Integer;
begin
  if not FMoving and IsIndexValid(Index) then
    for I := Count - 1 downto Index do
      ChangeCategory(I, I + 1);
  inherited Insert(Index, S);
end;

procedure TdxBarManagerCategories.Exchange(Index1, Index2: Integer);
var
  I: Integer;
  List1: TList;
  List2: TList;
begin
  if IsIndexValid(Index1) and IsIndexValid(Index2) then
  begin
    List1 := TList.Create;
    List2 := TList.Create;
    try
      Owner.GetAllItemsByCategory(Index1, List1);
      Owner.GetAllItemsByCategory(Index2, List2);
      for I := 0 to List1.Count - 1 do
        TdxBarItem(List1[I]).Category := Index2;
      for I := 0 to List2.Count - 1 do
        TdxBarItem(List2[I]).Category := Index1;
    finally
      List2.Free;
      List1.Free;
    end;
    inherited Exchange(Index1, Index2);
  end;
end;

procedure TdxBarManagerCategories.Move(CurIndex, NewIndex: Integer);
var
  List: TList;
  I: Integer;
begin
  if IsIndexValid(CurIndex) and IsIndexValid(NewIndex) and (CurIndex <> NewIndex) then
  begin
    List := TList.Create;
    try
      Owner.GetAllItemsByCategory(CurIndex, List);
      for I := 0 to List.Count - 1 do
        TdxBarItem(List[I]).FCategory := dxBarManagerTempCategoryIndex;
      if CurIndex < NewIndex then
        for I := CurIndex + 1 to NewIndex do
          ChangeCategory(I, I - 1)
      else
        for I := CurIndex - 1 downto NewIndex do
          ChangeCategory(I, I + 1);
      for I := 0 to List.Count - 1 do
        TdxBarItem(List[I]).FCategory := NewIndex;
    finally
      List.Free;
    end;
    FMoving := True;
    inherited Move(CurIndex, NewIndex);
    FMoving := False;
  end;
end;

function TdxBarManagerCategories.GetItemsVisible(AIndex: Integer): TdxBarItemVisible;
begin
  Result := Owner.CategoryItemsVisible[AIndex];
end;

function TdxBarManagerCategories.GetVisible(AIndex: Integer): Boolean;
begin
  Result := Owner.CategoryVisible[AIndex];
end;

procedure TdxBarManagerCategories.SetItemsVisible(AIndex: Integer; AValue: TdxBarItemVisible);
begin
  Owner.CategoryItemsVisible[AIndex] := AValue;
end;

procedure TdxBarManagerCategories.SetVisible(AIndex: Integer; AValue: Boolean);
begin
  Owner.CategoryVisible[AIndex] := AValue;
end;

{ TdxBarKeyTipData }

constructor TdxBarKeyTipData.Create(const AKeyTipInfo: TdxBarKeyTipInfo);
begin
  inherited Create;
  FKeyTipInfo := AKeyTipInfo;
end;

procedure TdxBarKeyTipData.HideKeyTipWindow(AKeyTipWindowsManager: IdxBarKeyTipWindowsManager);
begin
  if FKeyTipWindow <> nil then
  begin
    AKeyTipWindowsManager.Delete(FKeyTipWindow);
    FKeyTipWindow := nil;
  end;
end;

procedure TdxBarKeyTipData.ShowKeyTipWindow(AKeyTipWindowsManager: IdxBarKeyTipWindowsManager);
begin
  if FKeyTipWindow = nil then
    AKeyTipWindowsManager.Add(NormalizedKeyTip, BasePoint, HorzAlign, VertAlign, Enabled, FKeyTipWindow);
end;

function TdxBarKeyTipData.GetNormalizedKeyTip: string;
begin
  Result := AnsiUpperCase(KeyTip);
end;

{ TdxBarPersistent }

constructor TdxBarPersistent.Create(ABarManager: TdxBarManager);
begin
  inherited Create;
  FBarManager := ABarManager;
end;

function TdxBarPersistent.GetOwner: TPersistent;
begin
  Result := FBarManager;
end;

{ TdxBarControlEditor }

class procedure TdxBarControlEditor.InitCustomizationPopup(AItemLinks: TdxBarItemLinks);
var
  AItemLink: TdxBarItemLink;
begin
  AItemLink := BarDesignController.AddInternalItem(AItemLinks, PopupItemClass, GetPopupItemCaption);
  InitializePopupItem(AItemLink);
end;

class function TdxBarControlEditor.GetAddedItemClass(const AAddedItemName: string): TdxBarItemClass;
begin
  Result := nil;
end;

class function TdxBarControlEditor.GetPopupItemCaption: string;
begin
  Result := '';
end;

class procedure TdxBarControlEditor.InitializePopupItem(AItemLink: TdxBarItemLink);
begin
// do nothing
end;

class function TdxBarControlEditor.PopupItemClass: TdxBarItemClass;
begin
  Result := nil;
end;

class procedure TdxBarControlEditor.AddItem(AClickedButton: TdxBarButton);
var
  AItemLink: TdxBarItemLink;
begin
  BarDesignController.FCustomizingItemLinks.BeginUpdate;
  try
    AItemLink := BarDesignController.AddItem(GetAddedItemClass(AClickedButton.Caption));
    InitializeAddedItem(AItemLink, AClickedButton.Caption);
  finally
    BarDesignController.FCustomizingItemLinks.EndUpdate;
  end;
//  BarDesignController.SelectItem(AItemLink);
//  AItemLink.BarControl.SetKeySelectedItem(AItemLink.Control);
  AItemLink.BarControl.SelectItemControl(AItemLink.Control, mbRight, []);
end;

class procedure TdxBarControlEditor.InitializeAddedItem(AItemLink: TdxBarItemLink; AAddedItemName: string);
begin
// do nothing
end;

class procedure TdxBarControlEditor.OnButtonClick(Sender: TObject);
begin
  AddItem(Sender as TdxBarButton);
end;

{ TdxAddSubItemEditor }

class function TdxAddSubItemEditor.GetAddedItemClass(const AAddedItemName: string): TdxBarItemClass;
begin
  Result := TdxBarSubItem;
end;

class function TdxAddSubItemEditor.GetPopupItemCaption: string;
begin
  Result := dxSBAR_CP_ADDSUBITEM;
end;

class procedure TdxAddSubItemEditor.InitializePopupItem(AItemLink: TdxBarItemLink);
begin
  (AItemLink.Item as TdxBarButton).OnClick := OnButtonClick;
  AItemLink.Item.Enabled := BarDesignController.CustomizingBarManager.CanAddComponents;
end;

class function TdxAddSubItemEditor.PopupItemClass: TdxBarItemClass;
begin
  Result := TdxBarButton;
end;

{ TdxAddButtonEditor }

class function TdxAddButtonEditor.GetAddedItemClass(const AAddedItemName: string): TdxBarItemClass;
begin
  Result := TdxBarButton;
end;

class function TdxAddButtonEditor.GetPopupItemCaption: string;
begin
  Result := dxSBAR_CP_ADDBUTTON;
end;

{ TdxAddLargeButtonEditor }

class function TdxAddLargeButtonEditor.GetAddedItemClass(const AAddedItemName: string): TdxBarItemClass;
begin
  Result := TdxBarLargeButton;
end;

class function TdxAddLargeButtonEditor.GetPopupItemCaption: string;
begin
  Result := dxSBAR_CP_ADDLARGEBUTTON;
end;

{ TdxAddSeparatorEditor }

class function TdxAddSeparatorEditor.GetAddedItemClass(const AAddedItemName: string): TdxBarItemClass;
begin
  Result := TdxBarSeparator;
end;

class function TdxAddSeparatorEditor.GetPopupItemCaption: string;
begin
  Result := dxSBAR_CP_ADDSEPARATOR;
end;

{ TdxItemsEditorEx }

class procedure TdxItemsEditorEx.InitSubItem(AItemLinks: TdxBarItemLinks);
var
  I: Integer;
begin
  for I := 0 to RegdxItemList.VisibleItemCount - 1 do
    BarDesignController.AddInternalItem(AItemLinks, TdxBarButton,
      RegdxItemList.VisibleItemClass[I].ClassName, OnButtonClick);
end;

class function TdxItemsEditorEx.GetAddedItemClass(const AAddedItemName: string): TdxBarItemClass;
begin
  Result := TdxBarItemClass(FindClass(AAddedItemName));
end;

class function TdxItemsEditorEx.GetPopupItemCaption: string;
begin
  Result := dxSBAR_CP_ADDDXITEM;
end;

class procedure TdxItemsEditorEx.InitializePopupItem(AItemLink: TdxBarItemLink);
var
  ASubItem: TdxBarSubItem;
begin
  ASubItem := TdxBarSubItem(AItemLink.Item);
  ASubItem.Enabled := BarDesignController.CustomizingBarManager.CanAddComponents;
  ASubItem.IsInternal := True;
  if ASubItem.Enabled then
  begin
    ASubItem.ItemLinks.BeginUpdate;
    try
      InitSubItem(ASubItem.ItemLinks);
    finally
      ASubItem.ItemLinks.EndUpdate;
    end;
  end;
end;

class function TdxItemsEditorEx.PopupItemClass: TdxBarItemClass;
begin
  Result := TdxBarSubItem;
end;

{ TCustomdxBarControlDesignHelper }

class function TCustomdxBarControlDesignHelper.CanDynamicallyChangeViewLevels: Boolean;
begin
  Result := False;
end;

class procedure TCustomdxBarControlDesignHelper.FilterItemActions(var ASupportedActions: TdxBarCustomizationActions);
begin
  ASupportedActions := ASupportedActions - GetForbiddenActions;
end;

class procedure TCustomdxBarControlDesignHelper.GetEditors(AEditors: TList);
var
  I: Integer;
begin
  for I := 0 to BarDesignController.FRegisteredBarControlEditors.Count - 1 do
    AEditors.Add(BarDesignController.FRegisteredBarControlEditors[I])
end;

class function TCustomdxBarControlDesignHelper.GetForbiddenActions: TdxBarCustomizationActions;
begin
  Result := [caChangeButtonPaintStyle, caChangePosition, caChangeViewLevels,
    caChangeButtonGroup, caChangeRecentList, caChangeDistributed]
end;

{ TdxBarControlDesignHelper }

class function TdxBarControlDesignHelper.GetForbiddenActions: TdxBarCustomizationActions;
begin
  Result := inherited GetForbiddenActions - [caChangeButtonPaintStyle];
end;

{ TdxBarSubMenuControlDesignHelper }

class procedure TdxBarSubMenuControlDesignHelper.GetEditors(AEditors: TList);
begin
  inherited GetEditors(AEditors);
  AEditors.Add(TdxAddSeparatorEditor);
end;

class function TdxBarSubMenuControlDesignHelper.GetForbiddenActions: TdxBarCustomizationActions;
begin
  Result := inherited GetForbiddenActions - [caChangeRecentList];
end;

{ TdxBarDesignController }

constructor TdxBarDesignController.Create;
begin
  inherited Create;
  FRegisteredBarControlDesignHelpers := TcxRegisteredClassList.Create;
  FRegisteredBarControlEditors := TList.Create;
  FNotifyComponent := TcxFreeNotificator.Create(nil);
  FNotifyComponent.OnFreeNotification := FreeNotification;
  FInternalItems := TComponentList.Create;
end;

destructor TdxBarDesignController.Destroy;
begin
  FreeAndNil(FToolbarsPopup);
  FreeAndNil(FCustomizationPopup);
  FreeAndNil(FInternalItems);
  FreeAndNil(FNotifyComponent);
  FreeAndNil(FRegisteredBarControlEditors);
  FreeAndNil(FRegisteredBarControlDesignHelpers);
  inherited;
end;

procedure TdxBarDesignController.AddCustomizeItem(AItemLinks: TdxBarItemLinks;
  AItemClass: TdxBarItemClass; ABeginGroup: Boolean = True);
var
  AItemLink: TdxBarItemLink;
begin
  if AItemLinks.BarManager.CanCustomize then
  begin
    AItemLink := AddInternalItem(AItemLinks, AItemClass,
      cxGetResourceString(@dxSBAR_CUSTOMIZE), CustomizeItemClick);
    AItemLink.BeginGroup := ABeginGroup;
    AItemLink.Item.Enabled := dxBarCustomizingForm = nil;
  end;
end;

function TdxBarDesignController.AddInternalItem(AItemLinks: TdxBarItemLinks;
  AItemClass: TdxBarItemClass; ACaption: string; AOnClick: TNotifyEvent = nil;
  ATag: TcxTag = 0; ABeginGroup: Boolean = False): TdxBarItemLink;
var
  AItem: TdxBarItem;
begin
  Result := AItemLinks.AddItem(AItemClass, nil);
  AItem := Result.Item;
  AddInternalItem(AItem);

  AItem.Caption := ACaption;
  AItem.OnClick := AOnClick;
  AItem.Tag := ATag;
  Result.BeginGroup := ABeginGroup;
end;

procedure TdxBarDesignController.AddInternalItem(AItem: TdxBarItem; AList: TList = nil);
begin
  if AList = nil then
    AList := FInternalItems;

  AList.Add(AItem);
  RemoveItemFromBarManagerList(AItem);
end;

procedure TdxBarDesignController.ClearInternalItems;
begin
  FInternalItems.Clear;
end;

procedure TdxBarDesignController.RemoveItemFromBarManagerList(AItem: TdxBarItem);
begin
  AItem.BarManager.ItemList.Remove(AItem);
end;

function TdxBarDesignController.AddItem(ABarItemClass: TdxBarItemClass): TdxBarItemLink;
var
  ACategoryIndex, AItemIndex: Integer;
  AItem: TdxBarItem;
begin
  CustomizingBarManager.ItemList.BeginUpdate;
  try
    FCustomizingItemLinks.BeginUpdate;
    try
      Result := FCustomizingItemLinks.AddItem(ABarItemClass, {GetBarManagerForm(FCustomizingBarManager, fkAny).Designer.GetRoot} FCustomizingBarManager.Owner);

      AItem := Result.Item;
      ACategoryIndex := FCustomizingBarManager.Categories.IndexOf(dxSBAR_DEFAULTCATEGORYNAME);
      if ACategoryIndex = -1 then
        ACategoryIndex := 0;
      AItem.Category := ACategoryIndex;
      AItem.Name := FCustomizingBarManager.GetUniqueItemName(ABarItemClass);
      AItem.Caption := ABarItemClass.GetNewCaption;
      AItemIndex := FCustomizingItemLinks.IndexOf(CustomizingItemLink);
      if AItemIndex <> -1 then
        Result.Index := AItemIndex + 1;
    finally
      FCustomizingItemLinks.EndUpdate;
    end;
  finally
    CustomizingBarManager.ItemList.EndUpdate;
  end;
end;

procedure TdxBarDesignController.SelectItemLink(AItemLink: TdxBarItemLink);
begin
  if (CustomizingBarControl <> nil) and
     not IsRectEmpty(CustomizingBarControl.GetItemRect(AItemLink.Control)) then
  begin
    CustomizingBarControl.BarGetFocus(AItemLink.Control);
    SelectItem(AItemLink);
  end;
end;

procedure TdxBarDesignController.DesignerModified;
begin
  FCustomizingBarManager.DesignerModified;
end;

function TdxBarDesignController.IsCustomizedByPopup: Boolean;
begin
  Result := (FCustomizationPopup <> nil) and (FCustomizationPopup.BarControl <> nil);
end;

procedure TdxBarDesignController.RegisterBarControlDesignHelper(
  ABarControlClass: TCustomdxBarControlClass;
  AHelperClass: TCustomdxBarControlDesignHelperClass);
begin
  FRegisteredBarControlDesignHelpers.Register(ABarControlClass, AHelperClass);
end;

procedure TdxBarDesignController.RegisterBarControlEditor(AEditor: TdxBarControlEditorClass);
begin
  FRegisteredBarControlEditors.Add(AEditor);
end;

procedure TdxBarDesignController.UnregisterBarControlDesignHelper(
  ABarControlClass: TCustomdxBarControlClass;
  AHelperClass: TCustomdxBarControlDesignHelperClass);
begin
  FRegisteredBarControlDesignHelpers.Unregister(ABarControlClass, AHelperClass);
end;

procedure TdxBarDesignController.UnregisterBarControlEditor(
  AEditor: TdxBarControlEditorClass);
begin
  FRegisteredBarControlEditors.Remove(AEditor);
end;

procedure TdxBarDesignController.DropSelection(ASelectableItem: IdxBarSelectableItem);
begin
  if IsItemLastSelected(ASelectableItem) then
    FLastSelectedItem := nil;
end;

function TdxBarDesignController.IsItemCustomized(ASelectableItem: IdxBarSelectableItem): Boolean;
begin
  Result := IsCustomizedByPopup and (ASelectableItem.GetInstance = FCustomizingItemLink);
end;

function TdxBarDesignController.IsItemLastSelected(ASelectableItem: IdxBarSelectableItem): Boolean;
begin
  Result := (ASelectableItem <> nil) and (ASelectableItem = LastSelectedItem);
end;

function TdxBarDesignController.IsItemLinkCustomized: Boolean;
begin
  Result := IsCustomizedByPopup and (FCustomizingItemLink <> nil);
end;

function TdxBarDesignController.IsItemSingleSelected(ASelectableItem: IdxBarSelectableItem): Boolean;
begin
  Result := (ASelectableItem <> nil) and IsSelectionSingle(ASelectableItem.GetBarManager);
end;

function TdxBarDesignController.IsSelectionComplex(ABarManager: TdxBarManager): Boolean;
var
  ASelection: TdxObjectList;
  I: Integer;
begin
  Result := False;
  ASelection := TdxObjectList.Create;
  try
    ABarManager.GetSelection(ASelection);
    CleanSelectableItems(ASelection);
    for I := 0 to ASelection.Count - 1 do
      Result := Result or GetSelectableItem(ASelection[I]).IsComplex;
  finally
    ASelection.Free;
  end;
end;

function TdxBarDesignController.IsSelectionSingle(ABarManager: TdxBarManager): Boolean;
var
  ASelection: TdxObjectList;
begin
  ASelection := TdxObjectList.Create;
  try
    ABarManager.GetSelection(ASelection);
    CleanSelectableItems(ASelection);
    Result := ASelection.Count = 1;
  finally
    ASelection.Free;
  end;
end;

function TdxBarDesignController.NeedDefaultSelection(ASelectableItem: IdxBarSelectableItem): Boolean;
begin
//  Result := IsItemCustomized(ASelectableItem) or IsItemSingleSelected(ASelectableItem) and not IsSelectionComplex(ASelectableItem.GetBarManager);
  Result := not ASelectableItem.GetBarManager.Designing and IsItemLastSelected(ASelectableItem) or
    IsSelectionSingle(ASelectableItem.GetBarManager) and
    (not IsSelectionComplex(ASelectableItem.GetBarManager) or IsItemCustomized(ASelectableItem));
end;

procedure TdxBarDesignController.SelectItem(ASelectableItem: IdxBarSelectableItem;
  ASelectionOperation: TdxBarSelectionOperation = soExclusive);
begin
  if ASelectableItem <> nil then
    ASelectableItem.SelectComponent(ASelectionOperation);
  case ASelectionOperation of
    soAdd, soExclusive: LastSelectedItem := ASelectableItem;
    soExclude: SynchronizeLastSelectedItem;
  end;
end;

procedure TdxBarDesignController.SelectObject(AObject: TPersistent;
  ASelectionOperation: TdxBarSelectionOperation);
begin
  if GetSelectableItem(AObject) <> nil then
    SelectItem(GetSelectableItem(AObject), ASelectionOperation)
  else
    CustomizingBarManager.SelectComponent(AObject, ASelectionOperation);
end;

procedure TdxBarDesignController.SynchronizeLastSelectedItem;
begin
  if (LastSelectedItem <> nil) and
    (not LastSelectedItem.IsComponentSelected or not IsApplicationActive)then
    LastSelectedItem := nil;
end;

function TdxBarDesignController.DeleteSelectedObjects(ADestruction, AIsKeyboardAction: Boolean): Boolean;

  function IsComplexItemSelected(ASelection: TdxObjectList): Boolean;
  var
    I: Integer;
  begin
    Result := False;
    for I := 0 to ASelection.Count - 1 do
      Result := Result or (ASelection[I] is TdxBarItem) and (TdxBarItem(ASelection[I]).LinkCount > 1);
  end;

  function GetNextSelectedObject(ASelection: TdxObjectList): TPersistent;

    function CanSelect(AObject: TObject): Boolean;
    begin
      Result := (ASelection.IndexOf(AObject) = -1) and IsObjectUnbound(AObject, ASelection);
    end;

  var
    ASelectableItem, ANextSelectableItem: IdxBarSelectableItem;
  begin
    Result := nil;
    ASelectableItem := GetSelectableItem(ASelection.Last);
    ANextSelectableItem := ASelectableItem.GetNextSelectableItem;
    while (Result = nil) and (ANextSelectableItem <> nil) and (ANextSelectableItem.GetInstance <> ASelectableItem.GetInstance) do
    begin
      if CanSelect(ANextSelectableItem.GetInstance) then
        Result := ANextSelectableItem.GetInstance;
      ANextSelectableItem := ANextSelectableItem.GetNextSelectableItem;
    end;
    if (Result = nil) and CanSelect(ASelectableItem.GetSelectableParent) then
      Result := ASelectableItem.GetSelectableParent;
  end;

var
  ASelection: TdxObjectList;
  ASelectableItem: IdxBarSelectableItem;
  ANextSelectedObject: TPersistent;
  I: Integer;
begin
  Result := False;

  FindCustomizingBarManager;
  if CanCustomize(CustomizingBarManager, AIsKeyboardAction) then
  begin
    if CustomizingBarManager.Designing then
    begin
      ASelection := TdxObjectList.Create;
      try
        GetSelection(ASelection);
        RemoveIrrelevantObjectsForDelete(ASelection, ADestruction);
        if ASelection.Count > 0 then
        begin
          Result := True;
          if ADestruction or not IsComplexItemSelected(ASelection) or
            (dxBarMessageBox(dxSBAR_WANTTODELETECOMPLEXITEM, MB_YESNO) = IDYES) then
          begin
            CustomizingBarManager.BeginUpdate;
            try
              ANextSelectedObject := GetNextSelectedObject(ASelection);
              for I := ASelection.Count - 1 downto 0 do
              begin
                ASelectableItem := GetSelectableItem(ASelection[I]);
                ASelectableItem.DeleteSelection(ASelectableItem, ADestruction);
              end;
              if ANextSelectedObject <> nil then
                SelectObject(ANextSelectedObject);
            finally
              CustomizingBarManager.EndUpdate;
            end;
            DesignerModified;
          end;
        end;
      finally
        ASelection.Free;
      end;
    end
    else
      CustomizingBarManager.LastSelectedLinkAtDesign.Free;
  end;
end;

procedure TdxBarDesignController.DeleteCustomizingItem;
begin
  if FCustomizingItemLink = nil then Exit;
  FCustomizingItemLink.Item.Free;
  FCustomizingItemLink := nil;
end;

procedure TdxBarDesignController.DeleteCustomizingItemLink;
begin
  FreeAndNil(FCustomizingItemLink);
end;

function TdxBarDesignController.SelectParentComponent: Boolean;
var
  ASelectedObjects: TdxObjectList;
  ASelectableItem: IdxBarSelectableItem;
begin
  FindCustomizingBarManager;
  if CanCustomize(CustomizingBarManager, True) then
  begin
    ASelectedObjects := TdxObjectList.Create;
    try
      CustomizingBarManager.GetActiveSelection(ASelectedObjects);
      Result := IsSelectableItem(ASelectedObjects.Last, ASelectableItem) and
        ASelectableItem.SelectParentComponent;
    finally
      ASelectedObjects.Free;
    end;
  end
  else
    Result := False;
end;

function TdxBarDesignController.AddInternalBar(ABarManager: TdxBarManager): TdxBar;
begin
  ABarManager.Bars.BeginUpdate;
  try
    Result := ABarManager.Bars.Add;
    Result.AllowQuickCustomizing := False;
    Result.Hidden := True;
  finally
    ABarManager.Bars.EndUpdate(False);
  end;
end;

procedure TdxBarDesignController.ShowCustomCustomizePopup(
  ABarManager: TdxBarManager; AInitPopupProc: TInitPopupProc; APainter: TdxBarPainter; APopupPoint: TPoint;
  ACustomizingBarControl: TCustomdxBarControl = nil; ACustomizingItemLink: TdxBarItemLink = nil);

  procedure DeactivateCustomizingItem;
  begin
//    if (FCustomizingBarControl <> nil) and FCustomizingBarControl.IsFocused then
//      FCustomizingBarControl.SetMouseSelectedItem(GetControlByLink(FCustomizingItemLink));
    if (FCustomizingBarControl <> nil) and (FCustomizingBarControl.SelectedControl <> nil) then
      FCustomizingBarControl.SelectedControl.ControlInactivate(False);
  end;

var
  APopupControl: TdxBarCustomizingPopup;
begin
  ClearInternalItems;
  FreeAndNil(FCustomizationPopup);

  FCustomizingBarControl := ACustomizingBarControl;
  FCustomizingItemLink := ACustomizingItemLink;
  FCustomizingBarManager := ABarManager;

  FCustomizationPopup := TdxBarInternalLinksOwner.Create(FCustomizingBarManager, TdxBarCustomizingPopup);
  FCustomizationPopup.ItemLinks.CreateBarControl;
  APopupControl := FCustomizationPopup.BarControl as TdxBarCustomizingPopup;
  ABarManager.FOwnedObjects.Add(APopupControl);
  if ACustomizingBarControl <> nil then
    APopupControl.FParentWnd := ACustomizingBarControl.Handle;
  APopupControl.FPainter := APainter;
  APopupControl.OnCloseUp := CustomizationPopupCloseUp;
  AInitPopupProc(FCustomizationPopup.ItemLinks);
  if FCustomizationPopup.ItemLinks.Count > 0 then
  begin
    DeactivateCustomizingItem;
    FCustomizingBarManager.DoShowCustomizingPopup(FCustomizationPopup.ItemLinks);
    APopupControl.Left := APopupPoint.X;
    APopupControl.Top := APopupPoint.Y;
    APopupControl.Show;
  end
  else
    FCustomizingBarControl := nil;
end;

procedure TdxBarDesignController.ShowCustomCustomizePopup(
  ABarManager: TdxBarManager; AInitPopupProc: TInitPopupProc; APainter: TdxBarPainter;
  ACustomizingBarControl: TCustomdxBarControl = nil; ACustomizingItemLink: TdxBarItemLink = nil);
begin
  ShowCustomCustomizePopup(ABarManager, AInitPopupProc, APainter, GetMouseCursorPos, ACustomizingBarControl,
    ACustomizingItemLink);
end;

procedure TdxBarDesignController.ShowCustomizePopup(ABarControl: TCustomdxBarControl;
  ACustomizingItemLink: TdxBarItemLink);
begin
  FCustomizingItemLinks := ABarControl.ItemLinks;
  ShowCustomCustomizePopup(ABarControl.BarManager, InitCustomizationPopup, ABarControl.Painter, ABarControl, ACustomizingItemLink);
end;

procedure TdxBarDesignController.SetCustomizePopupTopMosts(AShow: Boolean);
var
  APrevBarControl, ABarControl: TCustomdxBarControl;
begin
  if AShow then
  begin
    dxSetZOrder(FCustomizationPopup.BarControl.Handle);
    APrevBarControl := FCustomizationPopup.BarControl;
    if CustomizingItemLink.Control <> nil then
    begin
      ABarControl := CustomizingBarControl;
      repeat
        dxSetZOrder(ABarControl.Handle, APrevBarControl.Handle);
        APrevBarControl := ABarControl;
        ABarControl := ABarControl.ParentBar;
      until ABarControl = nil;
    end;
  end
  else
  begin
    if CustomizingItemLink.Control <> nil then
    begin
      ABarControl := CustomizingBarControl;
      while ABarControl.ParentBar <> nil do
        ABarControl := ABarControl.ParentBar;
      repeat
        dxSetZOrder(ABarControl.Handle, HWND_NOTOPMOST);
        ABarControl := ABarControl.ChildBar;
      until ABarControl = nil;
    end;
    dxSetZOrder(FCustomizationPopup.BarControl.Handle, HWND_NOTOPMOST);
  end;
end;

procedure TdxBarDesignController.InitToolBarPopup(AItemLinks: TdxBarItemLinks);
var
  I: Integer;
  ABars: TdxBars;
  ABar: TdxBar;
  AItem: TdxBarButton;
  AItemLink: TdxBarItemLink;
begin
  ClearOwnedItems(AItemLinks);
  ABars := AItemLinks.BarManager.Bars;
  for I := 0 to ABars.Count - 1 do
  begin
    ABar := ABars[I];
    if ABar.CanClose and not ABar.Hidden and (ABar.MergeData.MergedWith = nil) then
    begin
      AItemLink := AddInternalItem(AItemLinks, TdxBarButton, ABar.Caption, ToolbarsPopupClick);
      AItem := TdxBarButton(AItemLink.Item);
      AItem.Tag := TdxNativeInt(ABar);
      AItem.ButtonStyle := bsChecked;
      AItem.Down := ABars[I].Visible;
    end;
  end;
  AddCustomizeItem(AItemLinks, TdxBarButton);
end;

procedure TdxBarDesignController.ShowToolbarsPopup(ABarManager: TdxBarManager; APainter: TdxBarPainter);
var
  APopupControl: TdxBarInternalSubMenuControl;
begin
  ClearInternalItems;
  FreeAndNil(FToolbarsPopup);

  FCustomizingBarManager := ABarManager;

  FToolbarsPopup := TdxBarInternalLinksOwner.Create(ABarManager, TdxBarInternalSubMenuControl);
  FToolbarsPopup.ItemLinks.CreateBarControl;
  APopupControl := FToolbarsPopup.BarControl as TdxBarInternalSubMenuControl;
  ABarManager.FOwnedObjects.Add(APopupControl);
  APopupControl.FPainter := APainter;
  InitToolBarPopup(FToolbarsPopup.ItemLinks);
  ABarManager.DoShowToolbarsPopup(FToolbarsPopup.ItemLinks);
  if FToolbarsPopup.FItemLinks.Count > 0 then
  begin
    ABarManager.HideAll;
    APopupControl.Left := GetMouseCursorPos.X;
    APopupControl.Top := GetMouseCursorPos.Y;
    APopupControl.FShowAnimation := True;
    APopupControl.Show;
  end;
end;

procedure TdxBarDesignController.ShowQuickControl(ABarControl: TdxBarControl; const AOwnerRect: TRect);
var
  AQuickControl: TdxBarPopupControl;
begin
  FCustomizingBarManager := ABarControl.BarManager;

  AQuickControl := ABarControl.GetQuickControlClass.Create(ABarControl.Bar.BarManager);
  AQuickControl.BeginUpdate;
  try
    AQuickControl.InitializeForPopup(ABarControl, ABarControl.Bar);
    ABarControl.InitQuickControl(AQuickControl);
  finally
    AQuickControl.CancelUpdate;
  end;

  ShowQuickControl(AQuickControl, ABarControl.Painter, AOwnerRect);

  PlaySound(psMenuPopup);
end;

procedure TdxBarDesignController.ShowQuickControl(
  AQuickControl: TdxBarPopupControl; APainter: TdxBarPainter; const ARect: TRect);
begin
  FQuickControl := AQuickControl;
  FPrevQuickControlDestroy := FQuickControl.OnDestroy;
  FQuickControl.OnDestroy := QuickControlDestroy;
  FQuickControl.FPainter := APainter;
//  FQuickControl.HandleNeeded;

  FQuickControl.Popup(ARect);
end;

function TdxBarDesignController.CanDeleteSelectedObjects: Boolean;
var
  ASelection: TdxObjectList;
begin
  ASelection := TdxObjectList.Create;
  try
    GetSelection(ASelection);
    RemoveIrrelevantObjectsForDelete(ASelection);
    Result := ASelection.Count > 0;
  finally
    ASelection.Free;
  end;
end;

procedure TdxBarDesignController.GetSelection(ASelection: TdxObjectList);
begin
  CustomizingBarManager.GetSelection(ASelection);
  CleanSelectableItems(ASelection);
end;

function TdxBarDesignController.IsObjectUnbound(AObject: TObject; AMasterObjects: TdxObjectList): Boolean;
var
  I: Integer;
  AInternalMasterObjects: TdxObjectList;
  ASelectableItem: IdxBarSelectableItem;
begin
  Result := True;
  if IsSelectableItem(AObject, ASelectableItem) then
  begin
    AInternalMasterObjects := TdxObjectList.Create;
    try
      ASelectableItem.GetMasterObjects(AInternalMasterObjects);
      for I := 0 to AInternalMasterObjects.Count - 1 do
        Result := (AMasterObjects.IndexOf(AInternalMasterObjects[I]) = -1) and IsObjectUnbound(AInternalMasterObjects[I], AMasterObjects);
    finally
      AInternalMasterObjects.Free;
    end;
  end;
end;

procedure TdxBarDesignController.RemoveIrrelevantObjectsForDelete(ASelection: TdxObjectList; ADestruction: Boolean = False);
var
  I: Integer;
begin
  for I := ASelection.Count - 1 downto 0 do
    if not GetSelectableItem(ASelection[I]).CanDelete(ADestruction) or
         ADestruction and not IsObjectUnbound(ASelection[I], ASelection) then
      ASelection.Delete(I);
end;

procedure TdxBarDesignController.ClearOwnedItems(AItemLinks: TdxBarItemLinks);
begin
  while AItemLinks.Count > 0 do
    AItemLinks.Items[0].Item.Free;
end;

procedure TdxBarDesignController.CustomizeItemClick(Sender: TObject);
begin
  TdxBarItem(Sender).BarManager.Customizing(True);
end;

procedure TdxBarDesignController.TextItemChange(Sender: TObject);
begin
  if TdxBarEdit(Sender).Text = '' then
  begin
    if (FCustomizationPopup <> nil) and (FCustomizationPopup.BarControl <> nil) then
      FCustomizationPopup.BarControl.Hide;
    dxBarMessageBox(cxGetResourceString(@dxSBAR_COMMANDNAMECANNOTBEBLANK), MB_ICONSTOP);
  end
  else
    if FCustomizingBarManager.Designing then
    begin
      CustomizingItemLink.Item.Caption := TdxBarEdit(Sender).Text;
      SynchronizeAction(caChangeCaption);
      DesignerModified;
    end
    else
      CustomizingItemLink.UserCaption := TdxBarEdit(Sender).Text;
end;

procedure TdxBarDesignController.CustomizationPopupCloseUp(Sender: TObject; AReason: TdxBarCloseUpReason);
begin
  FCustomizingBarControl := nil;
end;

procedure TdxBarDesignController.CustomizationPopupItemClick(Sender: TObject);

  procedure ChangeButtonGroup(AButtonGroupAction: TdxChangeButtonGroupAction);

    const
      AGroupPosition: array[TdxChangeButtonGroupAction] of TdxBarButtonGroupPosition = (bgpNone, bgpStart, bgpMember, bgpMember, bgpNone);

    procedure MakeButtonGroup;
    var
      I: Integer;
      ALink: TdxBarItemLink;
    begin
      FCustomizingItemLinks.BeginUpdate;
      try
        ALink := CustomizingItemLink;
        for I := FCustomizingItemLinks.Count - 1 downto 0 do
          if FCustomizingItemLinks[I].IsComponentSelected then
          begin
            ALink := FCustomizingItemLinks[I];
            ALink.ButtonGroup := AGroupPosition[AButtonGroupAction];
          end;
        if AButtonGroupAction = bgaGroup then
          ALink.ButtonGroup := bgpStart;
      finally
        FCustomizingItemLinks.EndUpdate;
      end;
    end;

  begin
    if AButtonGroupAction in [bgaNone..bgaMember] then
    begin
      CustomizingItemLink.ButtonGroup := AGroupPosition[AButtonGroupAction];
      SynchronizeAction(caChangeButtonGroup);
    end
    else
      MakeButtonGroup;
  end;

  procedure ChangeViewLevel(AViewLevelAction: TdxChangeViewLevelAction);
  var
    AViewLevel: TdxBarItemRealViewLevel;
  begin
    case AViewLevelAction of
      vlaChangeLargeIconWithText..vlaChangeControl:
        begin
          AViewLevel := TdxBarItemViewLevel(AViewLevelAction);
          if AViewLevel in CustomizingItemLink.ViewLevels then
            CustomizingItemLink.ViewLevels := CustomizingItemLink.ViewLevels - [AViewLevel]
          else
            CustomizingItemLink.ViewLevels := CustomizingItemLink.ViewLevels + [AViewLevel];
        end;
      vlaSetAll:
        CustomizingItemLink.ViewLevels := [ivlLargeIconWithText..ivlControlOnly];
      vlaSetLargeIconWithTextOnly:
        CustomizingItemLink.ViewLevels := [ivlLargeIconWithText];
      vlaSetLargeControlOnly:
        CustomizingItemLink.ViewLevels := [ivlLargeControlOnly];
      vlaSetSmallIconWithTextOnly:
        CustomizingItemLink.ViewLevels := [ivlSmallIconWithText];
      vlaSetSmallIconOnly:
        CustomizingItemLink.ViewLevels := [ivlSmallIcon];
      vlaSetControlOnly:
        CustomizingItemLink.ViewLevels := [ivlControlOnly];
    end;
  end;

var
  ADetailAction: WORD;
  ABasicAction: TdxBarCustomizationAction;
  ABarButton: TdxBarButton;
begin
  ABarButton := Sender as TdxBarButton;
  ABasicAction := TdxBarCustomizationAction(HiWord(ABarButton.Tag));
  ADetailAction := LoWord(ABarButton.Tag);
  case ABasicAction of
    caDelete:
      DeleteSelectedObjects(False, False);
    caDeleteItem:
      DeleteSelectedObjects(True, False);
    caDeleteLink:
      DeleteCustomizingItemLink;
    caSelectLink:
      FCustomizingItemLink.BarManager.SelectComponent(FCustomizingItemLink, soExclusive);

    // multiple operations
    caReset:
      CustomizingItemLink.UserDefine := [];
    caChangeButtonPaintStyle:
      CustomizingItemLink.UserPaintStyle := TdxBarPaintStyle(ADetailAction);
    caChangePosition:
      CustomizingItemLink.Position := TdxBarItemPosition(ADetailAction);
    caChangeViewLevels:
      begin
        ChangeViewLevel(TdxChangeViewLevelAction(ADetailAction));
        UpdateViewLevelsSubItemButtonStates(ABarButton.Links[0].Owner);
      end;
    caChangeButtonGroup:
      ChangeButtonGroup(TdxChangeButtonGroupAction(ADetailAction));
    caChangeBeginGroup:
      CustomizingItemLink.BeginGroup := not CustomizingItemLink.BeginGroup;
    caChangeVisible:
      CustomizingItemLink.Visible := not CustomizingItemLink.Visible;
    caChangeRecentList:
      CustomizingItemLink.MostRecentlyUsed := not CustomizingItemLink.MostRecentlyUsed;
    caChangeDistributed:
      CustomizingItemLink.Distributed := not CustomizingItemLink.Distributed;
  end;
  if not (ABasicAction in [caDelete, caDeleteItem, caDeleteLink, caChangeButtonGroup]) then
    SynchronizeAction(ABasicAction);
end;

function TdxBarDesignController.GetBarControlDesignHelperClass: TCustomdxBarControlDesignHelperClass;
begin
  Result := TCustomdxBarControlDesignHelperClass(
    FRegisteredBarControlDesignHelpers.FindClass(CustomizingBarControl.ClassType));
end;

procedure TdxBarDesignController.InitCustomizationPopup(AItemLinks: TdxBarItemLinks);

  function AddCustomizationButton(AItemLinks: TdxBarItemLinks;
    const ACaption: string; ABasicAction: TdxBarCustomizationAction;
    ABeginGroup: Boolean = False;
    AButtonStyle: TdxBarButtonStyle = bsDefault;
    AIsDown: Boolean = False;
    AEnabled: Boolean = True;
    AGroupIndex: Integer = 0; ADetailAction: Word = 0): TdxBarButton;
  var
    AItemLink: TdxBarItemLink;
    AItem: TdxBarButton;
  begin
    AItemLink := AddInternalItem(AItemLinks, TdxBarButton, ACaption, CustomizationPopupItemClick);
    AItemLink.BeginGroup := ABeginGroup;
    AItem := TdxBarButton(AItemLink.Item);
    AItem.Tag := MakeLong(ADetailAction, Word(ABasicAction));
    AItem.ButtonStyle := AButtonStyle;
    AItem.Down := AIsDown;
    AItem.Enabled := AEnabled;
    AItem.GroupIndex := AGroupIndex;
    Result := AItem;
  end;

  procedure AddCustomizationEdit(AItemLinks: TdxBarItemLinks; const ACaption: string);
  var
    AItemLink: TdxBarItemLink;
  begin
    AItemLink := AddInternalItem(AItemLinks, TdxBarEdit, ACaption);
    AItemLink.BeginGroup := True;
    TdxBarEdit(AItemLink.Item).Text := CustomizingItemLink.Caption;
    TdxBarEdit(AItemLink.Item).FOnChange := TextItemChange;
  end;

  function AddCustomizationSubItem(AItemLinks: TdxBarItemLinks;
    const ACaption: string; AActionType: TdxBarCustomizationAction;
    ABeginGroup: Boolean = False; AEnabled: Boolean = True): TdxBarSubItem;
  var
    AItemLink: TdxBarItemLink;
  begin
    AItemLink := AddInternalItem(AItemLinks, TdxBarSubItem, ACaption);
    Result := TdxBarSubItem(AItemLink.Item);
    AItemLink.BeginGroup := ABeginGroup;
    Result.Enabled := AEnabled;
    Result.IsInternal := True;
  end;

  function GetSupportedActions: TdxBarCustomizationActions;
  var
    ASelection: TdxObjectList;
    I: Integer;
    ASelectableItem: IdxBarSelectableItem;
  begin
    Result := FLastSelectedItem.GetSupportedActions;
    if CustomizingBarManager.Designing then
    begin
      ASelection := TdxObjectList.Create;
      try
        GetSelection(ASelection);
        for I := 0 to ASelection.Count - 1 do
        begin
          ASelectableItem := GetSelectableItem(ASelection[I]);
          Result := Result * ASelectableItem.GetSupportedActions;
        end;
      finally
        ASelection.Free;
      end;
    end;
  end;

  procedure AddViewLevelMenu(AExclusiveViewLevelsOnly: Boolean);

    function GetButtonStyle(AViewLevelAction: TdxChangeViewLevelAction): TdxBarButtonStyle;
    begin
      if AExclusiveViewLevelsOnly or
        (AViewLevelAction in [vlaChangeLargeIconWithText..vlaChangeControl]) then
        Result := bsChecked
      else
        Result := bsDefault;
    end;

    function GetButtonCaption(AViewLevelAction: TdxChangeViewLevelAction; AViewLevelNames: TStringDynArray): string;
    begin
      case AViewLevelAction of
        vlaChangeLargeIconWithText..vlaChangeControl: Result := AViewLevelNames[Ord(AViewLevelAction)];
        vlaSetAll: Result := cxGetResourceString(@dxSBAR_CP_ALLVIEWLEVELS);
      else
        Result := AViewLevelNames[Ord(AViewLevelAction) - Ord(vlaSetLargeIconWithTextOnly)] + cxGetResourceString(@dxSBAR_CP_SINGLEVIEWLEVELITEMSUFFIX);
      end;
    end;


  const
    RequiredItemViewLevelMap: array [TdxChangeViewLevelAction] of TdxBarItemRealViewLevel = (
    ivlLargeIconWithText, ivlLargeControlOnly, ivlSmallIconWithText, ivlSmallIcon, ivlControlOnly,
    ivlControlOnly, {SetAll}
    ivlLargeIconWithText, ivlLargeControlOnly, ivlSmallIconWithText, ivlSmallIcon, ivlControlOnly);

  var
    AViewLevelAction, AStartViewLevelAction, APrevViewLevelAction: TdxChangeViewLevelAction;
    AViewLevelNames: TStringDynArray;
    AOwnerLinks: TdxBarItemLinks;
  begin
    AViewLevelNames := SetToStringArray(TypeInfo(TdxBarItemViewLevels));
    AOwnerLinks := AddCustomizationSubItem(AItemLinks, cxGetResourceString(@dxSBAR_CP_VIEWLEVELSMENU),
      caChangeViewLevels, AExclusiveViewLevelsOnly).ItemLinks;
    if AExclusiveViewLevelsOnly then
      AStartViewLevelAction := vlaSetLargeIconWithTextOnly
    else
      AStartViewLevelAction := Low(TdxChangeViewLevelAction);
    APrevViewLevelAction := AStartViewLevelAction;
    for AViewLevelAction := AStartViewLevelAction to High(TdxChangeViewLevelAction) do
      if (RequiredItemViewLevelMap[AViewLevelAction] in CustomizingItemLink.Control.PossibleViewLevels) or
        (AViewLevelAction = vlaSetAll) then
      begin
        AddCustomizationButton(AOwnerLinks, GetButtonCaption(AViewLevelAction, AViewLevelNames),
          caChangeViewLevels, (AViewLevelAction = vlaSetAll) or (APrevViewLevelAction = vlaSetAll), GetButtonStyle(AViewLevelAction),
          False, True, 0, Word(AViewLevelAction)).CloseSubMenuOnClick := False;
        APrevViewLevelAction := AViewLevelAction;
      end;

    UpdateViewLevelsSubItemButtonStates(AOwnerLinks);
  end;

  procedure AddButtonPaintStyleMenu;
  const
    APaintStyleCaptions: array [TdxBarPaintStyle] of TcxResourceStringID =
      (@dxSBAR_CP_DEFAULTSTYLE, @dxSBAR_CP_TEXTONLYALWAYS, @dxSBAR_CP_TEXTONLYINMENUS, @dxSBAR_CP_IMAGEANDTEXT);
  var
    APaintStyle: TdxBarPaintStyle;
    AOwnerLinks: TdxBarItemLinks;
  begin
    { unusually
    if CustomizingBarManager.Designing then
      AOwnerLinks := AddCustomizationSubItem(AItemLinks, cxGetResourceString(@dxSBAR_CP_BUTTONPAINTSTYLEMENU),
        caChangeButtonPaintStyle, True).ItemLinks
    else
    }
      AOwnerLinks := AItemLinks;
    for APaintStyle := Low(TdxBarPaintStyle) to High(TdxBarPaintStyle) do
      AddCustomizationButton(AOwnerLinks, cxGetResourceString(APaintStyleCaptions[APaintStyle]),
        caChangeButtonPaintStyle, APaintStyle = Low(TdxBarPaintStyle), bsChecked,
        CustomizingItemLink.PaintStyle = APaintStyle,
        CustomizingItemLink.CanChangePaintStyle, dxBarCustomizingPopupPaintStyleGroupIndex, Word(APaintStyle));
  end;

  procedure AddPositionMenu;
  var
    APosition: TdxBarItemPosition;
    APositionNames: TStringDynArray;
    AOwnerLinks: TdxBarItemLinks;
  begin
    APositionNames := EnumToStringArray(TypeInfo(TdxBarItemPosition));
    AOwnerLinks := AddCustomizationSubItem(AItemLinks, cxGetResourceString(@dxSBAR_CP_POSITIONMENU), caChangePosition, True).ItemLinks;
    for APosition := Low(TdxBarItemPosition) to High(TdxBarItemPosition) do
      AddCustomizationButton(AOwnerLinks, APositionNames[Ord(APosition)],
        caChangePosition, False, bsChecked,
        CustomizingItemLink.Position = APosition, True, 0, Word(APosition));
  end;

  procedure AddButtonGroupMenu;

    function IsDowned(AButtonGroupAction: TdxChangeButtonGroupAction): Boolean;
    begin
      Result := (AButtonGroupAction in [bgaNone..bgaMember]) and (CustomizingItemLink.ButtonGroup = TdxBarButtonGroupPosition(AButtonGroupAction));
    end;

    function GetButtonStyle(AButtonGroupAction: TdxChangeButtonGroupAction): TdxBarButtonStyle;
    begin
      if AButtonGroupAction in [bgaNone..bgaMember] then
        Result := bsChecked
      else
        Result := bsDefault;
    end;

    function GetButtonCaption(AButtonGroupAction: TdxChangeButtonGroupAction; AButtonGroupNames: TStringDynArray): string;
    begin
      case AButtonGroupAction of
        bgaGroup: Result := cxGetResourceString(@dxSBAR_CP_BUTTONGROUP);
        bgaUngroup: Result := cxGetResourceString(@dxSBAR_CP_BUTTONUNGROUP);
      else
        Result := AButtonGroupNames[Ord(AButtonGroupAction)];
      end;
    end;

  var
    AButtonGroupAction: TdxChangeButtonGroupAction;
    AButtonGroupNames: TStringDynArray;
    AOwnerLinks: TdxBarItemLinks;
  begin
    AButtonGroupNames := EnumToStringArray(TypeInfo(TdxBarButtonGroupPosition));
    AOwnerLinks := AddCustomizationSubItem(AItemLinks, cxGetResourceString(@dxSBAR_CP_BUTTONGROUPMENU), caChangeButtonGroup).ItemLinks;
    for AButtonGroupAction := Low(TdxChangeButtonGroupAction) to High(TdxChangeButtonGroupAction) do
      AddCustomizationButton(AOwnerLinks, GetButtonCaption(AButtonGroupAction, AButtonGroupNames),
        caChangeButtonGroup, AButtonGroupAction = bgaGroup, GetButtonStyle(AButtonGroupAction),
        IsDowned(AButtonGroupAction), True, 0, Word(AButtonGroupAction));
  end;

const
  AChangeCaptionName: array [Boolean] of TcxResourceStringID = (@dxSBAR_CP_NAME, @dxSBAR_CP_CAPTION);
  ADeleteLinkName: array [Boolean] of TcxResourceStringID = (@dxSBAR_CP_DELETE, @dxSBAR_CP_DELETELINK);
var
  ABarControlEditors: TList;
  I: Integer;
  AAction: TdxBarCustomizationAction;
  ASupportedActions: TdxBarCustomizationActions;
  ACustomItemLink: IdxBarCustomItemLink;
begin
  AItemLinks.BeginUpdate;
  try
    FCustomizingBarManager.ItemList.BeginUpdate;
    try
      if FCustomizingBarManager.Designing and IsSelectionSingle(FCustomizingBarManager) then
      begin
        ABarControlEditors := TList.Create;
        try
          GetBarControlDesignHelperClass.GetEditors(ABarControlEditors);
          for I := 0 to ABarControlEditors.Count - 1 do
            TdxBarControlEditorClass(ABarControlEditors[I]).InitCustomizationPopup(AItemLinks);
        finally
          FreeAndNil(ABarControlEditors);
        end;
      end;

    ASupportedActions := GetSupportedActions;
    GetBarControlDesignHelperClass.FilterItemActions(ASupportedActions);
    for AAction := Low(TdxBarCustomizationAction) to High(TdxBarCustomizationAction) do
      if AAction in ASupportedActions then
        case AAction of
          caReset:
            AddCustomizationButton(AItemLinks, cxGetResourceString(@dxSBAR_CP_RESET), AAction, True);
          caDelete:
            AddCustomizationButton(AItemLinks, cxGetResourceString(@dxSBAR_CP_DELETE), AAction, True,
              bsDefault, False, CanDeleteSelectedObjects).ShortCut := VK_DELETE;
          caDeleteItem:
            AddCustomizationButton(AItemLinks, cxGetResourceString(@dxSBAR_CP_DELETEITEM), AAction, False,
              bsDefault, False, CustomizingItemLink.Item.CanDelete(True)).ShortCut := ShortCut(VK_DELETE, [ssCtrl]);
          caDeleteLink:
            AddCustomizationButton(AItemLinks, cxGetResourceString(ADeleteLinkName[FCustomizingBarManager.Designing]), AAction, False, bsDefault, False);
          caSelectLink:
            AddCustomizationButton(AItemLinks, 'Select Link', AAction, True);
          caChangeCaption:
            AddCustomizationEdit(AItemLinks, cxGetResourceString(AChangeCaptionName[FCustomizingBarManager.Designing]));
          caChangeButtonPaintStyle:
            AddButtonPaintStyleMenu;
          caChangePosition:
            AddPositionMenu;
          caChangeViewLevels:
            AddViewLevelMenu(not GetBarControlDesignHelperClass.CanDynamicallyChangeViewLevels);
          caChangeButtonGroup:
            AddButtonGroupMenu;
          caChangeDistributed:
            AddCustomizationButton(AItemLinks, cxGetResourceString(@dxSBAR_CP_DISTRIBUTED), AAction, False,
              bsChecked, CustomizingItemLink.Distributed);
          caChangeBeginGroup:
            AddCustomizationButton(AItemLinks, cxGetResourceString(@dxSBAR_CP_BEGINAGROUP), AAction, True,
              bsChecked, CustomizingItemLink.BeginGroup, CustomizingItemLink.Index > 0);
          caChangeVisible:
            AddCustomizationButton(AItemLinks, cxGetResourceString(@dxSBAR_CP_VISIBLE), AAction, not (caChangeBeginGroup in ASupportedActions),
              bsChecked, CustomizingItemLink.Visible);
          caChangeRecentList:
            AddCustomizationButton(AItemLinks, cxGetResourceString(@dxSBAR_CP_MOSTRECENTLYUSED), AAction, False,
              bsChecked, CustomizingItemLink.MostRecentlyUsed);
        end;
    if Supports(CustomizingItemLink, IdxBarCustomItemLink, ACustomItemLink) then
      ACustomItemLink.ProcessCustomizationPopup(AItemLinks);
    finally
      FCustomizingBarManager.ItemList.CancelUpdate;
    end;
  finally
    AItemLinks.EndUpdate;
  end;
end;

procedure TdxBarDesignController.SynchronizeAction(ABasicAction: TdxBarCustomizationAction);
var
  I: Integer;
  ASelection: TdxObjectList;
begin
  ASelection := TdxObjectList.Create;
  try
    GetSelection(ASelection);
    for I := 0 to ASelection.Count - 1 do
      GetSelectableItem(ASelection[I]).ExecuteCustomizationAction(ABasicAction);
  finally
    ASelection.Free;
  end;
end;

procedure TdxBarDesignController.UpdateViewLevelsSubItemButtonStates(AItemLinks: TdxBarItemLinks);
const
  ViewLevelActionToItemViewLevel: array [vlaSetLargeIconWithTextOnly..vlaSetControlOnly] of TdxBarItemRealViewLevel = (
    ivlLargeIconWithText, ivlLargeControlOnly, ivlSmallIconWithText, ivlSmallIcon, ivlControlOnly);
var
  I: Integer;
  AButton: TdxBarButton;
  AChangeAction: TdxChangeViewLevelAction;
begin
  for I := 0 to AItemLinks.Count - 1 do
  begin
    AButton := AItemLinks[I].Item as TdxBarButton;
    AChangeAction := TdxChangeViewLevelAction(LoWord(AButton.Tag));
    if not GetBarControlDesignHelperClass.CanDynamicallyChangeViewLevels then
      AButton.Down := [ViewLevelActionToItemViewLevel[AChangeAction]] = CustomizingItemLink.ViewLevels
    else
      if AChangeAction in [vlaChangeLargeIconWithText..vlaChangeControl] then
        AButton.Down := TdxBarItemViewLevel(LoWord(AButton.Tag)) in CustomizingItemLink.ViewLevels;
  end;
end;

procedure TdxBarDesignController.ToolbarsPopupClick(Sender: TObject);
var
  ABar: TdxBar;
begin
  ABar := TdxBar(TComponent(Sender).Tag);
  ABar.Visible := not ABar.Visible;
end;

procedure TdxBarDesignController.QuickControlDestroy(Sender: TObject);
begin
  FQuickControl := nil;
  CallNotify(FPrevQuickControlDestroy, Sender);
end;

procedure TdxBarDesignController.FindCustomizingBarManager;
var
  I: Integer;
  ASelection: TdxObjectList;
begin
  if LastSelectedItem <> nil then
    FCustomizingBarManager := LastSelectedItem.GetBarManager
  else
  begin
    ASelection := TdxObjectList.Create;
    try
      FCustomizingBarManager := nil;
      for I := 0 to dxBarManagerList.Count - 1 do
      begin
        dxBarManagerList[I].GetActiveSelection(ASelection);
        CleanSelectableItems(ASelection);
        if ASelection.Count > 0 then
        begin
          FCustomizingBarManager := dxBarManagerList[I];
          Break;
        end;
      end;
    finally
      ASelection.Free;
    end;
  end;
end;

function TdxBarDesignController.CanCustomize(ABarManager: TdxBarManager; AIsKeyboardAction: Boolean): Boolean;
begin
  Result := (ABarManager <> nil) and
    (not AIsKeyboardAction or
      (ABarManager.Owner.HandleAllocated) and (cxIsParentFocused(ABarManager.Owner.Handle)));
end;

procedure TdxBarDesignController.SetLastSelectedItem(Value: IdxBarSelectableItem);

  procedure UpdateItem(ASelectedItem: IdxBarSelectableItem; AOperation: TOperation);
  var
    AInstance: TPersistent;
  begin
    if ASelectedItem <> nil then
    begin
      ASelectedItem.Invalidate;
      AInstance := ASelectedItem.GetInstance;
      if AInstance is TComponent then
        case AOperation of
          opInsert: FNotifyComponent.FreeNotification(TComponent(AInstance));
          opRemove: FNotifyComponent.RemoveFreeNotification(TComponent(AInstance));
        end;
    end;
  end;

var
  APrevSelectedItem: IdxBarSelectableItem;
begin
  if FLastSelectedItem <> Value then
  begin
    APrevSelectedItem := FLastSelectedItem;
    FLastSelectedItem := Value;
    UpdateItem(APrevSelectedItem, opRemove);
    UpdateItem(FLastSelectedItem, opInsert);
  end;
end;

procedure TdxBarDesignController.FreeNotification(AComponent: TComponent);
begin
  DropSelection(GetSelectableItem(AComponent));
end;

{ TdxBarComponent }

constructor TdxBarComponent.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FChangeNotifies := TInterfaceList.Create;
  FEnabled := True;
  FVisible := ivAlways;
end;

destructor TdxBarComponent.Destroy;
begin
  FreeAndNil(FChangeNotifies);
  inherited Destroy;
end;

procedure TdxBarComponent.AddChangeNotify(AListener: IdxBarComponentListener);
begin
  FChangeNotifies.Add(AListener);
end;

procedure TdxBarComponent.RemoveChangeNotify(AListener: IdxBarComponentListener);
begin
  if FChangeNotifies <> nil then
    FChangeNotifies.Remove(AListener);
end;

procedure TdxBarComponent.Changed(AllItems: Boolean = False);
var
  I: Integer;
begin
  if not (csDestroying in ComponentState) then
    for I := 0 to FChangeNotifies.Count - 1 do
    begin
      if AllItems then
        (FChangeNotifies[I] as IdxBarComponentListener).Changed(nil)
      else
        (FChangeNotifies[I] as IdxBarComponentListener).Changed(Self);
    end;
end;

function TdxBarComponent.GetEnabled: Boolean;
begin
  Result := FEnabled;
end;

function TdxBarComponent.GetVisible: TdxBarItemVisible;
begin
  Result := FVisible;
end;

procedure TdxBarComponent.SetBarManager(Value: TdxBarManager);
begin
  FBarManager := Value;
end;

procedure TdxBarComponent.SetEnabled(Value: Boolean);
begin
  FEnabled := Value;
end;

procedure TdxBarComponent.SetVisible(Value: TdxBarItemVisible);
begin
  FVisible := Value;
end;

procedure TdxBarComponent.GetMasterObjects(AList: TdxObjectList);
begin
  AList.Add(Owner);
end;

function TdxBarComponent.GetNextSelectableItem: IdxBarSelectableItem;
begin
  Result := nil;
end;

function TdxBarComponent.GetSelectableParent: TPersistent;
begin
  Result := Owner;
end;

function TdxBarComponent.CanDelete(ADestruction: Boolean = False): Boolean;
begin
  Result := BarManager.CanDeleteComponent(Self);
end;

procedure TdxBarComponent.DeleteSelection(var AReference: IdxBarSelectableItem; ADestruction: Boolean);
begin
  if CanDelete(ADestruction) then
  begin
    AReference := nil;
    Free;
  end;
end;

procedure TdxBarComponent.ExecuteCustomizationAction(ABasicAction: TdxBarCustomizationAction);
begin
// do nothing
end;

function TdxBarComponent.GetBarManager: TdxBarManager;
begin
  Result := FBarManager;
end;

function TdxBarComponent.GetSelectionStatus: TdxBarSelectionStatus;
begin
  Result := BarManager.GetSelectionStatus(Self);
end;

function TdxBarComponent.GetSupportedActions: TdxBarCustomizationActions;
begin
  Result := [caDelete];
end;

procedure TdxBarComponent.Invalidate;
begin
// do nothing
end;

function TdxBarComponent.IsComplex: Boolean;
begin
  Result := False;
end;

function TdxBarComponent.IsComponentSelected: Boolean;
begin
  Result := BarManager.IsComponentSelected(Self);
end;

procedure TdxBarComponent.SelectComponent(ASelectionOperation: TdxBarSelectionOperation = soExclusive);
begin
  BarManager.SelectComponent(Self, ASelectionOperation);
end;

function TdxBarComponent.SelectParentComponent: Boolean;
begin
  Result := False;
end;

procedure TdxBarComponent.SelectionChanged;
begin
// do nothing
end;

function TdxBarComponent.GetPersistentInstance: TPersistent;
begin
  Result := Self;
end;

function TdxBarComponent.GetComponentInstance: TComponent;
begin
  Result := Self;
end;

{ TdxObjectList }

constructor TdxObjectList.Create;
begin
  inherited Create(False);
end;

procedure TdxObjectList.Add(AObject: TObject);
begin
  if (AObject <> nil) and (IndexOf(AObject) = -1) then
    inherited Add(AObject);
end;

procedure TdxObjectList.AddList(AObjects: TList);
begin
  AddFromList(AObjects, Self);
end;

procedure TdxObjectList.CopyFrom(ASource: TList);
begin
  CopyList(ASource, Self);
end;

procedure TdxObjectList.CopyTo(ADestination: TList);
begin
  CopyList(Self, ADestination);
end;

procedure TdxObjectList.XorList(ASourceA, ASourceB: TList);
begin
  Clear;
  AddFromList(ASourceA, ASourceB);
  AddFromList(ASourceB, ASourceA);
end;

function TdxObjectList.First: TObject;
begin
  Result := GetItem(0);
end;

function TdxObjectList.Last: TObject;
begin
  Result := GetItem(Count - 1);
end;

procedure TdxObjectList.CopyList(ASource, ADestination: TList);
var
  I: Integer;
begin
  ADestination.Clear;
  ADestination.Capacity := ASource.Capacity;
  for I := 0 to ASource.Count - 1 do
    if ADestination is TdxObjectList then
      TdxObjectList(ADestination).Add(ASource[I])
    else
      ADestination.Add(ASource[I]);
end;

function TdxObjectList.GetItem(AIndex: Integer): TObject;
begin
  if (AIndex >= 0) and (AIndex < Count) then
    Result := inherited GetItem(AIndex)
  else
    Result := nil;
end;

procedure TdxObjectList.AddFromList(ASource, AExcludedList: TList);
var
  I: Integer;
begin
  for I := 0 to ASource.Count - 1 do
    if AExcludedList.IndexOf(ASource[I]) = -1 then
      Add(ASource[I]);
end;

{ TdxBarComponentList }

procedure TdxBarComponentList.BarComponentChanged(AComponent: TdxBarComponent);
begin
  Update(AComponent);
end;

procedure TdxBarComponentList.BarComponentEnabledChanged(AComponent: TdxBarComponent);
begin
end;

procedure TdxBarComponentList.DoNotify(AItem: TComponent; AAction: TListNotification);
begin
  case AAction of
    lnExtracted, lnDeleted:
      TdxBarComponent(AItem).RemoveChangeNotify(Self);
    lnAdded:
      TdxBarComponent(AItem).AddChangeNotify(Self);
  end;
  inherited;
end;

function TdxBarComponentList.GetItemClass: TClass;
begin
  Result := TdxBarComponent;
end;

function TdxBarComponentList._AddRef: Integer; stdcall;
begin
  Result := -1;
end;

function TdxBarComponentList._Release: Integer; stdcall;
begin
  Result := -1;
end;

function TdxBarComponentList.QueryInterface(const IID: TGUID; out Obj): HRESULT; stdcall;
begin
  if GetInterface(IID, Obj) then
    Result := S_OK
  else
    Result := E_NOINTERFACE;
end;

{ TdxBarGroup }

constructor TdxBarGroup.Create(AOwner: TComponent);
begin
  inherited;
  FItems := TdxBarComponentList.Create;
end;

destructor TdxBarGroup.Destroy;
begin
  FreeAndNil(FItems);
  inherited;
end;

function TdxBarGroup.GetCount: Integer;
begin
//  Result := FItems.Count;
  Result := InternalGetCount;
end;

function TdxBarGroup.GetIndex: Integer;
begin
  Result := FBarManager.FGroups.IndexOf(Self);
end;

function TdxBarGroup.GetItem(Index: Integer): TComponent;
begin
  Result := TComponent(FItems[Index]);
end;

function TdxBarGroup.InternalGetCount: Integer;
begin
  if IsAncestorComponentDifferencesDetection(Self) then
    Result := FItemsNames.Count
  else
    Result := FItems.Count;
end;

function TdxBarGroup.InternalGetItemName(Index: Integer): string;
begin
  if IsAncestorComponentDifferencesDetection(Self) then
    Result := FItemsNames[Index]
  else
    Result := Items[Index].Name;
end;

procedure TdxBarGroup.SetIndex(Value: Integer);
begin
  if Index <> Value then
    FBarManager.GroupList.Move(Index, Value);
end;

procedure TdxBarGroup.ReadItems(Reader: TReader);
var
  AItem: TComponent;
begin
  if csLoading in ComponentState then
  begin
    if FItemsNames = nil then
      FItemsNames := TStringList.Create
    else
      FItemsNames.Clear;
    Reader.ReadListBegin;
    try
      while not Reader.EndOfList do
        FItemsNames.Add(Reader.ReadString);
    finally
      Reader.ReadListEnd;
    end;
  end
  else
  begin
    ItemList.Clear;
    Reader.ReadListBegin;
    try
      while not Reader.EndOfList do
      begin
        AItem := BarManager.Owner.FindComponent(Reader.ReadString);
        if AItem <> nil then
          Add(TdxBarComponent(AItem));
      end;
    finally
      Reader.ReadListEnd;
    end;
  end;
end;

procedure TdxBarGroup.WriteItems(Writer: TWriter);
var
  I: Integer;
begin
  Writer.WriteListBegin;
  try
    for I := 0 to InternalGetCount - 1 do
      Writer.WriteString(InternalGetItemName(I));
  finally
    Writer.WriteListEnd;
  end;
end;

procedure TdxBarGroup.DefineProperties(Filer: TFiler);

  function NeedWriteItems: Boolean;

    function IsGroupsEqual(AGroup1, AGroup2: TdxBarGroup): Boolean;
    var
      I: Integer;
    begin
      Result := AGroup1.InternalGetCount = AGroup2.InternalGetCount;
      if Result then
        for I := 0 to AGroup1.InternalGetCount - 1 do
          Result := Result and (AGroup1.InternalGetItemName(I) = AGroup2.InternalGetItemName(I))
    end;

  begin
    Result := (Filer.Ancestor = nil) or not IsGroupsEqual(Self, TdxBarGroup(Filer.Ancestor));
  end;

begin
  inherited;
  Filer.DefineProperty('Items', ReadItems, WriteItems, NeedWriteItems);
end;

procedure TdxBarGroup.Loaded;
var
  I: Integer;
  AItem: TComponent;
begin
  inherited;
  if FItemsNames = nil then Exit;
  try
    for I := 0 to FItemsNames.Count - 1 do
    begin
      AItem := FBarManager.Owner.FindComponent(FItemsNames[I]);
      if AItem <> nil then Add(TdxBarComponent(AItem));
    end;
  finally
    FreeAndNil(FItemsNames);
  end;
end;

procedure TdxBarGroup.SetName(const NewName: TComponentName);
begin
  inherited;
  Changed;
end;

procedure TdxBarGroup.SetEnabled(Value: Boolean);
var
  ALock: Boolean;
  I: Integer;
begin
  //if FEnabled <> Value then
  begin
    inherited;
    ALock := (BarDesignController.QuickControl = nil) and ([csLoading, csDestroying] * ComponentState = []);
    if ALock then
      FBarManager.BeginUpdate;
    try
      for I := 0 to Count - 1 do
        TdxBarComponent(Items[I]).Enabled := Value;
    finally
      if ALock then
        FBarManager.EndUpdate;
    end;
  end;
end;

procedure TdxBarGroup.SetVisible(Value: TdxBarItemVisible);
var
  I: Integer;
begin
  //if FVisible <> Value then
  begin
    inherited;
    if [csLoading, csDestroying] * ComponentState = [] then
      FBarManager.BeginUpdate;
    try
      for I := 0 to Count - 1 do
        TdxBarComponent(Items[I]).Visible := Value;
    finally
      if [csLoading, csDestroying] * ComponentState = [] then
        FBarManager.EndUpdate;
    end;
  end;
end;

function TdxBarGroup.GetParentComponent: TComponent;
begin
  Result := FBarManager;
end;

function TdxBarGroup.HasParent: Boolean;
begin
  Result := FBarManager <> nil;
end;

procedure TdxBarGroup.SetParentComponent(AParent: TComponent);
begin
  inherited;
  if AParent is TdxBarManager then
    TdxBarManager(AParent).AddGroup(Self);
end;

procedure TdxBarGroup.Add(AItem: TdxBarComponent);

  function IsRecursive(AItem: TComponent): Boolean;
  var
    I: Integer;
  begin
    Result := False;
    if AItem is TdxBarGroup then
    begin
      Result := AItem = Self;
      if not Result then
        with TdxBarGroup(AItem) do
          for I := 0 to Count - 1 do
          begin
            Result := IsRecursive(Items[I]);
            if Result then Break;
          end;
    end;
  end;

begin
  if not (AItem is TdxBarComponent) or (IndexOf(AItem) <> -1) then Exit;
  if IsRecursive(AItem) then
    raise EdxException.Create(cxGetResourceString(@dxSBAR_RECURSIVEGROUPS));
  FItems.Add(AItem);
end;

procedure TdxBarGroup.Delete(Index: Integer);
begin
  FItems.Delete(Index);
end;

function TdxBarGroup.IndexOf(AItem: TdxBarComponent): Integer;
begin
  Result := FItems.IndexOf(AItem);
end;

procedure TdxBarGroup.Move(FromIndex, ToIndex: Integer);
begin
  FItems.Move(FromIndex, ToIndex);
end;

procedure TdxBarGroup.Remove(AItem: TdxBarComponent);
begin
  FItems.Remove(AItem);
end;

{ TdxBarPopupMenuLink }

function TdxBarPopupMenuLink.GetBarManager: TdxBarManager;
begin
  Result := TdxBarPopupMenuLinks(Collection).BarManager;
end;

function TdxBarPopupMenuLink.GetWinControl: TWinControl;
begin
  if Control is TWinControl then
    Result := TWinControl(Control)
  else
    Result := nil;
end;

procedure TdxBarPopupMenuLink.SetControl(Value: TControl);
begin
  if (Value <> nil) and not IsControlUnderBarManager(BarManager, Value) then
    Value := nil;
  if FControl <> Value then
  begin
    cxWindowProcController.Remove(FWindowProcObject);
    FControl := Value;
    if FControl <> nil then
    begin
      FControl.FreeNotification(BarManager);
      FWindowProcObject := cxWindowProcController.Add(FControl, NewWndProc);
    end;
  end;
end;

procedure TdxBarPopupMenuLink.SetPopupMenu(Value: TdxBarCustomPopupMenuComponent);
begin
  if FPopupMenu <> Value then
  begin
    FPopupMenu := Value;
    cxAddFreeNotification(BarManager, Value);
  end;
end;

procedure TdxBarPopupMenuLink.ContextPopup(Sender: TObject; MousePos: TPoint; var Handled: Boolean);
var
  AControlAtPos: TControl;
begin
  if Assigned(FPrevOnContextPopup) then
    FPrevOnContextPopup(Sender, MousePos, Handled);
  if Control is TWinControl then
    AControlAtPos := TWinControl(Control).ControlAtPos(MousePos, True, True)
  else
    AControlAtPos := nil;
  if not Handled and (ProcessChildren or (AControlAtPos = nil)) then
    Handled := DoAction(MousePos);
end;

function TdxBarPopupMenuLink.DoAction(AClientPopupPoint: TPoint): Boolean;
var
  AClickedByMouse: Boolean;
begin
  AClickedByMouse := not cxPointIsEqual(cxInvalidPoint, AClientPopupPoint);
  Result := FPopupMenu <> nil;
  if Assigned(FOnAction) then
    FOnAction(Self, AClientPopupPoint.X, AClientPopupPoint.Y, AClickedByMouse, Result);
  if Result and (FPopupMenu <> nil) then
  begin
    with Control.ClientToScreen(AClientPopupPoint) do
      FPopupMenu.Popup(X, Y);
  end;
end;

function TdxBarPopupMenuLink.IsShortCut(AShortCut: TShortCut): Boolean;
var
  X, Y: Integer;
begin
  Result := FPopupMenu <> nil;
  if Assigned(FOnAction) then
  begin
    X := -1;
    Y := -1;
    FOnAction(Self, X, Y, False, Result);
  end;
  if Result then
    Result := (FPopupMenu <> nil) and FPopupMenu.ItemLinks.IsShortCut(AShortCut);
end;

procedure TdxBarPopupMenuLink.NewWndProc(var Message: TMessage);

  function IsContextMenuProcessed: Boolean;
  var
    AOnContextPopup: TContextPopupEvent;
  begin
    AOnContextPopup := ContextPopup;
    Result := dxSameMethods(TControlAccess(Control).OnContextPopup, AOnContextPopup);
  end;

begin
  if (Message.Msg = WM_CONTEXTMENU) and not (csDesigning in Control.ComponentState) then
  begin
    if not IsContextMenuProcessed then
    begin
      FPrevOnContextPopup := TControlAccess(Control).OnContextPopup;
      TControlAccess(Control).OnContextPopup := ContextPopup;
      try
        FWindowProcObject.DefaultProc(Message);
      finally
        TControlAccess(Control).OnContextPopup := FPrevOnContextPopup;
      end;
    end;
  end
  else
    FWindowProcObject.DefaultProc(Message);
end;

constructor TdxBarPopupMenuLink.Create(Collection: TCollection);
begin
  inherited;
  FProcessChildren := True;
end;

destructor TdxBarPopupMenuLink.Destroy;
begin
  Control := nil;
  inherited;
end;

procedure TdxBarPopupMenuLink.Assign(Source: TPersistent);

  function FindLinkComponent(AComponent: TComponent): TComponent;
  begin
    if AComponent <> nil then
      Result := BarManager.Owner.FindComponent(AComponent.Name)
    else
      Result := nil;
  end;

begin
  if Source is TdxBarPopupMenuLink then
  begin
    Control := FindLinkComponent(TdxBarPopupMenuLink(Source).Control) as TWinControl;
    PopupMenu := FindLinkComponent(TdxBarPopupMenuLink(Source).PopupMenu) as TdxBarPopupMenu;
    ProcessChildren := TdxBarPopupMenuLink(Source).ProcessChildren;
  end
  else
    inherited Assign(Source);
end;

function TdxBarPopupMenuLink.DoAction(Wnd: HWND; const P: TPoint): Boolean;
begin
  Result := DoAction(Control.ScreenToClient(P));
end;

{ TdxBarPopupMenuLinks }

constructor TdxBarPopupMenuLinks.Create(ABarManager: TdxBarManager);
begin
  inherited Create(TdxBarPopupMenuLink);
  FBarManager := ABarManager;
end;

function TdxBarPopupMenuLinks.GetItem(Index: Integer): TdxBarPopupMenuLink;
begin
  Result := TdxBarPopupMenuLink(inherited GetItem(Index));
end;

procedure TdxBarPopupMenuLinks.SetItem(Index: Integer; Value: TdxBarPopupMenuLink);
begin
  inherited SetItem(Index, Value);
end;

function TdxBarPopupMenuLinks.GetOwner: TPersistent;
begin
  Result := FBarManager;
end;

function TdxBarPopupMenuLinks.IsShortCut(AControl: TWinControl; AShortCut: TShortCut): Boolean;
var
  AItem: TdxBarPopupMenuLink;
  AParentBarManager: TdxBarManager;
  I: Integer;
begin
  Result := False;

  for I := 0 to Count - 1 do
  begin
    if Items[I].Control = AControl then
      Result := Items[I].IsShortCut(AShortCut);
    if Result then
      Break;
  end;

  if not Result then
    for I := 0 to Count - 1 do
    begin
      AItem := Items[I];
      if AItem.ProcessChildren and (AItem.WinControl <> nil) and
        IsChildControl(AItem.WinControl, AControl) then
          Result := AItem.IsShortCut(AShortCut);
      if Result then
        Break;
    end;

  if not Result then
  begin
    AParentBarManager := BarManager.ParentBarManager;
    if AParentBarManager <> nil then
      Result := AParentBarManager.PopupMenuLinks.IsShortCut(AControl, AShortCut);
  end;
end;

function TdxBarPopupMenuLinks.Add: TdxBarPopupMenuLink;
begin
  Result := TdxBarPopupMenuLink(inherited Add);
end;

function TdxBarPopupMenuLinks.DoAction(AControl: TWinControl; Wnd: HWND;
  const P: TPoint): Boolean;
var
  AItem: TdxBarPopupMenuLink;
  AParentBarManager: TdxBarManager;
  I: Integer;
begin
  Result := False;
  if BarManager.Designing then
    Exit;

  for I := 0 to Count - 1 do
  begin
    if Items[I].Control = AControl then
      Result := Items[I].DoAction(Wnd, P);
    if Result then
      Break;
  end;

  if not Result then
    for I := 0 to Count - 1 do
    begin
      AItem := Items[I];
      if AItem.ProcessChildren and (AItem.WinControl <> nil) and
        IsChildControl(AItem.WinControl, Wnd) then
          Result := Items[I].DoAction(Wnd, P);
      if Result then
        Break;
    end;

  if not Result then
  begin
    AParentBarManager := BarManager.ParentBarManager;
    if AParentBarManager <> nil then
      Result := AParentBarManager.PopupMenuLinks.DoAction(AControl, Wnd, P);
  end;
end;

{ TdxBarBackgrounds }

constructor TdxBarBackgrounds.Create(ABarManager: TdxBarManager);
begin
  inherited;
  FBarBackgroundBitmap := dxBarCreateBitmap(BitmapChanged);
  FSubMenuBackgroundBitmap := cxCreateBitmap(0, 0, cxDoubleBufferedBitmapPixelFormat);
end;

destructor TdxBarBackgrounds.Destroy;
begin
  FreeAndNil(FSubMenuBackgroundBitmap);
  FreeAndNil(FBarBackgroundBitmap);
  inherited Destroy;
end;

procedure TdxBarBackgrounds.Assign(Source: TPersistent);
begin
  if Source is TdxBarBackgrounds then
  begin
    Bar := TdxBarBackgrounds(Source).Bar;
    SubMenu := TdxBarBackgrounds(Source).SubMenu;
  end
  else
    inherited Assign(Source);
end;

procedure TdxBarBackgrounds.Changed;
begin
  BarManager.InternalStyleChanged; // TODO: ???
end;

procedure TdxBarBackgrounds.BitmapChanged(Sender: TObject);
begin
  Changed;
end;

procedure TdxBarBackgrounds.SetBarBackgroundBitmap(Value: TBitmap);
begin
  FBarBackgroundBitmap.Assign(Value);
end;

procedure TdxBarBackgrounds.SetSubMenuBackgroundBitmap(Value: TBitmap);
begin
  FSubMenuBackgroundBitmap.Assign(Value);
end;

{ TdxBarManager }

var
  EatKey, WaitForMenu: Boolean;
  EatingKey: WPARAM;
  InMouseHook: Boolean;

  FDockTimerID: UINT;
  FDockBarManager: TdxBarManager;

  FHintWindowShowing: Boolean;
  FHintTimerID, FHiddenHintTimerID: UINT;
  FCustomHint: string;
  FLiveHiddenHint: Boolean;

procedure KillHintTimer;
begin
  dxKillTimer(0, FHintTimerID);
end;

procedure KillHiddenHintTimer;
begin
  if dxKillTimer(0, FHiddenHintTimerID) then
    FLiveHiddenHint := False;
end;

type
  TdxBarKeyboardHookController = class
  public
    class function IsAnyKeyPressed: Boolean;
    class function GetShiftState: TShiftState;
    class function IsKeyBeingPressed(ALParam: LPARAM): Boolean;
    class function IsKeyWasDownBefore(ALParam: LPARAM): Boolean;
    class procedure EatKeyIfPressed(AWParam: WPARAM; ALParam: LPARAM);
    class procedure HandleKey(ABarManager: TdxBarManager; AWParam: WPARAM; ALParam: LPARAM; var AHookResult: LRESULT);
    class function HandleShortCut(ABarManager: TdxBarManager; AKey: Word; AShift: TShiftState; AShortCut: TShortCut): Boolean;
    class function HandleAccelKey(ABarManager: TdxBarManager; AKey: Word; AShift: TShiftState): Boolean;
    class function IsActiveBarFocused(ABarManager: TdxBarManager): Boolean;
    class function FindBarManagerAmongParents(AWnd: HWND; AFindRootAccessibleObject: Boolean; out AIRootAccessibilityHelper: IdxBarAccessibilityHelper): TdxBarManager;
    class function GetBarManager(AWParam: WPARAM; ALParam: LPARAM; out AIRootAccessibilityHelper: IdxBarAccessibilityHelper; var AHookResult: LRESULT): TdxBarManager;
    class function HandleByManager(AWParam: WPARAM; ALParam: LPARAM; var AHookResult: LRESULT): Boolean;
    class function IsSystemMenuLaunchKey(AKey: Word): Boolean;
    class function HandleByActiveBarControlIfNeeded(AWParam: WPARAM; ALParam: LPARAM; var AHookResult: LRESULT): Boolean;
    class function HideAllIfNeeded: Boolean;
  end;

class function TdxBarKeyboardHookController.IsAnyKeyPressed: Boolean;
var
  KS: TKeyboardState;
  I: Integer;
begin
  GetKeyboardState(KS);
  for I := Low(KS) to High(KS) do
  begin
    Result := KS[I] and 128 <> 0;
    if Result then Break;
  end;
end;

class function TdxBarKeyboardHookController.GetShiftState: TShiftState;
begin
  Result := [];
  if GetKeyState(VK_SHIFT) < 0 then Result := Result + [ssShift];
  if GetKeyState(VK_CONTROL) < 0 then Result := Result + [ssCtrl];
  if GetKeyState(VK_MENU) < 0 then Result := Result + [ssAlt];
end;

class function TdxBarKeyboardHookController.IsKeyBeingPressed(ALParam: LPARAM): Boolean;
begin
  Result := (ALParam and $80000000) = 0;
end;

class function TdxBarKeyboardHookController.IsKeyWasDownBefore(ALParam: LPARAM): Boolean;
begin
  Result := (ALParam and $40000000) <> 0;
end;

class procedure TdxBarKeyboardHookController.EatKeyIfPressed(AWParam: WPARAM; ALParam: LPARAM);
begin
  if IsKeyBeingPressed(ALParam) then
  begin
    EatKey := True;
    EatingKey := AWParam;
  end;
end;

class procedure TdxBarKeyboardHookController.HandleKey(ABarManager: TdxBarManager; AWParam: WPARAM; ALParam: LPARAM; var AHookResult: LRESULT);
var
  AShift: TShiftState;
  AShortCut: TShortCut;
begin
  AShift := GetShiftState;
  AShortCut := GetShortCutFromMessageData(AWParam, ALParam);
  if HandleShortCut(ABarManager, AWParam, AShift, AShortCut) then
    AHookResult := 1
  else
    if (ssAlt in AShift) and HandleAccelKey(ABarManager, AWParam, AShift) then
      AHookResult := 1;
end;

class function TdxBarKeyboardHookController.HandleShortCut(ABarManager: TdxBarManager; AKey: Word; AShift: TShiftState; AShortCut: TShortCut): Boolean;

  function IsBarManagerShortCut(ABarManager: TdxBarManager; AShortCut: TShortCut): Boolean;
  var
    ABar: TdxBar;
    I: Integer;
  begin
    if ABarManager.FIgnoreKeyStroke then
      Exit(False);
    Result := (ABarManager.MainMenuBar <> nil) and (ABarManager.MainMenuBar.IsShortCut(AShortCut));
    if not Result then
      for I := 0 to ABarManager.Bars.Count - 1 do
      begin
        ABar := ABarManager.Bars[I];
        if (ABar <> ABarManager.MainMenuBar) and
          (ABar.Visible and (ABar.Control <> nil) and ABar.Control.CanProcessShortCut or (ABarManager.GetBarIndexInRestoringList(ABar) <> -1)) then
        begin
          Result := ABar.IsShortCut(AShortCut);
          if Result then Break;
        end;
      end;
    if not Result then
      for I := 0 to ABarManager.FPopupMenus.Count - 1 do
      begin
        Result := (ABarManager.FPopupMenus[I] as TdxBarCustomPopupMenuComponent).IsShortCut(AShortCut);
        if Result then Break;
      end;
  end;

var
  AControl: TWinControl;
  ATempBarManager: TdxBarManager;
  AWnd: HWND;
  AIgnoreList: TList<TdxBarManager>;
begin
  Result := ABarManager.DoHandleKey(AKey, AShift);
  if not Result and not ABarManager.FIgnoreKeyStroke then
  begin
    AControl := dxFindVCLControl(GetFocus);
    Result := ABarManager.PopupMenuLinks.IsShortCut(AControl, AShortCut) or IsBarManagerShortCut(ABarManager, AShortCut);
  end;
  AIgnoreList := TList<TdxBarManager>.Create;
  try
    if not Result then
    begin
      AWnd := ABarManager.Owner.Handle;
      while not Result and IsChildClassWindow(AWnd) do
      begin
        AWnd := GetParent(AWnd);
        ATempBarManager := GetBarManagerByHandle(AWnd);
        if ATempBarManager <> nil then
        begin
          AIgnoreList.Add(ATempBarManager);
          Result := ATempBarManager.DoHandleKey(AKey, AShift) or IsBarManagerShortCut(ATempBarManager, AShortCut);
        end;
      end;
    end;
    if not Result then
    begin
      ATempBarManager := ABarManager;
      repeat
        ATempBarManager := dxBarManagerList.NextActive(ATempBarManager, True);
        if ATempBarManager = ABarManager then
          Break;
        if not AIgnoreList.Contains(ATempBarManager) then
          Result := ATempBarManager.DoHandleKey(AKey, AShift) or IsBarManagerShortCut(ATempBarManager, AShortCut);
      until Result;
    end;
  finally
    AIgnoreList.Free;
  end;
end;

class function TdxBarKeyboardHookController.HandleAccelKey(ABarManager: TdxBarManager; AKey: Word; AShift: TShiftState): Boolean;

  function GlobalFindItemWithAccel(ABarManager: TdxBarManager; AKey: Word; AShift: TShiftState): TdxBarItemLink;
  var
    ABar: TdxBar;
    I: Integer;
  begin
    if ABarManager.FIgnoreKeyStroke then
      Exit(nil);
    if ABarManager.MainMenuControl <> nil then
      Result := ABarManager.MainMenuBar.ItemLinks.FindItemWithAccel(AKey, AShift, nil)
    else
      Result := nil;
    if Result = nil then
      for I := 0 to ABarManager.Bars.Count - 1 do
      begin
        ABar := ABarManager.Bars[I];
        if ABar.Visible and (ABar <> ABarManager.MainMenuBar) then
        begin
          Result := ABar.ItemLinks.FindItemWithAccel(AKey, AShift, nil);
          if Result <> nil then Break;
        end;
      end;
  end;

  function GetItemLinkWithAccel(ABarManager: TdxBarManager; AKey: Word; AShift: TShiftState): TdxBarItemLink;
  var
    ATempBarManager: TdxBarManager;
    AWnd: HWND;
  begin
    Result := nil;
    AWnd := ABarManager.Owner.Handle;
    repeat
      ATempBarManager := GetBarManagerByHandle(AWnd);
      if ATempBarManager <> nil then
        Result := GlobalFindItemWithAccel(ATempBarManager, AKey, AShift);
      if not IsChildClassWindow(AWnd) then
        Break;
      AWnd := GetParent(AWnd);
    until Result <> nil;

    if Result = nil then
    begin
      ATempBarManager := ABarManager;
      repeat
        ATempBarManager := dxBarManagerList.NextActive(ATempBarManager, True);
        if ATempBarManager = ABarManager then
          Break;
        Result := GlobalFindItemWithAccel(ATempBarManager, AKey, AShift);
      until Result <> nil;
    end;
  end;

var
  AIsUniqueItem: Boolean;
  AItemLink: TdxBarItemLink;
begin
  Result := False;
  AItemLink := GetItemLinkWithAccel(ABarManager, AKey, AShift);
  if (AItemLink <> nil) and AItemLink.Item.Enabled then
  begin
    AIsUniqueItem := AItemLink.Owner.FindItemWithAccel(AKey, AShift, AItemLink) = AItemLink;
    if not AItemLink.Control.CanDestroyOnClick or not AIsUniqueItem then
      (AItemLink.BarControl as TdxBarControl).BarGetFocus(AItemLink.Control);
    if AIsUniqueItem then
    begin
      if AItemLink.Control is TdxBarSubItemControl then
        AItemLink.BarControl.IsDowned := True;
      AItemLink.Control.AcceleratorClick;
    end;
    Result := True;
  end;
end;

class function TdxBarKeyboardHookController.IsActiveBarFocused(ABarManager: TdxBarManager): Boolean;
var
  ACurIndex: Integer;
begin
  ACurIndex := dxBarManagerList.IndexOf(ABarManager);
  repeat
    Result := ABarManager.BarControlFocused;
    ABarManager := dxBarManagerList.NextActive(ABarManager, True);
  until Result or (dxBarManagerList.IndexOf(ABarManager) = ACurIndex);
end;



class function TdxBarKeyboardHookController.FindBarManagerAmongParents(AWnd: HWND; AFindRootAccessibleObject: Boolean; out AIRootAccessibilityHelper: IdxBarAccessibilityHelper): TdxBarManager;
begin
  Result := nil;
  if AWnd <> 0 then
  repeat
    if AFindRootAccessibleObject then
    begin
      AIRootAccessibilityHelper := GetRootAccessibleObject(AWnd);
      if AIRootAccessibilityHelper <> nil then
        Result := AIRootAccessibilityHelper.GetBarManager;
    end
    else
      Result := GetBarManagerByHandle(AWnd);
    if not IsChildClassWindow(AWnd) then
      Break;
    AWnd := GetParent(AWnd);
  until Result <> nil;
end;

class function TdxBarKeyboardHookController.GetBarManager(AWParam: WPARAM; ALParam: LPARAM; out AIRootAccessibilityHelper: IdxBarAccessibilityHelper; var AHookResult: LRESULT): TdxBarManager;
var
  AControl: TWinControl;
  I: Integer;
  AActiveForm: TCustomForm;
  AFindRootAccessibleObject: Boolean;
  AMessage: TMessage;
begin
  AFindRootAccessibleObject := (AWParam = VK_F10) or (AWParam = VK_MENU);
  Result := FindBarManagerAmongParents(GetFocus, AFindRootAccessibleObject, AIRootAccessibilityHelper);

  AActiveForm := GetActiveForm;
  if (Result = nil) then
  begin
    if AActiveForm <> nil then
    begin
      Result := FindBarManagerAmongParents(GetActiveForm.Handle, AFindRootAccessibleObject, AIRootAccessibilityHelper);
      if (Result = nil) and (GetActiveForm.PopupParent <> nil) and IsWindowEnabledEx(GetActiveForm.PopupParent.Handle) then
        Result := FindBarManagerAmongParents(GetActiveForm.PopupParent.Handle, AFindRootAccessibleObject, AIRootAccessibilityHelper);
      if (Result = nil) and (Application.MainForm <> nil) and IsWindowEnabledEx(Application.MainForm.Handle) then
        Result := FindBarManagerAmongParents(Application.MainForm.Handle, AFindRootAccessibleObject, AIRootAccessibilityHelper);
      if (Result <> nil) and not Result.AllowCallFromAnotherForm then
        Result := nil;
    end;
  end;

  if (Result = nil) and not AFindRootAccessibleObject then
  begin
    AControl := FindControl(GetActiveWindow);
    if (AControl <> nil) and not IsWindowEnabledEx(AControl.Handle) then
      AControl := nil;
    if (AControl is TCustomForm) and (TCustomForm(AControl).Parent = nil) then
      AControl := dxGetParentFormForDocking(AControl);
    if AControl is TCustomForm then
      for I := 0 to dxBarManagerList.Count - 1 do
        if dxBarManagerList[I].GetMainForm = AControl then
        begin
          Result := dxBarManagerList[I];
          Break;
        end;
    if (Result <> nil) and not Result.IsCustomizing and (AActiveForm <> nil) and IsWindowEnabledEx(AActiveForm.Handle) and IsKeyBeingPressed(ALParam) then
    begin
      AMessage.WParam := AWParam;
      AMessage.LParam := ALParam;
      if AActiveForm.IsShortCut(TWMKey(AMessage)) then
      begin
        Result := nil;
        AHookResult := 1;
      end;
    end;
  end;
  if (Result <> nil) and (Result.IsCustomizing or IsActiveBarFocused(Result) or not IsWindowEnabledEx(Result.Owner.Handle)) then
    Result := nil;
end;

class function TdxBarKeyboardHookController.HandleByManager(AWParam: WPARAM; ALParam: LPARAM; var AHookResult: LRESULT): Boolean;
var
  AKeyTipWindowsManager: IdxBarKeyTipWindowsManager;
  AIRootAccessibilityHelper: IdxBarAccessibilityHelper;
  ABarManager: TdxBarManager;
begin
  Result := False;
  ABarManager := GetBarManager(AWParam, ALParam, AIRootAccessibilityHelper, AHookResult);
  if ABarManager = nil then
    Exit;

  if IsKeyBeingPressed(ALParam) then  // press key
  begin
    if (((AWParam = VK_MENU) and not (ssCtrl in GetShiftState)) or
      (ABarManager.UseF10ForMenu and (AWParam = VK_F10) and (GetShiftState = []))) and
      not (EatKey and (AWParam = EatingKey)) then
    begin
      if not IsKeyWasDownBefore(ALParam) then
      begin
        ABarManager.HideHint;
        WaitForMenu := True;
        if AIRootAccessibilityHelper.AreKeyTipsSupported(AKeyTipWindowsManager) then
          BarNavigationController.BeginKeyTipsWaiting(AIRootAccessibilityHelper);
      end;
    end
    else
    begin
      BarNavigationController.EndKeyTipsWaiting(False);
      HandleKey(ABarManager, AWParam, ALParam, AHookResult);
      Result := True;
    end;
  end
  else  // release key
    if IsKeyWasDownBefore(ALParam) then
    begin
      if (AWParam = VK_MENU) and WaitForMenu or ABarManager.UseF10ForMenu and (AWParam = VK_F10) and (GetShiftState = []) then
      begin
        WaitForMenu := False;
        BarNavigationController.SelectDefaultObject(AIRootAccessibilityHelper);
        AHookResult := 1;
        Result := True;
        if AIRootAccessibilityHelper.AreKeyTipsSupported(AKeyTipWindowsManager) then
          BarNavigationController.EndKeyTipsWaiting(True);
      end
      else
        BarNavigationController.EndKeyTipsWaiting(False);
    end;
end;

class function TdxBarKeyboardHookController.IsSystemMenuLaunchKey(AKey: Word): Boolean;
begin
  Result := (AKey = VK_SPACE) and ([ssCtrl, ssShift, ssAlt] * GetShiftState = [ssAlt]);
end;

class function TdxBarKeyboardHookController.HandleByActiveBarControlIfNeeded(AWParam: WPARAM; ALParam: LPARAM; var AHookResult: LRESULT): Boolean;
const
  KeyMessages: array[Boolean] of Integer = (WM_KEYUP, WM_KEYDOWN);
begin
  Result := False;
  if EatKey and (AWParam = EatingKey) and not IsKeyBeingPressed(ALParam) then  // release eating key
  begin
    EatKey := False;
    AHookResult := 1;
    Result := True;
    Exit;
  end;
  if dsKeyAlreadyProcessed in BarDesignController.FDesignStates then
    Exit;
  if BarNavigationController.NeedsKey(AWParam, GetShiftState) then
  begin
    EatKeyIfPressed(AWParam, ALParam);
    if IsKeyBeingPressed(ALParam) then
      BarNavigationController.HandleKey(AWParam, GetShiftState);
//      if (BarNavigationController.SelectedObjectParent <> nil) or not KeyPressed then
//        EatKey := False;
    AHookResult := 1;
    Result := True;
  end
  else
  begin
    if (IsSystemMenuLaunchKey(AWParam) or IsTextCharForKeyTip(AWParam)) and
      (BarNavigationController.IsKeyTipsWaiting or BarNavigationController.KeyTipsHandlingMode)
    then
      BarNavigationController.StopKeyboardHandling;

    if IsActiveBarControlAccessible and not ActiveBarControl.IsCustomizing then
    begin
      if not ActiveBarControl.PreProcessKey(AWParam, GetShiftState) then
      begin
        EatKeyIfPressed(AWParam, ALParam);
        SendMessage(ActiveBarControl.Handle, KeyMessages[IsKeyBeingPressed(ALParam)], AWParam, ALParam);
        if (ActiveBarControl <> nil) or (GetKeyState(AWParam) >= 0) then
          EatKey := False;
        AHookResult := 1;
        Result := True;
      end
    end
    else
      if BarNavigationController.SelectedObject <> nil then
      begin
        EatKeyIfPressed(AWParam, ALParam);
        AHookResult := 1;
        Result := True;
      end
      else
        case AWParam of
          VK_DELETE:
            if IsKeyBeingPressed(ALParam) and BarDesignController.DeleteSelectedObjects(ssCtrl in GetShiftState, True) then
            begin
              AHookResult := 1;
              Result := True;
            end;
            {
            if ActiveBarControl.BarManager.SelectedItem <> nil then
            begin
              if not (ssCtrl in ShiftState) then
                ActiveBarControl.BarManager.SelectedItem.ItemLink.Free
              else
                if ActiveBarControl.BarManager.Designing and
                  ActiveBarControl.BarManager.CanDeleteComponent(ActiveBarControl.BarManager.SelectedItem.Item) then
                    ActiveBarControl.BarManager.SelectedItem.Item.Free;
              AHookResult := 1;
              Result := True;
            end;
                    }

          VK_ESCAPE:
            if (ActiveBarControl <> nil) and (GetCapture = ActiveBarControl.Handle) then
            begin
              ReleaseCapture;
              AHookResult := 1;
              Result := True;
              Exit;
            end
            else
              if IsKeyBeingPressed(ALParam) and BarDesignController.SelectParentComponent then
              begin
                AHookResult := 1;
                Result := True;
              end;

          VK_MENU:
            if (ActiveBarControl = nil) and (BarDesignController.FQuickControl <> nil) then
            begin
              EatKeyIfPressed(AWParam, ALParam);
              BarDesignController.FQuickControl.HideAll;
              if (GetKeyState(AWParam) >= 0) then
                EatKey := False;
              AHookResult := 1;
              Result := True;
            end;
        end;
  end;
end;

class function TdxBarKeyboardHookController.HideAllIfNeeded: Boolean;
begin
  Result := (BarDesignController.QuickControl <> nil) and BarDesignController.QuickControl.NeedHideOnKeyPress;
  if Result then
    BarDesignController.QuickControl.HideAll;
end;

procedure dxBarKeyboardHook(ACode: Integer; AWParam: WPARAM; ALParam: LPARAM; var AHookResult: LRESULT);
begin
  if TdxBarKeyboardHookController.HideAllIfNeeded then
    Exit;
  if ACode = HC_NOREMOVE then
    Exit;
  if FIsMDIButtonPressed then
  begin
    AHookResult := 1;
    Exit;
  end;
  if AWParam = VK_PROCESSKEY then
    Exit;  // for Korean windows
  if ACode < 0 then
    Exit;
  if TdxBarKeyboardHookController.HandleByActiveBarControlIfNeeded(AWParam, ALParam, AHookResult) then
    Exit;
  if GetCapture = 0 then
    TdxBarKeyboardHookController.HandleByManager(AWParam, ALParam, AHookResult);
end;

function BarGetMouseWheelReceiver: TdxBarMouseWheelEventReceiver;
begin
  if ActiveBarControl <> nil then
    if (ActiveBarControl.SelectedControl <> nil) and ActiveBarControl.SelectedControl.Focused then
      Result := mwrFocusedItemControl
    else
      if ActiveBarControl.NeedsMouseWheel then
        Result := mwrActiveBarControl
      else
        Result := mwrNone
  else
    Result := mwrWindow;
end;

function ProcessMessage(AWindow: HWND; out AIsMessageForMeaningParent: Boolean): Boolean;

  function IsChildWindowEx(AControl: TCustomdxBarControl; AWindow: HWND; out AIsDirectChild: Boolean): Boolean;
  begin
    repeat
      Result := AControl.IsChildWindow(AWindow);
      if not Result then
      begin
        Result := AControl.IsMeaningParent(AWindow);
        AIsDirectChild := Result;
      end
      else
        AIsDirectChild := False;
      AControl := AControl.GetEquivalentParentBar;
    until (AControl = nil) or Result;
  end;

begin
  AIsMessageForMeaningParent := False;
  Result := not ActiveBarControl.IsWindowEnabled and not ActiveBarManager.IsCustomizing or
    IsChildWindowEx(ActiveBarControl, AWindow, AIsMessageForMeaningParent);
end;

procedure dxBarMouseHook(ACode: Integer; wParam: WPARAM; lParam: LPARAM; var AHookResult: LRESULT);

var
  AMHS: PMouseHookStruct;

  function ActiveControl: TdxBarItemControl;
  begin
    Result := nil;
    if FindControl(AMHS.hwnd) is TCustomdxBarControl then
      Result := TCustomdxBarControl(FindControl(AMHS.hwnd)).SelectedControl;

    if (Result = nil) and (GetCapture > 0) and (ActiveBarControl <> nil) then
      if cxWindowFromPoint(AMHS.pt) = ActiveBarControl.Handle then
        Result := ActiveBarControl.SelectedControl
      else
      begin
        Result := ActiveBarControl.SelectedControl;
        if (Result <> nil) and
          (not (Result.ItemLink.Item is TCustomdxBarCombo) or
           not TCustomdxBarCombo(Result.ItemLink.Item).DroppedDown) then
          Result := nil;
      end;
  end;

  function NeedProcessThisEvent(AWnd: HWND): Boolean;
  var
    I: Integer;
  begin
    Result := FindControl(AWnd) <> nil;
    if IsWin95 and not Result then
      for I := 0 to Screen.FormCount - 1 do
        if Screen.Forms[I].Handle = AWnd then
        begin
          Result := True;
          Break;
        end;
  end;

  procedure CheckHookParams;

    function IsMouseOverCustomizingControl(AParentHandle, AControlHandle: HWND; const AMousePos: TPoint): Boolean;
    var
      AChildHandle: HWND;
      AClientPos: TPoint;
    begin
      AClientPos := AMousePos;
      ScreenToClient(AParentHandle, AClientPos);
      AChildHandle := ChildWindowFromPointEx(AParentHandle, AClientPos, CWP_SKIPINVISIBLE);
      Result := AChildHandle = AControlHandle;
      if not Result and (AChildHandle <> 0) and (AChildHandle <> AParentHandle) then
        Result := IsMouseOverCustomizingControl(AChildHandle, AControlHandle, AMousePos);
    end;

  var
    ACustomizingControl: TWinControl;
  begin
    if dxBarCustomizingForm <> nil then
    begin
      ACustomizingControl := dxBarCustomizingForm.BarManager.Owner;
      if (ACustomizingControl <> nil) and IsChildClassWindow(ACustomizingControl.Handle) then
      begin
        if IsMouseOverCustomizingControl(AMHS.hwnd, ACustomizingControl.Handle, AMHS.pt) then
        begin
          if (WM_MOUSEMOVE <= wParam) and (wParam <= WM_MBUTTONDBLCLK) then
            wParam := wParam - WM_MOUSEMOVE + WM_NCMOUSEMOVE;
          AMHS.hwnd := ACustomizingControl.Handle;
          AMHS.wHitTestCode := UINT(HTERROR);
        end;
      end;
    end;
  end;

  function BarsWantMouse: Boolean;

    function AllowCustomize(ABarManager: TdxBarManager): Boolean;
    begin
      Result := (dxBarCustomizingForm <> nil) and
        {#DG when adding new toolbar - BarControl must ignore mouse}
        (dxBarCustomizingForm.Active or IsChildEx(GetActiveWindow, ABarManager.Owner.Handle));
    end;

  var
    ABarManager: TdxBarManager;
    I: Integer;
  begin
    Result := False;
    if NeedProcessThisEvent(AMHS.hwnd) and (SmallInt(AMHS.wHitTestCode) = HTERROR) then
    begin
      ABarManager := dxBarManagerList.CustomizingBarManager;
      if (ABarManager <> nil) and AllowCustomize(ABarManager) then
        for I := 0 to ABarManager.Bars.Count - 1 do
          if (ABarManager.Bars[I].Control <> nil) and ABarManager.Bars[I].Control.WantMouse then
          begin
            Result := True;
            AMHS.hwnd := ABarManager.Bars[I].Control.Handle;
            AMHS.wHitTestCode := SendMessage(AMHS.hwnd, WM_NCHITTEST, 0, MakeLParam(AMHS.pt.X, AMHS.pt.Y));
            SendMessage(AMHS.hwnd, WM_SETCURSOR, AMHS.hwnd, MakeLParam(AMHS.wHitTestCode, wParam));
            Break;
          end;
    end;
  end;

  function HideAllIfNeeded(var AHookResult: LRESULT): Boolean;
  var
    AIsMessageForMeaningParent: Boolean;
    APrevActiveBarControl: TCustomdxBarControl;
  begin
    Result := False;
    if not InMouseHook and (ACode >= 0) and (ActiveBarControl <> nil) then
    begin
      InMouseHook := True;
      if ((wParam = WM_RBUTTONUP) or (wParam = WM_NCRBUTTONUP) or
        (wParam = WM_MBUTTONUP) or (wParam = WM_NCMBUTTONUP)) and
        (ActiveControl = nil) and not ProcessMessage(AMHS.hwnd, AIsMessageForMeaningParent) then
      begin
        InMouseHook := False;
        AHookResult := 1;
        Result := True;
        Exit;
      end;
      if not ActiveBarManager.Dragging then
        repeat
          APrevActiveBarControl := ActiveBarControl;
          if ({((wParam = WM_LBUTTONUP) or (wParam = WM_NCLBUTTONUP)) and (ActiveControl = nil) and
              (AnimatingSubMenu = nil) and not ActiveBarControl.IsCustomizing and
              ((ActiveBarControl is TdxBarControl) or (ActiveBarControl.ParentBar <> nil)) or}
            IsMouseDownMessage(wParam)) then
          begin
            if not ProcessMessage(AMHS.hwnd, AIsMessageForMeaningParent) then
            begin
              ActiveBarControl.HideAll(bcrUnknown);
              if not IsWindowVisible(AMHS.hwnd) then
              begin
                AHookResult := 1;
                Result := True;
              end;
            end
            else
            begin
              if AIsMessageForMeaningParent then
                ActiveBarControl.ProcessMouseDownMessageForMeaningParent(
                  AMHS.hwnd, wParam, AMHS.pt);
              Break;
            end
          end
          else
            Break;
        until (ActiveBarControl = nil) or (APrevActiveBarControl = ActiveBarControl);
      InMouseHook := False;
{      if not IsWindowVisible(AMHS.hwnd) and
        (ActiveBarControl <> nil) and ActiveBarControl.IsWindowEnabled then
      begin
        AHookResult := 1;
        Result := True;
      end;     }
    end;
  end;

  procedure CheckNavigationController;
  begin
    if ((BarNavigationController.AssignedSelectedObject <> nil) or
      BarNavigationController.IsKeyTipsWaiting or
      BarNavigationController.KeyTipsHandlingMode) and
      IsMouseDownMessage(wParam) then
        BarNavigationController.StopKeyboardHandling;
  end;

  procedure CheckBarMarkState;
  var
    AQuickControl: TdxBarPopupControl;
  begin
    if (BarDesignController.QuickControl <> nil) and
      not BarDesignController.QuickControl.IsActive and
        (BarDesignController.QuickControl <> BarDesignController.CustomizingBarControl) and
      IsMouseDownMessage(wParam) then
    begin
      AQuickControl := BarDesignController.QuickControl;
      if not AQuickControl.IsChildWindow(AMHS.hwnd) and
        (not AQuickControl.ParentBar.MouseOnMark or (wParam = WM_RBUTTONDOWN)) then
          AQuickControl.CloseUp;
    end;
  end;

  procedure ProcessManually(var AHookResult: LRESULT);
  var
    P: TPoint;
    AKeys: Longint;
  begin
    P := AMHS.pt;
    if (WM_NCMOUSEMOVE <= wParam) and (wParam <= WM_NCMBUTTONDBLCLK) then
    begin
      wParam := wParam - WM_NCMOUSEMOVE + WM_MOUSEMOVE;
      ScreenToClient(AMHS.hwnd, P);
    end;
    if wParam <> WM_MOUSEMOVE then
      SetForegroundWindow(dxBarCustomizingForm.Handle);
    AKeys :=
      Byte(GetAsyncKeyState(VK_CONTROL) < 0) * MK_CONTROL +
      Byte(LeftButtonPressed) * MK_LBUTTON +
      Byte(GetAsyncKeyState(VK_MBUTTON) < 0) * MK_MBUTTON +
      Byte(RightButtonPressed) * MK_RBUTTON +
      Byte(GetAsyncKeyState(VK_SHIFT) < 0) * MK_SHIFT;
    SendMessage(AMHS.hwnd, wParam, AKeys, MakeLParam(P.X, P.Y));
    AHookResult := 1;
  end;

  procedure TrackMouseMoving;
  var
    APoint: TPoint;
    AWnd: HWND;
    AMessage: TMessage;
    AControl: TWinControl;
  begin
    if wParam = WM_MOUSEMOVE then
    begin
      if (BarDesignController.QuickControl <> nil) and (BarDesignController.QuickControl.AlwaysTrackMouse) then
        BarDesignController.QuickControl.TrackMouse;
      AWnd := AMHS.hwnd;
      repeat
        AControl := FindControl(AWnd);
        if AControl is TCustomdxBarControl then
        begin
          if AWnd <> AMHS.hwnd then
          begin
            APoint := dxMapWindowPoint(0, AWnd, AMHS.pt);
            AMessage.Msg := WM_MOUSEMOVE;
            AMessage.WParam := 0;
            AMessage.LParam := MakeLParam(APoint.X, APoint.Y);
            (AControl as TCustomdxBarControl).WMMouseMove(TWMMouse(AMessage));
          end;
          Break;
        end;
        AWnd := GetParent(AWnd);
      until AWnd = 0;
    end;
  end;

var
  AManualProcessing: Boolean;
begin
  if (ACode = HC_ACTION) and IsMouseDownMessage(wParam) then
  begin
    BarNavigationController.ResetNavigationMode;
    WaitForMenu := False;
  end;

  AMHS := PMouseHookStruct(lParam);
  if (AMHS.hwnd = GetCapture) and (wParam <> WM_RBUTTONUP) then // TTreeView has capture while WM_RBUTTONUP
    Exit;

  CheckHookParams;
  AManualProcessing := BarsWantMouse;
  if HideAllIfNeeded(AHookResult) then
    Exit;
  CheckBarMarkState;
  CheckNavigationController;

  if AManualProcessing then
    ProcessManually(AHookResult);

  TrackMouseMoving;
end;

type
  TdxBarWndProcHookController = class
  public
    class procedure CallMainFormClientWndProc(AWnd: HWND; AMsg: Cardinal; AWParam: WPARAM; ALParam: LPARAM);
    class procedure CallOwnerWndProc(AMsg: Cardinal; AWParam: WPARAM; ALParam: LPARAM; AHandle: HWND);
    class function GetWindowParentForm(AWnd: HWND): TCustomForm;
    class function GetBarManager(AWnd: HWND): TdxBarManager;
    class function IsMdiClient(AWnd: HWND): Boolean;
  end;

class procedure TdxBarWndProcHookController.CallMainFormClientWndProc(AWnd: HWND; AMsg: Cardinal; AWParam: WPARAM; ALParam: LPARAM);
var
  ABarManager: TdxBarManager;
begin
  if (AWnd <> 0) and (Application.MainForm <> nil) and Application.MainForm.HandleAllocated then
  begin
    if IsMdiClient(AWnd) then
    begin
      ABarManager := GetBarManager(Application.MainForm.Handle);
      if (ABarManager <> nil) and not ABarManager.IsDestroying then
        ABarManager.MainFormClientWndProc(AMsg, AWParam, ALParam);
    end;
  end;
end;

class procedure TdxBarWndProcHookController.CallOwnerWndProc(AMsg: Cardinal; AWParam: WPARAM; ALParam: LPARAM; AHandle: HWND);
var
  ABarManager: TdxBarManager;
  AParentForm: TCustomForm;
  AWnd: HWND;
begin
  if (AMsg = WM_ACTIVATE) and ((AHandle = GetParent(ALParam)) or (HWND(ALParam) = GetParent(AHandle))) and
    not IsAnotherApplicationWindow(AHandle) and not IsAnotherApplicationWindow(ALParam) then
      Exit;
  AWnd := AHandle;
  if (AMsg = WM_HELP) and (ActiveBarControl <> nil) then
  begin
    AParentForm := GetWindowParentForm(AWnd);
    if (AParentForm = nil) or not IsBarManagerOwner(ActiveBarManager, AParentForm.Handle) then
      AWnd := GetBarManagerForm(ActiveBarManager, fkAny).Handle;
  end;
  ABarManager := GetBarManager(AWnd);
  if (ABarManager = nil) and (AMsg = WM_ACTIVATE) then
  begin
    if IsWindowVisible(GetParent(AHandle)) then
      ABarManager := GetBarManager(GetParent(AHandle));
  end;
  if ABarManager <> nil then
    ABarManager.OwnerWndProc(AWnd, AMsg, AWParam, ALParam);
  TdxBarManager.SendFormBroadcastMessage(AWnd, AMsg, AWParam, ALParam);
end;

class function TdxBarWndProcHookController.GetWindowParentForm(AWnd: HWND): TCustomForm;
begin
  while not (FindControl(AWnd) is TCustomForm) and (GetParent(AWnd) <> 0) do
    AWnd := GetParent(AWnd);
  if FindControl(AWnd) is TCustomForm then
    Result := TCustomForm(FindControl(AWnd))
  else
    Result := nil;
end;

class function TdxBarWndProcHookController.GetBarManager(AWnd: HWND): TdxBarManager;
begin
  Result := GetBarManagerByHandle(AWnd);
end;

class function TdxBarWndProcHookController.IsMdiClient(AWnd: HWND): Boolean;
begin
  Result := (AWnd <> 0) and SameText(cxGetClassName(AWnd), 'MDICLIENT');
end;

procedure dxBarWndProcHook(ACode: Integer; AWParam: WPARAM; ALParam: LPARAM; var AHookResult: LRESULT);
var
  AMsg: PCWPStruct;
begin
  AMsg := PCWPStruct(ALParam);

  case AMsg.message of
    WM_ACTIVATE:
      if (LOWORD(AMsg.wParam) = WA_INACTIVE) and IsAnotherApplicationWindow(AMsg.lParam) then
        FApplicationDeactivation := True;
    WM_ACTIVATEAPP:
      begin
        FApplicationDeactivation := False;
        FApplicationActive := Bool(AMsg.wParam);
        BarDesignController.SynchronizeLastSelectedItem;
      end;
  end;

  TdxBarWndProcHookController.CallOwnerWndProc(AMsg.message, AMsg.wParam, AMsg.lParam, AMsg.hwnd);
  if IsMDIForm(Application.MainForm) and Application.MainForm.HandleAllocated and
    (AMsg.hwnd = Application.MainForm.Handle) and not IsPopupMenuShowed
  then
    case AMsg.message of
// B35995
//          WM_ACTIVATE:
//            ActivateMDIChildFormToolbars(LOWORD(AMsg.wParam) <> WA_INACTIVE, AMsg.lParam);
      WM_WINDOWPOSCHANGED:
        if dxBarCustomizingForm <> nil then
          dxBarCustomizingForm.UpdateVisibility(PWindowPos(AMsg.lParam)^);
    end;

  case AMsg.message of
    WM_CHILDACTIVATE, WM_DESTROY, WM_MDIACTIVATE:
      TdxBarWndProcHookController.CallMainFormClientWndProc(GetParent(AMsg.hwnd), AMsg.message, AMsg.wParam, AMsg.lParam);
  end;
end;

var
  FPrevInitProc: TProcedure;

procedure dxBarInitProc;
begin
  if Assigned(FPrevInitProc) then
    FPrevInitProc;
  InitMMSystem;
end;

procedure RegisterdxBarManager(ABarManager: TdxBarManager);
begin
  if dxBarManagerList.IndexOf(ABarManager) < 0 then
  begin
    if dxBarManagerList.Count = 0 then
    begin
      dxSetHook(htKeyboard, dxBarKeyboardHook);
      dxSetHook(htMouse, dxBarMouseHook);
      dxSetHook(htWndProc, dxBarWndProcHook);
    end;
    dxBarManagerList.Add(ABarManager);
    if Assigned(FOnRegisterBarManager) then
      FOnRegisterBarManager(ABarManager);
  end;
  if not ABarManager.Designing then
    ABarManager.CheckHintWindow;
end;

procedure FinalizationBars;
begin
  dxReleaseHook(dxBarWndProcHook);
  dxReleaseHook(dxBarMouseHook);
  dxReleaseHook(dxBarKeyboardHook);
  FreeAndNil(FHintWindow);
end;

procedure UnregisterdxBarManager(ABarManager: TdxBarManager);
begin
  if dxBarManagerList <> nil then
  begin
    dxBarManagerList.Extract(ABarManager);
    if dxBarManagerList.Count = 0 then
      FinalizationBars;
  end;

  if Assigned(FOnUnregisterBarManager) then
    FOnUnregisterBarManager(ABarManager);
end;

{ TCustomdxBarControlViewInfo }

constructor TCustomdxBarControlViewInfo.Create(ABarControl: TCustomdxBarControl);
begin
  inherited Create;
  FBarControl := ABarControl;
  FItemControlViewInfos := TList.Create
end;

destructor TCustomdxBarControlViewInfo.Destroy;
begin
  FreeAndNil(FItemControlViewInfos);
  inherited Destroy;
end;

procedure TCustomdxBarControlViewInfo.Calculate;
begin
  Clear;
end;

function TCustomdxBarControlViewInfo.GetItemControlIndex(
  AItemControl: TdxBarItemControl): Integer;
begin
  Result := FItemControlViewInfos.IndexOf(AItemControl.ViewInfo);
end;

function TCustomdxBarControlViewInfo.IsAssociatedWithSeparator(
  AItemControl: TdxBarItemControl; out ASeparatorIndex: Integer): Boolean;
var
  I: Integer;
begin
  Result := False;
  for I := 0 to High(FSeparatorsData) do
    if FSeparatorsData[I].AssociatedItemControl = AItemControl then
    begin
      Result := True;
      ASeparatorIndex := I;
      Break;
    end;
end;

function TCustomdxBarControlViewInfo.IsItemControlVisible(
  AItemControl: TdxBarItemControl): Boolean;
begin
  Result := FItemControlViewInfos.IndexOf(AItemControl.ViewInfo) <> -1;
end;

procedure TCustomdxBarControlViewInfo.AddItemControlViewInfo(
  AViewInfo: TdxBarItemControlViewInfo);
begin
  FItemControlViewInfos.Add(AViewInfo);
end;

procedure TCustomdxBarControlViewInfo.AddSeparatorInfo(const ARect: TRect;
  AKind: TdxBarItemSeparatorKind; AAssociatedItemControl: TdxBarItemControl);
var
  AIndex: Integer;
begin
  AIndex := Length(FSeparatorsData);
  SetLength(FSeparatorsData, AIndex + 1);
  with FSeparatorsData[AIndex] do
  begin
    AssociatedItemControl := AAssociatedItemControl;
    Bounds := ARect;
    Kind := AKind;
  end;
end;

procedure TCustomdxBarControlViewInfo.Clear;
begin
  FItemControlViewInfos.Clear;
  RemoveSeparatorInfos;
end;

procedure TCustomdxBarControlViewInfo.RemoveItemControlViewInfo(
  AViewInfo: TdxBarItemControlViewInfo);
begin
  FItemControlViewInfos.Remove(AViewInfo);
end;

procedure TCustomdxBarControlViewInfo.RemoveSeparatorInfos;
begin
  SetLength(FSeparatorsData, 0);
end;

function TCustomdxBarControlViewInfo.GetItemControlCount: Integer;
begin
  Result := FItemControlViewInfos.Count;
end;

function TCustomdxBarControlViewInfo.GetItemControlViewInfo(
  AIndex: Integer): TdxBarItemControlViewInfo;
begin
  Result := TdxBarItemControlViewInfo(FItemControlViewInfos[AIndex]);
end;

function TCustomdxBarControlViewInfo.GetSeparatorCount: Integer;
begin
  Result := Length(FSeparatorsData);
end;

function TCustomdxBarControlViewInfo.GetSeparatorInfo(
  AIndex: Integer): TdxBarItemSeparatorInfo;
begin
  with FSeparatorsData[AIndex] do
  begin
    Result.Bounds := Bounds;
    Result.Kind := Kind;
  end;
end;

procedure TCustomdxBarControlViewInfo.SetSeparatorInfo(AIndex: Integer;
  const Value: TdxBarItemSeparatorInfo);
begin
  with FSeparatorsData[AIndex] do
  begin
    Bounds := Value.Bounds;
    Kind := Value.Kind;
  end;
end;

{ TdxBarDragInfo }

constructor TdxBarDragInfo.Create(ABarManager: TdxBarManager);
begin
  inherited Create;
  FBarManager := ABarManager;
end;

destructor TdxBarDragInfo.Destroy;
begin
  cxRemoveObjectLink(FDragOverBarControlLink);
  cxRemoveObjectLink(FDragLineBarControlLink);
  inherited Destroy;
end;

procedure TdxBarDragInfo.BeginDrag(AItem: TdxBarItem; AItemLink: TdxBarItemLink);
begin
  FDraggingItem := AItem;
  FDraggingItemLink := AItemLink;
  if FDraggingItemLink <> nil then
    FDragDownPoint := FDraggingItemLink.ScreenToClient(GetMouseCursorPos);
  FDefaultCursor := Screen.Cursor;
  FCaptureWnd := FBarManager.GetWindowForMouseCapturing;
  SetCapture(FCaptureWnd);
  ProcessMouseMessages;
end;

procedure TdxBarDragInfo.DragDrop;
begin
  case DraggingState of
    dsNoDrop: DeleteDraggingItemLink;
    dsNoDrag: {do nothing};
    dsBeginGroup: ChangeBeginGroup;
    dsCategory: MoveItemToAnotherCategory;
    dsCopy, dsDrag:
      begin
        FDraggingState := dsNoDrag;
        CreateNewItemLink;
      end;
  end;
end;

procedure TdxBarDragInfo.EndDrag;
begin
  if GetCapture = FCaptureWnd then
    ReleaseCapture;
  DraggingState := dsNoDrag;

  DestroyWindow(FDraggingItemLinkParentHandle);

  RepaintItemControl(DraggingControl);
  FDraggingItem := nil;
  FDraggingItemLink := nil;
  DragOverBarControl := nil;
  DragLineBarControl := nil;
end;

procedure TdxBarDragInfo.HandleDragging;
var
  AWnd: HWND;
  AMsg: TMsg;
  P: TPoint;
  AControl: TWinControl;
  ACategoryItemIndex: Integer;
  AAccept: Boolean;
begin
  Include(BarDesignController.FDesignStates, dsKeyAlreadyProcessed);
  try
    while GetCapture = FCaptureWnd do
    begin
      case Integer(GetMessage(AMsg, 0, 0, 0)) of
        -1: Break;
        0: begin
            PostQuitMessage(AMsg.wParam);
            Break;
          end;
      end;
      case AMsg.message of
        WM_KEYDOWN:
          case AMsg.wParam of
            VK_ESCAPE: Break;
            VK_CONTROL:
              if HasTarget then
                DraggingState := dsCopy;
          end;
        WM_KEYUP:
          case AMsg.wParam of
            VK_CONTROL:
              if HasTarget then
                DraggingState := dsDrag;
          end;
        WM_MOUSEMOVE:
          begin
            P := GetMouseCursorPos;

            AWnd := cxWindowFromPoint(P);
            AControl := FindControl(AWnd);

            if CategoriesList <> nil then
              if AControl = CategoriesList then
              begin
                P := CategoriesList.ScreenToClient(P);
                ACategoryItemIndex := CategoriesList.ItemAtPos(P, True);
                if (0 <= ACategoryItemIndex) and (ACategoryItemIndex <= CategoriesList.Items.Count - 1) then
                begin
                  CategoriesList.ItemIndex := ACategoryItemIndex;
                  DraggingState := dsCategory;
                end
                else
                begin
                  CategoriesList.ItemIndex := FDraggingItem.Category;
                  DraggingState := dsNoDrop;
                end;
                Continue;
              end
              else
              begin
                CategoriesList.ItemIndex := FDraggingItem.Category;
              end;

            BeginUpdate;
            try
              if (dxBarSubMenuEditor <> nil) and (dxBarSubMenuEditor.Handle = AWnd) then
                dxBarSubMenuEditor.Perform(CM_ACTIVATE, 0, 0);

              CalcDragOverItemParameters(P);

              AAccept := True;
              if DragOverBarControl <> nil then
                DragOverBarControl.DragOver(P.X, P.Y, AAccept);

              if AAccept and HasTarget then
              begin
                if IsDragCopy then
                  DraggingState := dsCopy
                else
                begin
                  if (DragOverItemControl <> nil) and (FDraggingItemLink <> nil) and
                       ((DragOverItemLink = FDraggingItemLink) or NoNeedDragLine) then
                    DraggingState := dsBeginGroup
                  else
                    DraggingState := dsDrag
                end;
              end
              else
                DraggingState := dsNoDrop;
            finally
              EndUpdate;
            end;
          end;
        WM_LBUTTONUP:
          begin
            DragDrop;
            Break;
          end;
      else
        TranslateMessage(AMsg);
        DispatchMessage(AMsg);
      end;
    end;
  finally
    Exclude(BarDesignController.FDesignStates, dsKeyAlreadyProcessed);
  end;
end;

procedure TdxBarDragInfo.BeginUpdate;
begin
  Inc(FLockCount);
end;

procedure TdxBarDragInfo.EndUpdate;
begin
  if FLockCount > 0 then
  begin
    Dec(FLockCount);
    DragInfoChanged;
  end;
end;

procedure TdxBarDragInfo.CalcDragOverItemParameters(var ACursorPos: TPoint);

  function GetDragOverBarControl(AControl: TWinControl): TCustomdxBarControl;
  var
    I: Integer;
    ABarControl: TdxBarControl;
  begin
    Result := nil;
    if AControl is TCustomdxBarControl then
    begin
      if TCustomdxBarControl(AControl).BarManager = FBarManager then
        Result := TCustomdxBarControl(AControl)
    end
    else
      for I := 0 to FBarManager.Bars.Count - 1 do
      begin
        ABarControl := FBarManager.Bars[I].Control;
        if (ABarControl <> nil) and ABarControl.WantMouse then
        begin
          Result := ABarControl;
          Break;
        end;
      end;

    if (Result <> nil) and not Result.CanCustomizing then
      Result := nil;
  end;

var
  AItemLink: TdxBarItemLink;
  AIsBeginGroup, AIsFirstPart, AIsVerticalDirection: Boolean;
begin
  AIsFirstPart := False;
  AIsBeginGroup := False;
  AIsVerticalDirection := False;
  AItemLink := nil;
  DragOverBarControl := GetDragOverBarControl(FindControl(cxWindowFromPoint(ACursorPos)));
  if DragOverBarControl <> nil then
  begin
    ACursorPos := DragOverBarControl.ScreenToClient(ACursorPos);
    DragOverBarControl.CalcDragOverParameters(ACursorPos, AItemLink,
      AIsBeginGroup, AIsFirstPart, AIsVerticalDirection);
  end;
  DragOverItemLink := AItemLink;
  DragOverBeginGroup := AIsBeginGroup;
  DragOverFirstPart := AIsFirstPart;
  DragOverVerticalDirection := AIsVerticalDirection;
end;

function TdxBarDragInfo.CategoriesList: TListBox;
begin
  if (dxBarCustomizingForm <> nil) and (FDraggingItemLink = nil) and FBarManager.Designing then
    Result := dxBarCustomizingForm.CategoriesList
  else
    Result := nil;
end;

procedure TdxBarDragInfo.DragInfoChanged;
var
  ACursor: TCursor;
begin
  if FLockCount = 0 then
  begin
    case DraggingState of
      dsNoDrop:
        begin
          ACursor := crdxBarDragNoDrop;
          DrawDraggingLine(False);
          FDragOverItemLink := nil;
        end;
      dsDrag:
        begin
          DrawDraggingLine(False);
          ACursor := crdxBarDrag;
          if not NoNeedDragLine then
            DrawDraggingLine(True);
        end;
      dsCopy:
        begin
          DrawDraggingLine(False);
          ACursor := crdxBarDragCopy;
          DrawDraggingLine(True);
        end;
      dsCategory: ACursor := crdxBarDrag;
      dsBeginGroup:
        begin
          DrawDraggingLine(False);
          ACursor := crdxBarDrag;
        end;
    else {dsNoDrag}
      begin
        ACursor := FDefaultCursor;
        DrawDraggingLine(False);
      end;
    end;
    SetCursor(Screen.Cursors[ACursor]);
    FModified := False;
  end
  else
    FModified := True;
end;

procedure TdxBarDragInfo.DrawDraggingLine(AVisible: Boolean);

  procedure CalculateDragLineParameters;
  var
    ACustomItemLink: IdxBarCustomItemLink;
    ADragLineItemLink: TdxBarItemLink;
    AIsLastControl: Boolean;
    AParentLinks: TdxBarItemLinks;
  begin
    FDragLineVerticalDirection := DragOverVerticalDirection;

    if DragOverItemLink <> nil then
    begin
      ADragLineItemLink := DragOverItemLink;
      FDragLineFirstPart := DragOverFirstPart;
      if Supports(ADragLineItemLink, IdxBarCustomItemLink, ACustomItemLink) and
        ACustomItemLink.ProcessDragLineParameters(FDragLineFirstPart, FDragOverBeginGroup, FDragLineRect) then
        Exit;
      AParentLinks := FDragOverItemLink.Owner;
      if FDragOverBeginGroup then
      begin
        if FDragLineFirstPart then
          ADragLineItemLink := AParentLinks.Prev(ADragLineItemLink, True);
        FDragLineFirstPart := not FDragLineFirstPart;
      end
      else
        if not FDragLineFirstPart then
        begin
          AIsLastControl := ADragLineItemLink.Control.FLastInRow or AParentLinks.Next(ADragLineItemLink, True).BeginGroup;
          if not AIsLastControl then
          begin
            ADragLineItemLink := AParentLinks.Next(ADragLineItemLink, True);
            FDragLineFirstPart := True;
          end;
        end;
      FDragLineRect := ADragLineItemLink.ItemRect;
    end
    else
    begin
      FDragLineFirstPart := True;
      FDragLineRect := DragLineBarControl.ClientRect;
    end;
  end;

begin
  if (FDragLineVisible <> AVisible) then
  begin
  (*
  {TODO CHECK IT}
      if not ADragLineVisible then
        FDragOverItemControl.Parent.Update;
    *)
    if AVisible then
    begin
      if DragOverBarControl <> nil then
      begin
        DragLineBarControl := DragOverBarControl;
        CalculateDragLineParameters;
        InternalDrawDraggingLine;
        FDragLineVisible := AVisible;
      end;
    end
    else
    begin
      if DragLineBarControl <> nil then
        InternalDrawDraggingLine;

      DragLineBarControl := nil;
      FDragLineVisible := AVisible;
    end;
  end;
end;

function TdxBarDragInfo.HasTarget: Boolean;
begin
  Result := (DragOverItemControl <> nil) or
    (DragOverBarControl <> nil) and (DragOverBarItemLinks.VisibleItemCount = 0);
end;

function TdxBarDragInfo.IsDragCopy: Boolean;
begin
  Result := (GetAsyncKeyState(VK_CONTROL) < 0) or (FDraggingItemLink = nil);
end;

function TdxBarDragInfo.NoNeedDragLine: Boolean;
var
  ACustomItemLink: IdxBarCustomItemLink;
begin
  Result := not HasTarget or
   ((DraggingItemLink <> nil) and
     ((DragOverItemLink = DraggingItemLink) and (not DragOverBeginGroup or not FDragOverFirstPart) or

       (FDraggingItemLink.VisibleIndex > 0) and
       (DragOverItemLink = FDraggingItemLink.Owner.Prev(FDraggingItemLink, True)) and
       (not FDraggingItemLink.BeginGroup and not FDragOverBeginGroup and not FDragOverFirstPart) or

       (FDraggingItemLink.VisibleIndex < (FDraggingItemLink.Owner.VisibleItemCount - 1)) and
       ((DragOverItemLink = FDraggingItemLink.Owner.Next(FDraggingItemLink, True)) and
         ((FDragOverBeginGroup or not DragOverItemLink.BeginGroup) and FDragOverFirstPart))) and
     (not Supports(DragOverItemLink, IdxBarCustomItemLink, ACustomItemLink) or
       not ACustomItemLink.ProcessNeedDragLine(FDraggingItemLink, FDragOverFirstPart, FDragOverBeginGroup)));
end;

procedure TdxBarDragInfo.ChangeBeginGroup;
var
  ACursorPos: TPoint;
  ABeginGroup: Boolean;
  ACursorOffset: Integer;
begin
  ACursorPos := FDraggingItemLink.ScreenToClient(GetMouseCursorPos);
  if DragOverBarControl.IsVerticalDirection then
    ACursorOffset := ACursorPos.Y - FDragDownPoint.Y
  else
    if DragOverBarControl.UseRightToLeftAlignment then
      ACursorOffset := FDragDownPoint.X - ACursorPos.X
    else
      ACursorOffset := ACursorPos.X - FDragDownPoint.X;
  ABeginGroup := ACursorOffset > 0;
  if Abs(ACursorOffset) >= MakeBeginGroupDragSize then
    if FDraggingItemLink.BeginGroup <> ABeginGroup then
    begin
      FDraggingItemLink.BarControl.SelectedLink := DraggingItemLink;
      FBarManager.InternalSetSelectedItem(DraggingControl);
      FDraggingItemLink.BeginGroup := ABeginGroup;
    end
    else
      FDraggingItemLink.BarControl.SetKeySelectedItem(DraggingControl);
end;

procedure TdxBarDragInfo.CreateNewItemLink;
var
  ASetBeginGroup{, ANeedRepaintBar}: Boolean;
  AItemLink: TdxBarItemLink;
  ACustomItemLink: IdxBarCustomItemLink;
begin
  FBarManager.LockDesignerModified(True);
  FBarManager.BeginUpdate;
  FBarManager.ItemList.BeginUpdate;
  DragOverBarItemLinks.BeginUpdate;
  try
    AItemLink := DragOverBarItemLinks.Add;
    begin
      AItemLink.InternalBringToTopInRecentList(True);

      if FDraggingItemLink <> nil then
      begin
        if not IsDragCopy then
          FDraggingItemLink.FIsMarkedForDeletion := True;
        try
          AItemLink.Assign(FDraggingItemLink);
        finally
          FDraggingItemLink.FIsMarkedForDeletion := False;
        end;
        AItemLink.FBeginGroup := False;
      end
      else
        AItemLink.Item := FDraggingItem;

      if DragOverItemLink <> nil then
      begin
        ASetBeginGroup := FDragOverBeginGroup and not FDragOverFirstPart or
          not FDragOverBeginGroup and FDragOverFirstPart and DragOverItemLink.BeginGroup;
        AItemLink.Index := DragOverItemLink.Index +
          Byte(not FDragOverBeginGroup and not FDragOverFirstPart);
        if ASetBeginGroup then
        begin
          AItemLink.BeginGroup := True;
          DragOverItemLink.BeginGroup := False;
        end;
        if Supports(DragOverItemLink, IdxBarCustomItemLink, ACustomItemLink) then
          ACustomItemLink.ProcessDroppedItemLink(AItemLink);
      end;

      AItemLink.CreateControl;
      FBarManager.InternalSetSelectedItem(AItemLink.Control);
      DragOverBarControl.SelectedLink := AItemLink;

      //temp
      if not IsDragCopy then
        DeleteDraggingItemLink;

      { WHY ???
      if (FDraggingItemLink <> nil) and not IsDragCopy then
      begin
        ANeedRepaintBar := FDraggingItemLink.Owner <> DragOverBarItemLinks;
        DeleteDraggingItemLink;
      end
      else
        ANeedRepaintBar := True;

      if ANeedRepaintBar then
        DragOverBarControl.RepaintBar;
        }

      // activate BarControl which contains new ItemLink
      if (ActiveBarControl <> nil) and (DragOverBarControl is TdxBarControl) and
        (ActiveBarControl <> DragOverBarControl) then
      begin
        ActiveBarControl.HideAll;
        TdxBarControl(DragOverBarControl).BarGetFocus(AItemLink.Control);
      end;
      BarDesignController.SelectItem(AItemLink, soAdd);
    end
  finally
    DragOverBarItemLinks.EndUpdate;
    FBarManager.ItemList.CancelUpdate;
    FBarManager.EndUpdate;
    FBarManager.LockDesignerModified(False);
  end;
end;

procedure TdxBarDragInfo.DeleteDraggingItemLink;
begin
  if FDraggingItemLink <> nil then
    FDraggingItemLink.MoveBeginGroupItemIfNeeded;
  dxFreeAndNil(FDraggingItemLink);
  FBarManager.DesignerModified;
end;

procedure TdxBarDragInfo.InternalDrawDraggingLine;
const
  LineSize = 6;
  Pairs: array[0..5] of DWORD = (2, 2, 2, 2, 2, 2);

  procedure PolyPolyLine(ADC: HDC; const Points: array of TPoint);
  begin
    Windows.PolyPolyLine(ADC, Points, Pairs, 6);
  end;

var
  ADC: HDC;
  AOrigin: Integer;
begin
  ADC := DragLineBarControl.Canvas.Handle;
  SetROP2(ADC, R2_NOT);
  try
    with FDragLineRect do
      if FDragLineVerticalDirection then
      begin
        if FDragLineFirstPart then
          AOrigin := Top
        else
          AOrigin := Bottom - LineSize;
        PolyPolyLine(ADC,
          [Point(Left, AOrigin), Point(Left, AOrigin + LineSize),
           Point(Left + 1, AOrigin + 1), Point(Left + 1, AOrigin + LineSize - 1),

           Point(Left + 2, AOrigin + 2), Point(Right - 2, AOrigin + 2),
           Point(Left + 2, AOrigin + 3), Point(Right - 2, AOrigin + 3),

           Point(Right - 2, AOrigin + 1), Point(Right - 2, AOrigin + LineSize - 1),
           Point(Right - 1, AOrigin), Point(Right - 1, AOrigin + LineSize)]);
      end
      else
      begin
        if FDragLineFirstPart then
          AOrigin := Left
        else
          AOrigin := Right - LineSize;
        PolyPolyLine(ADC,
          [Point(AOrigin, Top), Point(AOrigin + LineSize, Top),
           Point(AOrigin + 1, Top + 1), Point(AOrigin + LineSize - 1, Top + 1),

           Point(AOrigin + 2, Top + 2), Point(AOrigin + 2, Bottom - 2),
           Point(AOrigin + 3, Top + 2), Point(AOrigin + 3, Bottom - 2),

           Point(AOrigin + 1, Bottom - 2), Point(AOrigin + LineSize - 1, Bottom - 2),
           Point(AOrigin, Bottom - 1), Point(AOrigin + LineSize, Bottom - 1)]);
      end;
  finally
    SetROP2(ADC, R2_COPYPEN);
  end;
end;

procedure TdxBarDragInfo.MoveItemToAnotherCategory;
begin
  if (CategoriesList <> nil) and (FDraggingItem.Category <> CategoriesList.ItemIndex) then
    FDraggingItem.Category := CategoriesList.ItemIndex;
end;

function TdxBarDragInfo.GetDraggingControl: TdxBarItemControl;
begin
  Result := GetControlByLink(FDraggingItemLink);
end;

function TdxBarDragInfo.GetDragLineBarControl: TCustomdxBarControl;
begin
  Result := TCustomdxBarControl(GetObjectByObjectLink(FDragLineBarControlLink));
end;

function TdxBarDragInfo.GetDragOverBarControl: TCustomdxBarControl;
begin
  Result := TCustomdxBarControl(GetObjectByObjectLink(FDragOverBarControlLink));
end;

function TdxBarDragInfo.GetDragOverBarItemLinks: TdxBarItemLinks;
begin
  if DragOverBarControl <> nil then
    Result := DragOverBarControl.ItemLinks
  else
    Result := nil;
end;

function TdxBarDragInfo.GetDragOverItemControl: TdxBarItemControl;
begin
  Result := GetControlByLink(FDragOverItemLink);
end;

procedure TdxBarDragInfo.SetDraggingState(Value: TdxBarDraggingState);
begin
  if FDraggingState <> Value then
  begin
    FDraggingState := Value;
    DragInfoChanged;
  end;
end;

procedure TdxBarDragInfo.SetDragLineBarControl(Value: TCustomdxBarControl);
begin
  cxRemoveObjectLink(FDragLineBarControlLink);
  FDragLineBarControlLink := cxAddObjectLink(Value);
end;

procedure TdxBarDragInfo.SetDragOverBarControl(Value: TCustomdxBarControl);
begin
  cxRemoveObjectLink(FDragOverBarControlLink);
  FDragOverBarControlLink := cxAddObjectLink(Value);
end;

procedure TdxBarDragInfo.SetDragOverBeginGroup(Value: Boolean);
begin
  if FDragOverBeginGroup <> Value then
  begin
    FDragOverBeginGroup := Value;
    DragInfoChanged;
  end;
end;

procedure TdxBarDragInfo.SetDragOverFirstPart(Value: Boolean);
begin
  if FDragOverFirstPart <> Value then
  begin
    FDragOverFirstPart := Value;
    DragInfoChanged;
  end;
end;

procedure TdxBarDragInfo.SetDragOverVerticalDirection(Value: Boolean);
begin
  if FDragOverVerticalDirection <> Value then
  begin
    FDragOverVerticalDirection := Value;
    DragInfoChanged;
  end;
end;

procedure TdxBarDragInfo.SetDragOverItemLink(Value: TdxBarItemLink);
begin
  if FDragOverItemLink <> Value then
  begin
    FDragOverItemLink := Value;

    if FDragOverItemLink <> nil then
    begin
      DrawDraggingLine(False);
      if (DragOverItemControl <> nil) and DragOverItemControl.IsDropDown or
        (DragOverBarControl.SelectedControl <> nil) and DragOverBarControl.SelectedControl.IsDropDown then
        DragOverBarControl.SetMouseSelectedItem(DragOverItemControl)
      else
      begin  // for better painting
        FBarManager.SelectedItem := DragOverItemControl;
        DragOverBarControl.SelectedLink := DragOverItemLink;
      end;
      ProcessPaintMessages;
    end;

    DragInfoChanged;
  end;
end;

{ TdxBarImageOptions }

constructor TdxBarImageOptions.Create;
begin
  inherited;
  FNotifyComponent := TcxFreeNotificator.Create(nil);
  FNotifyComponent.OnFreeNotification := FreeNotification;

  FImagesChangeLink := TChangeLink.Create;
  FLargeImagesChangeLink := TChangeLink.Create;
  FHotImagesChangeLink := TChangeLink.Create;
  FDisabledImagesChangeLink := TChangeLink.Create;
  FDisabledLargeImagesChangeLink := TChangeLink.Create;

  FCacheGlyphs := True;
  FUseLeftBottomPixelAsTransparent := True;
  FStretchGlyphs := True;
  FImageListBkColor := clFuchsia;
  CalcGlyphSize;
end;

destructor TdxBarImageOptions.Destroy;
begin
  FreeAndNil(FDisabledImagesChangeLink);
  FreeAndNil(FDisabledLargeImagesChangeLink);
  FreeAndNil(FHotImagesChangeLink);
  FreeAndNil(FLargeImagesChangeLink);
  FreeAndNil(FImagesChangeLink);

  FreeAndNil(FNotifyComponent);
  inherited;
end;

procedure TdxBarImageOptions.Assign(Source: TPersistent);
begin
  if Source is TdxBarImageOptions then
  begin
    DisabledImages := TdxBarImageOptions(Source).DisabledImages;
    DisabledLargeImages := TdxBarImageOptions(Source).DisabledLargeImages;
    HotImages := TdxBarImageOptions(Source).HotImages;
    ImageListBkColor := TdxBarImageOptions(Source).ImageListBkColor;
    Images := TdxBarImageOptions(Source).Images;
    LargeImages := TdxBarImageOptions(Source).LargeImages;
    LargeIcons := TdxBarImageOptions(Source).LargeIcons;
    MakeDisabledImagesFaded := TdxBarImageOptions(Source).MakeDisabledImagesFaded;
    SmoothGlyphs := TdxBarImageOptions(Source).SmoothGlyphs;
    StretchGlyphs := TdxBarImageOptions(Source).StretchGlyphs;
    UseLargeImagesForLargeIcons := TdxBarImageOptions(Source).UseLargeImagesForLargeIcons;
    UseLeftBottomPixelAsTransparent := TdxBarImageOptions(Source).UseLeftBottomPixelAsTransparent;
  end
  else
    inherited Assign(Source);
end;

function TdxBarImageOptions.GetImages(AEnabled: Boolean; var ADrawImageEnabled: TdxDefaultBoolean): TCustomImageList;
begin
  Result := GetImagesCore(AEnabled, Images, DisabledImages, ADrawImageEnabled);
end;

function TdxBarImageOptions.GetImagesCore(AEnabled: Boolean;
  AImages, ADisabledImages: TCustomImageList; var ADrawImageEnabled: TdxDefaultBoolean): TCustomImageList;
begin
  if (ADisabledImages <> nil) and not AEnabled then
  begin
    ADrawImageEnabled := bTrue;
    Result := ADisabledImages;
  end
  else
  begin
    ADrawImageEnabled := dxBooleanToDefaultBoolean(AEnabled);
    Result := AImages;
  end;
end;

function TdxBarImageOptions.GetLargeImages(AEnabled: Boolean; var ADrawImageEnabled: TdxDefaultBoolean): TCustomImageList;
begin
  Result := GetImagesCore(AEnabled, LargeImages, DisabledLargeImages, ADrawImageEnabled);
end;

function TdxBarImageOptions.GetIsLoading: Boolean;

  function InternalIsLoading(AImages: TCustomImageList): Boolean;
  begin
    Result := (AImages <> nil) and (csLoading in AImages.ComponentState);
  end;

begin
  Result := InternalIsLoading(FImages) or InternalIsLoading(FDisabledImages) or
    InternalIsLoading(FDisabledLargeImages) or InternalIsLoading(FHotImages) or
    InternalIsLoading(FLargeImages);
end;

procedure TdxBarImageOptions.SetImageList(var ANewValue, AOldValue: TCustomImageList; const AChangeLink: TChangeLink);
begin
  cxSetImageList(ANewValue, AOldValue, AChangeLink, FNotifyComponent);
end;

procedure TdxBarImageOptions.SetHotImages(Value: TCustomImageList);
begin
  SetImageList(Value, FHotImages, FHotImagesChangeLink);
end;

procedure TdxBarImageOptions.SetImageListBkColor(Value: TColor);
begin
  if FImageListBkColor <> Value then
  begin
    FImageListBkColor := Value;
    CallNotify(FOnImageOptionsChange, Self);
  end;
end;

procedure TdxBarImageOptions.SetImages(Value: TCustomImageList);
begin
  SetImageList(Value, FImages, FImagesChangeLink);
end;

procedure TdxBarImageOptions.SetDisabledImages(Value: TCustomImageList);
begin
  SetImageList(Value, FDisabledImages, FDisabledImagesChangeLink);
end;

procedure TdxBarImageOptions.SetDisabledLargeImages(Value: TCustomImageList);
begin
  SetImageList(Value, FDisabledLargeImages, FDisabledLargeImagesChangeLink);
end;

procedure TdxBarImageOptions.SetLargeIcons(Value: Boolean);
begin
  if FLargeIcons <> Value then
  begin
    FLargeIcons := Value;
    CallNotify(FOnLargeIconsChange, Self);
  end;
end;

procedure TdxBarImageOptions.SetLargeImages(Value: TCustomImageList);
begin
  if FLargeImages <> Value then
  begin
    SetImageList(Value, FLargeImages, FLargeImagesChangeLink);
    if LargeIcons and UseLargeImagesForLargeIcons then
      CallNotify(FOnLargeIconsChange, Self);
  end;
end;

procedure TdxBarImageOptions.SetMakeDisabledImagesFaded(Value: Boolean);
begin
  if FMakeDisabledImagesFaded <> Value then
  begin
    FMakeDisabledImagesFaded := Value;
    CallNotify(FOnImageOptionsChange, Self);
  end;
end;

procedure TdxBarImageOptions.SetUseLargeImagesForLargeIcons(Value: Boolean);
begin
  if FUseLargeImagesForLargeIcons <> Value then
  begin
    FUseLargeImagesForLargeIcons := Value;
    CallNotify(FOnImageOptionsChange, Self);
  end;
end;

procedure TdxBarImageOptions.SetUseLeftBottomPixelAsTransparent(Value: Boolean);
begin
  if FUseLeftBottomPixelAsTransparent <> Value then
  begin
    FUseLeftBottomPixelAsTransparent := Value;
    CallNotify(FOnImageOptionsChange, Self);
  end;
end;

procedure TdxBarImageOptions.CalcGlyphSize;
begin
  if LargeIcons then
  begin
    if IsLargeImagesForLargeIcons then
      FGlyphSize := MulDiv(LargeImages.Width, dxDefaultDPI, dxGetImageSourceDPI(LargeImages))
    else
      FGlyphSize := DefaultGlyphSize * 2;
  end
  else
    FGlyphSize := DefaultGlyphSize;
end;

function TdxBarImageOptions.IsLargeImagesForLargeIcons: Boolean;
begin
  Result := UseLargeImagesForLargeIcons and (LargeImages <> nil);
end;

procedure TdxBarImageOptions.FreeNotification(AComponent: TComponent);
begin
  if AComponent = DisabledLargeImages then DisabledLargeImages := nil;
  if AComponent = DisabledImages then DisabledImages := nil;
  if AComponent = HotImages then HotImages := nil;
  if AComponent = Images then Images := nil;
  if AComponent = LargeImages then LargeImages := nil;
end;

{ TdxBarManagerPostMergeOperationInfoList }

procedure TdxBarManagerPostMergeOperationInfoList.AddOrSet(
  AChildBarManager: TdxBarManager; AOperation: TdxBarMergeOperation);
var
  AIndex: Integer;
begin
  AIndex := Find(AChildBarManager);
  if AIndex < 0 then
    AIndex := Add(TdxBarManagerPostMergeOperationInfo.Create);
  Items[AIndex].ChildBarManager := AChildBarManager;
  Items[AIndex].Operation := AOperation;
end;

function TdxBarManagerPostMergeOperationInfoList.Extract(
  AChildBarManager: TdxBarManager; out AOperation: TdxBarMergeOperation): Boolean;
var
  AIndex: Integer;
begin
  AIndex := Find(AChildBarManager);
  Result := AIndex >= 0;
  if Result then
  begin
    AOperation := Items[AIndex].Operation;
    FreeAndDelete(AIndex);
  end;
end;

function TdxBarManagerPostMergeOperationInfoList.Find(AChildBarManager: TdxBarManager): Integer;
var
  I: Integer;
begin
  Result := -1;
  for I := 0 to Count - 1 do
    if Items[I].ChildBarManager = AChildBarManager then
    begin
      Result := I;
      Break;
    end;
end;

function TdxBarManagerPostMergeOperationInfoList.GetItem(AIndex: Integer): TdxBarManagerPostMergeOperationInfo;
begin
  Result := TdxBarManagerPostMergeOperationInfo(inherited Items[AIndex]);
end;

{ TdxBarManagerMDIStateHelper }

constructor TdxBarManagerMDIStateHelper.Create(ABarManager: TdxBarManager);
begin
  inherited Create;
  FBarManager := ABarManager;
  FPostMergeOperations := TdxBarManagerPostMergeOperationInfoList.Create;
end;

destructor TdxBarManagerMDIStateHelper.Destroy;
begin
  FreeAndNil(FPostMergeOperations);
  inherited Destroy;
end;

procedure TdxBarManagerMDIStateHelper.DoActiveChildChanged(const ANewActiveChild, AOldActiveChild: HWND);
begin
  BeginChildStateChanging;
  try
    DoChildStateChanged(AOldActiveChild, scChildDeactivated);
    DoChildStateChanged(ANewActiveChild, scChildActivated);
  finally
    EndChildStateChanging;
  end;
end;

procedure TdxBarManagerMDIStateHelper.DoActiveChildMaximizedChanged(const AActiveChild: HWND);
begin
  DoChildStateChanged(AActiveChild, scMaximizedChanged);
end;

procedure TdxBarManagerMDIStateHelper.WndProc(var Message: TMessage);
var
  AChildBarManager: TdxBarManager;
  AMergeOperation: TdxBarMergeOperation;
begin
  if Message.Msg = DXM_BAR_MERGE then
  try
    AChildBarManager := TdxBarManager(Message.LParam);
    if (dxBarManagerList.IndexOf(AChildBarManager) >= 0) and PostMergeOperations.Extract(AChildBarManager, AMergeOperation) then
    begin
      if AChildBarManager.IsDestroying and (AMergeOperation = bmoMerge) then
        Exit;

      BarManager.DoBeforeMerge(AChildBarManager, AMergeOperation);
      try
        if Assigned(BarManager.OnMerge) or not BarManager.DoProcessMergeOperation(AChildBarManager, AMergeOperation) then
        begin
          BarManager.DoMenuMerging(AChildBarManager, AMergeOperation);
          BarManager.DoMerge(AChildBarManager, AMergeOperation);
        end;
      finally
        BarManager.DoAfterMerge(AChildBarManager, AMergeOperation);
      end;
    end;
  finally
    EndChildStateChanging;
  end
  else
    inherited;
end;

function TdxBarManagerMDIStateHelper.GetMergingParameters(AChildWnd: HWND; AChildStateChange: TdxBarMDIStateChange;
  out AMergeOperation: TdxBarMergeOperation; out AChildBarManager: TdxBarManager): Boolean;

  function InitializeMergingParameters(AOperation: TdxBarMergeOperation): Boolean;
  begin
    AMergeOperation := AOperation;
    AChildBarManager := GetBarManagerByHandle(AChildWnd);
    Result := AChildBarManager <> nil;
  end;

begin
  Result := False;
  if not ((AChildStateChange = scMaximizedChanged) and BarManager.AlwaysMerge) then
  begin
    if NeedMergeMDIChild(AChildStateChange, BarManager.AlwaysMerge) then
      Result := InitializeMergingParameters(bmoMerge)
    else
      if NeedUnmergeMDIChild(AChildStateChange) then
        Result := InitializeMergingParameters(bmoUnmerge)
  end;
end;

function TdxBarManagerMDIStateHelper.NeedMergeMDIChild(AChange: TdxBarMDIStateChange; AAlwaysMerge: Boolean): Boolean;
begin
  Result := (AChange <> scChildDeactivated) and (AAlwaysMerge or BarManager.IsMDIMaximized);
end;

function TdxBarManagerMDIStateHelper.NeedUnmergeMDIChild(AChange: TdxBarMDIStateChange): Boolean;
begin
  Result := (AChange = scChildDeactivated) or (AChange = scMaximizedChanged) and not BarManager.IsMDIMaximized;
end;

procedure TdxBarManagerMDIStateHelper.NotifyMDIStateChangedHandlers(AChange: TdxBarMDIStateChange; AWnd: HWND);
var
  AEventData: TdxBarMDIStateChangeEventData;
begin
  AEventData.Change := AChange;
  AEventData.Wnd := AWnd;
  BarManager.MDIStateChangedHandlers.CallEvents(BarManager, AEventData);
end;

procedure TdxBarManagerMDIStateHelper.UpdateSystemMenu(AChange: TdxBarMDIStateChange; AWnd: HWND);
begin
  if BarManager.MainMenuBar <> nil then
  begin
    if NeedMergeMDIChild(AChange, False) then
      BarManager.CreateMDIChildSystemMenu(AWnd)
    else
      if NeedUnmergeMDIChild(AChange) and BarManager.IsMDIChildSystemMenuExist then
        BarManager.DestroyMDIChildSystemMenu;
  end;
end;

procedure TdxBarManagerMDIStateHelper.BeginChildStateChanging;
begin
  Inc(FChildStateChangeLockCount);
end;

procedure TdxBarManagerMDIStateHelper.CheckLockMainForm;
begin
  if dxBarLockMainFormOnMergingMDIChildForm and (FChildStateChangeLockCount > 0) and not FMainFormLocked then
  begin
    SendMessage(Application.MainForm.Handle, WM_SETREDRAW, 0, 0);
    FMainFormLocked := True;
  end;
end;

procedure TdxBarManagerMDIStateHelper.DoChildStateChanged(AWnd: HWND; AChange: TdxBarMDIStateChange);
var
  AChildBarManager: TdxBarManager;
  AMergeOperation: TdxBarMergeOperation;
begin
  UpdateSystemMenu(AChange, AWnd);
  if GetMergingParameters(AWnd, AChange, AMergeOperation, AChildBarManager) then
  begin
    BeginChildStateChanging;
    PostMergeOperations.AddOrSet(AChildBarManager, AMergeOperation);
    CheckLockMainForm;
    if ((AChange = scMaximizedChanged) or IsZoomed(AWnd)) and not AChildBarManager.IsDestroying then
      PostMessage(Handle, DXM_BAR_MERGE, 0, LPARAM(AChildBarManager))
    else
      SendMessage(Handle, DXM_BAR_MERGE, 0, LPARAM(AChildBarManager));
  end;
  NotifyMDIStateChangedHandlers(AChange, AWnd);
end;

procedure TdxBarManagerMDIStateHelper.EndChildStateChanging;
begin
  Dec(FChildStateChangeLockCount);
  if (FChildStateChangeLockCount = 0) and FMainFormLocked then
  begin
    FMainFormLocked := False;
    SendMessage(Application.MainForm.Handle, WM_SETREDRAW, 1, 0);
    cxRedrawWindow(Application.MainForm.Handle, RDW_INVALIDATE or RDW_FRAME or RDW_ERASE or RDW_ALLCHILDREN);
    if BarManager.MainFormActive then
      BarManager.ActivateFloatToolbars(True, True, 0);
  end;
end;

{ TdxBarManagerUpdateActionsListener }

constructor TdxBarManagerUpdateActionsListener.Create(AOwner: TComponent);
begin
  inherited;
  FBarManager := AOwner as TdxBarManager;
  ControlStyle := [csActionClient];
  Parent := FBarManager.Owner;
  CorrectPosition;
end;

procedure TdxBarManagerUpdateActionsListener.InitiateAction;
var
  I: Integer;
begin
  for I := 0 to FBarManager.Bars.Count - 1 do
    with FBarManager.Bars[I] do
     if Visible then
       ItemLinks.InitiateActions;
end;

procedure TdxBarManagerUpdateActionsListener.CorrectPosition;
var
  I: Integer;
begin
  for I := 0 to Parent.ControlCount - 1 do
    if (Parent.Controls[I] <> Self) and Parent.Controls[I].Visible then
    begin
      SetBounds(Parent.Controls[I].Left, Parent.Controls[I].Top, 0, 0);
      Break;
    end;
end;

{ TdxBarManager }

constructor TdxBarManager.Create(AOwner: TComponent);
begin
  Include(FInternalState, bisCreating);
  if (AOwner = nil) and (Application.MainForm <> nil) then
    AOwner := Application.MainForm;
  if not (AOwner is TWinControl) then
    raise EdxException.Create(cxGetResourceString(@dxSBAR_BARMANAGERBADOWNER));
  if GetBarManagerByComponent(AOwner) <> nil then
    raise EdxException.Create(cxGetResourceString(@dxSBAR_BARMANAGERMORETHANONE));
  Exclude(FInternalState, bisCreating);

  inherited Create(AOwner);

  FBackgrounds := TdxBarBackgrounds.Create(Self);
  FLookAndFeel := TcxLookAndFeel.Create(Self);
  FLookAndFeel.OnChanged := LFChanged;
  Style := dxBarDefaultStyle;
  FAllowReset := True;
  FAutoDockColor := True;

  FMDIChildSystemMenuItems := TComponentList.Create;
  FMDIStateHelper := TdxBarManagerMDIStateHelper.Create(Self);
  FItems := TdxBarComponentList.Create;

  FCategories := TdxBarManagerCategories.Create(Self);
  FDockControls := TList.Create;
  FPopupMenus := TComponentList.Create(False);
  FBars := TdxBars.Create(Self);
  if not (csDesigning in ComponentState) then
    FUpdateActionsListener := TdxBarManagerUpdateActionsListener.Create(Self);

  FMergeOperationHandlers := TInterfaceList.Create;
  FReadIniFileHandlers := TcxEventHandlerCollection.Create;
  FWriteIniFileHandlers := TcxEventHandlerCollection.Create;
  FMDIStateChangedHandlers := TcxEventHandlerCollection.Create;
  FSystemFontChangedHandlers := TcxEventHandlerCollection.Create;

  FCanCustomize := True;
  FDockColor := clBtnFace;
  FBarCaptionFont := TFont.Create;
  FEditFont := TFont.Create;
  FFont := TFont.Create;
  FFont.OnChange := FontChanged;

  FGroups := TdxBarComponentList.Create;
  FOwnedObjects := TComponentList.Create;

  FHelpButtonGlyph := dxBarCreateSmartGlyph(HelpButtonGlyphChanged);
  FHideFloatingBarsWhenInactive := True;

  FThemeChangedNotificator := TdxThemeChangedNotificator.Create;
  FThemeChangedNotificator.OnThemeChanged := ThemeChanged;
  FButtonArrowWidth := dxBarDefaultButtonArrowWidth;
  FLargeButtonArrowWidth := dxBarDefaultLargeButtonArrowWidth;
  FMenusShowRecentItemsFirst := True;
  FMostRecentItemsPercents := 95;
  CalcMostRecentlyUsedUseCount;
  FPopupMenuLinks := TdxBarPopupMenuLinks.Create(Self);
  FShowFullMenusAfterDelay := True;
  FShowHint := True;
  FShowHintForDisabledItems := True;

  FUseBarHintWindow := True;
  FUseF10ForMenu := True;
  UseSystemFont := True;
  FWaitForDockingTime := 21;
  CreateToolbarsBrushes;

  FDragInfo := TdxBarDragInfo.Create(Self);

  FImageOptions := TdxBarImageOptions.Create(Self);
  FImageOptions.FImagesChangeLink.OnChange := ImageListChange;
  FImageOptions.FLargeImagesChangeLink.OnChange := LargeImageListChange;
  FImageOptions.FHotImagesChangeLink.OnChange := HotImageListChange;
  FImageOptions.FDisabledImagesChangeLink.OnChange := DisabledImageListChange;
  FImageOptions.FDisabledLargeImagesChangeLink.OnChange := DisabledLargeImageListChange;
  FImageOptions.FOnImageOptionsChange := ImageOptionsChange;
  FImageOptions.FOnLargeIconsChange := LargeIconsChange;
  if not (csDesigning in ComponentState) then
    FSavedState := TMemoryStream.Create;
  RegisterdxBarManager(Self);
  dxSystemInfo.AddListener(Self);
  if not IsDesigning then
  begin
    FWindowProcObject := cxWindowProcController.Add(AOwner as TWinControl, OwnerWindowProc);
    FBiDiMode := (AOwner as TWinControl).BiDiMode;
  end;
end;

destructor TdxBarManager.Destroy;
begin
  if not (bisCreating in FInternalState) then
  begin
    cxWindowProcController.Remove(FWindowProcObject);
    dxSystemInfo.RemoveListener(Self);
    UnregisterdxBarManager(Self);
    FreeAndNil(FThemeChangedNotificator);

    FHintObject := nil;
    if FHintTimerID <> 0 then
    begin
      KillHintTimer;
      HideHint;
    end;
    KillHiddenHintTimer;
    Customizing(False);

    FreeAndNil(FUpdateActionsListener);
    FBars.Clear;
    FreeAndNil(FSavedState);
    FreeAndNil(FImageOptions);
    FreeAndNil(FDragInfo);
    FreeAndNil(FLookAndFeel);

    DestroyToolbarsBrushes;
    FreeAndNil(FPopupMenus);
    FreeAndNil(FHelpButtonGlyph);
    FGroups.OwnsObjects := True;
    FreeAndNil(FOwnedObjects);
    FreeAndNil(FGroups);
    FreeAndNil(FFont);
    FreeAndNil(FEditFont);
    FreeAndNil(FBarCaptionFont);
    FreeAndNil(FBars);

    FreeAndNil(FMergeOperationHandlers);
    FreeAndNil(FMDIStateChangedHandlers);
    FreeAndNil(FSystemFontChangedHandlers);
    FreeAndNil(FReadIniFileHandlers);
    FreeAndNil(FWriteIniFileHandlers);
    FreeAndNil(FMDIStateHelper);

    FreeAndNil(FDockControls);
    DestroyItems;
    FreeAndNil(FCategories);
    DestroyBarRestoringList;
    FreeAndNil(FPopupMenuLinks);
    FreeAndNil(FBackgrounds);
    FreeAndNil(FDefaultPainter);
  end;
  inherited Destroy;
end;

procedure TdxBarManager.ActivateHint(AShow: Boolean; const CustomHint: string; AHintObject: TObject = nil);
var
  AHintKeeper2: IdxBarHintKeeper2;
begin
  if not IsCustomizing and ShowHint then
  begin
    FCustomHintSupported := Supports(AHintObject, IdxBarHintKeeper2, AHintKeeper2) and
      AHintKeeper2.IsCustomHintSupported;
    CheckHintWindow;
    if AShow and not IsCustomHintStyle and TdxBarHintWindow(FHintWindow).IsScreenTipWindow then
      DoActivateHint(False, '', nil);
    DoActivateHint(AShow, CustomHint, AHintObject);
  end;
end;

procedure TdxBarManager.HideHint;
begin
  ActivateHint(False, '');
end;

procedure TdxBarManager.BeginUpdate;
begin
  DoBeginUpdate(True);
end;

procedure TdxBarManager.EndUpdate(ACheckBarsChanges: Boolean = True);
begin
  DoEndUpdate(ACheckBarsChanges, True);
end;

procedure TdxBarManager.InternalSetSelectedItem(Value: TdxBarItemControl);
begin
  FSelectedItem := Value;
end;

function TdxBarManager.GetBarControlFocused: Boolean;
begin
  Result := FFocusedBarControl <> nil;
end;

function TdxBarManager.GetBarsLoading: Boolean;
begin
  Result := bisBarsLoading in FInternalState;
end;

function TdxBarManager.GetCanModifyDesigner: Boolean;
begin
  Result := FLockDesignerModifiedCount = 0;
end;

function TdxBarManager.GetCategoryItemsVisible(AIndex: Integer): TdxBarItemVisible;
begin
  if (0 <= AIndex) and (AIndex < FCategories.Count) then
    with FCategories do
      if Objects[AIndex] = nil then
        Result := ivAlways
      else
        Result := TdxBarCategoryData(Objects[AIndex]).ItemsVisible
  else Result := ivNever;
end;

function TdxBarManager.GetCategoryVisible(AIndex: Integer): Boolean;
begin
  if (0 <= AIndex) and (AIndex < FCategories.Count) then
    with FCategories do
      Result := (Objects[AIndex] = nil) or TdxBarCategoryData(Objects[AIndex]).Visible
  else Result := False;
end;

function TdxBarManager.GetDesigning: Boolean;
begin
  Result := csDesigning in ComponentState;
end;

function TdxBarManager.GetDockColor: TColor;
begin
  if FAutoDockColor then
    Result := TControlAccess(Owner).Color
  else
    Result := FDockColor;
end;

function TdxBarManager.GetDockControl(Index: Integer): TdxDockControl;
begin
  Result := FDockControls[Index];
end;

function TdxBarManager.GetDockControlCount: Integer;
begin
  Result := FDockControls.Count;
end;

function TdxBarManager.GetDragging: Boolean;
begin
  Result := DragInfo.DraggingState <> dsNoDrag;
end;

function TdxBarManager.GetDraggingItem: TdxBarItem;
begin
  Result := DragInfo.DraggingItem;
end;

function TdxBarManager.GetDraggingItemLink: TdxBarItemLink;
begin
  Result := DragInfo.DraggingItemLink;
end;

function TdxBarManager.GetFlat: Boolean;
begin
  Result := FStyle = bmsFlat;
end;

function TdxBarManager.GetFlatToolbarsBorderColor: COLORREF;

  function GetDarkValue(Value: Byte): Byte;
  begin
    Result := MulDiv(Value, 8, 10);
  end;

begin
  Result := GetSysColor(COLOR_BTNSHADOW);
  Result := RGB(
    GetDarkValue(GetRValue(Result)),
    GetDarkValue(GetGValue(Result)),
    GetDarkValue(GetBValue(Result)));
  Result := dxGetNearestColor(Result);
end;

function TdxBarManager.GetFlatToolbarsColor: COLORREF;

  function GetLightValue(Value: Byte): Byte;
  begin
    Result := Value + MulDiv(255 - Value, 16, 100);
  end;

begin
  Result := GetSysColor(COLOR_BTNFACE);
  Result := RGB(
    GetLightValue(GetRValue(Result)),
    GetLightValue(GetGValue(Result)),
    GetLightValue(GetBValue(Result)));
  Result := dxGetNearestColor(Result);
end;

function TdxBarManager.GetFlatToolbarsDownedColor: COLORREF;
begin
  Result := dxGetNearestColor(GetLightColor(11, 9, 73));
end;

function TdxBarManager.GetFlatToolbarsDownedSelColor: COLORREF;
begin
  Result := dxGetNearestColor(GetLightColor(14, 44, 40));
end;

function TdxBarManager.GetFlatToolbarsSelColor: COLORREF;
begin
  Result := dxGetNearestColor(GetLightColor(-2, 30, 72));
end;

function TdxBarManager.GetGroup(Index: Integer): TdxBarGroup;
begin
  Result := TdxBarGroup(FGroups[Index]);
end;

function TdxBarManager.GetGroupCount: Integer;
begin
  Result := FGroups.Count;
end;

function TdxBarManager.GetInternalDockControl(ADockingStyle: TdxBarDockedDockingStyle): TdxDockControl;
begin
  Result := FBars.DockControls[ADockingStyle];
end;

function TdxBarManager.GetIsCustomizing: Boolean;
begin
  Result := FIsCustomizing or Designing;
end;

function TdxBarManager.GetIsDestroying: Boolean;
begin
  Result := csDestroying in ComponentState;
end;

function TdxBarManager.GetIsHandleCreating: Boolean;
begin
  Result := bisHandleCreating in FInternalState;
end;

function TdxBarManager.GetIsInitializing: Boolean;
begin
  Result := IsLoading or (bisAfterLoading in InternalState);
end;

function TdxBarManager.GetItemCount: Integer;
begin
  Result := FItems.Count;
end;

function TdxBarManager.GetItem(Index: Integer): TdxBarItem;
begin
  if (0 <= Index) and (Index < FItems.Count) then
    Result := TdxBarItem(FItems[Index])
  else
    Result := nil;
end;

function TdxBarManager.GetLastSelectedLinkAtDesign: TdxBarItemLink;
var
  ASelectedItem: TPersistent;
begin
  ASelectedItem := GetInstance(BarDesignController.LastSelectedItem);
  if not(ASelectedItem is TdxBarItemLink) or (TdxBarItemLink(ASelectedItem).BarManager <> Self) or (TdxBarItemLink(ASelectedItem).Control = nil) then
    ASelectedItem := nil;

  Result := TdxBarItemLink(ASelectedItem);
end;

function TdxBarManager.GetRestoringListBar(Index: Integer): TdxBar;
begin
  Result := TdxBar(FBarRestoringList[Index]);
end;

function TdxBarManager.GetRestoringListBarCount: Integer;
begin
  if BarRestoringListExists then
    Result := FBarRestoringList.Count
  else
    Result := 0;
end;

function TdxBarManager.GetScaled: Boolean;
begin
  Result := Scalable;
end;

function TdxBarManager.GetTabOrder: Integer;
begin
  Result := dxBarManagerList.IndexOf(Self);
end;

procedure TdxBarManager.IniFileCollectionCallMethods(ACollection: TcxEventHandlerCollection;
  AIniFile: TCustomIniFile; AStoringKind: TdxBarStoringKind; ASection: string);
var
  AIniFileEventData: TdxBarIniFileEventData;
begin
  AIniFileEventData.IniFile := AIniFile;
  AIniFileEventData.StoringKind := AStoringKind;
  AIniFileEventData.BaseSection := ASection;
  AIniFileEventData.Delimiter := GetSectionDelimiter(AStoringKind);
  ACollection.CallEvents(Self, AIniFileEventData);
end;

function TdxBarManager.InternalGetPainterClass: TdxBarPainterClass;
begin
  Result := TdxBarPainterClass(DefaultPainter.ClassType);
end;

procedure TdxBarManager.SetAutoAlignBars(Value: Boolean);
begin
  if FAutoAlignBars <> Value then
  begin
    FAutoAlignBars := Value;
    DoLockUpdate(False, False, False);
  end;
end;

procedure TdxBarManager.SetAutoDockColor(Value: Boolean);
var
  I: Integer;
begin
  if FAutoDockColor <> Value then
  begin
    FAutoDockColor := Value;
    for I := 0 to DockControlCount - 1 do
      DockControls[I].ColorChanged;
  end;
end;

procedure TdxBarManager.SetAutoHideEmptyBars(Value: Boolean);
var
  I: Integer;
begin
  if FAutoHideEmptyBars <> Value then
  begin
    FAutoHideEmptyBars := Value;
    if not Value then
      for I := 0 to FBars.Count - 1 do
        Bars[I].FInternallyHidden := False;
  end;
end;

procedure TdxBarManager.SetBackgrounds(Value: TdxBarBackgrounds);
begin
  FBackgrounds.Assign(Value);
end;

procedure TdxBarManager.SetButtonArrowWidth(Value: Integer);
begin
  if FButtonArrowWidth <> Value then
  begin
    if Value < 2 then Exit;
    FButtonArrowWidth := Value;
    Bars.Repaint;
  end;
end;

procedure TdxBarManager.SetCategories(Value: TStrings);
begin
  Categories.Assign(Value);
end;

procedure TdxBarManager.SetCategoryItemsVisible(AIndex: Integer; Value: TdxBarItemVisible);
var
  ACategoryData: TdxBarCategoryData;
  AEmptyBars, AList: TList;
  APrevValue: TdxBarItemVisible;
  I: Integer;
begin
  if (AIndex < 0) or (AIndex >= FCategories.Count) then
    Exit;

  APrevValue := CategoryItemsVisible[AIndex];
  with FCategories do
  begin
    ACategoryData := TdxBarCategoryData(Objects[AIndex]);
    if ACategoryData = nil then
    begin
      Objects[AIndex] := TdxBarCategoryData.Create;
      ACategoryData := TdxBarCategoryData(Objects[AIndex]);
      ACategoryData.ItemsVisible := ivAlways;
      ACategoryData.Visible := True;
    end;
    if Self.IsLoading then
    begin
      ACategoryData.LoadedItemsVisible := Value;
      Exit;
    end;
    ACategoryData.ItemsVisible := Value;

    if not Designing then
    begin
      AEmptyBars := nil;
      if AutoHideEmptyBars then
      begin
        AEmptyBars := TList.Create;
        for I := 0 to FBars.Count - 1 do
          if FBars[I].ItemLinks.AvailableItemCount = 0 then AEmptyBars.Add(FBars[I]);
      end;
      Self.BeginUpdate;

      AList := TList.Create;
      try
        GetAllItemsByCategory(AIndex, AList);
        if Value = ivAlways then
        begin
          for I := AList.Count - 1 downto 0 do
            if TdxBarItem(AList[I]).Visible = APrevValue then
              TdxBarItem(AList[I]).Visible := Value;
        end
        else
          for I := 0 to AList.Count - 1 do
            if TdxBarItem(AList[I]).Visible = APrevValue then
              TdxBarItem(AList[I]).Visible := Value;
      finally
        AList.Free;

        if AutoHideEmptyBars then
          for I := 0 to Bars.Count - 1 do
            if (Value = ivNever) and (Bars[I].ItemLinks.AvailableItemCount = 0) and (AEmptyBars.IndexOf(Bars[I]) = -1) or
              (Value = ivAlways) and (Bars[I].ItemLinks.AvailableItemCount > 0) and Bars[I].FInternallyHidden then
            begin
              Bars[I].Visible := Value = ivAlways;
              Bars[I].FInternallyHidden := Value = ivNever;
            end;
        FreeAndNil(AEmptyBars);
        Self.EndUpdate;
      end;
    end;
  end;
  if Value <> APrevValue then
    DesignerModified;
end;

procedure TdxBarManager.SetCategoryVisible(AIndex: Integer; Value: Boolean);
begin
  if (0 <= AIndex) and (AIndex < FCategories.Count) and
    (CategoryVisible[AIndex] <> Value) then
  begin
    with FCategories do
    begin
      if Objects[AIndex] = nil then
      begin
        Objects[AIndex] := TdxBarCategoryData.Create;
        TdxBarCategoryData(Objects[AIndex]).ItemsVisible := ivAlways;
      end;
      TdxBarCategoryData(Objects[AIndex]).Visible := Value;
    end;
    DesignerModified;
  end;
end;

function TdxBarManager.GetMainForm: TCustomForm;
begin
  Result := GetBarManagerForm(Self, fkMain);
end;

function TdxBarManager.GetMainMenuControl: TdxBarControl;
begin
  if MainMenuBar <> nil then
    Result := FMainMenuBar.Control
  else
    Result := nil;
end;

function TdxBarManager.GetMasterForm: TCustomForm;
begin
  Result := GetBarManagerForm(Self, fkMainOrMDIChild);
end;

function TdxBarManager.GetNotDocking: TdxBarDockingStyles;
begin
  Result := FNotDocking;
end;

function TdxBarManager.GetParentBarManager: TdxBarManager;
begin
  Result := nil;
  if Owner.HandleAllocated then
    Result := GetBarManagerForComponent(GetChildWindowVCLParent(Owner.Handle));
end;

function TdxBarManager.GetParentedOwner: TWinControl;
begin
  Result := TWinControl(inherited Owner);
end;

procedure TdxBarManager.SetDockColor(Value: TColor);
var
  I: Integer;
begin
  if FDockColor <> Value then
  begin
    FDockColor := Value;
    FAutoDockColor := False;
    for I := 0 to DockControlCount - 1 do
      DockControls[I].ColorChanged;
  end;
end;

procedure TdxBarManager.SetFlatCloseButton(Value: Boolean);
begin
  if FFlatCloseButton <> Value then
  begin
    FFlatCloseButton := Value;
    if MainMenuControl <> nil then
    begin
      if (SelectedItem <> nil) and (SelectedItem.Parent = MainMenuControl) then
        SelectedItem := nil;
      MainMenuControl.RepaintBar;
    end;
  end;
end;

procedure TdxBarManager.SetFont(Value: TFont);
begin
  Font.Assign(Value);
end;

procedure TdxBarManager.SetHelpButtonGlyph(Value: TdxSmartGlyph);
begin
  FHelpButtonGlyph.Assign(Value);
end;

procedure TdxBarManager.SetHideFloatingBarsWhenInactive(Value: Boolean);
begin
  if FHideFloatingBarsWhenInactive <> Value then
  begin
    FHideFloatingBarsWhenInactive := Value;
    ShowToolbars(FMainFormActive or not FHideFloatingBarsWhenInactive, False, 0);
  end;
end;

procedure TdxBarManager.SetDraggingItem(Value: TdxBarItem);
begin
  DragInfo.DraggingItem := Value;
end;

procedure TdxBarManager.SetDraggingItemLink(Value: TdxBarItemLink);
begin
  DragInfo.DraggingItemLink := Value;
end;

function TdxBarManager.GetIsLoading: Boolean;
begin
  Result := csLoading in ComponentState;
end;

function TdxBarManager.GetIsRecreating: Boolean;
begin
  Result := csRecreating in Owner.ControlState;
end;

function TdxBarManager.GetIsStateSaving: Boolean;
begin
  Result := bisStateSaving in FInternalState;
end;

procedure TdxBarManager.SetLargeButtonArrowWidth(Value: Integer);
var
  I: Integer;
begin
  if FLargeButtonArrowWidth <> Value then
  begin
    if Value < 2 then Exit;
    FLargeButtonArrowWidth := Value;
    for I := 0 to Bars.Count - 1 do
      with Bars[I] do
        if Control <> nil then Control.RepaintBar;
  end;
end;

procedure TdxBarManager.SetLockUpdate(Value: Boolean);
begin
  if Value <> FLockUpdate then
  begin
    FLockUpdate := Value;
    if FLockUpdate then
      BeginUpdate
    else
      EndUpdate(False);
  end;
end;

procedure TdxBarManager.SetLookAndFeel(Value: TcxLookAndFeel);
begin
  FLookAndFeel.Assign(Value);
end;

procedure TdxBarManager.SetMenuAnimations(Value: TdxBarMenuAnimations);
begin
  if FMenuAnimations <> Value then
  begin
    FMenuAnimations := Value;
    DesignerModified;
    UpdateBarManagerOptions;
  end;
end;

procedure TdxBarManager.SetMenusShowRecentItemsFirst(Value: Boolean);
begin
  if FMenusShowRecentItemsFirst <> Value then
  begin
    FMenusShowRecentItemsFirst := Value;
    DesignerModified;
    UpdateBarManagerOptions;
  end;
end;

procedure TdxBarManager.SetMostRecentItemsPercents(Value: Byte);
begin
  if Value > 100 then Value := 100;
  FMostRecentItemsPercents := Value;
  CalcMostRecentlyUsedUseCount;
end;

procedure TdxBarManager.SetNotDocking(Value: TdxBarDockingStyles);
begin
  if FNotDocking <> Value then
  begin
    FNotDocking := Value;
    InternalStyleChanged; // TODO: ???
  end;
end;

procedure TdxBarManager.SetPopupMenuLinks(Value: TdxBarPopupMenuLinks);
begin
  FPopupMenuLinks.Assign(Value);
end;

procedure TdxBarManager.SetRegistryPath(Value: string);
begin
  FRegistryPath := Value;
  CorrectRegistryPath(FRegistryPath);
end;

procedure TdxBarManager.SetScaled(AValue: Boolean);
begin
  if Scaled <> AValue then
  begin
    Scalable := AValue;
    if AValue and not UseSystemFont then
      AssignFont;
  end;
end;

procedure TdxBarManager.SetSelectedItem(Value: TdxBarItemControl);
begin
  if FSelectedItem <> Value then
  begin
    if IsCustomizing and (FSelectedItem <> nil) and
      ((Value = nil) or
       (GetParentBarForControl(Value) <> GetParentBarForControl(FSelectedItem))) then
      if GetParentBarForControl(FSelectedItem) <> nil then
        GetParentBarForControl(FSelectedItem).SetMouseSelectedItem(nil)
      else
        if (dxBarSubMenuEditor <> nil) and (GetParentBarOrSubMenuForControl(FSelectedItem) =
          dxBarSubMenuEditor.ItemLinks.BarControl) then
            dxBarSubMenuEditor.ItemLinks.DestroyBarControl;
    InternalSetSelectedItem(Value);
{#DG may be un necessary ?
    if (OldSelectedItem <> nil) and (OldSelectedItem.Parent <> nil) and not Dragging then
      OldSelectedItem.Repaint;
}
{#DG
    if Designing and (FSelectedItem <> nil) and not Dragging then
      SelectComponent(FSelectedItem.ItemLink.Item);
}
(* #DG LastSelectedObject idea
    if (Value = nil) and IsCustomizing and not Designing then
      SelectedLink := nil;
*)
  end;
end;

procedure TdxBarManager.SetShowCloseButton(Value: Boolean);
begin
  if FShowCloseButton <> Value then
  begin
    FShowCloseButton := Value;
    if MainMenuControl <> nil then
    begin
      if (SelectedItem <> nil) and (SelectedItem.Parent = MainMenuControl) then
        SelectedItem := nil;
      MainMenuControl.RepaintBar;
    end;
  end;
end;

procedure TdxBarManager.SetShowFullMenusAfterDelay(Value: Boolean);
begin
  if FShowFullMenusAfterDelay <> Value then
  begin
    FShowFullMenusAfterDelay := Value;
    DesignerModified;
    UpdateBarManagerOptions;
  end;
end;

procedure TdxBarManager.SetShowHelpButton(Value: Boolean);
begin
  if FShowHelpButton <> Value then
  begin
    FShowHelpButton := Value;
    UpdateHelpButton;
  end;
end;

procedure TdxBarManager.SetShowHint(Value: Boolean);
begin
  if FShowHint <> Value then
  begin
    FShowHint := Value;
    DesignerModified;
    UpdateBarManagerOptions;
  end;
end;

procedure TdxBarManager.SetShowShortCutInHint(Value: Boolean);
begin
  if FShowShortCutInHint <> Value then
  begin
    FShowShortCutInHint := Value;
    DesignerModified;
    UpdateBarManagerOptions;
  end;
end;

procedure TdxBarManager.SetStyle(Value: TdxBarManagerStyle);
begin
  if FStyle <> Value then
  begin
    FStyle := Value;
    InternalStyleChanged;
  end;
end;

procedure TdxBarManager.SetSunkenBorder(Value: Boolean);
var
  I: Integer;
begin
  if FSunkenBorder <> Value then
  begin
    FSunkenBorder := Value;
    for I := 0 to DockControlCount - 1 do
      DockControls[I].NCChanged;
  end;
end;

procedure TdxBarManager.SetTabOrder(Value: Integer);
begin
  if Value < 0 then Value := 0;
  if Value >= dxBarManagerList.Count then Value := dxBarManagerList.Count - 1;
  dxBarManagerList.Move(dxBarManagerList.IndexOf(Self), Value);
end;

procedure TdxBarManager.SetUseSystemFont(Value: Boolean);
begin
  if FUseSystemFont <> Value then
  begin
    FUseSystemFont := Value;
    if FUseSystemFont then
      SystemInfoChanged(SPI_SETNONCLIENTMETRICS);
  end;
end;

procedure TdxBarManager.SetWaitForDockingTime(Value: Integer);
begin
  if Value >= 0 then FWaitForDockingTime := Value;
end;

function TdxBarManager.GetDisabledImages: TCustomImageList;
begin
  Result := FImageOptions.DisabledImages;
end;

function TdxBarManager.GetDisabledLargeImages: TCustomImageList;
begin
  Result := FImageOptions.DisabledLargeImages;
end;

function TdxBarManager.GetHotImages: TCustomImageList;
begin
  Result := FImageOptions.HotImages;
end;

function TdxBarManager.GetImageListBkColor: TColor;
begin
  Result := FImageOptions.FImageListBkColor;
end;

function TdxBarManager.GetImages: TCustomImageList;
begin
  Result := FImageOptions.Images;
end;

function TdxBarManager.GetLargeImages: TCustomImageList;
begin
  Result := FImageOptions.LargeImages;
end;

function TdxBarManager.GetLargeIcons: Boolean;
begin
  Result := FImageOptions.LargeIcons;
end;

function TdxBarManager.GetMainMenuBar: TdxBar;
begin
  Result := FMainMenuBar;
  if (Result <> nil) and (Result.Control <> nil) and not Result.Control.IsMainMenu then
    Result := nil;
end;

function TdxBarManager.GetMakeDisabledImagesFaded: Boolean;
begin
  Result := FImageOptions.MakeDisabledImagesFaded;
end;

function TdxBarManager.GetStretchGlyphs: Boolean;
begin
  Result := FImageOptions.StretchGlyphs;
end;

function TdxBarManager.GetUseLargeImagesForLargeIcons: Boolean;
begin
  Result := FImageOptions.UseLargeImagesForLargeIcons;
end;

procedure TdxBarManager.SetDisabledImages(Value: TCustomImageList);
begin
  FImageOptions.DisabledImages := Value;
end;

procedure TdxBarManager.SetDisabledLargeImages(Value: TCustomImageList);
begin
  FImageOptions.DisabledLargeImages := Value;
end;

procedure TdxBarManager.SetHotImages(Value: TCustomImageList);
begin
  FImageOptions.HotImages := Value;
end;

procedure TdxBarManager.SetImageListBkColor(Value: TColor);
begin
  FImageOptions.ImageListBkColor := Value;
end;

procedure TdxBarManager.SetImages(Value: TCustomImageList);
begin
  FImageOptions.Images := Value;
end;

procedure TdxBarManager.SetLargeIcons(Value: Boolean);
begin
  FImageOptions.LargeIcons := Value;
end;

procedure TdxBarManager.SetLargeImages(Value: TCustomImageList);
begin
  FImageOptions.LargeImages := Value;
end;

procedure TdxBarManager.SetMakeDisabledImagesFaded(Value: Boolean);
begin
  FImageOptions.MakeDisabledImagesFaded := Value;
end;

procedure TdxBarManager.SetStretchGlyphs(Value: Boolean);
begin
  FImageOptions.StretchGlyphs := Value;
end;

procedure TdxBarManager.SetUseLargeImagesForLargeIcons(Value: Boolean);
begin
  FImageOptions.UseLargeImagesForLargeIcons := Value;
end;

procedure TdxBarManager.DisabledImageListChange(Sender: TObject);
begin
  CustomImagesChanged(DisabledImagesChanged);
end;

procedure TdxBarManager.DisabledLargeImageListChange(Sender: TObject);
begin
  CustomImagesChanged(DisabledLargeImagesChanged);
end;

procedure TdxBarManager.HotImageListChange(Sender: TObject);
begin
  CustomImagesChanged(HotImagesChanged);
end;

procedure TdxBarManager.ImageListChange(Sender: TObject);
begin
  CustomImagesChanged(ImagesChanged);
end;

procedure TdxBarManager.ImageOptionsChange(Sender: TObject);
begin
  Bars.Repaint;
end;

procedure TdxBarManager.LargeIconsChange;
begin
  FImageOptions.CalcGlyphSize;
  DesignerModified;
  UpdateBarManagerOptions;
  Bars.Repaint;
end;

procedure TdxBarManager.LargeImageListChange(Sender: TObject);
begin
  CustomImagesChanged(LargeImagesChanged);
end;

function TdxBarManager.BarByNewName(const AName: string): TdxBar;
var
  I: Integer;
begin
  for I := 0 to FBars.Count - 1 do
  begin
    Result := FBars[I];
    if Result.Name = AName then Exit;
  end;
  Result := nil;
end;

procedure TdxBarManager.FontChanged(Sender: TObject);
var
  I: Integer;
begin
  if not FInternalFontChange then
    FUseSystemFont := False;

  if Scaled then
  begin
    Font.OnChange := nil;
    try
      AssignFont;
    finally
      Font.OnChange := FontChanged;
    end;
  end;

  CreateEditFontHandle(Font, FEditFont, Scaled, ScaleFactor);
  FBarCaptionFont.Handle := CreateToolbarCaptionFontHandle(Font, UseSystemFont, ScaleFactor);
  FSystemFontChangedHandlers.CallEvents(Self, []);
  for I := 0 to Bars.Count - 1 do
    Bars[I].InternalUpdateFont;
  for I := 0 to FPopupMenus.Count - 1 do
    TdxBarPopupMenu(FPopupMenus[I]).InternalUpdateFont;
end;

{ TSystemMenuSubItem }

type
  TSystemMenuSubItem = class(TCustomdxBarSubItem)
  strict private
    FMDIChildHandle: HWND;

    procedure ButtonClick(Sender: TObject);
  protected
    procedure BuildMenu;
    procedure DirectClick; override;
    function GetIconHandle(AScaleFactor: TdxScaleFactor): HICON;
  public
    property MDIChildHandle: HWND read FMDIChildHandle write FMDIChildHandle;
  end;

{ TSystemMenuSubItem }

function TSystemMenuSubItem.GetIconHandle(AScaleFactor: TdxScaleFactor): HICON;
begin
  Result := dxGetFormIcon(MDIChildHandle, AScaleFactor.Apply(16), AScaleFactor.Apply(16));
end;

procedure TSystemMenuSubItem.ButtonClick(Sender: TObject);
begin
  SendMessage(MDIChildHandle, WM_SYSCOMMAND, TdxBarItem(Sender).Tag, 0);
end;

procedure TSystemMenuSubItem.BuildMenu;
const
  SLength = 1024;

  procedure BuildSubMenu(SubItem: TCustomdxBarSubItem; Menu: HWND);
  const
    BitmapNames: array[HBMMENU_POPUP_CLOSE..HBMMENU_POPUP_MINIMIZE] of string =
      ('DXBARCLOSE', 'DXBARRESTORE', 'DXBARMAXIMIZE', 'DXBARMINIMIZE');
  var
    ABeginGroup: Boolean;
    AItemText: array[0..SLength - 1] of Char;
    I, P: Integer;
    MI: TMenuItemInfo;
    AShortCutText: string;
    AItem: TdxBarItem;
    ABitmap: TBitmap;
  begin
    ABeginGroup := False;
    for I := 0 to GetMenuItemCount(Menu) - 1 do
    begin
      with MI do
      begin
        if not IsWin95 then
          cbSize := SizeOf(MI)
        else
        begin
          cbSize := 44;
          MI.hbmpItem := 0;
        end;
        fMask := MIIM_CHECKMARKS or MIIM_ID or MIIM_STATE or MIIM_SUBMENU or MIIM_TYPE;
        dwTypeData := AItemText;
        cch := SLength;
      end;
      GetMenuItemInfo(Menu, I, True, MI);

      if MI.fType and MFT_SEPARATOR <> 0 then
      begin
        ABeginGroup := True;
        Continue;
      end;

      if MI.fType and MFT_BITMAP <> 0 then
        GetMenuString(Menu, I, AItemText, SLength, MF_BYPOSITION)
      else
        if MI.cch = 0 then
          AItemText := '';
      P := Pos(#9, AItemText);
      if P = 0 then
        AShortCutText := ''
      else
      begin
        AShortCutText := Copy(AItemText, P + 1, Length(AItemText) - P);
        StrLCopy(AItemText, AItemText, P - 1);
      end;

      if MI.hSubMenu = 0 then
      begin
        AItem := TdxBarButton.Create(Owner);
        if MI.fState and MFS_CHECKED <> 0 then
          with TdxBarButton(AItem) do
          begin
            ButtonStyle := bsChecked;
            Down := True;
          end;
        with AItem do
        begin
          Tag := MI.wID;
          OnClick := ButtonClick;
        end;
      end
      else
      begin
        AItem := TdxBarSubItem.Create(Owner);
        BuildSubMenu(TCustomdxBarSubItem(AItem), MI.hSubMenu);
      end;
      BarDesignController.AddInternalItem(AItem);
      with AItem do
      begin
        Caption := AItemText;
        Enabled := MI.fState and (MFS_DISABLED or MFS_GRAYED) = 0;
        ABitmap := TBitmap.Create;
        try
          if InRange(MI.hbmpItem, HBMMENU_POPUP_CLOSE, HBMMENU_POPUP_MINIMIZE) then
            ABitmap.Handle := LoadBitmap(HInstance, PChar(BitmapNames[MI.hbmpItem]))
          else
          begin
            if MI.fState and MFS_CHECKED <> 0 then
              if MI.hbmpChecked <> 0 then
                ABitmap.Handle := CopyImage(MI.hbmpChecked, IMAGE_BITMAP, 0, 0, 0)
              else
            else
              if MI.hbmpUnchecked <> 0 then
                ABitmap.Handle := CopyImage(MI.hbmpUnchecked, IMAGE_BITMAP, 0, 0, 0);
            if (ABitmap.Handle = 0) and (MI.fType and MFT_BITMAP <> 0) then
              ABitmap.Handle := CopyImage(HBITMAP(MI.dwTypeData), IMAGE_BITMAP, 0, 0, 0);
          end;
          ShortCut := TextToShortCut(AShortCutText);
          Glyph.Assign(ABitmap);
        finally
          ABitmap.Free;
        end;
      end;

      with SubItem.ItemLinks.Add do
      begin
        BeginGroup := ABeginGroup;
        Item := AItem;
      end;
      ABeginGroup := False;
    end;
  end;

begin
  BarDesignController.ClearInternalItems;
  BuildSubMenu(Self, GetSystemMenu(FMDIChildHandle, False));
end;

procedure TSystemMenuSubItem.DirectClick;
begin
  BuildMenu;
  inherited;
end;

{ TSystemMenuSubItemControl }

type
  TSystemMenuSubItemControl = class(TdxBarSubItemControl)
  private
    function GetItem: TSystemMenuSubItem;
  protected
    function CanActivate: Boolean; override;
    function CanCustomize: Boolean; override;
    function CanSelect: Boolean; override;
    procedure DblClick; override;
    procedure DoPaint(ARect: TRect; PaintType: TdxBarPaintType); override;
    function HasShadow: Boolean; override;
    function GetDefaultHeight: Integer; override;
    function GetDefaultWidth: Integer; override;
    function IsExpandable: Boolean; override;
    function WantsDblClick: Boolean; override;
  public
    property Item: TSystemMenuSubItem read GetItem;
  end;

function TSystemMenuSubItemControl.GetItem: TSystemMenuSubItem;
begin
  Result := TSystemMenuSubItem(ItemLink.Item);
end;

function TSystemMenuSubItemControl.CanActivate: Boolean;
begin
  Result := inherited CanActivate and not BarManager.Dragging;
end;

function TSystemMenuSubItemControl.CanCustomize: Boolean;
begin
  Result := False;
end;

function TSystemMenuSubItemControl.CanSelect: Boolean;
begin
  Result := not BarManager.IsCustomizing;
end;

procedure TSystemMenuSubItemControl.DblClick;
begin
  inherited;
  Parent.HideAll;
  SendMessage(Item.MDIChildHandle, WM_SYSCOMMAND, GetMenuDefaultItem(GetSystemMenu(Item.MDIChildHandle, False), 0, 0), 0);
end;

procedure TSystemMenuSubItemControl.DoPaint(ARect: TRect; PaintType: TdxBarPaintType);
var
  AIcon: HIcon;
begin
  AIcon := Item.GetIconHandle(ScaleFactor);
  try
    Parent.FillBackground(Canvas.Handle, ARect, Parent.BkBrush, clNone, True);
    DrawIconEx(Canvas.Handle, ARect.Left, ARect.Top, AIcon, cxRectWidth(ARect), cxRectHeight(ARect), 0, 0, DI_NORMAL);
  finally
    DestroyIcon(AIcon);
  end;
end;

function TSystemMenuSubItemControl.HasShadow: Boolean;
begin
  Result := False;
end;

function TSystemMenuSubItemControl.GetDefaultHeight: Integer;
begin
  Result := dxGetSystemMetrics(SM_CYSMICON, ScaleFactor);
end;

function TSystemMenuSubItemControl.GetDefaultWidth: Integer;
begin
  Result := dxGetSystemMetrics(SM_CXSMICON, ScaleFactor);
end;

function TSystemMenuSubItemControl.IsExpandable: Boolean;
begin
  Result := False;
end;

function TSystemMenuSubItemControl.WantsDblClick: Boolean;
begin
  Result := True;
end;

{ continuation }

function TdxBarManager.ActiveMDIChild: HWND;
begin
  if (Application.MainForm <> nil) and (Application.MainForm.ClientHandle <> 0) then
    Result := SendMessage(Application.MainForm.ClientHandle, WM_MDIGETACTIVE, 0, 0)
  else
    Result := 0;
end;

procedure TdxBarManager.DoMDIButtonCommand(AButton: TdxBarMDIButton);
begin
  SendMessage(ActiveMDIChild, WM_SYSCOMMAND, MDIButtonCommands[AButton], 0);
end;

procedure TdxBarManager.CreateMDIChildSystemMenu(AWnd: HWND);
var
  ASystemMenuSubItem: TSystemMenuSubItem;
begin
  if GetSystemMenu(AWnd, False) = 0 then Exit;
  ASystemMenuSubItem := TSystemMenuSubItem.Create(Owner);
  BarDesignController.AddInternalItem(ASystemMenuSubItem, FMDIChildSystemMenuItems);
  ASystemMenuSubItem.MDIChildHandle := AWnd;
  with MainMenuBar.ItemLinks.Add do
  begin
    Item := ASystemMenuSubItem;
    Index := 0;
  end;
end;

procedure TdxBarManager.DestroyMDIChildSystemMenu;
begin
  FMDIChildSystemMenuItems.Clear;
end;

function TdxBarManager.IsMDIChildSystemMenuExist: Boolean;
begin
  Result := FMDIChildSystemMenuItems.Count <> 0; // TODO
end;

procedure TdxBarManager.CheckToolbarsVisibility;
var
  WorkArea, R: TRect;
  I: Integer;
begin
  WorkArea := GetWorkArea(Point(Owner.Left + Owner.Width div 2, Owner.Top + Owner.Height div 2));
  for I := 0 to FBars.Count - 1 do
    with FBars[I] do
      if DockingStyle = dsNone then
      begin
        if Control = nil then
          R := Bounds(FloatLeft, FloatTop,
            BarNCSizeX(dsNone) + FloatClientWidth, BarNCSizeY(dsNone) + FloatClientHeight)
        else
          R := Control.BoundsRect;
        with WorkArea do
        begin
          if R.Bottom > Bottom then OffsetRect(R, 0, Bottom - R.Bottom);
          if R.Top < Top then OffsetRect(R, 0, Top - R.Top);
          if R.Right > Right then OffsetRect(R, Right - R.Right, 0);
          if R.Left < Left then OffsetRect(R, Left - R.Left, 0);
        end;
        if Control = nil then
        begin
          LockDesignerModified(True);
          try
            FloatLeft := R.Left;
            FloatTop := R.Top;
          finally
            LockDesignerModified(False);
          end;
        end
        else
          Control.BoundsRect := R;
      end;
end;

class function TdxBarManager.IsFormBroadcastMessage(AMsg: UINT): Boolean;
begin
  Result := (AMsg = WM_ACTIVATE) or (AMsg = WM_ACTIVATEAPP) or
    (AMsg = WM_CHILDACTIVATE) or (AMsg = WM_MDIACTIVATE) or
    (AMsg = WM_SYSCOLORCHANGE) or (AMsg = WM_SYSCOMMAND) or
    (AMsg = WM_WINDOWPOSCHANGED) or (AMsg = WM_WINDOWPOSCHANGING);
end;

function TdxBarManager.IsOwnerMDIChild(ARecursive: Boolean): Boolean;
begin
  if ARecursive then
    Result := IsMDIChild(GetBarManagerForm(Self, fkMainOrMDIChild))
  else
    Result := (Owner is TCustomForm) and IsMDIChild(TCustomForm(Owner));
end;

procedure TdxBarManager.MainFormClientWndProc(Msg: UINT; AWParam: WPARAM; ALParam: LPARAM);

  function HasChanges: Boolean;
  var
    I: Integer;
  begin
    Result := False;
    for I := 0 to Bars.Count - 1 do
    begin
      Result := Bars[I].FChanged;
      if Result then Break;
    end;
  end;

var
  AActiveMDIChild: HWND;
  APrevActiveMDIChild: HWND;
  APrevIsMDIMaximized: Boolean;
begin
  AActiveMDIChild := ActiveMDIChild;
  APrevActiveMDIChild := FPrevActiveMDIChild;
  APrevIsMDIMaximized := IsMDIMaximized;
  FIsMDIMaximized := (AActiveMDIChild <> 0) and IsZoomed(AActiveMDIChild);

  DoBeginUpdate(False);
  try
    if AActiveMDIChild <> APrevActiveMDIChild then
    begin
      FPrevActiveMDIChild := AActiveMDIChild;
      MDIStateHelper.DoActiveChildChanged(AActiveMDIChild, APrevActiveMDIChild);
    end
    else
      if IsMDIMaximized <> APrevIsMDIMaximized then
        MDIStateHelper.DoActiveChildMaximizedChanged(AActiveMDIChild);
  finally
    if HasChanges then
      DoEndUpdate(True, False)
    else
      DoCancelUpdate(False);

    if IsMDIMaximized and (MainMenuControl <> nil) then
      PostMessage(MainMenuControl.Handle, DXM_BAR_REPAINTBAR, 0, 0);
  end;
end;

procedure TdxBarManager.OwnerWndProc(AWnd: HWND; AMsg: UINT; AWParam: WPARAM; ALParam: LPARAM);

  procedure HandleFormBroadcastMessage;
  begin
    case AMsg of
      WM_ACTIVATE:
        if not FApplicationDeactivation then
          DoActivate(LOWORD(AWParam), HiWord(AWParam), AWnd, ALParam);
      WM_ACTIVATEAPP:
        DoActivateApp(Bool(AWParam), ALParam);
      WM_CHILDACTIVATE:
        ActivateFloatToolbars(True, False, 0);
      WM_MDIACTIVATE:
        ActivateFloatToolbars(HWND(ALParam) = AWnd, False, 0);
      WM_SYSCOLORCHANGE:
        begin
          RefreshDeviceConsts;
          CreatePatternBrush;
          RecreateToolbarsBrushes;
          RefreshFloatingBarsShadows;
        end;
      WM_SYSCOMMAND:
        if (AWParam = SC_CLOSE) and Designing and (ActiveBarControl <> nil) and
          (ActiveBarManager = Self) then
            ActiveBarControl.HideAll;
      WM_WINDOWPOSCHANGING:
        if PWindowPos(ALParam).flags and SWP_HIDEWINDOW <> 0 then
          ActivateFloatToolbars(False, True, 0);
      WM_WINDOWPOSCHANGED:
        begin
          if FIsCustomizing and (dxBarCustomizingForm <> nil) then
          begin
            dxBarCustomizingForm.UpdateVisibility(PWindowPos(ALParam)^);
            if dxBarSubMenuEditor <> nil then
              if PWindowPos(ALParam).flags and SWP_SHOWWINDOW <> 0 then
                ShowWindow(dxBarSubMenuEditor.Handle, SW_SHOWNA)
              else
                if PWindowPos(ALParam).flags and SWP_HIDEWINDOW <> 0 then
                  ShowWindow(dxBarSubMenuEditor.Handle, SW_HIDE);
          end;

          if not IsOwnerMDIChild(True) and (PWindowPos(ALParam).flags and SWP_SHOWWINDOW <> 0) then
            ActivateFloatToolbars(True, True, 0);
        end;
    end;
  end;

  procedure HandleOwnerMessage;

    procedure ExecHelpCommand(AItemControl: TdxBarItemControl; ABarControl: TCustomdxBarControl);
    var
      P: TPoint;
      AContextID, AItemContextID, ABarContextID: Integer;
    begin
      if AItemControl <> nil then
        AItemContextID := AItemControl.Item.HelpContext
      else
        AItemContextID := 0;
      ABarContextID := ABarControl.HelpContext;
      AContextID := IfThen(AItemContextID <> 0, AItemContextID, ABarContextID);

      HideAll;
      if AContextID <> 0 then
      begin
        if biHelp in TCustomFormAccess(GetBarManagerForm(Self, fkAny)).BorderIcons then
        begin
          if AItemContextID <> 0 then
          begin
            with AItemControl.ItemBounds do
              P := Point((Left + Right) div 2, Bottom);
            ClientToScreen(ABarControl.Handle, P);
            Application.HelpCommand(HELP_SETPOPUP_POS, dxPointToLParam(P));
          end;
          Application.HelpCommand(HELP_CONTEXTPOPUP, AContextID);
        end
        else
          Application.HelpContext(AContextID);
      end;
    end;

    procedure HandleHelpByActiveControl;
    var
      ABarControl: TCustomdxBarControl;
      AItemControl: TdxBarItemControl;
    begin
      ABarControl := ActiveBarControl;
      AItemControl := ABarControl.SelectedControl;
      if (AItemControl = nil) or (AItemControl.Item.HelpContext = 0) then
      begin
        while ABarControl.ParentBar <> nil do
        begin
          if ABarControl is TdxBarSubMenuControl then
          begin
            AItemControl := TdxBarSubMenuControl(ABarControl).ParentItemControl;
            if (AItemControl <> nil) and (AItemControl.Item.HelpContext <> 0) then Break;
          end;
          ABarControl := ABarControl.ParentBar;
        end;
      end;
      ExecHelpCommand(AItemControl, ABarControl);
    end;

    procedure HandleHelpByInActiveControl(const AHelpInfo: THelpInfo);
    var
      AControl: TWinControl;
      AItemControl: TdxBarItemControl;
      P: TPoint;
    begin
      AControl := FindControl(AHelpInfo.hItemHandle);
      if AControl is TCustomdxBarControl then
      begin
        P := AHelpInfo.MousePos;
        ScreenToClient(AControl.Handle, P);
        AItemControl := TCustomdxBarControl(AControl).ItemAtPos(P);

        ExecHelpCommand(AItemControl, TCustomdxBarControl(AControl));
      end;
    end;

  begin
    case AMsg of
      WM_CANCELMODE:
        DoModalActivate;
      WM_CREATE:
        DoCreate;
      WM_DISPLAYCHANGE:
        CheckToolbarsVisibility;
      WM_HELP:
        if not Designing and (PHelpInfo(ALParam).iContextType = HELPINFO_WINDOW) then
        begin
          if ActiveBarControl <> nil then
            HandleHelpByActiveControl
          else
            HandleHelpByInActiveControl(PHelpInfo(ALParam)^)
        end;
    end;
  end;

begin
  if (csDestroying in Owner.ComponentState) or (Owner = dxBarCustomizingForm) then
  begin
    if (AMsg = WM_DESTROY) and not Designing then
    begin
      if StoreInRegistry then
        SaveToRegistry(RegistryPath);
      if StoreInIniFile then
        SaveToIniFile(IniFileName);
    end;
    Exit;
  end;

  if Bars = nil then
    Exit;

  if IsFormBroadcastMessage(AMsg) then
    HandleFormBroadcastMessage
  else
    HandleOwnerMessage;
  {WM_NCACTIVATE:   - does not allow submenu.edit.SetFocus
    if TCustomFormAccess(MainForm).FormStyle = fsMDIChild then
      ActivateToolbars(Boolean(wParam), False, 0);}
end;

class procedure TdxBarManager.SendFormBroadcastMessage(AOwnerHandle: HWND; AMsg: UINT; AWParam: WPARAM; ALParam: LPARAM);
var
  ABarManager: TdxBarManager;
  I: Integer;
begin
  if IsFormBroadcastMessage(AMsg) then
    for I := 0 to dxBarManagerList.Count - 1 do
    begin
      ABarManager := dxBarManagerList[I];
      if ABarManager.Owner.HandleAllocated and (ABarManager.Owner.Handle <> AOwnerHandle) and
        IsBarManagerOwner(ABarManager, AOwnerHandle) and (ABarManager.GetMainForm <> nil) then
          ABarManager.OwnerWndProc(AOwnerHandle, AMsg, AWParam, ALParam);
    end;
end;

var
  HintTimerABarManager: TdxBarManager;

procedure ShowHintTimerProc(Wnd: HWnd; Msg, TimerID, SysTime: Longint); stdcall;
begin
  if (HintTimerABarManager <> nil) and
    not HintTimerABarManager.IsDestroying then
    with HintTimerABarManager do
    begin
      KillHintTimer;
      DisplayHint;
    end;
end;

procedure HideHintTimerProc(Wnd: HWnd; Msg, TimerID, SysTime: Longint); stdcall;
begin
  if (HintTimerABarManager <> nil) and
    not HintTimerABarManager.IsDestroying then
    with HintTimerABarManager do
    begin
      KillHintTimer;
      HideHint;
    end;
end;

procedure KillHiddenHintTimerProc(Wnd: HWnd; Msg, TimerID, SysTime: Longint); stdcall;
begin
  KillHiddenHintTimer;
end;

procedure TdxBarManager.DisplayHint;

  procedure StartHideHintTimer;
  begin
    FHintWindowShowing := True;
    HintTimerABarManager := Self;
    FHintTimerID := SetTimer(0, 0, GetHideHintTime, @HideHintTimerProc);
  end;

  function DoProcessCustomHintInfo(var AHint: string; var AHintRect: TRect): Boolean;
  var
    AHintInfo: THintInfo;
    AHintKeeper2: IdxBarHintKeeper2;
  begin
    Supports(FHintObject, IdxBarHintKeeper2, AHintKeeper2);
    Result := cxProcessControlHintInfo(AHintInfo, FHintWindow,
      AHintKeeper2.GetHintedControl, AHint, AHintRect) and (AHintInfo.HintStr <> '');
    if Result then
    begin
      FHintWindow.Color := AHintInfo.HintColor;
      AHint := AHintInfo.HintStr;
    end;
  end;

  function ActivateHintWindow(const AHintText: string; AShortCut: string = ''): Boolean;
  var
    AHintRect: TRect;
    AHintPos: TPoint;
    AHintKeeper: IdxBarHintKeeper;
    AWidth, AHeight: Integer;
    AHint: string;
    AHintWindowHelper: IcxHintWindowHelper;
    R: TRect;
  begin
    FShortCut := AShortCut;
    AHint := AHintText;
    if IsCustomHintStyle then
      if SysLocale.MiddleEast and (BiDiMode = bdRightToLeft) then
        AHint := IfThen(AHint <> '', AShortCut + AHint)
      else
        AHint := IfThen(AHint <> '', AHint + AShortCut);
    AHintRect := FHintWindow.CalcHintRect(Screen.Width, AHint, Self);
    Result := not IsRectEmpty(AHintRect);
    if Result then
    begin
      AHintKeeper := GetHintKeeper;
      AHeight := cxRectHeight(AHintRect);
      AWidth := cxRectWidth(AHintRect);

      AHintPos := GetMouseCursorPos;
      if IsCustomHintStyle and Supports(FHintWindow, IcxHintWindowHelper, AHintWindowHelper) then
      begin
        R := cxRectBounds(AHintPos.X, AHintPos.y, 1, cxGetCursorSize.cy);
        AHintWindowHelper.SetHintAreaBounds(R, False);
        AHintPos.Y := AHintPos.Y + cxGetCursorSize.cy;
      end
      else
        if AHintKeeper <> nil then
          AHintPos := AHintKeeper.GetHintPosition(AHintPos, AHeight);
      if SysLocale.MiddleEast and (BiDiMode = bdRightToLeft) then
        AHintPos.X := AHintPos.X - AWidth;
      AHintRect := cxRectBounds(AHintPos.X, AHintPos.Y, AWidth, AHeight);
      MakeVisibleOnDesktop(AHintRect, AHintPos);

      Result := not IsCustomHintStyle or DoProcessCustomHintInfo(AHint, AHintRect);
      if Result then
        cxActivateHint(FHintWindow, AHintRect, AHint);
      StartHideHintTimer;
    end;
  end;

var
  AHintKeeper: IdxBarHintKeeper;
  ANeedDeactivate: Boolean;
  AHintText, AShortCut: string;
begin
  ANeedDeactivate := True;
  if FCustomHint <> '' then
    ANeedDeactivate := not ActivateHintWindow(FCustomHint)
  else
    if Supports(FHintObject, IdxBarHintKeeper, AHintKeeper) then
      if AHintKeeper.DoHint(ANeedDeactivate, AHintText, AShortCut) then
      begin
        if AHintKeeper.GetEnabled or ShowHintForDisabledItems then
        begin
          if not ShowShortCutInHint and not Application.HintShortCuts then
            AShortCut := '';
          ANeedDeactivate := not ActivateHintWindow(AHintText, AShortCut);
        end
        else
          ANeedDeactivate := True;
      end;
  if ANeedDeactivate then
    HideHint;
end;

var
  FHintTimerPrevShow: Boolean; //***

procedure TdxBarManager.DoActivateHint(AShow: Boolean; const CustomHint: string; AHintObject: TObject);
var
  PrevShow: Boolean;
begin
  if not AShow and not FHintTimerPrevShow{***} then Exit;
  FHintTimerPrevShow := AShow; //***
  FCustomHint := CustomHint;
  FHintWindowShowing := False;
  PrevShow := AShow;
  AShow := AShow and
    ((SelectedItem <> nil) and not SelectedItem.Parent.IsActive or (FCustomHint <> '') or (AHintObject <> nil));
  KillHintTimer;
  FHintObject := AHintObject;
  if AShow then
  begin
    if not IsHintActive and not FLiveHiddenHint then
    begin
      HintTimerABarManager := Self;
      FHintTimerID := SetTimer(0, 0, GetShowHintTime, @ShowHintTimerProc);
    end
    else
      DisplayHint;
  end
  else
  begin
    if IsHintActive then
    begin
      ShowWindow(FHintWindow.Handle, SW_HIDE);
      if PrevShow then
      begin
        KillHiddenHintTimer;
        FLiveHiddenHint := True;
        FHiddenHintTimerID := SetTimer(0, 0, dxBarHiddedHintLifeTime, @KillHiddenHintTimerProc);
      end;
    end;
  end;
end;

function TdxBarManager.GetHideHintTime: Integer;
begin
  if IsCustomHintStyle then
    Result := dxBarWaitForHideHintTime
  else
    Result := TdxBarHintWindow(FHintWindow).HideHintTime;
end;

function TdxBarManager.GetHintWindowClass: THintWindowClass;
begin
  if IsCustomHintStyle then
    Result := cxGetHintWindowClass
  else
    Result := dxBarHintWindowClass;
end;

function TdxBarManager.GetShowHintTime: Integer;
begin
  if IsCustomHintStyle then
    Result := dxBarWaitForShowHintTime
  else
    Result := TdxBarHintWindow(FHintWindow).ShowHintTime;
end;

function TdxBarManager.GetHintKeeper: IdxBarHintKeeper;
begin
  Supports(FHintObject, IdxBarHintKeeper, Result);
end;

function TdxBarManager.IsHintActive: Boolean;
begin
  Result := IsControlVisible(FHintWindow);
end;

procedure TdxBarManager.DestroyItems;
begin
  FreeAndNil(FMDIChildSystemMenuItems);
  FItems.OwnsObjects := True;
  FreeAndNil(FItems);
end;

procedure TdxBarManager.HelpButtonGlyphChanged(Sender: TObject);
begin
  UpdateHelpButton;
end;

procedure TdxBarManager.CalcMostRecentlyUsedUseCount;
var
  I: Integer;
begin
  if FMostRecentItemsPercents = 100 then FMostRecentlyUsedUseCount := 0
  else
    for I := 1 to MaxInt do
      if I * (100 - FMostRecentItemsPercents) div 100 > 0 then
      begin
        FMostRecentlyUsedUseCount := I;
        Break;
      end;
end;

function TdxBarManager.ShowRecentItemsFirst: Boolean;
begin
  Result := CanShowRecentItems and MenusShowRecentItemsFirst;
end;

procedure TdxBarManager.AddDockControl(ADockControl: TdxDockControl);
begin
  FDockControls.Add(ADockControl);
  FreeNotification(ADockControl);
end;

procedure TdxBarManager.RemoveDockControl(ADockControl: TdxDockControl);
var
  I: Integer;
  AList: TList;
  ABar: TdxBar;
begin
  if FBars <> nil then
  begin
    AList := TList.Create;
    try
      for I := 0 to FBars.Count - 1 do
        AList.Add(FBars[I]);

      for I := 0 to AList.Count - 1 do
      begin
        ABar := TdxBar(AList[I]);
        if ABar.DockControl = ADockControl then
          ABar.DockControl := nil;
        if ABar.DockedDockControl = ADockControl then
          ABar.DockedDockControl := nil;
        if ABar.RealDockControl = ADockControl then
          ABar.Visible := False;
      end;
    finally
      AList.Free;
    end;
  end;
  FDockControls.Remove(ADockControl);
  ADockControl.ParentColor := True;
end;

procedure TdxBarManager.AddGroup(AGroup: TdxBarGroup);
begin
  FGroups.Add(AGroup);
  AGroup.FBarManager := Self;
end;

{#DG
procedure TdxBarManager.RemoveGroup(AGroup: TdxBarGroup);
begin
  FGroups.Remove(AGroup);
end;
}

function TdxBarManager.CorrectRegistryPath(var APath: string): Boolean;
begin
  Result := APath <> '';
  if Result then
  begin
    if APath[1] <> '\' then
      APath := '\' + APath;
    if APath[Length(APath)] <> '\' then
      APath := APath + '\';
  end;
end;

function TdxBarManager.GetSavedBarIndex(AState: TCustomIniFile; const ABarCaption: string): Integer;
var
  ABarCount, I: Integer;
begin
  ABarCount := AState.ReadInteger(GetBarManagerSection(GetBaseIniSection, skIni), 'BarCount', 0);
  for I := 0 to ABarCount - 1 do
  begin
    if AState.ReadString(TdxBar.GetIniSection(GetBaseIniSection, I), 'Caption', '') = ABarCaption then
      Exit(I);
  end;
  Result := -1;
end;

function TdxBarManager.IsDockColorStored: Boolean;
begin
  Result := not FAutoDockColor;
end;

function TdxBarManager.IsStyleStored: Boolean;
begin
  Result := FStyle <> dxBarDefaultStyle;
end;

procedure TdxBarManager.LoadLinkItemNames;
var
  I: Integer;
begin
  for I := 0 to ItemCount - 1 do
    if Items[I].GetItemLinks <> nil then
      Items[I].GetItemLinks.LoadItemNames;
  for I := 0 to Bars.Count - 1 do
    Bars[I].ItemLinks.LoadItemNames;
end;

procedure TdxBarManager.ReadBars(AReader: TReader);
begin
  FReadingOldBars := True;
  try
    Bars.ReadOldCollection(AReader);
  finally
    FReadingOldBars := False;
  end;
end;

procedure TdxBarManager.ReadDockControlHeights(Reader: TReader);

  procedure SetSize(AStyle: TdxBarDockingStyle; ASize: Integer);
  begin
    if ASize <> 0 then
      if AStyle in [dsLeft, dsRight] then
        InternalDockControls[AStyle].Width := ASize
      else
        InternalDockControls[AStyle].Height := ASize
  end;

begin
  Reader.ReadListBegin;
  try
    SetSize(dsLeft, Reader.ReadInteger);
    SetSize(dsRight, Reader.ReadInteger);
    SetSize(dsTop, Reader.ReadInteger);
    SetSize(dsBottom, Reader.ReadInteger);
  finally
    Reader.ReadListEnd;
  end;
end;

procedure TdxBarManager.WriteDockControlHeights(Writer: TWriter);
begin
  Writer.WriteListBegin;
  try
    Writer.WriteInteger(InternalDockControls[dsLeft].Width);
    Writer.WriteInteger(InternalDockControls[dsRight].Width);
    Writer.WriteInteger(InternalDockControls[dsTop].Height);
    Writer.WriteInteger(InternalDockControls[dsBottom].Height);
  finally
    Writer.WriteListEnd;
  end;
end;

procedure TdxBarManager.CreateFlatToolbarsBrushes;
begin
  DestroyFlatToolbarsBrushes;
  FFlatToolbarsBorderBrush := CreateSolidBrush(FlatToolbarsBorderColor);
  FFlatToolbarsBrush := CreateSolidBrush(FlatToolbarsColor);
  FFlatToolbarsDownedBrush := CreateSolidBrush(FlatToolbarsDownedColor);
  FFlatToolbarsDownedSelBrush := CreateSolidBrush(FlatToolbarsDownedSelColor);
  FFlatToolbarsSelBrush := CreateSolidBrush(FlatToolbarsSelColor);
end;

procedure TdxBarManager.DestroyFlatToolbarsBrushes;
begin
  DeleteGDIObject(FFlatToolbarsSelBrush);
  DeleteGDIObject(FFlatToolbarsDownedSelBrush);
  DeleteGDIObject(FFlatToolbarsDownedBrush);
  DeleteGDIObject(FFlatToolbarsBrush);
  DeleteGDIObject(FFlatToolbarsBorderBrush);
end;

procedure TdxBarManager.CreateThemeToolbarsBrushes;
begin
  DestroyThemeToolbarsBrushes;
  if FThemeAvailable then
  begin
    FThemeToolbarsBrush := CreateSolidBrush(ThemeToolbarColor);
//  FThemeToolbarsDownedBrush := CreateSolidBrush();
//  FThemeToolbarsDownedSelBrush := CreateSolidBrush();
//  FThemeToolbarsSelBrush := CreateSolidBrush();
  end;
end;

procedure TdxBarManager.DestroyThemeToolbarsBrushes;
begin
//  if FThemeToolbarsSelBrush <> 0 then DeleteObject(FThemeToolbarsSelBrush);
//  if FThemeToolbarsDownedSelBrush <> 0 then DeleteObject(FThemeToolbarsDownedSelBrush);
//  if FThemeToolbarsDownedBrush <> 0 then DeleteObject(FThemeToolbarsDownedBrush);
  DeleteGDIObject(FThemeToolbarsBrush);
end;

procedure TdxBarManager.DestroyToolbarsBrushes;
begin
  DestroyThemeToolbarsBrushes;
  DestroyFlatToolbarsBrushes;
  ReleaseOffice11Colors;
end;

procedure TdxBarManager.CreateToolbarsBrushes;
begin
  CreateFlatToolbarsBrushes;
  CreateThemeToolbarsBrushes;
  CreateOffice11Colors;
  ResetBackgrounds;
end;

procedure TdxBarManager.RecreateToolbarsBrushes;
begin
  CreateFlatToolbarsBrushes;
  CreateThemeToolbarsBrushes;
  RefreshOffice11Colors;
  ResetBackgrounds;
end;

procedure TdxBarManager.RefreshFloatingBarsShadows;
var
  I: Integer;
begin
  for I := 0 to Bars.Count - 1 do
    if (Bars[I].DockingStyle = dsNone) and (Bars[I].Control <> nil) then
      Bars[I].Control.RefreshShadow;
end;

procedure TdxBarManager.ResetBackgrounds;
var
  I: Integer;
begin
  for I := 0 to DockControlCount - 1 do
  begin
//    DockControls[I].ResetBackground;
    DockControls[I].BarManagerChanged;
    DockControls[I].UpdateDoubleBuffered;
    DockControls[I].Invalidate;
  end;
  for I := 0 to Bars.Count - 1 do
    if Bars[I].Control <> nil then
    begin
      Bars[I].Control.ResetBackground;
      Bars[I].Control.UpdateDoubleBuffered;
      Bars[I].Control.FullInvalidate;
    end;
end;

procedure TdxBarManager.InitPainter;
begin
  FThemeAvailable := AreVisualStylesAvailable([totToolBar, totComboBox, totEdit,
    totWindow, totScrollBar, totRebar, totStatus, totSpin, totProgress]);
  FreeAndNil(FDefaultPainter);
  FDefaultPainter := GetPainterClass.Create(TdxNativeInt(LookAndFeel.SkinPainter));
end;

procedure TdxBarManager.InternalStyleChanged;
var
  I: Integer;
begin
  if not IsDestroying and not (bisStyleChanging in FInternalState) then
  begin
    Include(FInternalState, bisStyleChanging);
    try
      InitPainter;
      if Bars <> nil then
      begin
        for I := 0 to Bars.Count - 1 do
          if Bars[I].Control <> nil then
            Bars[I].Control.BarManagerStyleChanged;
        HostBarManagerStyleChanged;
        ResetBackgrounds;
      end;
    finally
      Exclude(FInternalState, bisStyleChanging);
    end;
  end;
end;

procedure TdxBarManager.ThemeChanged;
begin
  InternalStyleChanged;
end;

procedure TdxBarManager.LFChanged(Sender: TcxLookAndFeel; AChangedValues: TcxLookAndFeelValues);
begin
  InternalStyleChanged;
end;

procedure TdxBarManager.DoActivate(AState, AMinimized: WORD; AHandle, AWndPrevious: HWND);
var
  AControl: TWinControl;
  AMainForm: TCustomForm;
  ANeedActivate: Boolean;
begin
  Include(FInternalState, bisFormActivating);
  try
    AMainForm := GetBarManagerForm(Self, fkMainOrMDIChild);
    if IsMDIChild(AMainForm) and (Application.MainForm.ActiveMDIChild <> AMainForm) then
      Exit;
    AMainForm := GetMainForm;
    AControl := FindControl(AWndPrevious);

    if (AState = WA_INACTIVE) and (AControl is TCustomdxBarControl) and
      (TCustomdxBarControl(AControl).BarManager.GetMainForm = AMainForm) then
        Exit;
    if {(AState = WA_INACTIVE) and }(ActiveBarControl <> nil) and
      (ActiveBarControl.SelectedControl <> nil) and
      ActiveBarControl.SelectedControl.IsChildWindow(AWndPrevious) then
        Exit;

    ANeedActivate := MainFormActive and not (IsWindowEnabledEx(AMainForm.Handle) or Designing) or
      (AState <> WA_INACTIVE) or (AMainForm.Handle = AWndPrevious);
    ActivateFloatToolbars(ANeedActivate, False, AWndPrevious);

    if not (bisToolbarsVisibleChanging in FInternalState) and (AState <> WA_INACTIVE) and //ANeedActivate and
      (dxBarCustomizingForm <> nil) and FIsCustomizing and not IsWindowEnabledEx(AMainForm.Handle)
      and not IsChildEx(dxBarCustomizingForm.Handle, AHandle) then
        SendMessage(dxBarCustomizingForm.Handle, WM_ACTIVATE, MakeWParam(AState, AMinimized), AMainForm.Handle);

    if (AState = WA_INACTIVE) and (AMainForm.Handle <> AWndPrevious) and (FMouseTrackingBarControl <> nil) then
      FMouseTrackingBarControl.MouseLeave;
  finally
    Exclude(FInternalState, bisFormActivating);
  end;
end;

procedure TdxBarManager.DoActivateApp(AActivate: Boolean; AThreadID: DWORD);
begin
  if bisModalActivating in FInternalState then
    Exit;
  if not AActivate then
  begin
    if MainFormActive and not IsWindowEnabledEx(GetMainForm.Handle) then
      Include(FInternalState, bisWasActive);
    ActivateFloatToolbars(False, False, 0);
    if (ActiveBarControl <> nil) and (ActiveBarControl.BarManager = Self) then
      ActiveBarControl.HideAll; //SC-Q93427
    if SelectedItem <> nil then
      SendMessage(SelectedItem.Parent.Handle, WM_MOUSELEAVE, 0, 0);
  end
  else {TODO}
    if bisWasActive in FInternalState then
    begin
      ActivateFloatToolbars(True, False, 0);
      Exclude(FInternalState, bisWasActive);
    end;
end;

procedure TdxBarManager.DoCreate;
var
  I: Integer;
begin
  if BarRestoringListExists and IsParentFormAvailable then
  begin
    ParentForm.DisableAlign;
    Include(FInternalState, bisHandleCreating);
    try
      for I := 0 to DockControlCount - 1 do
        if CanAllocateHandle(DockControls[I]) then // for BarDockControl
          DockControls[I].HandleNeeded;
      ShowBarsFromRestoringList(nil);
    finally
      if RestoringListBarCount = 0 then // for BarDockControl
        DestroyBarRestoringList;
      Exclude(FInternalState, bisHandleCreating);
      ParentForm.EnableAlign;
    end;
  end;
end;

procedure TdxBarManager.DoModalActivate;
var
  AWasModalActivating: Boolean;
begin
  if BarNavigationController.IsKeyTipsWaiting then
    BarNavigationController.EndKeyTipsWaiting(False);
  AWasModalActivating := bisModalActivating in FInternalState;
  Include(FInternalState, bisModalActivating);
  try
    if not IsInternalWindowsDisabling and (ActiveBarControl <> nil) and
      (ActiveBarControl.BarManager = Self){SC-S90738} and ActiveBarControl.NeedHideOnClick
    then
      ActiveBarControl.HideAll;
  finally
    if not AWasModalActivating then
      Exclude(FInternalState, bisModalActivating);
  end;
end;

procedure TdxBarManager.DoMenuMerging(AChildBarManager: TdxBarManager; AOperation: TdxBarMergeOperation);
var
  ABar: TdxBar;
  AMergedBarList: TList;
  I: Integer;
begin
  if (MainMenuBar <> nil) and (AChildBarManager.MainMenuBar <> nil) then
  begin
    case AOperation of
      bmoMerge:
        if Assigned(OnMenuMerge) then
        begin
          OnMenuMerge(Self, AChildBarManager, True);
          if AChildBarManager.MainMenuBar.MergeData.MergedWith = nil then
          begin
            AChildBarManager.MainMenuBar.MergeData.MergedWith := MainMenuBar;
            MainMenuBar.MergeData.MergedBarList.Add(AChildBarManager.MainMenuBar);
            AChildBarManager.MainMenuBar.MergeData.VisibleBeforeMerging := AChildBarManager.MainMenuBar.Visible;
          end;
          AChildBarManager.MainMenuBar.SetVisibility(False);
        end
        else
          MainMenuBar.Merge(AChildBarManager.MainMenuBar);

      bmoUnmerge:
        begin
          AMergedBarList := TList.Create;
          try
            MainMenuBar.MergeData.SaveMergedBarList(AMergedBarList);
            MainMenuBar.InternalUnmergeFromBar(nil, False);
            if Assigned(OnMenuMerge) then
              OnMenuMerge(Self, AChildBarManager, False);
            for I := 0 to AMergedBarList.Count - 1 do
            begin
              ABar := TdxBar(AMergedBarList[I]);
              ABar.SetVisibility(ABar.MergeData.VisibleBeforeMerging);
            end;
          finally
            AMergedBarList.Free;
          end;
        end;
    end;
  end;
end;

procedure TdxBarManager.DoAfterMerge(AChildBarManager: TdxBarManager; AOperation: TdxBarMergeOperation);
begin
  if Assigned(OnAfterMerge) then
    OnAfterMerge(Self, AChildBarManager, AOperation = bmoMerge);
end;

procedure TdxBarManager.DoBeforeMerge(AChildBarManager: TdxBarManager; AOperation: TdxBarMergeOperation);
begin
  if Assigned(OnBeforeMerge) then
    OnBeforeMerge(Self, AChildBarManager, AOperation = bmoMerge);
end;

procedure TdxBarManager.DoMerge(AChildBarManager: TdxBarManager; AOperation: TdxBarMergeOperation);
begin
  if Assigned(OnMerge) then
    OnMerge(Self, AChildBarManager, AOperation = bmoMerge);
end;

function TdxBarManager.DoProcessMergeOperation(
  AChildBarManager: TdxBarManager; AOperation: TdxBarMergeOperation): Boolean;
var
  AHandler: IdxBarManagerMergeOperationHandler;
  I: Integer;
begin
  Result := False;
  for I := 0 to MergeOperationHandlers.Count - 1 do
  begin
    if Supports(MergeOperationHandlers[I], IdxBarManagerMergeOperationHandler, AHandler) then
      AHandler.ProcessMergeOperation(AChildBarManager, AOperation, Result);
    if Result then
      Break;
  end;
end;

procedure TdxBarManager.DoLockUpdate(ALock, ACheckBarsChanges, ACancelUpdate: Boolean; ALockRedraw: Boolean = True);

  function HasChanges(ABar: TdxBar): Boolean;
  begin
    Result := ACheckBarsChanges and ABar.FChanged;
  end;

var
  ABar: TdxBar;
  ADockControl: TdxDockControl;
  I, J: Integer;
begin
  try
    if ALockRedraw then
      for I := 0 to DockControlCount - 1 do
        if DockControls[I].Visible and DockControls[I].HandleAllocated then
          SendMessage(DockControls[I].Handle, WM_SETREDRAW, WPARAM(not ALock), 0);

    if not ALock and not ACancelUpdate then
    begin
      if FChangedSubMenuControl <> nil then
      begin
        FChangedSubMenuControl.RepaintBar;
        FChangedSubMenuControl := nil;
      end;

      for I := 0 to Bars.Count - 1 do
      begin
        ABar := Bars[I];
        if (ABar.Control <> nil) and HasChanges(ABar) then
          ABar.Control.RecreateControls;
      end;

      for I := 0 to Bars.Count - 1 do
      begin
        ABar := Bars[I];
        if (ABar.Control <> nil) and HasChanges(ABar) then
          ABar.Control.RepaintBarEx(False)
      end;

      for I := 0 to DockControlCount - 1 do
      begin
        ADockControl := DockControls[I];
        for J := ADockControl.RowCount - 1 downto 0 do
          if TdxDockRow(ADockControl.RowList[J]).FBars.Count = 0 then
          begin
            TdxDockRow(ADockControl.RowList[J]).Free;
            ADockControl.RowList.Delete(J);
          end;
        if ADockControl.Visible and ADockControl.HandleAllocated then
        begin
          ADockControl.UpdateDock;
          SendMessage(ADockControl.Handle, WM_NCPAINT, 0, 0);
        end;
      end;

      for I := 0 to Bars.Count - 1 do
      begin
        ABar := Bars[I];
        if (ABar.Control <> nil) and not HasChanges(ABar) then
        begin
          ABar.Control.FrameChanged;
          ABar.Control.Repaint;
        end;
      end;
    end;
  finally
    for I := 0 to Bars.Count - 1 do
      Bars[I].FChanged := False;
  end;
end;

procedure TdxBarManager.DoBeginUpdate(ALockRedraw: Boolean);
begin
  Inc(FLockUpdateCount);
  if FLockUpdateCount = 1 then
    DoLockUpdate(True, False, False, ALockRedraw);
end;

procedure TdxBarManager.DoCancelUpdate(ALockRedraw: Boolean);
begin
  Dec(FLockUpdateCount);
  if (FLockUpdateCount = 0) and not IsDestroying then
    DoLockUpdate(False, False, True, ALockRedraw);
end;

procedure TdxBarManager.DoEndUpdate(ACheckBarsChanges, ALockRedraw: Boolean);
begin
  Dec(FLockUpdateCount);
  if (FLockUpdateCount = 0) and not IsDestroying then
    DoLockUpdate(False, ACheckBarsChanges, False, ALockRedraw);
end;

function TdxBarManager.DoHandleKey(AKey: Word; AShift: TShiftState): Boolean;
begin
  FIgnoreKeyStroke := False;
  Result := False;
  if Assigned(OnHandleKey) then
    OnHandleKey(Self, AKey, AShift, Result);
end;

function TdxBarManager.CanDeleteComponent(AComponent: TComponent): Boolean;
begin
  Result := (FdxBarDesignHelper = nil) or
    FdxBarDesignHelper.CanDeleteComponent(AComponent);
end;

procedure TdxBarManager.GetSelection(AList: TList);
begin
  if FdxBarDesignHelper <> nil then
    FdxBarDesignHelper.GetSelection(AList);
end;

function TdxBarManager.GetSelectionStatus(AComponent: TPersistent): TdxBarSelectionStatus;
begin
  if FdxBarDesignHelper <> nil then
    Result := FdxBarDesignHelper.GetSelectionStatus(AComponent)
  else
    Result := ssUnselected;
end;

function TdxBarManager.IsComponentSelected(AComponent: TPersistent): Boolean;
begin
  Result := (GetSelectionStatus(AComponent) = ssActiveSelected);
end;

procedure TdxBarManager.SelectComponent(AComponent: TPersistent; ASelectionOperation: TdxBarSelectionOperation = soExclusive);
begin
  if FdxBarDesignHelper <> nil then
    FdxBarDesignHelper.SelectComponent(AComponent, ASelectionOperation);
end;

procedure TdxBarManager.SetSelection(AList: TList);
begin
  if FdxBarDesignHelper <> nil then
    FdxBarDesignHelper.SetSelection(AList);
end;

procedure TdxBarManager.ShowDefaultEventHandler(AItem: TdxBarItem);
begin
  if FdxBarDesignHelper <> nil then
    FdxBarDesignHelper.ShowDefaultEventHandler(AItem);
end;

function TdxBarManager.UniqueName(const BaseName: string): string;
begin
  if FdxBarDesignHelper <> nil then
    Result := FdxBarDesignHelper.UniqueName(BaseName)
end;

procedure TdxBarManager.CreateBarRestoringList;
begin
  if not BarRestoringListExists then
    FBarRestoringList := TList.Create;
end;

procedure TdxBarManager.DestroyBarRestoringList;
begin
  FreeAndNil(FBarRestoringList);
end;

function TdxBarManager.BarRestoringListExists: Boolean;
begin
  Result := FBarRestoringList <> nil;
end;

procedure TdxBarManager.AddBarToRestoringList(ABar: TdxBar);
begin
  if BarRestoringListExists and (FBarRestoringList.IndexOf(ABar) = -1) then
    FBarRestoringList.Add(ABar);
end;

procedure TdxBarManager.RemoveBarFromRestoringList(ABar: TdxBar);
begin
  if BarRestoringListExists then
    FBarRestoringList.Remove(ABar);
end;

procedure TdxBarManager.ShowBarsFromRestoringList(ADockControl: TdxBarDockControl);

  function CanShowBar(ABar: TdxBar): Boolean;
  begin
    if ADockControl = nil then
      Result := (ABar.RealDockControl = nil) or ABar.RealDockControl.HandleAllocated
    else
      Result := (ABar.DockControl = ADockControl) and (ABar.DockingStyle <> dsNone);
  end;

var
  I: Integer;
begin
  for I := RestoringListBarCount - 1 downto 0 do
    if CanShowBar(RestoringListBars[I]) then
      RestoringListBars[I].Visible := True;
end;

function TdxBarManager.GetBarIndexInRestoringList(ABar: TdxBar): Integer;
begin
  if BarRestoringListExists then
    Result := FBarRestoringList.IndexOf(ABar)
  else
    Result := -1;
end;

procedure TdxBarManager.AssignFont;
var
  ASystemFont: TLogFont;
begin
  ASystemFont := dxSystemInfo.NonClientMetrics.lfMenuFont;
  if FUseSystemFont then
  begin
    FInternalFontChange := True;
    try
      Font.Handle := CreateFontIndirect(ASystemFont);
      Font.Height := ScaleFactor.Apply(ASystemFont.lfHeight, dxSystemScaleFactor);
    finally
      FInternalFontChange := False;
    end;
  end
  else
    if Scaled then
      Font.Height := ScaleFactor.Apply(ASystemFont.lfHeight, dxSystemScaleFactor);
end;

function TdxBarManager.CanReset: Boolean;
begin
  Result := (FReadStateCount > 0) and FAllowReset;
end;

procedure TdxBarManager.ChangeScale(M, D: Integer);
var
  I: Integer;
begin
  inherited ChangeScale(M, D);
  Bars.ChangeScale(M, D);
  for I := 0 to ItemCount - 1 do
    Items[I].ChangeScale(M, D);
  AssignFont;
end;

procedure TdxBarManager.DefineProperties(Filer: TFiler);

  function HasDockControlsHeights: Boolean;
  var
    AStyle: TdxBarDockingStyle;
  begin
    Result := csReading in ComponentState;
    for AStyle := dsLeft to dsBottom do
      if AStyle in [dsLeft, dsRight] then
        Result := Result or (InternalDockControls[AStyle].Width <> 0) and ((Filer.Ancestor = nil) or (TdxBarManager(Filer.Ancestor).InternalDockControls[AStyle].Width <> InternalDockControls[AStyle].Width))
      else
        Result := Result or (InternalDockControls[AStyle].Height <> 0) and ((Filer.Ancestor = nil) or (TdxBarManager(Filer.Ancestor).InternalDockControls[AStyle].Height <> InternalDockControls[AStyle].Height));
  end;

begin
  inherited;
  Filer.DefineProperty('Bars', ReadBars, nil, False);
  Filer.DefineProperty('DockControlHeights', ReadDockControlHeights, WriteDockControlHeights, HasDockControlsHeights);
end;

procedure TdxBarManager.DesignerModified;
begin
  if ParentForm = nil then
    Exit;
  if not (IsInitializing or IsDestroying) then
    if not CanModifyDesigner then
      FDesignerModifiedInvoked := True
    else
    begin
      FModified := True;
      if Designing and not (csUpdating in ComponentState) and not IsRecreating and
        ([bisBarsLoading, bisHandleCreating] * FInternalState = []) and not FImageOptions.IsLoading then
          BarDesignController.DesignerModified(ParentForm);
    end;
end;

procedure TdxBarManager.DoBarAfterReset(ABar: TdxBar);
begin
  if Assigned(FOnBarAfterReset) then FOnBarAfterReset(Self, ABar);
end;

procedure TdxBarManager.DoBarBeforeReset(ABar: TdxBar);
begin
  if Assigned(FOnBarBeforeReset) then FOnBarBeforeReset(Self, ABar);
end;

procedure TdxBarManager.DoBarClose(ABar: TdxBar);
begin
  if Assigned(FOnBarClose) then FOnBarClose(Self, ABar);
end;

procedure TdxBarManager.DoBarDockingStyleChanged(ABar: TdxBar);
begin
  if not BarsLoading then
  begin
    if Assigned(FOnBarDockingStyleChange) then
      FOnBarDockingStyleChange(Self, ABar);
    ABar.Changed(True);
  end;
end;

procedure TdxBarManager.DoClickItem(AItem: TdxBarItem);
begin
  if Assigned(FOnClickItem) then FOnClickItem(Self, AItem);
end;

procedure TdxBarManager.DoCloseButtonClick;
begin
  CallNotify(FOnCloseButtonClick, Self);
end;

function TdxBarManager.DoDocking(ABar: TdxBar; AStyle: TdxBarDockingStyle;
  ADockControl: TdxDockControl): Boolean;
begin
  Result :=
    not (AStyle in ABar.NotDocking) and
    (((ADockControl = nil) or ADockControl.Main) and not (AStyle in NotDocking) or
     (ADockControl <> nil) and not ADockControl.Main and ADockControl.CanDocking(ABar));
  if Assigned(FOnDocking) then FOnDocking(ABar, AStyle, ADockControl, Result);
end;

procedure TdxBarManager.DoItemLinkAdd(AItemLink: TdxBarItemLink);
begin
  if not IsLoading then
  begin
    if Assigned(OnItemLinkAdd) then
      OnItemLinkAdd(Self, AItemLink);
    dxCallNotify(OnItemLinksChanged, AItemLink);
  end;
end;

procedure TdxBarManager.DoItemLinkChange(AItemLink: TdxBarItemLink);
begin
  if not IsLoading then
  begin
    if Assigned(OnItemLinkChange) then
      OnItemLinkChange(Self, AItemLink);
    dxCallNotify(OnItemLinksChanged, AItemLink);
  end;
end;

procedure TdxBarManager.DoItemLinkDelete(AItemLink: TdxBarItemLink);
begin
  if not IsDestroying then
  begin
    if Assigned(OnItemLinkDelete) then
      OnItemLinkDelete(Self, AItemLink);
    dxCallNotify(OnItemLinksChanged, AItemLink);
  end;
end;

procedure TdxBarManager.DoHelpButtonClick;
begin
  CallNotify(FOnHelpButtonClick, Self);
end;

procedure TdxBarManager.DoMergeItemLink(
  ADstItemLinks, ASrcItemLinks: TdxBarItemLinks; ASrcItemLink: TdxBarItemLink;
  var AMergeKind: TdxBarItemMergeKind; var AMergeIndex: Integer);
begin
  if Assigned(FOnMergeItemLink) then
    FOnMergeItemLink(Self, ADstItemLinks, ASrcItemLinks, ASrcItemLink,
      AMergeKind, AMergeIndex);
end;

function TdxBarManager.DoResetBar(ABar: TdxBar; var AShowConfirmation: Boolean): Boolean;
begin
  Result := False;
  if Assigned(FOnBarReset) then
    OnBarReset(Self, ABar, Result, AShowConfirmation);
end;

procedure TdxBarManager.DoShowCustomizingPopup(PopupItemLinks: TdxBarItemLinks);
begin
  if Assigned(FOnShowCustomizingPopup) then FOnShowCustomizingPopup(Self, PopupItemLinks);
end;

procedure TdxBarManager.DoShowToolbarsPopup(PopupItemLinks: TdxBarItemLinks);
begin
  if Assigned(FOnShowToolbarsPopup) then FOnShowToolbarsPopup(Self, PopupItemLinks);
end;

procedure TdxBarManager.DragAndDrop(AItem: TdxBarItem; AItemLink: TdxBarItemLink);
begin
  DragInfo.BeginDrag(AItem, AItemLink);
  try
    DragInfo.HandleDragging;
  finally
    DragInfo.EndDrag;
  end;
end;

function TdxBarManager.FindDockControl(APath: string): TdxBarDockControl;
var
  ARootName: string;
  ARoot: TComponent;
begin
  ARootName := Copy(APath, 1, Pos('.', APath) - 1);
  if ARootName <> '' then
  begin
    ARoot := FindGlobalComponent(ARootName);
    Delete(APath, 1, Length(ARootName) + 1);
  end
  else
    ARoot := Owner;
  Result := FindNestedComponent(ARoot, APath) as TdxBarDockControl;
end;

function TdxBarManager.GetCategoryRealIndex(AIndex: Integer): Integer;
var
  I: Integer;
begin
  if Designing then Result := AIndex
  else
  begin
    Result := -1;
    for I := 0 to FCategories.Count - 1 do
      if CategoryVisible[I] then
      begin
        Inc(Result);
        if Result = AIndex then
        begin
          Result := I;
          Exit;
        end;
      end;
    Result := -1;
  end;
end;

procedure TdxBarManager.GetChildren(Proc: TGetChildProc; Root: TComponent);
var
  I: Integer;
begin
  for I := 0 to Bars.Count - 1 do
    if Bars[I].Owner = Root then Proc(Bars[I]);
  for I := 0 to ItemCount - 1 do
    if (Items[I].Owner = Root) and (Items[I].Category > -1) then Proc(Items[I]);
  for I := 0 to GroupCount - 1 do
    if Groups[I].Owner = Root then Proc(Groups[I]);
end;

function TdxBarManager.GetChildOwner: TComponent;
begin
  Result := Owner;
end;

function TdxBarManager.GetPainterClass: TdxBarPainterClass;
begin
  case GetRealPaintStyle of
    rpsEnhanced:
      Result := TdxBarEnhancedPainter;
    rpsFlat:
      Result := TdxBarFlatPainter;
    rpsXP:
      Result := TdxBarXPPainter;
    rpsOffice11:
      Result := TdxBarOffice11Painter;
    rpsSkin:
      Result := dxBarSkinPainterClass;
  else{rpsStandard}
    Result := TdxBarStandardPainter;
  end;
end;

procedure TdxBarManager.GetRealLookAndFeel(ALookAndFeel: TcxLookAndFeel);

  procedure SetupLookAndFeel(AKind: TcxLookAndFeelStyle);
  begin
    ALookAndFeel.SkinName := '';
    ALookAndFeel.SetStyle(AKind);
  end;

begin
  case GetRealPaintStyle of
    rpsXP:
      SetupLookAndFeel(lfsNative);
    rpsStandard, rpsEnhanced:
      SetupLookAndFeel(lfsFlat);
    rpsFlat:
      SetupLookAndFeel(lfsUltraFlat);
    rpsOffice11:
      SetupLookAndFeel(lfsOffice11);
  else{rpsSkin}
    ALookAndFeel.Assign(LookAndFeel);
  end;
end;

function TdxBarManager.GetRealPaintStyle: TdxBarRealPaintStyle;
const
  BarManagerStyleToRealPaintStyle: array [bmsStandard..bmsOffice11] of TdxBarRealPaintStyle =
    (rpsStandard, rpsEnhanced, rpsFlat, rpsXP, rpsOffice11);
  LookAndFeelKindToRealPaintStyle: array [TcxLookAndFeelKind] of TdxBarRealPaintStyle =
    (rpsEnhanced, rpsStandard, rpsFlat, rpsOffice11);
begin
  case Style of
    bmsUseLookAndFeel:
      if LookAndFeel.NativeStyle and FThemeAvailable then
        Result := rpsXP
      else
        if LookAndFeel.SkinPainter <> nil then
          Result := rpsSkin
        else
          Result := LookAndFeelKindToRealPaintStyle[LookAndFeel.Kind];

    bmsXP:
      if FThemeAvailable then
        Result := rpsXP
      else
        Result := rpsEnhanced;
  else
    Result := BarManagerStyleToRealPaintStyle[Style];
  end;
end;

function TdxBarManager.GetWindowForMouseCapturing: HWND;
begin
  if FIsCustomizing and (dxBarCustomizingForm <> nil) then
    Result := dxBarCustomizingForm.Handle
  else
    if IsWindowVisible(Application.Handle) then
      Result := Application.Handle
    else
      Result := Owner.Handle;
end;

procedure TdxBarManager.SetChildOrder(Child: TComponent; Order: Integer);
begin
  inherited;
  if Child is TdxBarItem then
    TdxBarItem(Child).Index := Order - Bars.Count;
  if Child is TdxBarGroup then
    TdxBarGroup(Child).Index := Order - Bars.Count - ItemCount;
end;

procedure TdxBarManager.CustomImagesChanged(AChangeProc: TdxBarItemChangeProc);
var
  I: Integer;
begin
  if not IsLoading and not IsDestroying then
  begin
    BeginUpdate;
    try
      for I := 0 to ItemCount - 1 do
        AChangeProc(Items[I]);
    finally
      EndUpdate;
    end;
  end;
end;

procedure TdxBarManager.DisabledImagesChanged(AItem: TdxBarItem);
begin
  if AItem.ImageIndex > -1 then
    AItem.GlyphChanged;
end;

procedure TdxBarManager.DisabledLargeImagesChanged(AItem: TdxBarItem);
begin
  if AItem.UseLargeImages then
    AItem.LargeGlyphChanged;
end;

procedure TdxBarManager.HotImagesChanged(AItem: TdxBarItem);
begin
  if AItem.UseHotImages then
    AItem.HotGlyphChanged;
end;

procedure TdxBarManager.ImagesChanged(AItem: TdxBarItem);
begin
  if AItem.ImageIndex > -1 then
    AItem.GlyphChanged;
end;

function TdxBarManager.GetGlyphSize(AScaleFactor: TdxScaleFactor): Integer;
begin
  Result := AScaleFactor.Apply(FImageOptions.FGlyphSize);
end;

function TdxBarManager.IsLargeImagesForLargeIcons: Boolean;
begin
  Result := FImageOptions.IsLargeImagesForLargeIcons;
end;

procedure TdxBarManager.LargeImagesChanged(AItem: TdxBarItem);
begin
  if AItem.UseLargeImages then
    AItem.LargeGlyphChanged;
end;

procedure TdxBarManager.DisableFloatToolBars;
var
  I: Integer;
begin
  FDisabledToolBarsList := TList.Create;
  for I := 0 to Bars.Count - 1 do
    if Bars[I].IsFloat then
      DisableWindow(FDisabledToolBarsList, Bars[I].Control.Handle);
end;

procedure TdxBarManager.EnableFloatToolBars;
begin
  EnableWindows(FDisabledToolBarsList);
  FreeAndNil(FDisabledToolBarsList);
end;

procedure TdxBarManager.BarVisibleChanged(ABar: TdxBar);
begin
  if not IsDestroying then
  begin
    if Assigned(FOnBarVisibleChange) then
      FOnBarVisibleChange(Self, ABar);
  end;
end;

function TdxBarManager.GetLookAndFeel: TcxLookAndFeel;
begin
  Result := FLookAndFeel;
end;

function TdxBarManager.GetAction: TBasicAction;
var
  AScreenTipProvider: IdxScreenTipProvider;
begin
  Result := nil;
  if Supports(FHintObject, IdxScreenTipProvider, AScreenTipProvider) then
    Result := AScreenTipProvider.GetAction;
end;

function TdxBarManager.GetScreenTip: TdxScreenTip;
var
  AScreenTipProvider: IdxScreenTipProvider;
begin
  Result := nil;
  if Supports(FHintObject, IdxScreenTipProvider, AScreenTipProvider) then
    Result := AScreenTipProvider.GetScreenTip;
end;

function TdxBarManager.GetShortCut: string;
begin
  Result := FShortCut;
end;

function TdxBarManager.GetParentForm: TCustomForm;
begin
  Result := GetBarManagerForm(Self, fkAny);
end;

procedure TdxBarManager.SystemInfoChanged(AParameter: Cardinal);
begin
  if not (csDestroying in Owner.ComponentState) and (Owner <> dxBarCustomizingForm) and (Bars <> nil) then
    case AParameter of
      SPI_SETNONCLIENTMETRICS:
        AssignFont;
      SPI_SETWORKAREA:
        CheckToolbarsVisibility;
    end;
end;

procedure TdxBarManager.ActivateFloatToolbars(AActivate, AForceOperation: Boolean; AActiveWindow: HWND);
begin
  if (AActivate <> FMainFormActive) or AForceOperation then
  begin
    FMainFormActive := AActivate;
    ShowToolbars(AActivate, AForceOperation, AActiveWindow);
  end;
end;

function TdxBarManager.IsInternalDockControl(ADockControl: TdxDockControl): Boolean;
begin
  Result := ADockControl.IsInternal;
end;

function TdxBarManager.IsUpdateLocked: Boolean;
begin
  Result := FLockUpdateCount > 0;
end;

procedure TdxBarManager.Loaded;

  procedure SortItems;
  var
    I: Integer;
    ASorted: Boolean;
  begin
    repeat
      ASorted := True;
      for I := 0 to ItemCount - 2 do
        if Items[I].Category > Items[I + 1].Category then
        begin
          MoveItem(I + 1, I);
          ASorted := False;
        end;
    until ASorted;
  end;

  procedure CheckBrokenLinks;

  var
    ALinksList: TdxObjectList;

    procedure CheckLink(ALink: TdxBarItemLink);
    begin
      if ALink.Item = nil then
        ALinksList.Add(ALink);
    end;

    procedure CheckLinks(ALinks: TdxBarItemLinks);
    var
      I: Integer;
    begin
      if ALinks <> nil then
        for I := 0 to ALinks.Count - 1 do
          CheckLink(ALinks[I]);
    end;

  const
    AMessage = ' has broken bar item links. These links are not associated with any bar item, and may cause problems when creating a bar layout.'+#13#10+#13#10+'Do you want to delete broken bar item links?';
  var
    I: Integer;
  begin
    ALinksList := TdxObjectList.Create;
    try
      for I := 0 to ItemCount - 1 do
        CheckLinks(Items[I].GetItemLinks);

      for I := 0 to FBars.Count - 1 do
        CheckLinks(FBars[I].ItemLinks);

      if ALinksList.Count > 0 then
        case MessageBox(0, PChar(cxGetFullComponentName(Self) + AMessage), 'ExpressBars', MB_ICONWARNING or MB_YESNOCANCEL) of
          IDYES:
            begin
              ALinksList.OwnsObjects := True;
              ALinksList.Clear;
              DesignerModified;
            end;
          IDCANCEL: Abort;
        end;
    finally
      ALinksList.Free;
    end;
  end;

var
  I: Integer;
begin
  inherited Loaded;
//  FUpdateActionsListener.CorrectPosition;

  if IsUpdateLocked then Exit;

  Include(FInternalState, bisAfterLoading);
  try
    LoadLinkItemNames;
    if Designing then
      SortItems;
    Include(FInternalState, bisBarsLoading);
    try
      for I := 0 to FBars.Count - 1 do
        with FBars[I] do
        begin
          FIsPredefined := True;
          DockControl := FLoadedDockControl;
          if DockControl = nil then
            DockingStyle := FLoadedDockingStyle;
          Visible := FLoadedVisible;
        end;
      SaveState;
      if not Designing then
      begin
        if FStoreInRegistry then LoadFromRegistry(FRegistryPath);
        if FStoreInIniFile then LoadFromIniFile(FIniFileName);
      end;
    finally
      Exclude(FInternalState, bisBarsLoading);
    end;

    BeginUpdate;
    try
      for I := 0 to FCategories.Count - 1 do
        if FCategories.Objects[I] <> nil then
          CategoryItemsVisible[I] := TdxBarCategoryData(FCategories.Objects[I]).LoadedItemsVisible;
    finally
      EndUpdate;
    end;

    for I := 0 to DockControlCount - 1 do
      DockControls[I].UpdateDock;
  finally
    Exclude(FInternalState, bisAfterLoading);
  end;

  if IsDesigning then
    CheckBrokenLinks
  else
    CheckBidiMode;
end;

procedure TdxBarManager.LockDesignerModified(ALock: Boolean;
  AInvokeDesignerModifiedOnUnlock: Boolean = True);
begin
  if ALock then
  begin
    if FLockDesignerModifiedCount = 0 then
      FDesignerModifiedInvoked := False;
    Inc(FLockDesignerModifiedCount);
  end
  else
  begin
    Dec(FLockDesignerModifiedCount);
    if (FLockDesignerModifiedCount = 0) and AInvokeDesignerModifiedOnUnlock and FDesignerModifiedInvoked then
      DesignerModified;
  end;
end;

procedure TdxBarManager.Notification(AComponent: TComponent; Operation: TOperation);
var
  I: Integer;
begin
  inherited;
  if (Operation = opRemove) and (AComponent = FUpdateActionsListener) then
    FUpdateActionsListener := nil;
  if (Operation = opRemove) and (FPopupMenuLinks <> nil) then
  begin
    if AComponent is TControl then
      for I := 0 to FPopupMenuLinks.Count - 1 do
        if FPopupMenuLinks[I].Control = AComponent then
          FPopupMenuLinks[I].Control := nil;
    if AComponent is TdxBarPopupMenu then
      for I := 0 to FPopupMenuLinks.Count - 1 do
        if FPopupMenuLinks[I].PopupMenu = AComponent then
          FPopupMenuLinks[I].PopupMenu := nil;
  end;
end;

procedure TdxBarManager.ReadState(Reader: TReader);
begin
  inherited;
  Inc(FReadStateCount);
end;

procedure TdxBarManager.SetName(const NewName: TComponentName);
var
  I: Integer;
  OldName, ItemName, NamePrefix: TComponentName;
  Item: TdxBarItem;
begin
  OldName := Name;
  inherited SetName(NewName);
  if Designing and (Name <> OldName) then
    for I := 0 to FItems.Count - 1 do
    begin
      Item := Items[I];
      if Item.Owner = Owner then
      begin
        ItemName := Item.Name;
        NamePrefix := ItemName;
        if Length(NamePrefix) > Length(OldName) then
        begin
          SetLength(NamePrefix, Length(OldName));
          if CompareText(OldName, NamePrefix) = 0 then
          begin
            System.Delete(ItemName, 1, Length(OldName));
            System.Insert(NewName, ItemName, 1);
            try
              Item.Name := ItemName;
            except
              on EComponentError do
            end;
          end;
        end;
      end;
    end;
end;

procedure TdxBarManager.ShowToolbars(AShow, AForceOperation: Boolean; AActiveWindow: HWND);

  function CanHideToolbars: Boolean;
  begin
    Result := HideFloatingBarsWhenInactive or AForceOperation;
  end;

  procedure InvalidateBarsCaptions;
  var
    I: Integer;
  begin
    for I := 0 to Bars.Count - 1 do
      if Bars[I].IsFloat then
        Bars[I].Control.FrameChanged;
  end;

var
  I: Integer;
begin
  if (bisToolbarsVisibleChanging in FInternalState) or not IsParentFormAvailable then
    Exit;
  Include(FInternalState, bisToolbarsVisibleChanging);
  try
    if not CanHideToolbars then
      InvalidateBarsCaptions;
    if not AShow then
    begin
      if GetParent(AActiveWindow) = GetMainForm.Handle then
        Exit;
      if (ActiveBarControl <> nil) and ActiveBarControl.CanDeactivate(Self, AActiveWindow) then
        ActiveBarControl.HideAll;

      BarNavigationController.StopKeyboardHandling;

      if not CanHideToolbars then
      begin
        if BarDesignController.QuickControl <> nil then
          BarDesignController.QuickControl.CloseUp;
        Exit;
      end;
      if (AActiveWindow = 0) or (FindControl(AActiveWindow) is TCustomForm) and
        ((dxBarCustomizingForm = nil) or (AActiveWindow <> dxBarCustomizingForm.Handle) or not FIsCustomizing) or
        IsAnotherApplicationWindow(AActiveWindow) or
        (AActiveWindow = Application.Handle) then
      begin
        for I := 0 to Bars.Count - 1 do
          if Bars[I].IsFloat and Bars[I].Control.CanHideOnDeactivate then
            Bars[I].Control.Hide;
        if not AForceOperation then
          SendMessage(ParentForm.Handle, WM_NCACTIVATE, 0, 0);
      end;
    end
    else
      if IsOwnerVisible or IsOwnerMDIChild(True) then
        for I := 0 to Bars.Count - 1 do
          if Bars[I].IsFloat and Bars[I].Visible then
            Bars[I].Control.Show;
  finally
    Exclude(FInternalState, bisToolbarsVisibleChanging);
  end;
end;

procedure TdxBarManager.UpdateControlByMouse(ABarControl: TCustomdxBarControl);
var
  AMouseControl: TWinControl;
  P: TPoint;
begin
  P := GetMouseCursorPos;
  AMouseControl := FindControl(cxWindowFromPoint(P));
  if (AMouseControl is TCustomdxBarControl) and ((ABarControl = nil) or (ABarControl = AMouseControl)) then
  begin
    Windows.ScreenToClient(AMouseControl.Handle, P);
    TCustomdxBarControl(AMouseControl).FLastMousePos := cxInvalidPoint;
    PostMessage(AMouseControl.Handle, WM_MOUSEMOVE, 0, MakeLParam(P.X, P.Y));
  end;
end;

function TdxBarManager.IsOwnerVisible: Boolean;
var
  AWnd: HWND;
begin
  Result := IsControlVisible(Owner);
  if Result then
  begin
    AWnd := Owner.Handle;
    while not IsIconic(AWnd) and IsChildClassWindow(AWnd) do
      AWnd := GetParent(AWnd);
    Result := not IsIconic(AWnd);
  end;
end;

function TdxBarManager.IsParentFormAvailable: Boolean;
begin
  Result := ParentForm <> nil;
end;

function TdxBarManager.IsUncustomizable: Boolean;
var
  ACustomizingBarManager: TdxBarManager;
begin
  ACustomizingBarManager := dxBarManagerList.GetCustomizingBarManager;
  Result := (ACustomizingBarManager <> nil) and (Self <> ACustomizingBarManager);
end;

function TdxBarManager.CanAddComponents: Boolean;
begin
  Result := Owner.ComponentState * [csDesigning, csInline] <> [csDesigning, csInline];
end;

function TdxBarManager.GetLightColor(ABtnFaceColorPart, AHighlightColorPart, AWindowColorPart: Integer): COLORREF;
begin
  Result := cxGraphics.GetLightColor(ABtnFaceColorPart, AHighlightColorPart, AWindowColorPart);
end;

function TdxBarManager.BarByCaption(const ACaption: string): TdxBar;
var
  I: Integer;
begin
  for I := 0 to FBars.Count - 1 do
  begin
    Result := FBars[I];
    if Result.Caption = ACaption then Exit;
  end;
  Result := nil;
end;

function TdxBarManager.BarByComponentName(const AName: string): TdxBar;
var
  I: Integer;
begin
  Result := nil;
  for I := 0 to Bars.Count - 1 do
    if Bars[I].Name = AName then
    begin
      Result := Bars[I];
      Break;
    end;
end;

function TdxBarManager.BarByOldName(const AName: string): TdxBar;
var
  I: Integer;
begin
  Result := nil;
  for I := 0 to Bars.Count - 1 do
    if Bars[I].OldName = AName then
    begin
      Result := Bars[I];
      Break;
    end;
end;

//function TdxBarManager.CheckBarName(const AName: string): string;
//begin
//  if BarByNewName(AName) = nil then
//    Result := AName
//  else
//    Result := GetUniqueToolbarName(AName);
//end;

function TdxBarManager.GetUniqueToolbarCaption(const ABaseName: string): string;
var
  I: Integer;
begin
  I := 0;
  repeat
    Inc(I);
    Result := ABaseName + IntToStr(I);
  until BarByCaption(Result) = nil;
end;

function TdxBarManager.GetUniqueToolbarName(const ABaseName: string): string;
var
  I: Integer;
begin
  if not IsLoading and Designing then
    Result := UniqueName(ABaseName)
  else
  begin
    I := 0;
    repeat
      Inc(I);
      Result := ABaseName + IntToStr(I);
    until BarByNewName(Result) = nil;
  end;
end;

function TdxBarManager.GetAllItemsByCategory(ACategory: Integer; List: TList): Integer;
var
  I: Integer;
begin
  List.Clear;
  if (0 <= ACategory) and (ACategory < Categories.Count) then
    for I := 0 to ItemCount - 1 do
      if Items[I].Category = ACategory then List.Add(Items[I]);
  Result := List.Count;
end;

function TdxBarManager.GetCountByCategory(ACategory: Integer): Integer;
var
  I: Integer;
begin
  Result := 0;
  if (0 <= ACategory) and (ACategory < Categories.Count) then
    for I := 0 to ItemCount - 1 do
      with Items[I] do
        if (Category = ACategory) and
          (Designing or ActuallyVisible and not Hidden) then
          Inc(Result);
end;

function TdxBarManager.GetItemByCategory(ACategory, AIndex: Integer): TdxBarItem;
var
  AList: TList;
begin
  Result := nil;
  AList := TList.Create;
  try
    GetItemsByCategory(ACategory, AList);
    if (0 <= AIndex) and (AIndex < AList.Count) then
      Result := TdxBarItem(AList[AIndex]);
  finally
    AList.Free;
  end;
end;

function TdxBarManager.GetItemByName(const AName: string): TdxBarItem;
var
  I: Integer;
begin
  Result := nil;
  for I := 0 to ItemCount - 1 do
    if CompareText(Items[I].Name, AName) = 0 then
    begin
      Result := Items[I];
      Break;
    end;
end;

function TdxBarManager.GetItemsByCategory(ACategory: Integer; List: TList): Integer;
var
  I: Integer;
begin
  if Designing then
    Result := GetAllItemsByCategory(ACategory, List)
  else
  begin
    List.Clear;
    if (0 <= ACategory) and (ACategory < Categories.Count) then
      for I := 0 to ItemCount - 1 do
        with Items[I] do
          if (Category = ACategory) and ActuallyVisible and not Hidden then
            List.Add(Items[I]);
    Result := List.Count;
  end;
end;

function TdxBarManager.GetUniqueItemName(ABarItemClass: TdxBarItemClass): string;
var
  S, S1: string;
  I, J: Integer;
  AFound: Boolean;
begin
  S := ABarItemClass.ClassName;
  Delete(S, 1, 1);
  if Designing then
    Result := UniqueName(S)
  else
  begin
    J := 0;
    repeat
      Inc(J);
      S1 := S + IntToStr(J);
      AFound := False;
      for I := 0 to ItemCount - 1 do
        if CompareText(S1, Items[I].Name) = 0 then
        begin
          AFound := True;
          Break;
        end;
    until not AFound;
    Result := S1;
  end;
end;

function TdxBarManager.AddButton: TdxBarButton;
begin
  Result := TdxBarButton(AddItem(TdxBarButton));
end;

function TdxBarManager.AddItem(AClass: TdxBarItemClass): TdxBarItem;
var
  ACategoryIndex: Integer;
begin
  Result := AClass.Create(Self);
  ACategoryIndex := Categories.IndexOf(dxSBAR_DEFAULTCATEGORYNAME);
  if ACategoryIndex = -1 then
    ACategoryIndex := 0;
  Result.Category := ACategoryIndex;
end;

function TdxBarManager.AddSubItem: TdxBarSubItem;
begin
  Result := TdxBarSubItem(AddItem(TdxBarSubItem));
end;

function TdxBarManager.AddToolBar(AIsMainMenu: Boolean = False;
  ANeedEditCaption: Boolean = False): TdxBar;
var
  AWorkArea: TRect;
  ACaption: string;
begin
  Result := nil;
  ACaption := GetUniqueToolbarCaption(cxGetResourceString(@dxSBAR_TOOLBARNEWNAME));
  if ANeedEditCaption and not dxBarEditName(ACaption, 0, 0, Self, nil) then
    Exit;
  BeginUpdate;
  try
    Bars.BeginUpdate; // TODO FIX!!!
    try
      Result := Bars.Add;
      Result.Caption := ACaption;
      AWorkArea := GetWorkArea(Point(Owner.Left, Owner.Top));
      Result.FloatLeft := Owner.Left - 50;
      if Result.FloatLeft < AWorkArea.Left then
        Result.FloatLeft := Owner.Left + Owner.Width + 10;
      Result.FloatTop := Owner.Top;
      if Result.FloatTop < AWorkArea.Top then
        Result.FloatTop := AWorkArea.Top + 10;
      Result.DockingStyle := dsTop;
      if AIsMainMenu then
      begin
        Result.Row := 0;
        Result.IsMainMenu := True;
        Result.Visible := True;
      end
      else
      begin
        Result.Row := Result.RealDockControl.RowCount;
        Result.OneOnRow := True;
        Result.Visible := True;
        Result.OneOnRow := False;
      end;
      BarDesignController.SelectItem(Result);
    finally
      Bars.EndUpdate;
    end;
  finally
    EndUpdate;
  end;
end;

procedure TdxBarManager.DeleteToolBar(ABar: TdxBar; AConfirmation: Boolean);
begin
  if ABar = nil then
    Exit;
  if not AConfirmation or
       (dxBarMessageBox(Format(cxGetResourceString(@dxSBAR_WANTTODELETETOOLBAR), [ABar.Caption]),
         MB_ICONEXCLAMATION or MB_OKCANCEL) = ID_OK) then
    ABar.Free;
end;

procedure TdxBarManager.ExchangeItems(Index1, Index2: Integer);
begin
  FItems.Exchange(Index1, Index2);
  DesignerModified;
end;

{procedure TdxBarManager.FocusItem(AItem: TdxBarItem);
var
  AdxBarItemLink : TdxBarItemLink;
begin
  AdxBarItemLink := AItem.GetCurItemLink;
  if AdxBarItemLink = nil then
    AdxBarItemLink := AItem.GetLinks(0);
  if (AdxBarItemLink <> nil) then
    begin
      if AdxBarItemLink.BarControl = nil then
        TdxBarSubItem(TdxBarItemLinks(AdxBarItemLink.owner).owner).DropDown;
      if AdxBarItemLink.FControl <> nil then
      begin
        TdxBarWinControl(AdxBarItemLink.FControl).SetFocused(True);
        AdxBarItemLink.GetBarControl.SetSelectedItem(AdxBarItemLink.FControl);
      end;
    end;
end;}

procedure TdxBarManager.MoveItem(CurIndex, NewIndex: Integer);
begin
  FItems.Move(CurIndex, NewIndex);
  DesignerModified;
end;

procedure TdxBarManager.RenameToolBar(ABar: TdxBar);
var
  ACaption: string;
begin
  if ABar = nil then
    Exit;
  ACaption := ABar.Caption;
  if dxBarEditName(ACaption, 0, 1, Self, ABar) then
    ABar.Caption := ACaption;
end;

procedure TdxBarManager.ResetToolBar(ABar: TdxBar);
begin
  if ABar <> nil then
    ABar.ResetWithConfirmation;
end;

procedure TdxBarManager.Merge(ABarManager: TdxBarManager; ACanCreateNewBar: Boolean = True);
var
  ABar, ANewBar: TdxBar;
  I: Integer;
begin
  if (ABarManager = nil) or (ABarManager = Self) then
    raise EdxException.Create(cxGetResourceString(@dxSBAR_CANTMERGEBARMANAGER));

  for I := 0 to ABarManager.Bars.Count - 1 do
  begin
    ABar := ABarManager.Bars[I];
    if ABar.MergeData.MergedWith <> nil then
      raise EdxException.Create(cxGetResourceString(@dxSBAR_ONEOFTOOLBARSALREADYMERGED));
    if ABar.MergeData.MergedBarList.Count <> 0 then
      raise EdxException.Create(cxGetResourceString(@dxSBAR_ONEOFTOOLBARSHASMERGEDTOOLBARS));
  end;

  if not DoProcessMergeOperation(ABarManager, bmoMerge) then
  begin
    for I := 0 to ABarManager.Bars.Count - 1 do
    begin
      ABar := ABarManager.Bars[I];
      if ABar.Visible and (BarByCaption(ABar.Caption) <> nil) then
        BarByCaption(ABar.Caption).Merge(ABar);
    end;

    if ACanCreateNewBar then
      for I := 0 to ABarManager.Bars.Count - 1 do
      begin
        ABar := ABarManager.Bars[I];
        if ABar.Visible and (ABar.MergeData.MergedWith = nil) then
        begin
          ANewBar := CreateBarAsByMerging;
          ANewBar.Caption := ABar.Caption;
          ANewBar.Merge(ABar);
          ANewBar.Visible := True;
        end;
      end;
  end;
end;

procedure TdxBarManager.Unmerge(ABarManager: TdxBarManager = nil);
begin
  if not DoProcessMergeOperation(ABarManager, bmoUnmerge) then
    InternalUnmerge(ABarManager, False);
end;

procedure TdxBarManager.Customizing(Show: Boolean);
var
  APrevBarCount, I: Integer;
begin
  if (FIsCustomizing <> Show) and (not Show or (dxBarCustomizingForm = nil)) then
  begin
//    BeginUpdate; //#DG flickers
    try
      for I := Bars.Count - 1 downto 0 do
        if Bars[I].Control <> nil then
          with Bars[I].Control do
          begin
            APrevBarCount := Self.Bars.Count;
            HideAll;
            if APrevBarCount = Self.Bars.Count then // HideAll can destroy Bar
              DestroyControls;
          end;
      FIsCustomizing := Show;
      for I := 0 to Bars.Count - 1 do
        with Bars[I] do
        begin
          ItemLinks.RefreshVisibilityLists;
          if Control <> nil then Control.CreateControls;
        end;
      for I := 0 to ItemCount - 1 do
        if Items[I] is TCustomdxBarSubItem then
           TCustomdxBarSubItem(Items[I]).ItemLinks.RefreshVisibilityLists;
      for I := 0 to FPopupMenus.Count - 1 do
        TdxBarPopupMenu(FPopupMenus[I]).ItemLinks.RefreshVisibilityLists;
    finally
//      EndUpdate(False);
    end;
    dxBarCustomizing(Self, Show);
    for I := 0 to Bars.Count - 1 do
      with Bars[I] do
        if Control <> nil then
          with Control do
          begin
            UpdateControlState;
            RepaintBar;
          end;
  end;
end;

procedure TdxBarManager.HideAll;
begin
  if (ActiveBarControl <> nil) {and (ActiveBarControl.BarManager = Self) }then
    ActiveBarControl.HideAll;
end;

procedure TdxBarManager.ResetUsageData;
var
  ABarIndex: Integer;
  ASavedState: TCustomIniFile;
  I: Integer;
begin
  BeginUpdate;
  try
    ASavedState := ReadSavedState;
    try
      for I := 0 to ItemCount - 1 do
        Items[I].LoadUsageData(ASavedState, GetBaseIniSection);

      for I := 0 to Bars.Count - 1 do
      begin
        ABarIndex := GetSavedBarIndex(ASavedState, Bars[I].Caption);
        if ABarIndex <> -1 then
          Bars[I].LoadUsageData(ASavedState, GetBaseIniSection, ABarIndex);
      end;
    finally
      ASavedState.Free;
    end;
  finally
    EndUpdate;
  end;
end;

procedure TdxBarManager.ResetUsageDataWithConfirmation;
begin
  if dxBarMessageBox(cxGetResourceString(@dxSBAR_WANTTORESETUSAGEDATA),
       MB_YESNO or MB_DEFBUTTON2 or MB_ICONEXCLAMATION) = ID_YES then
    ResetUsageData;
end;

function GetComponentPath(ABarManagerOwner, AComponent: TComponent): string;
begin
  Result := AComponent.Name;
  if (Result <> '') and (AComponent.Owner <> ABarManagerOwner) then
    while not (AComponent is TCustomForm) and (AComponent.Owner <> nil) and
      (AComponent.Owner.Name <> '') do
    begin
      AComponent := AComponent.Owner;
      Result := AComponent.Name + '.' + Result;
    end;
end;

procedure TdxBarManager.CheckHintWindow;
begin
  if (FHintWindow = nil) or (FHintWindow.ClassType <> GetHintWindowClass) then
  begin
    FHintWindow.Free;
    FHintWindow := GetHintWindowClass.Create(nil);
    FHintWindow.BiDiMode := BiDiMode;
  end;
end;

function TdxBarManager.IsCustomHintStyle: Boolean;
begin
  Result := FCustomHintSupported and not FUseBarHintWindow;
end;

function TdxBarManager.GetBarManagerSection(const ABaseSection: string;
  AStoringKind: TdxBarStoringKind): string;
begin
  Result := ABaseSection;
  if AStoringKind = skIni then
    Result := Result + 'Main';
end;

function TdxBarManager.GetBaseIniSection: string;
var
  AOwner: TComponent;
begin
  Result := Name + GetSectionDelimiter(skIni);
  AOwner := Owner;
  while (AOwner <> nil) and (AOwner.Name <> '') do
  begin
    Result := AOwner.Name + GetSectionDelimiter(skIni) + Result;
    if AOwner is TCustomForm then
      Break;
    AOwner := AOwner.Owner;
  end;
end;

procedure TdxBarManager.LoadBarManager(ASource: TCustomIniFile; const ASection: string; AStoringKind: TdxBarStoringKind);
var
  ABarCount, AItemCount, I: Integer;
  ACurrentSection, ACustomSubItemName, ACustomSubItemSection: string;
  ACustomSubItemClass: TdxBarItemClass;
begin
  ACurrentSection := GetBarManagerSection(ASection, AStoringKind);
  Include(FInternalState, bisLoadingFromIni);
  BeginUpdate;
  try
    if CanShowRecentItems then
    begin
      MenusShowRecentItemsFirst := ASource.ReadBool(ACurrentSection, 'MenusShowRecentItemsFirst', MenusShowRecentItemsFirst);
      ShowFullMenusAfterDelay := ASource.ReadBool(ACurrentSection, 'ShowFullMenusAfterDelay', ShowFullMenusAfterDelay);
    end;
    LargeIcons := ASource.ReadBool(ACurrentSection, 'LargeIcons', LargeIcons);
    MenuAnimations := TdxBarMenuAnimations(ASource.ReadInteger(ACurrentSection, 'MenuAnimations', Byte(MenuAnimations)));
    ShowHint := ASource.ReadBool(ACurrentSection, 'ShowHint', ShowHint);
    ShowShortCutInHint := ASource.ReadBool(ACurrentSection, 'ShowShortCutInHint', ShowShortCutInHint);
    ABarCount := ASource.ReadInteger(ACurrentSection, 'BarCount', 0);
    AItemCount := ASource.ReadInteger(ASection + 'Items', 'ItemCount', -1);
    for I := 0 to ASource.ReadInteger(ASection + 'CustomSubItems', 'CustomSubItemCount', 0) - 1 do
    begin
      ACustomSubItemSection := ASource.ReadString(ASection + 'CustomSubItems', 'CustomSubItem' + IntToStr(I) + 'Section', '');
      ACustomSubItemName := ASource.ReadString(ACustomSubItemSection, 'Name', '');
      ACustomSubItemClass := TdxBarItemClass(GetClass(ASource.ReadString(ACustomSubItemSection, 'ClassName', '')));
      if (ACustomSubItemName <> '') and (GetItemByName(ACustomSubItemName) = nil) and (ACustomSubItemClass <> nil) then
        AddItem(ACustomSubItemClass).Name := ACustomSubItemName;
    end;
    if AItemCount > -1 then
    begin
      FNewItems := TStringList.Create;
      for I := 0 to ItemCount - 1 do
        if not ASource.ReadBool(ASection + 'Items', Items[I].Name, False) then
          FNewItems.Add(Items[I].Name);
    end;
    if ABarCount > 0 then
    begin
      for I := 0 to Bars.Count - 1 do
      begin
        Bars[I].Visible := False;
        Bars[I].DockRow := nil;
      end;
      for I := 0 to ABarCount - 1 do
      begin
        if I >= Bars.Count then
          Bars.Add;
        Bars[I].LoadFromIni(ASource, ASection, I, AStoringKind);
      end;
    end;
    for I := 0 to ItemCount - 1 do
      Items[I].LoadFromIni(ASource, ASection, AStoringKind);
    if AItemCount > -1 then
      FreeAndNil(FNewItems);
    IniFileCollectionCallMethods(ReadIniFileHandlers, ASource, AStoringKind, ASection);
  finally
    EndUpdate;
    Exclude(FInternalState, bisLoadingFromIni);
  end;
end;

function TdxBarManager.ReadSavedState: TMemIniFile;
begin
  SavedState.Position := 0;
  Result := TdxMemIniFile.Create(SavedState);
end;

procedure TdxBarManager.SaveBarManager(ADestination: TCustomIniFile; const ASection: string; AStoringKind: TdxBarStoringKind);

  procedure ClearOldData(ADestination: TCustomIniFile; const ASection: string);
  var
    AKeys: TStringList;
    I: Integer;
  begin
    AKeys := TStringList.Create;
    try
      ADestination.ReadSections(AKeys);
      for I := 0 to AKeys.Count - 1 do
        if Copy(AKeys[I], 1, Length(ASection)) = ASection then
          ADestination.EraseSection(AKeys[I]);
    finally
      AKeys.Free;
    end;
    if AStoringKind = skReg then
      ADestination.EraseSection(ASection);
  end;

  function GetBarCount: Integer;
  var
    I: Integer;
  begin
    Result := 0;
    for I := 0 to Bars.Count - 1 do
      if not Bars[I].MergeData.CreatedByMerging then
        Inc(Result);
  end;

  function GetCustomSubItemSectionsList: TStringList;
  var
    I: Integer;
  begin
    Result := TStringList.Create;
    for I := 0 to ItemCount - 1 do
      if not Items[I].IsPredefined and (Items[I] is TCustomdxBarSubItem) then
        Result.Add(Items[I].GetIniSection(ASection));
  end;

var
  ACurrentSection: string;
  ACustomSubItemSectionsList: TStringList;
  I: Integer;
begin
  ClearOldData(ADestination, ASection);
  ACurrentSection := GetBarManagerSection(ASection, AStoringKind);
  ADestination.WriteInteger(ACurrentSection, 'Version', dxBuildNumber);
  if CanShowRecentItems then
  begin
    ADestination.WriteBool(ACurrentSection, 'MenusShowRecentItemsFirst', MenusShowRecentItemsFirst);
    ADestination.WriteBool(ACurrentSection, 'ShowFullMenusAfterDelay', ShowFullMenusAfterDelay);
  end;
  ADestination.WriteBool(ACurrentSection, 'LargeIcons', LargeIcons);
  ADestination.WriteInteger(ACurrentSection, 'MenuAnimations', Ord(MenuAnimations));
  ADestination.WriteBool(ACurrentSection, 'ShowHint', ShowHint);
  ADestination.WriteBool(ACurrentSection, 'ShowShortCutInHint', ShowShortCutInHint);
  ADestination.WriteInteger(ACurrentSection, 'BarCount', GetBarCount);
  ADestination.WriteInteger(ASection + 'Items', 'ItemCount', ItemCount);
  for I := 0 to ItemCount - 1 do
    ADestination.WriteBool(ASection + 'Items', Items[I].Name, True);
  ACustomSubItemSectionsList := GetCustomSubItemSectionsList;
  try
    if ACustomSubItemSectionsList.Count > 0 then
    begin
      ADestination.WriteInteger(ASection + 'CustomSubItems', 'CustomSubItemCount', ACustomSubItemSectionsList.Count);
      for I := 0 to ACustomSubItemSectionsList.Count - 1 do
        ADestination.WriteString(ASection + 'CustomSubItems', 'CustomSubItem' + IntToStr(I) + 'Section', ACustomSubItemSectionsList[I]);
    end;
  finally
    ACustomSubItemSectionsList.Free;
  end;
  for I := 0 to Bars.Count - 1 do
    if not Bars[I].MergeData.CreatedByMerging then
      Bars[I].SaveToIni(ADestination, ASection, I, AStoringKind);
  for I := 0 to ItemCount - 1 do
    Items[I].SaveToIni(ADestination, ASection, AStoringKind);
  IniFileCollectionCallMethods(WriteIniFileHandlers, ADestination, AStoringKind, ASection);
end;

procedure TdxBarManager.SaveState;
var
  AIniFile: TdxMemIniFile;
begin
  if SavedState <> nil then
  begin
    Include(FInternalState, bisStateSaving);
    try
      SavedState.Size := 0;
      AIniFile := TdxMemIniFile.Create;
      try
        SaveBarManager(AIniFile, GetBaseIniSection, skIni);
        AIniFile.SaveToStream(SavedState);
      finally
        AIniFile.Free;
      end;
    finally
      Exclude(FInternalState, bisStateSaving);
    end;
  end;
end;

function TdxBarManager.CreateBarAsByMerging: TdxBar;
begin
  Result := Bars.Add;
  Result.MergeData.CreatedByMerging := True;
  Result.Move(dsTop, DockControls[Integer(dsTop) - 1].RowCount, 0);
end;

procedure TdxBarManager.InternalUnmerge(ABarManager: TdxBarManager; AForCustomization: Boolean);
var
  ABar: TdxBar;
  ABarLink: TcxObjectLink;
  ABarList: TList;
  I: Integer;
begin
  ABarList := nil;
  try
    if AForCustomization then
    begin
      ABarManager := nil;
      ABarList := TList.Create;
      for I := 0 to Bars.Count - 1 do
        if (Bars[I].MergeData.MergedWith <> nil) and
          (Bars[I].MergeData.MergedWith.BarManager = Self) then
            ABarList.Add(Bars[I]);
    end;

    for I := Bars.Count - 1 downto 0 do
    begin
      ABarLink := cxAddObjectLink(Bars[I]);
      try
        if AForCustomization then
        begin
          Bars[I].SaveMergeState;
          if Bars[I].MergeData.CreatedByMerging then
            Bars[I].ShouldNotBeDestroyedIfEmptyAfterUnmerge := True;
        end;
        Bars[I].InternalUnmergeFromBarManager(ABarManager, not AForCustomization);
        if ABarLink.Ref <> nil then
          Bars[I].ShouldNotBeDestroyedIfEmptyAfterUnmerge := False;
      finally
        cxRemoveObjectLink(ABarLink);
      end;
    end;

    if AForCustomization then
      for I := 0 to ABarList.Count - 1 do
      begin
        ABar := TdxBar(ABarList[I]);
        ABar.SetVisibility(ABar.MergeData.VisibleBeforeMerging);
      end;
  finally
    FreeAndNil(ABarList);
  end;
end;

procedure TdxBarManager.RestoreMergeState;
var
  ABar: TdxBar;
  I: Integer;
begin
  for I := 0 to Bars.Count - 1 do
  begin
    ABar := Bars[I];
    if not ABar.MergeData.CreatedByMerging then
      ABar.RestoreMergeState;
  end;

  for I := 0 to Bars.Count - 1 do
  begin
    ABar := Bars[I];
    if ABar.MergeData.CreatedByMerging then
    begin
      ABar.RestoreMergeState;
      ABar.Hidden := False;
      ABar.SetVisibility(ABar.MergeData.CreatedByMergingBarVisibleBeforeCustomization);
    end;
  end;
end;

procedure TdxBarManager.GetActiveSelection(AList: TList);
var
  I: Integer;
begin
  GetSelection(AList);
  for I := AList.Count - 1 downto 0 do
    if GetSelectionStatus(TPersistent(AList[I])) <> ssActiveSelected then
      AList.Delete(I);
end;

procedure TdxBarManager.GetAdornerTargetElements(AList: TStrings);
var
  I: Integer;
begin
  inherited GetAdornerTargetElements(AList);
  for I := 0 to Bars.Count - 1 do
    AList.AddObject(Bars[I].Name, Bars[I]);
end;

procedure TdxBarManager.BeginMouseTracking(ABarControl: TCustomdxBarControl);
begin
  if FMouseTrackingBarControl <> ABarControl then
  begin
    if FMouseTrackingBarControl <> nil then
      FMouseTrackingBarControl.MouseLeave;
    FMouseTrackingBarControl := ABarControl;
    cxControls.BeginMouseTracking(ABarControl, ABarControl.GetMouseTrackingBounds, ABarControl);
  end;
end;

procedure TdxBarManager.EndMouseTracking(ABarControl: TCustomdxBarControl);
begin
  if IsMouseTracking(ABarControl) then
    FMouseTrackingBarControl := nil;
  cxControls.EndMouseTracking(ABarControl);
end;

function TdxBarManager.IsMouseTracking(ABarControl: TCustomdxBarControl): Boolean;
begin
  Result := ABarControl = FMouseTrackingBarControl;
end;

procedure TdxBarManager.LoadFromRegistry(ARegistryPath: string);
var
  Registry: TRegistryIniFile;
begin
  if not CorrectRegistryPath(ARegistryPath) then
    Exit;
  Registry := TRegistryIniFile.Create(ARegistryPath);
  try
    LoadBarManager(Registry, ARegistryPath, skReg);
  finally
    Registry.Free;
  end;
end;

procedure TdxBarManager.SaveToRegistry(ARegistryPath: string);
var
  Registry: TRegistryIniFile;
begin
  if not CorrectRegistryPath(ARegistryPath) then
    Exit;
  Registry := TRegistryIniFile.Create(ARegistryPath);
  try
    SaveBarManager(Registry, ARegistryPath, skReg);
  finally
    Registry.Free;
  end;
end;

procedure TdxBarManager.LoadFromIniFile(const AFileName: string);
var
  AIniFile: TdxMemIniFile;
begin
  if (AFileName = '') and (FIniFileStream = nil) then
    Exit;
  AIniFile := TdxMemIniFile.Create(AFileName);
  try
    if FIniFileStream <> nil then
      AIniFile.LoadFromStream(FIniFileStream);
    LoadBarManager(AIniFile, GetBaseIniSection, skIni);
  finally
    AIniFile.Free;
  end;
end;

procedure TdxBarManager.SaveToIniFile(const AFileName: string);
var
  AIniFile: TdxMemIniFile;
begin
  if (AFileName = '') and (FIniFileStream = nil) then
    Exit;

  AIniFile := TdxMemIniFile.Create(AFileName);
  try
    SaveBarManager(AIniFile, GetBaseIniSection, skIni);
    AIniFile.Encoding := TEncoding.UTF8;
    if FIniFileStream <> nil then
      AIniFile.SaveToStream(FIniFileStream, TEncoding.UTF8)
    else
      AIniFile.UpdateFile
  finally
    AIniFile.Free;
  end;
end;

procedure TdxBarManager.LoadFromStream(AStream: TStream);
begin
  FIniFileStream := AStream;
  try
    LoadFromIniFile('');
  finally
    FIniFileStream := nil;
  end;
end;

procedure TdxBarManager.SaveToStream(AStream: TStream);
begin
  FIniFileStream := AStream;
  try
    SaveToIniFile('');
  finally
    FIniFileStream := nil;
  end;
end;

function TdxBarManager.CreateGroup: TdxBarGroup;
begin
  Result := TdxBarGroup.Create(Owner);
  AddGroup(Result);
end;

function TdxBarManager.CanShowRecentItems: Boolean;
begin
  Result := GetPaintStyle <> bmsStandard;
end;

function TdxBarManager.GetPaintStyle: TdxBarManagerStyle;
const
  AStyles: array[TcxLookAndFeelKind] of TdxBarManagerStyle = (
    bmsEnhanced, bmsStandard, bmsFlat, bmsOffice11);
begin
  if Style = bmsUseLookAndFeel then
  begin
    if LookAndFeel.NativeStyle and FThemeAvailable then
      Result := bmsXP
    else
      Result := AStyles[LookAndFeel.Kind]
  end
  else
    Result := Style;
end;

procedure TdxBarManager.IgnoreKeyStroke;
begin
  FIgnoreKeyStroke := True;
end;

function TdxBarManager.GetParentBidiMode: TBiDiMode;
var
  AParentForm: TCustomForm;
begin
  AParentForm := ParentForm;
  if AParentForm <> nil then
    Result := AParentForm.BiDiMode
  else
    Result := Application.BiDiMode;
end;

procedure TdxBarManager.CheckBidiMode;
var
  I: Integer;
  ABiDiMode: TBiDiMode;
begin
  ABiDiMode := GetParentBidiMode;
  if ABiDiMode <> FBiDiMode then
  begin
    FBiDiMode := ABiDiMode;
    FHintWindow.BiDiMode := FBiDiMode;
    BeginUpdate;
    try
      for I := 0 to DockControlCount - 1 do
        DockControls[I].BiDiMode := BiDiMode;

      for I := 0 to Bars.Count - 1 do
        if Bars[I].Control <> nil then
        begin
          Bars[I].Control.BiDiMode := BiDiMode;
          Bars[I].Control.RebuildBar;
        end;
    finally
      EndUpdate;
    end;
  end;
end;

procedure TdxBarManager.OwnerWindowProc(var Message: TMessage);
var
  I: integer;
begin
  if Message.Msg = CM_BIDIMODECHANGED then
  begin
    BeginUpdate;
    try
      FWindowProcObject.DefaultProc(Message);
      CheckBidiMode;
    finally
      EndUpdate;
    end;
    for I := 0 to DockControlCount - 1 do
    begin
      DockControls[I].ResetBackground;
      if DockControls[I].Visible and DockControls[I].HandleAllocated then
        cxRedrawWindow(DockControls[I].Handle, RDW_ALLCHILDREN or RDW_INVALIDATE);
    end;
  end
  else
    FWindowProcObject.DefaultProc(Message);
end;

{ TdxBarManagerList }

destructor TdxBarManagerList.Destroy;
begin
  FinalizationBars;
  inherited Destroy;
end;

function TdxBarManagerList.GetBarManager(Index: Integer): TdxBarManager;
begin
  Result := TdxBarManager(inherited GetItem(Index));
end;

function TdxBarManagerList.GetCustomizingBarManager: TdxBarManager;
var
  I: Integer;
begin
  Result := nil;
  for I := 0 to Count - 1 do
    if BarManagers[I].FIsCustomizing then
    begin
      Result := BarManagers[I];
      Break;
    end;
end;

function TdxBarManagerList.NextActive(ABarManager: TdxBarManager;
  AGoForward: Boolean): TdxBarManager;

  function IsBarManagerValid(ABarManager: TdxBarManager;
    AMainForm: TCustomForm): Boolean;
  var
    AForm: TCustomForm;
  begin
    Result := IsBarManagerOwner(ABarManager, AMainForm.Handle);
    if Result then
    begin
      AForm := GetBarManagerForm(ABarManager, fkMainOrMDIChild);
      Result := not IsMDIChild(AForm) or (AForm.Handle = ABarManager.ActiveMDIChild);
    end;
  end;

var
  AMainForm: TCustomForm;
  AIndex, AStartIndex: Integer;
begin
  AMainForm := ABarManager.GetMainForm;
  AStartIndex := IndexOf(ABarManager);
  AIndex := AStartIndex;
  if IsBarManagerValid(ABarManager, AMainForm) then
  repeat
    if AGoForward then
    begin
      Inc(AIndex);
      if AIndex = Count then
        AIndex := 0;
    end
    else
    begin
      Dec(AIndex);
      if AIndex < 0 then
        AIndex := Count - 1;
    end
  until (AIndex = AStartIndex) or IsBarManagerValid(BarManagers[AIndex], AMainForm);
  Result := BarManagers[AIndex];
end;

{ TdxBarAccessibilityHelper }

function TdxBarAccessibilityHelper.GetDefaultSelectableObject(
  ADirection: TcxAccessibilityNavigationDirection): IdxBarAccessibilityHelper;
begin
  Result := GetFirstSelectableObject;
end;

function TdxBarAccessibilityHelper.GetFirstSelectableObject: TdxBarAccessibilityHelper;
var
  I: Integer;
begin
  Result := nil;
  if Visible then
    if Selectable then
      Result := Self
    else
      for I := 0 to ChildCount - 1 do
      begin
        Result := Childs[I].GetFirstSelectableObject;
        if Result <> nil then
          Break;
      end;
end;

// IcxAccessibilityHelper
procedure TdxBarAccessibilityHelper.OwnerObjectDestroyed;
begin
  inherited OwnerObjectDestroyed;
  if BarNavigationController <> nil then
    BarNavigationController.UnassignObject(Self);
end;

// IdxBarAccessibilityHelper
function TdxBarAccessibilityHelper.AreKeyTipsSupported(
  out AKeyTipWindowsManager: IdxBarKeyTipWindowsManager): Boolean;
begin
  if ParentForKeyTip <> nil then
    Result := ParentForKeyTip.AreKeyTipsSupported(AKeyTipWindowsManager)
  else
    Result := False;
end;

function TdxBarAccessibilityHelper.CanNavigateToChildren(AKey: Word): Boolean;
begin
  Result := True;
end;

function TdxBarAccessibilityHelper.CanUnselectOnKeyDown(AKey: Word; AKeyTipsWereHidden: Boolean): Boolean;
begin
  if Parent <> nil then
    Result := Parent.CanUnselectOnKeyDown(AKey, AKeyTipsWereHidden)
  else
    Result := True;
end;

function TdxBarAccessibilityHelper.GetBarHelper: TdxBarAccessibilityHelper;
begin
  Result := Self;
end;

function TdxBarAccessibilityHelper.GetBarManager: TdxBarManager;
begin
  raise EdxException.Create('TdxBarAccessibilityHelper.GetBarManager fails');
end;

function TdxBarAccessibilityHelper.GetDefaultAccessibleObject: IdxBarAccessibilityHelper;
begin
  raise EdxException.Create('TdxBarAccessibilityHelper.GetDefaultAccessibleObject fails');
end;

function TdxBarAccessibilityHelper.GetNextAccessibleObject(
  ADirection: TcxAccessibilityNavigationDirection): IdxBarAccessibilityHelper;
var
  AObjects: TList;
begin
  AObjects := TList.Create;
  try
    GetChildrenForNavigation(Self, GetRootAccessibleObject.GetBarHelper,
      GetScreenBounds(cxAccessibleObjectSelfID), ADirection, True, AObjects);
    Result := dxBar.GetNextAccessibleObject(
      BarNavigationController.SelectedObject.GetBarHelper, AObjects, ADirection, True);
  finally
    AObjects.Free;
  end;
end;

function TdxBarAccessibilityHelper.GetRootAccessibleObject: IdxBarAccessibilityHelper;
begin
  Result := GetRootHelper as IdxBarAccessibilityHelper;
end;

function TdxBarAccessibilityHelper.HandleNavigationKey(var AKey: Word): Boolean;
begin
  Result := False;
end;

function TdxBarAccessibilityHelper.IsNavigationKey(AKey: Word): Boolean;
begin
  Result := False;
end;

function TdxBarAccessibilityHelper.IsSelected: Boolean;
var
  ASelectedObject: IdxBarAccessibilityHelper;
begin
  ASelectedObject := BarNavigationController.SelectedObject;
  Result := (ASelectedObject <> nil) and (ASelectedObject.GetHelper = Self);
end;

function TdxBarAccessibilityHelper.LogicalNavigationGetNextAccessibleObject(
  AShift: TShiftState): IdxBarAccessibilityHelper;
begin
  Result := Parent.LogicalNavigationGetNextChild(Parent.LogicalNavigationGetChildIndex(Self), AShift);
end;

procedure TdxBarAccessibilityHelper.Select(ASetFocus: Boolean);
begin
  BarNavigationController.SelectedObject := Self;
  BarNavigationController.SelectedObjectParent := Parent;
end;

procedure TdxBarAccessibilityHelper.Unselect(
  ANextSelectedObject: IdxBarAccessibilityHelper);
begin
  BarNavigationController.SelectedObject := nil;
  BarNavigationController.SelectedObjectParent := nil;
end;

procedure TdxBarAccessibilityHelper.GetChildrenForNavigation(
  ASelectedObject, AParentObject: TdxBarAccessibilityHelper;
  const ASelectedObjectScreenBounds: TRect;
  ADirection: TcxAccessibilityNavigationDirection;
  AAreOnlyNearObjectsAccepted: Boolean; AObjects: TList);

  function CheckObject(AObject: TdxBarAccessibilityHelper): Boolean;
  var
    R: TRect;
  begin
    Result := AObject.Selectable;
    if not Result then
      Exit;
    R := AObject.GetScreenBounds(cxAccessibleObjectSelfID);
    if AAreOnlyNearObjectsAccepted then
      if ADirection in [andLeft, andRight] then
        Result := (R.Bottom > ASelectedObjectScreenBounds.Top) and (R.Top < ASelectedObjectScreenBounds.Bottom)
      else
        Result := (R.Right > ASelectedObjectScreenBounds.Left) and (R.Left < ASelectedObjectScreenBounds.Right);
    if Result then
      case ADirection of
        andLeft, andRight:
          Result := not ((R.Left = ASelectedObjectScreenBounds.Left) and (R.Right = ASelectedObjectScreenBounds.Right));
        andUp:
          Result := R.Bottom <= ASelectedObjectScreenBounds.Top;
        andDown:
          Result := R.Top >= ASelectedObjectScreenBounds.Bottom;
      end;
  end;

var
  I: Integer;
begin
  if (AParentObject <> ASelectedObject) and AParentObject.Visible then
  begin
    if CheckObject(AParentObject) then
      AObjects.Add(AParentObject);
    for I := 0 to AParentObject.ChildCount - 1 do
      GetChildrenForNavigation(ASelectedObject, AParentObject.Childs[I],
        ASelectedObjectScreenBounds, ADirection, AAreOnlyNearObjectsAccepted, AObjects)
  end;
end;

procedure TdxBarAccessibilityHelper.GetChilds(AChilds: TList; AOnlyVisible: Boolean);
var
  AChild: TdxBarAccessibilityHelper;
  I: Integer;
begin
  if not AOnlyVisible or Visible then
    for I := 0 to ChildCount - 1 do
    begin
      AChild := Childs[I];
      if AChild.Selectable then
        AChilds.Add(AChild)
      else
        AChild.GetChilds(AChilds);
    end;
end;

function TdxBarAccessibilityHelper.GetKeyTip: string;
begin
  if GetAssignedKeyTip <> '' then
    Result := GetAssignedKeyTip
  else
    Result := GetDefaultKeyTip;
  if Length(Result) > 3 then
    SetLength(Result, 3);
end;

function TdxBarAccessibilityHelper.CreateKeyTipData: TdxBarKeyTipData;
var
  AKeyTipInfo: TdxBarKeyTipInfo;
begin
  GetKeyTipInfo(AKeyTipInfo);
  Result := TdxBarKeyTipData.Create(AKeyTipInfo);
end;

procedure TdxBarAccessibilityHelper.GetKeyTipInfo(out AKeyTipInfo: TdxBarKeyTipInfo);
begin
  cxZeroMemory(@AKeyTipInfo, SizeOf(AKeyTipInfo));
  AKeyTipInfo.KeyTip := GetKeyTip;
  AKeyTipInfo.Visible := Visible;
  AKeyTipInfo.OnExecute := KeyTipHandler;
end;

procedure TdxBarAccessibilityHelper.GetKeyTipData(AKeyTipsData: TList);
begin
  AKeyTipsData.Add(CreateKeyTipData);
end;

procedure TdxBarAccessibilityHelper.DoGetKeyTipsData(AKeyTipsData: TList);
var
  AChild: TdxBarAccessibilityHelper;
  I: Integer;
begin
  if Visible then
    for I := 0 to ChildCount - 1 do
    begin
      AChild := Childs[I];
      if AChild.Selectable then
        AChild.GetKeyTipData(AKeyTipsData)
      else
        AChild.DoGetKeyTipsData(AKeyTipsData);
    end;
end;

procedure TdxBarAccessibilityHelper.GetKeyTipsData(AKeyTipsData: TList);
begin
  DoGetKeyTipsData(AKeyTipsData);
  GenerateUniqueKeyTips(AKeyTipsData);
end;

procedure TdxBarAccessibilityHelper.GenerateUniqueKeyTips(AKeyTipsData: TList);

  function GetKeyTip(AList: TList; AIndex: Integer): string; // TODO TdxBarKeyTipsDataList
  begin
    Result := TdxBarKeyTipData(AList[AIndex]).KeyTip;
  end;

  function RemoveCollision(AIndex: Integer): Boolean;

    function GetSuffix(ATotalCount, AIndex: Integer): string;
    var
      I: Integer;
    begin
      Result := IntToStr(AIndex + 1);
      for I := Length(Result) to Length(IntToStr(ATotalCount)) - 1 do
        Result := '0' + Result;
    end;

    procedure InternalRemoveCollision(ACollisions: TdxObjectList);
    var
      I: Integer;
    begin
      for I := 0 to ACollisions.Count - 1 do
        TdxBarKeyTipData(ACollisions[I]).KeyTip := GetKeyTip(ACollisions, I) + GetSuffix(ACollisions.Count, I);
    end;

  var
    ACollisions: TdxObjectList;
    I: Integer;
  begin
    ACollisions := TdxObjectList.Create;
    try
      for I := 0 to AKeyTipsData.Count - 1 do
        if GetKeyTip(AKeyTipsData, AIndex) = GetKeyTip(AKeyTipsData, I) then
          ACollisions.Add(AKeyTipsData[I]);
      Result := ACollisions.Count > 1;
      if Result then
        InternalRemoveCollision(ACollisions)
      else
      begin
        for I := 0 to AKeyTipsData.Count - 1 do
          if (I <> AIndex) and (Pos(GetKeyTip(AKeyTipsData, AIndex), GetKeyTip(AKeyTipsData, I)) = 1) then
          begin
            InternalRemoveCollision(ACollisions);
            Result := True;
            Break;
          end;
      end;
    finally
      ACollisions.Free;
    end;
  end;

var
  I: Integer;
  AHasCollisions: Boolean;
begin
  repeat
    AHasCollisions := False;
    for I := 0 to AKeyTipsData.Count - 1 do
      AHasCollisions := RemoveCollision(I) or AHasCollisions;
  until not AHasCollisions;
end;

function TdxBarAccessibilityHelper.GetParentForKeyTip: TdxBarAccessibilityHelper;
begin
  Result := Parent;
end;

function TdxBarAccessibilityHelper.IsKeyTipContainer: Boolean;
begin
  Result := Selectable;
end;

procedure TdxBarAccessibilityHelper.KeyTipHandler(Sender: TObject);
begin
end;

procedure TdxBarAccessibilityHelper.KeyTipsEscapeHandler;
var
  ANewKeyTipContainer: IdxBarAccessibilityHelper;
begin
  ANewKeyTipContainer := GetKeyTipContainerParent(Self);
  if ANewKeyTipContainer = nil then
    BarNavigationController.StopKeyboardHandling
  else
  begin
    BarNavigationController.SetKeyTipsShowingState(ANewKeyTipContainer, '');
    BarNavigationController.ChangeSelectedObject(True, Self);
  end;
end;

function TdxBarAccessibilityHelper.LogicalNavigationGetChild(
  AIndex: Integer): TdxBarAccessibilityHelper;
begin
  Result := Childs[AIndex];
end;

function TdxBarAccessibilityHelper.LogicalNavigationGetChildCount: Integer;
begin
  Result := ChildCount;
end;

function TdxBarAccessibilityHelper.LogicalNavigationGetChildIndex(
  AChild: TdxBarAccessibilityHelper): Integer;
begin
  Result := GetChildIndex(AChild);
end;

function TdxBarAccessibilityHelper.LogicalNavigationGetNextChild(
  AChildIndex: Integer; AGoForward: Boolean): TdxBarAccessibilityHelper;

  function LogicalNavigationGetFirstChild(AContainer: TdxBarAccessibilityHelper): TdxBarAccessibilityHelper;
  var
    AChild: TdxBarAccessibilityHelper;
    I: Integer;
  begin
    Result := nil;
    if AGoForward then
      I := 0
    else
      I := AContainer.LogicalNavigationGetChildCount - 1;

    while (Result = nil) and (I >= 0) and (I < AContainer.LogicalNavigationGetChildCount) do
    begin
      AChild := AContainer.LogicalNavigationGetChild(I);
      if AChild.Selectable then
        Result := AChild
      else
        Result := LogicalNavigationGetFirstChild(AChild);

      if AGoForward then
        Inc(I)
      else
        Dec(I);
    end;
  end;

var
  AChild: TdxBarAccessibilityHelper;
begin
  repeat
    if AGoForward then
      Inc(AChildIndex)
    else
      Dec(AChildIndex);

    if (AChildIndex >= 0) and (AChildIndex < LogicalNavigationGetChildCount) then
    begin
      AChild := LogicalNavigationGetChild(AChildIndex);
      if AChild.Selectable then
        Result := AChild
      else
        Result := LogicalNavigationGetFirstChild(AChild);
    end
    else
      if Parent = nil then
        Result := LogicalNavigationGetFirstChild(Self)
      else
        Result := Parent.LogicalNavigationGetNextChild(Parent.LogicalNavigationGetChildIndex(Self), AGoForward);

  until Result <> nil;
end;

function TdxBarAccessibilityHelper.LogicalNavigationGetNextChild(AChildIndex: Integer;
  AShift: TShiftState): TdxBarAccessibilityHelper;
begin
  Result := LogicalNavigationGetNextChild(AChildIndex, not(ssShift in AShift));
end;

function TdxBarAccessibilityHelper.InternalGetChild(
  AIndex: Integer): TdxBarAccessibilityHelper;
begin
  Result := TdxBarAccessibilityHelper(GetChild(AIndex));
end;

function TdxBarAccessibilityHelper.InternalGetParent: TdxBarAccessibilityHelper;
begin
  Result := TdxBarAccessibilityHelper(GetParent);
end;


{ TdxBarCustomMergeData }

constructor TdxBarCustomMergeData.Create;
begin
  inherited Create;
  FFreeNotificator := TcxFreeNotificator.Create(nil);
  FFreeNotificator.OnFreeNotification := FreeNotification;
end;

destructor TdxBarCustomMergeData.Destroy;
begin
  FreeAndNil(FFreeNotificator);
  inherited Destroy;
end;

{ TdxBarMergeData }

constructor TdxBarMergeData.Create;
begin
  inherited Create;
  FMergedBarList := TList.Create;
  FSavedMergedBarList := TList.Create;
end;

destructor TdxBarMergeData.Destroy;
begin
  ClearSavedMergedBarList;
  FreeAndNil(FSavedMergedBarList);
  FreeAndNil(FMergedBarList);
  inherited Destroy;
end;

procedure TdxBarMergeData.ClearSavedMergedBarList;
var
  I: Integer;
begin
  for I := 0 to SavedMergedBarCount - 1 do
    FreeNotificator.RemoveSender(FSavedMergedBarList[I]);
  FSavedMergedBarList.Clear;
end;

procedure TdxBarMergeData.SaveMergedBarList(AList: TList = nil);
var
  I: Integer;
begin
  if AList = nil then
    AList := FSavedMergedBarList;
  for I := 0 to MergedBarList.Count - 1 do
    AList.Add(MergedBarList[I]);
  if AList = FSavedMergedBarList then
    SetFreeNotifications;
end;

procedure TdxBarMergeData.FreeNotification(Sender: TComponent);
begin
  FSavedMergedBarList.Remove(Sender);
end;

function TdxBarMergeData.GetSavedMergedBar(AIndex: Integer): TdxBar;
begin
  Result := TdxBar(FSavedMergedBarList[AIndex]);
end;

function TdxBarMergeData.GetSavedMergedBarListCount: Integer;
begin
  Result := FSavedMergedBarList.Count;
end;

procedure TdxBarMergeData.SetFreeNotifications;
var
  I: Integer;
begin
  for I := 0 to SavedMergedBarCount - 1 do
    FreeNotificator.AddSender(TComponent(FSavedMergedBarList[I]));
end;

{ TdxBarCaptionButton }

constructor TdxBarCaptionButton.Create(Collection: TCollection);
begin
  inherited;
  FGlyph := dxBarCreateBitmap(GlyphChanged);

  FNotifyComponent := TcxFreeNotificator.Create(nil);
  FNotifyComponent.OnFreeNotification := FreeNotification;
  Enabled := True;
end;

destructor TdxBarCaptionButton.Destroy;
begin
  BarAccessibilityHelperOwnerObjectDestroyed(FIAccessibilityHelper);
  FreeAndNil(FNotifyComponent);
  FreeAndNil(FGlyph);
  inherited;
end;

procedure TdxBarCaptionButton.Assign(Source: TPersistent);
begin
  if Source is TdxBarCaptionButton then
  begin
    Enabled := TdxBarCaptionButton(Source).Enabled;
    Glyph := TdxBarCaptionButton(Source).Glyph;
    Hint := TdxBarCaptionButton(Source).Hint;
    KeyTip := TdxBarCaptionButton(Source).KeyTip;
    Rect := TdxBarCaptionButton(Source).Rect;
    ScreenTip := TdxBarCaptionButton(Source).ScreenTip;
    OnClick := TdxBarCaptionButton(Source).OnClick;
  end
  else
    inherited Assign(Source);
end;

procedure TdxBarCaptionButton.Click;
begin
  CallNotify(OnClick, Self);
end;

function TdxBarCaptionButton.GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass;
begin
  Result := TdxBarCaptionButtonAccessibilityHelper;
end;

// IdxBarHintKeeper
function TdxBarCaptionButton.DoHint(var ANeedDeactivate: Boolean; out AHintText: string; out AShortCut: string): Boolean;
begin
  Result := False;
  ANeedDeactivate := False;
  AShortCut := '';
  AHintText := '';

  if State = DXBAR_HOT then
  begin
    AHintText := Hint;
    Result := True;
  end;
end;

function TdxBarCaptionButton.CreateHintViewInfo(const AHintText, AShortCut: string): TdxBarCustomHintViewInfo;
begin
  Result := Parent.CreateHintViewInfo(AHintText, AShortCut, ScreenTip);
end;

function TdxBarCaptionButton.GetEnabled: Boolean;
begin
  Result := State <> DXBAR_DISABLED;
end;

function TdxBarCaptionButton.GetHintPosition(const ACursorPos: TPoint; AHeight: Integer): TPoint;
var
  AClientOffset: TPoint;
  R: TRect;
begin
  AClientOffset := cxGetClientOffset(Parent.Handle);
  R := cxRectOffset(Rect, AClientOffset, False);
  Result := Parent.GetHintPosition(R, ACursorPos, AHeight);
end;

function TdxBarCaptionButton.GetCollection: TdxBarCaptionButtons;
begin
  Result := TdxBarCaptionButtons(inherited Collection);
end;

function TdxBarCaptionButton.GetIAccessibilityHelper: IdxBarAccessibilityHelper;
begin
  if FIAccessibilityHelper = nil then
    FIAccessibilityHelper := GetAccessibilityHelperClass.Create(Self);
  Result := FIAccessibilityHelper;
end;

function TdxBarCaptionButton.GetParent: TdxBarControl;
begin
  Result := Collection.Bar.Control;
end;

procedure TdxBarCaptionButton.GlyphChanged(Sender: TObject);
begin
  Changed(False);
end;

procedure TdxBarCaptionButton.Merge(AButton: TdxBarCaptionButton);
begin
  Assign(AButton);
  FCreatedFromMergingWith := AButton.Collection;
end;

procedure TdxBarCaptionButton.Unmerge(AButtons: TdxBarCaptionButtons);
begin
  if FCreatedFromMergingWith <> nil then
  begin
    if (AButtons = nil) or (AButtons = FCreatedFromMergingWith) then
      Free;
  end;
end;

procedure TdxBarCaptionButton.SetEnabled(Value: Boolean);
begin
  FEnabled := Value;
  if Value then
    State := DXBAR_NORMAL
  else
    State := DXBAR_DISABLED;
end;

procedure TdxBarCaptionButton.SetGlyph(Value: TBitmap);
begin
  FGlyph.Assign(Value);
end;

procedure TdxBarCaptionButton.SetScreenTip(Value: TdxScreenTip);
begin
  if FScreenTip <> Value then
  begin
    cxRemoveFreeNotification(FNotifyComponent, FScreenTip);
    FScreenTip := Value;
    cxAddFreeNotification(FNotifyComponent, FScreenTip);
  end;
end;

procedure TdxBarCaptionButton.SetState(Value: Integer);
begin
  if FState <> Value then
  begin
    FState := Value;
    if Parent <> nil then
      Parent.ActivateHint(FState = DXBAR_HOT, '', Self);
    Changed(False);
  end;
end;

procedure TdxBarCaptionButton.SetOnClick(Value: TNotifyEvent);
begin
  FOnClick := Value;
  Changed(True);
end;

procedure TdxBarCaptionButton.FreeNotification(AComponent: TComponent);
begin
  FScreenTip := nil;
end;

{ TdxBarCaptionButtons }

constructor TdxBarCaptionButtons.Create(ABar: TdxBar);
begin
  inherited Create(ABar, TdxBarCaptionButton);
end;

destructor TdxBarCaptionButtons.Destroy;
begin
  BarAccessibilityHelperOwnerObjectDestroyed(FIAccessibilityHelper);
  inherited Destroy;
end;

function TdxBarCaptionButtons.Add: TdxBarCaptionButton;
begin
  BeginUpdate;
  try
    Result := TdxBarCaptionButton(inherited Add);
  finally
    EndUpdate;
  end;
end;

procedure TdxBarCaptionButtons.Merge(AButtons: TdxBarCaptionButtons);
var
  I: Integer;
begin
  BeginUpdate;
  try
    for I := 0 to AButtons.Count - 1 do
      Add.Merge(AButtons[I]);
  finally
    EndUpdate;
  end;
end;

procedure TdxBarCaptionButtons.Unmerge(AButtons: TdxBarCaptionButtons);
var
  I: Integer;
begin
  BeginUpdate;
  try
    for I := Count - 1 downto 0 do
      Items[I].Unmerge(AButtons);
  finally
    EndUpdate;
  end;
end;

procedure TdxBarCaptionButtons.UpdateButtonStates(const AMousePos: TPoint; AMousePressed: Boolean = False);

  function GetItemState(AItem: TdxBarCaptionButton): Integer;
  const
    ItemStateMap: array[Boolean] of Integer = (DXBAR_HOT, DXBAR_PRESSED);
  begin
    if PtInRect(AItem.Rect, AMousePos) or AItem.IAccessibilityHelper.IsSelected then
      Result := ItemStateMap[AMousePressed]
    else
      Result := DXBAR_NORMAL;
  end;

var
  AItem: TdxBarCaptionButton;
  I: Integer;
begin
  for I := 0 to Count - 1 do
  begin
    AItem := Items[I];
    if AItem.Enabled then
      AItem.State := GetItemState(AItem);
  end;
end;

function TdxBarCaptionButtons.GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass;
begin
  Result := TdxBarCaptionButtonsAccessibilityHelper;
end;

function TdxBarCaptionButtons.GetButtonIndex(const APoint: TPoint): Integer;
var
  I: Integer;
begin
  Result := -1;
  for I := 0 to Count - 1 do
    if Items[I].Enabled and PtInRect(Items[I].Rect, APoint) then
    begin
      Result := I;
      Break;
    end;
end;

function TdxBarCaptionButtons.GetBar: TdxBar;
begin
  Result := TdxBar(Owner);
end;

function TdxBarCaptionButtons.GetIAccessibilityHelper: IdxBarAccessibilityHelper;
begin
  if FIAccessibilityHelper = nil then
    FIAccessibilityHelper := GetAccessibilityHelperClass.Create(Self);
  Result := FIAccessibilityHelper;
end;

function TdxBarCaptionButtons.GetItem(Index: Integer): TdxBarCaptionButton;
begin
  Result := TdxBarCaptionButton(inherited GetItem(Index));
end;

function TdxBarCaptionButtons.GetRect: TRect;
var
  I: Integer;
begin
  Result := cxEmptyRect;
  for I := 0 to Count - 1 do
    if not IsRectEmpty(Items[I].Rect) then
      UnionRect(Result, Result, Items[I].Rect);
end;

procedure TdxBarCaptionButtons.SetItem(Index: Integer; Value: TdxBarCaptionButton);
begin
  inherited SetItem(Index, Value);
end;

{ TdxBarItemOptions }

constructor TdxBarItemOptions.Create(AItemLinks: TdxBarItemLinks);
begin
  inherited Create;
  FItemLinks := AItemLinks;

  FShowDescriptions := GetDefaultValue(ioShowDescriptions) <> 0;
  FShowShortCuts := GetDefaultValue(ioShowShortCuts) <> 0;
  FSize := TdxBarMenuItemSize(GetDefaultValue(ioSize));
end;

procedure TdxBarItemOptions.Assign(Source: TPersistent);
begin
  if Source is TdxBarItemOptions then
  begin
    FAssignedValues := TdxBarItemOptions(Source).FAssignedValues;
    FShowDescriptions := TdxBarItemOptions(Source).FShowDescriptions;
    FShowShortCuts := TdxBarItemOptions(Source).FShowShortCuts;
    FSize := TdxBarItemOptions(Source).FSize;
  end
  else
    inherited;
end;

function TdxBarItemOptions.GetDefaultValue(AOption: TdxBarItemOptionValue): Integer;
begin
  Result := FItemLinks.GetDefaultValue(AOption);
end;

function TdxBarItemOptions.GetValue(AOption: TdxBarItemOptionValue): Integer;
begin
  case AOption of
    ioShowDescriptions:
      Result := Ord(ShowDescriptions);
    ioShowShortCuts:
      Result := Ord(ShowShortCuts);
  else {ioSize}
    Result := Ord(Size);
  end;
end;

function TdxBarItemOptions.GetShowDescriptions: Boolean;
begin
  if IsShowDescriptionsStored then
    Result := FShowDescriptions
  else
    Result := GetDefaultValue(ioShowDescriptions) <> 0;
end;

function TdxBarItemOptions.GetShowShortCuts: Boolean;
begin
  if IsShowShortCutsStored then
    Result := FShowShortCuts
  else
    Result := GetDefaultValue(ioShowShortCuts) <> 0;
end;

function TdxBarItemOptions.GetSize: TdxBarMenuItemSize;
begin
  if IsSizeStored then
    Result := FSize
  else
    Result := TdxBarMenuItemSize(GetDefaultValue(ioSize));
end;

procedure TdxBarItemOptions.SetAssignedValues(AValue: TdxBarItemOptionValues);
begin
  FAssignedValues := AValue;
{
  if FAssignedValues <> AValue then
  begin
    FAssignedValues := AValue;
    if not IsValueStored(ioShowDescriptions) then
      FShowDescriptions := GetDefaultValue(ioShowDescriptions);
    if not IsValueStored(ioShowShortCuts) then
      FShowShortCuts := GetDefaultValue(ioShowShortCuts);
    if not IsValueStored(ioSize) then
      FSize := GetDefaultValue(ioSize);
  end;
}
end;

procedure TdxBarItemOptions.SetShowDescriptions(AValue: Boolean);
begin
  FShowDescriptions := AValue;
  Include(FAssignedValues, ioShowDescriptions);
end;

procedure TdxBarItemOptions.SetShowShortCuts(AValue: Boolean);
begin
  FShowShortCuts := AValue;
  Include(FAssignedValues, ioShowShortCuts);
end;

procedure TdxBarItemOptions.SetSize(AValue: TdxBarMenuItemSize);
begin
  FSize := AValue;
  Include(FAssignedValues, ioSize);
end;

function TdxBarItemOptions.IsValueStored(AOption: TdxBarItemOptionValue): Boolean;
begin
  Result := AOption in AssignedValues;
end;

function TdxBarItemOptions.IsShowDescriptionsStored: Boolean;
begin
  Result := IsValueStored(ioShowDescriptions);
end;

function TdxBarItemOptions.IsShowShortCutsStored: Boolean;
begin
  Result := IsValueStored(ioShowShortCuts)
end;

function TdxBarItemOptions.IsSizeStored: Boolean;
begin
  Result := IsValueStored(ioSize);
end;

{ TdxBarItemLink }

constructor TdxBarItemLink.Create(Collection: TCollection);
begin
  inherited Create(Collection);
  FButtonGroup := bgpNone;
  FDistributed := True;
  FImageIndex := -1;
  FLoadedRecentIndex := -1;
  FLoadedVisible := True;
  FMostRecentlyUsed := True;
  FPosition := ipBeginsNewRow;
  FUseCount := BarManager.FMostRecentlyUsedUseCount;
  FUserGlyph := dxBarCreateSmartGlyph(OnUserGlyphChanged);
  FViewLevels := dxBarItemAllViewLevels;
  FVisible := True;
  AddToRecentList;
  BarManager.DoItemLinkAdd(Self);
end;

destructor TdxBarItemLink.Destroy;
var
  ABarControl: TCustomdxBarControl;
begin
  BarAccessibilityHelperOwnerObjectDestroyed(FIAccessibilityHelper);
  BarManager.DoItemLinkDelete(Self);
  ABarControl := BarControl;

  if (ABarControl <> nil) and not ABarControl.IsDestroying then
  begin
    if ABarControl.SelectedLink = Self then
    begin
      BarManager.InternalSetSelectedItem(nil);
      ABarControl.SelectedLink := nil;
    end;
    if BarControl.FPrevTrackedLink = Self then
      BarControl.FPrevTrackedLink := nil;
  end;

  DestroyControl;
  if BarDesignController <> nil then
    BarDesignController.DropSelection(Self);
  if FItem <> nil then
    FItem.FLinks.Remove(Self);
  FreeAndNil(FUserGlyph);

  RemoveFromRecentList;
  inherited Destroy;

{  if (ABarControl <> nil) and ABarControl.HandleAllocated and
    not ABarControl.IsDestroying then
  begin
    ABarControl.RepaintBar;
    if Assigned(AItemLinks.FOnChange) then AItemLinks.FOnChange(AItemLinks);
  end;}
end;

function TdxBarItemLink.GetAllowedViewLevels: TdxBarItemViewLevels;
begin
  Result := ViewLevels;
end;

function TdxBarItemLink.GetAvailableIndex: Integer;
begin
  if Owner = nil then
    Result := -1
  else
    Result := Owner.AvailableIndexOf(Self);
end;

function TdxBarItemLink.GetBarControl: TCustomdxBarControl;
begin
  Result := Owner.FBarControl;
end;

function TdxBarItemLink.GetCanVisibleIndex: Integer;
begin
  if Owner = nil then
    Result := -1
  else
    Result := Owner.CanVisibleIndexOf(Self);
end;

function TdxBarItemLink.GetCaption: string;
begin
  if not (udCaption in FUserDefine) and (FItem <> nil) then
    Result := FItem.Caption
  else
    Result := FUserCaption;
end;

function TdxBarItemLink.GetCollection: TdxBarItemLinks;
begin
  Result := TdxBarItemLinks(inherited Collection);
end;

function TdxBarItemLink.GetGlyph: TdxSmartGlyph;
begin
  if not (udGlyph in FUserDefine) and (FItem <> nil) then
    Result := FItem.Glyph
  else
    Result := FUserGlyph;
end;

function TdxBarItemLink.GetNext: TdxBarItemLink;
begin
  if Collection.Next(Self, True) <> Self then
    Result := Collection.Next(Self, True)
  else
    Result := nil;
end;

function TdxBarItemLink.GetOwnerValue: TdxBarItemLinks;
begin
  Result := Collection;
end;

function TdxBarItemLink.GetPaintStyle: TdxBarPaintStyle;
begin
  if not (udPaintStyle in FUserDefine) and (FItem <> nil) then
    Result := FItem.PaintStyle
  else
    Result := FUserPaintStyle;
end;

function TdxBarItemLink.GetUserDefine: TdxBarUserDefines;
begin
  Result := FUserDefine;
end;

function TdxBarItemLink.GetVisibleIndex: Integer;
begin
  if Owner <> nil then
    Result := Owner.VisibleIndexOf(Self)
  else
    Result := -1;
end;

function TdxBarItemLink.GetWidth: Integer;
begin
  if udWidth in FUserDefine then
    Result := FUserWidth
  else
    if Item is TdxCustomBarEdit then
    begin
      Result := TdxCustomBarEdit(Item).Width;
      if BarControl <> nil then
        Result := BarControl.ScaleFactor.Apply(Result, BarManager.ScaleFactor);
    end
    else
      Result := 0
end;

procedure TdxBarItemLink.ReadItemName(AReader: TReader);
begin
  FLoadedItemName := AReader.ReadString;
end;

procedure TdxBarItemLink.SetButtonGroup(Value: TdxBarButtonGroupPosition);
begin
  if Value <> FButtonGroup then
  begin
    FButtonGroup := Value;
    Changed(True);
  end;
end;

procedure TdxBarItemLink.SetCollection(Value: TdxBarItemLinks);
begin
  inherited Collection := Value;
end;

procedure TdxBarItemLink.SetDistributed(const Value: Boolean);
begin
  if FDistributed <> Value then
  begin
    FDistributed := Value;
    Owner.FPrimaryForDistributionItems.Add(Self);
    Changed(True);
  end
end;

procedure TdxBarItemLink.SetDistributedByPrimaryLink(const Value: Boolean);
begin
  if FDistributed <> Value then
  begin
    FDistributed := Value;
    Owner.DesignerModified;
  end;
  Owner.FPrimaryForDistributionItems.Remove(Self);
end;

procedure TdxBarItemLink.SetImageIndex(Value: Integer);
begin
  if FImageIndex <> Value then
  begin
    FImageIndex := Value;
    if Item <> nil then
      Item.GlyphChanged;
  end;
end;

procedure TdxBarItemLink.SetItem(Value: TdxBarItem);
var
  AErrorText: string;
  AOwner: TdxBarItemLinks;
begin
  if FItem <> Value then
  begin
    AOwner := Owner;
    AOwner.BeginUpdate;
    try
      DestroyControl;
      if FItem <> nil then
        FItem.FLinks.Remove(Self);
      FItem := nil;
      if Value <> nil then
      begin
        if not AOwner.CanContainItem(Value, AErrorText) then
        begin
          Free;
          raise EdxException.Create(AErrorText);
        end;
        try
          FItem := Value;
          FItem.FLinks.Add(Self);
          AOwner.RefreshVisibilityLists;
          if (AOwner.Owner <> nil) and not (csLoading in AOwner.Owner.ComponentState) then
            CheckMostRecentlyUsed;
        finally
          if AOwner.UpdateCount = 1 then
            BarManager.DoItemLinkChange(Self); // TdxBarItemLink.SetItem should fire OnItemLinkChange for compatibility with Bars5
        end;
      end
      else
        Free;
    finally
      AOwner.EndUpdate;
    end;
  end;
end;

procedure TdxBarItemLink.SetItemRect(Value: TRect);
begin
  if not cxRectIsEqual(FItemRect, Value) then
  begin
    FItemRect := Value;
    if (Owner.FItemRectsLockCount = 0) and (Control <> nil) then
      Control.DoCalculateParts;
  end;
end;

procedure TdxBarItemLink.SetMostRecentlyUsed(Value: Boolean);
begin
  if FMostRecentlyUsed <> Value then
  begin
    FMostRecentlyUsed := Value;
    CheckMostRecentlyUsed;
    if BarControl <> nil then
      BarControl.RepaintBar;
    Changed(False);
  end;
end;

procedure TdxBarItemLink.SetPosition(Value: TdxBarItemPosition);
begin
  if Value <> FPosition then
  begin
    FPosition := Value;
    Changed(True);
  end;
end;

procedure TdxBarItemLink.ForceSetUserDefine(AValue: TdxBarUserDefine);
begin
  FUserDefine := FUserDefine - [AValue];
  UserDefine := UserDefine + [AValue];
end;

procedure TdxBarItemLink.SetUserDefine(Value: TdxBarUserDefines);

  procedure ExcludeProperty(AProperty: TdxBarUserDefine);
  begin
    Exclude(FUserDefine, AProperty);
    case AProperty of
      udCaption:
        FUserCaption := '';
      udGlyph:
        FUserGlyph.Assign(nil);
      udPaintStyle:
        FUserPaintStyle := psStandard;
      udWidth:
        FUserWidth := 0;
    end;
  end;

  function CheckChanges(AProperty: TdxBarUserDefine): Boolean;
  begin
    Result := True;
    if (AProperty in FUserDefine) and not(AProperty in Value) then
      ExcludeProperty(AProperty)
    else
      if not(AProperty in FUserDefine) and (AProperty in Value) then
        Include(FUserDefine, AProperty)
      else
        Result := False;
  end;

  procedure PropertyChanged(AProperty: TdxBarUserDefine);
  begin
    if Control <> nil then
      case AProperty of
        udCaption:
          Control.CaptionChanged;
        udGlyph:
          Control.GlyphChanged;
        udPaintStyle:
          Control.PaintStyleChanged;
        udWidth:
          Control.WidthChanged;
      end;
  end;

var
  AProperty: TdxBarUserDefine;
begin
  if FUserDefine <> Value then
  begin
    for AProperty := Low(TdxBarUserDefine) to High(TdxBarUserDefine) do
      if CheckChanges(AProperty) then
        PropertyChanged(AProperty);

    Changed(False);
  end;
end;

procedure TdxBarItemLink.SetUserCaption(const Value: string);
begin
  if FUserCaption <> Value then
  begin
    FUserCaption := Value;
    ForceSetUserDefine(udCaption);
  end;
end;

procedure TdxBarItemLink.SetUserGlyph(Value: TdxSmartGlyph);
begin
  FUserGlyph.Assign(Value);
end;

procedure TdxBarItemLink.SetUserPaintStyle(Value: TdxBarPaintStyle);
begin
  if PaintStyle <> Value then
  begin
    FUserPaintStyle := Value;
    ForceSetUserDefine(udPaintStyle);
  end;
end;

procedure TdxBarItemLink.SetUserWidth(Value: Integer);
begin
  if Width <> Value then
  begin
    FUserWidth := Value;
    ForceSetUserDefine(udWidth);
  end;
end;

procedure TdxBarItemLink.SetViewLayout(Value: TdxBarItemViewLayout);
begin
  if FViewLayout <> Value then
  begin
    FViewLayout := Value;
    Changed(True);
  end;
end;

procedure TdxBarItemLink.SetViewLevels(Value: TdxBarItemViewLevels);
begin
  if FViewLevels <> Value then
  begin
    FViewLevels := Value;
    Changed(True);
  end;
end;

procedure TdxBarItemLink.SetVisible(Value: Boolean);
begin
  if Owner.IsLoading or Owner.FAssigning then
  begin
    FLoadedVisible := Value;
    Exit;
  end;
  if FVisible <> Value then
  begin
    FVisible := Value;
    if not BarManager.Designing then
      VisibleChanged;
    Changed(False);
  end;
end;

procedure TdxBarItemLink.WriteItemName(AWriter: TWriter);
begin
  if Item <> nil then
    AWriter.WriteString(Item.Name)
  else
    AWriter.WriteString('');
end;

procedure TdxBarItemLink.AddToRecentList;
begin
  Owner.FRecentItems.Add(Self);
end;

procedure TdxBarItemLink.RemoveFromRecentList;
begin
  if Owner.FRecentItems <> nil then
    Owner.FRecentItems.Remove(Self);
end;

procedure TdxBarItemLink.RestoreRecentIndex;
begin
  RecentIndex := FPrevRecentIndex;
end;

procedure TdxBarItemLink.SaveRecentIndex;
begin
  FPrevRecentIndex := RecentIndex;
end;

procedure TdxBarItemLink.InternalBringToTopInRecentList(IncCount: Boolean);
begin
  if (Owner <> nil) and not Owner.CanUseRecentItems then Exit;
  RecentIndex := 0;
  if IncCount then Inc(FUseCount);
end;

function TdxBarItemLink.IsPrimaryForDistribution: Boolean;
begin
  Result := Owner.FPrimaryForDistributionItems.IndexOf(Self) <> -1;
end;

procedure TdxBarItemLink.Synchronize(AItemLink: TdxBarItemLink);
begin
  FUseCount := AItemLink.FUseCount;
  RecentIndex := AItemLink.RecentIndex;
end;

procedure TdxBarItemLink.CheckMostRecentlyUsed;
begin
  if MostRecentlyUsed then
  begin
    FUseCount := BarManager.FMostRecentlyUsedUseCount;
    BringToTopInRecentList(False);
  end
  else
  begin
    FUseCount := 0;
    SendToBottomInRecentList;
  end;
end;

function TdxBarItemLink.GetRecentIndex: Integer;
begin
  Result := Owner.FRecentItems.IndexOf(Self);
end;

procedure TdxBarItemLink.SetRecentIndex(Value: Integer);
begin
  if Owner = nil then
    FPrevRecentIndex := Value
  else
  begin
    Value := Min(Value, Owner.FRecentItems.Count - 1);
    if RecentIndex <> Value then
    begin
      Owner.FRecentItems.Move(Owner.FRecentItems.IndexOf(Self), Value);
      Owner.RefreshVisibilityLists;
    end;
  end;
end;

function TdxBarItemLink.CanVisible: Boolean;
begin
  Result := Item.ActuallyVisible and Visible;
end;

function TdxBarItemLink.GetItem: TdxBarItem;
var
  AOwner: TdxBarItemLinks;
  AOwnerComponent: TComponent;
begin
  if FLoadedItemName <> '' then
  begin
    AOwner := Owner;
    if AOwner <> nil then
    begin
      AOwnerComponent := AOwner.Owner;
      if IsAncestorComponentDifferencesDetection(AOwnerComponent) then
        Exit(BarManager.GetItemByName(FLoadedItemName));
    end;
  end;
  Result := FItem;
end;

function TdxBarItemLink.GetRealItemLink: TdxBarItemLink;
begin
  if FOriginalItemLink <> nil then
    Result := FOriginalItemLink
  else
    Result := Self
end;

procedure TdxBarItemLink.OnUserGlyphChanged(Sender: TObject);
begin
  UserGlyphChanged;
end;

function TdxBarItemLink.GetIAccessibilityHelper: IdxBarAccessibilityHelper;
begin
  if FIAccessibilityHelper = nil then
    FIAccessibilityHelper := GetAccessibilityHelperClass.Create(Self);
  Result := FIAccessibilityHelper;
end;

function TdxBarItemLink.GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass;
begin
  Result := TdxBarItemLinkAccessibilityHelper;
end;

function TdxBarItemLink.GetAdornerTargetElementBounds: TRect;
begin
  Result := Control.ItemBounds;
end;

function TdxBarItemLink.GetAdornerTargetElementControl: TWinControl;
begin
  Result := BarControl;
end;

function TdxBarItemLink.GetAdornerTargetElementVisible: Boolean;
begin
  Result := Visible and not cxRectIsEmpty(FItemRect) and (BarControl <> nil) and
    BarControl.CanControlPaint(Control);
end;

function TdxBarItemLink.GetBeginGroup: Boolean;
var
  AVisibleIndex: Integer;

  function NeedShowHiddenBeginGroup: Boolean;
  begin
    Result := not((Control <> nil) and
      (bboExtendItemWhenAlignedToClient in Control.Parent.BehaviorOptions) and
      (Control.Align in [iaCenter, iaRight]));
  end;

  function HiddenBeginGroupExists: Boolean;
  var
    I: Integer;
  begin
    for I := Owner.VisibleItems[AVisibleIndex - 1].Index + 1 to Index - 1 do
    begin
      Result := Owner[I].BeginGroup;
      if Result then Exit;
    end;
    Result := False;
  end;

begin
  AVisibleIndex := VisibleIndex;
  Result := ((Control = nil) or Control.Parent.AllowSeparators) and
    (FBeginGroup and (AVisibleIndex <> 0) and
    ((AVisibleIndex = -1) or not(Owner.VisibleItems[AVisibleIndex - 1].Item is TdxBarSeparator)) or
      (AVisibleIndex > 0) and NeedShowHiddenBeginGroup and HiddenBeginGroupExists);
end;

procedure TdxBarItemLink.SetBeginGroup(Value: Boolean);
begin
  if FBeginGroup <> Value then
  begin
    FBeginGroup := Value;
    if Control <> nil then
      Control.BeginGroupChanged;
    Changed(False);
  end;
end;

procedure TdxBarItemLink.DefineProperties(Filer: TFiler);

  function NeedWriteItemName: Boolean;
  var
    AAncestorItem: TdxBarItem;
  begin
    if Filer.Ancestor is TdxBarItemLink then
    begin
      AAncestorItem := TdxBarItemLink(Filer.Ancestor).Item;
      Result := (AAncestorItem = nil) and (Item <> nil) or
        (AAncestorItem <> nil) and (Item = nil) or
        (AAncestorItem <> nil) and (AAncestorItem.Name <> Item.Name);
    end
    else
      Result := Item <> nil;
  end;

begin
  inherited DefineProperties(Filer);
  Filer.DefineProperty('ItemName', ReadItemName, WriteItemName, NeedWriteItemName);
end;

procedure TdxBarItemLink.LoadItemName;
begin
  if FLoadedItemName <> '' then
  begin
    Item := BarManager.GetItemByName(FLoadedItemName);
    FLoadedItemName := '';
    if Item = nil then
      Free;
  end;
end;

class function TdxBarItemLink.GetIniSection(const ABaseSection: string;
  ALinkIndex: Integer; AStoringKind: TdxBarStoringKind): string;
begin
  Result := ABaseSection + GetSectionDelimiter(AStoringKind) + 'ItemLink' + IntToStr(ALinkIndex);
end;

procedure TdxBarItemLink.LoadFromIni(ASource: TCustomIniFile;
  const ABaseSection: string; ALinkIndex: Integer; AStoringKind: TdxBarStoringKind);
var
  ASection, S: string;
  AStream: TMemoryStream;
  AViewLevels: TdxBarItemViewLevels;
begin
  ASection := GetIniSection(ABaseSection, ALinkIndex, AStoringKind);
  if ASource.ReadString(ASection, 'ItemName', '') = '' then
    Exit;

  Item := BarManager.GetItemByName(ASource.ReadString(ASection, 'ItemName', ''));
  if Item = nil then
  begin
    Free;
    Exit;
  end;

  AStream := TMemoryStream.Create;
  try
    BeginGroup := ASource.ReadBool(ASection, 'BeginGroup', False);
    if AStoringKind = skIni then
      S := ASource.ReadString(ASection, 'UserDefine', '')
    else
      S := '';

    if Length(S) = 1 then
      FUserDefine := TdxBarUserDefines(Byte(StrToInt(S))) // for compatibility with Bars 5
    else
      if ASource.ReadBinaryStream(ASection, 'UserDefine', AStream) <> 0 then
      begin
        AStream.Read(FUserDefine, SizeOf(TdxBarUserDefines));
        AStream.Position := 0;
      end;

    if udCaption in UserDefine then
      UserCaption := ASource.ReadString(ASection, 'UserCaption', '');
    if udPaintStyle in UserDefine then
      UserPaintStyle := TdxBarPaintStyle(ASource.ReadInteger(ASection, 'UserPaintStyle', 0));
    if udWidth in UserDefine then
      UserWidth := Collection.ScaleFactor.Apply(ASource.ReadInteger(ASection, 'UserWidth', Collection.ScaleFactor.Revert(100)));

    // don't load UserGlyph for IniFile
    if (AStoringKind = skReg) and (udGlyph in UserDefine) then
    begin
      if ASource.ReadBinaryStream(ASection, 'UserGlyph', AStream) <> 0 then
      begin
        UserGlyph.LoadFromStream(AStream);
        AStream.Position := 0;
      end;
    end;

    if Collection.Owner is TdxBar then
    begin
      ButtonGroup := TdxBarButtonGroupPosition(ASource.ReadInteger(ASection, 'ButtonGroup', Integer(bgpNone)));
      Position := TdxBarItemPosition(ASource.ReadInteger(ASection, 'Position', Integer(dxBarItemDefaultPosition)));
      ViewLayout := TdxBarItemViewLayout(ASource.ReadInteger(ASection, 'ViewLayout', Integer(ivlGlyphCaptionControl)));
      if ASource.ReadBinaryStream(ASection, 'ViewLevels', AStream) <> 0 then
      begin
        AStream.Read(AViewLevels, SizeOf(TdxBarItemViewLevels));
        AStream.Position := 0;
        ViewLevels := AViewLevels;
      end;
      FLoadedVisible := ASource.ReadBool(ASection, 'Visible', True);
    end;

    if BarManager.CanShowRecentItems and TdxBarItemLinks(Collection).FUseRecentItems then
    begin
      FLoadedRecentIndex := ASource.ReadInteger(ASection, 'RecentIndex', -1);
      FLoadedUseCount := ASource.ReadInteger(ASection, 'UseCount', 0);
    end;
  finally
    AStream.Free;
  end;
end;

procedure TdxBarItemLink.LoadUsageData(ASource: TCustomIniFile; ABaseSection: string; ALinkIndex: Integer);
begin
  FMostRecentlyUsed := ASource.ReadBool(GetIniSection(ABaseSection, ALinkIndex, skIni), 'MostRecentlyUsed', True);
end;

procedure TdxBarItemLink.SaveToIni(ADestination: TCustomIniFile;
  const ABaseSection: string; ALinkIndex: Integer; AStoringKind: TdxBarStoringKind);
var
  AStream: TMemoryStream;
  ASection: string;
begin
  ASection := GetIniSection(ABaseSection, ALinkIndex, AStoringKind);
  AStream := TMemoryStream.Create;
  try
    ADestination.WriteString(ASection, 'ItemName', Item.Name);
    ADestination.WriteBool(ASection, 'BeginGroup', FBeginGroup); // BeginGroup is complex
    AStream.SetSize(SizeOf(TdxBarUserDefines));
    AStream.Write(FUserDefine, SizeOf(TdxBarUserDefines));
    AStream.Position := 0;
    ADestination.WriteBinaryStream(ASection, 'UserDefine', AStream);

    if udCaption in UserDefine then
      ADestination.WriteString(ASection, 'UserCaption', UserCaption);
    if udPaintStyle in UserDefine then
      ADestination.WriteInteger(ASection, 'UserPaintStyle', Ord(UserPaintStyle));
    if udWidth in UserDefine then
      ADestination.WriteInteger(ASection, 'UserWidth', Collection.ScaleFactor.Revert(UserWidth));

    // don't save UserGlyph to IniFile
    if (AStoringKind = skReg) and (udGlyph in UserDefine) then
    begin
      UserGlyph.SaveToStream(AStream);
      AStream.Position := 0;
      ADestination.WriteBinaryStream(ASection, 'UserGlyph', AStream);
    end;

    if Collection.Owner is TdxBar then
    begin
      ADestination.WriteInteger(ASection, 'ButtonGroup', Ord(ButtonGroup));
      ADestination.WriteInteger(ASection, 'Position', Ord(Position));
      ADestination.WriteInteger(ASection, 'ViewLayout', Ord(ViewLayout));
      AStream.SetSize(SizeOf(TdxBarItemViewLevels));
      AStream.Position := 0;
      AStream.Write(ViewLevels, SizeOf(TdxBarItemViewLevels));
      AStream.Position := 0;
      ADestination.WriteBinaryStream(ASection, 'ViewLevels', AStream);
      ADestination.WriteBool(ASection, 'Visible', Visible);
    end;

    if BarManager.CanShowRecentItems and TdxBarItemLinks(Collection).FUseRecentItems then
    begin
      ADestination.WriteInteger(ASection, 'UseCount', FUseCount);
      ADestination.WriteInteger(ASection, 'RecentIndex', RecentIndex);
    end;

    if BarManager.IsStateSaving then
      ADestination.WriteBool(ASection, 'MostRecentlyUsed', MostRecentlyUsed);
  finally
    AStream.Free;
  end;
end;

procedure TdxBarItemLink.InitiateAction;
begin
  if Item <> nil then
    Item.UpdateActionLink;
end;

function TdxBarItemLink.CanChangePaintStyle: Boolean;
begin
  Result := Item.CanChangePaintStyle;
end;

procedure TdxBarItemLink.ChangeScale(M, D: Integer);
begin
  if udWidth in UserDefine then
    UserWidth := MulDiv(UserWidth, M, D);
end;

function TdxBarItemLink.HasItem(AItem: TdxBarItem): Boolean;
begin
  Result := FItem = AItem;
  if not Result and (FItem is TCustomdxBarSubItem) then
    Result := TCustomdxBarSubItem(FItem).ItemLinks.HasItem(AItem);
end;

function TdxBarItemLink.IsReferencedBy(ALinksOwner: IdxBarLinksOwner): Boolean;
var
  ASelfLinksOwner: IdxBarLinksOwner;
begin
  ASelfLinksOwner := GetLinksOwner(FItem);
  Result := (ASelfLinksOwner <> nil) and
    ((ASelfLinksOwner = ALinksOwner) or
      (ASelfLinksOwner.GetItemLinks <> nil) and (ASelfLinksOwner.GetItemLinks.IsReferencedBy(ALinksOwner)));
end;

function TdxBarItemLink.IsAccel(Key: Word; Shift: TShiftState): Boolean;
var
  AHotKey: string;
  AAccel: Char;
  AKeyScan: Word;
begin
  if not (ssCtrl in Shift) then
  begin
    AHotKey := GetHotkey(Caption);
    if AHotKey = '' then
      Result := False
    else
    begin
      AAccel := AHotKey[1];
      AKeyScan := Lo(VkKeyScan(AAccel));
      if dxCharInSet(AAccel, ['0'..'9']) then
        Result := (Shift = []) and ((AKeyScan = Key) or (AKeyScan + 48 = Key))
      else
        Result := AKeyScan = Key;
    end;
  end
  else
    Result := False;
end;

procedure TdxBarItemLink.MoveBeginGroupItemIfNeeded;
var
  ANextItemLink: TdxBarItemLink;
begin
  if (Item <> nil) and
     (CanVisibleIndex < Owner.CanVisibleItemCount - 1) and
     ((CanVisibleIndex = 0) and Owner.CanVisibleItems[CanVisibleIndex + 1].BeginGroup or
       BeginGroup and not Owner.CanVisibleItems[CanVisibleIndex + 1].BeginGroup) then
  begin
    ANextItemLink := Owner.CanVisibleItems[CanVisibleIndex + 1];
    ANextItemLink.BeginGroup := not ANextItemLink.BeginGroup;
  end;
end;

function TdxBarItemLink.ScreenToClient(const AScreenPos: TPoint): TPoint;
begin
  Result := AScreenPos;
  Windows.ScreenToClient(BarControl.Handle, Result);
  Dec(Result.X, ItemRect.Left);
  Dec(Result.Y, ItemRect.Top);
end;

procedure TdxBarItemLink.UserGlyphChanged;
begin
  if Control <> nil then
    Control.GlyphChanged;
  ForceSetUserDefine(udGlyph);
end;

procedure TdxBarItemLink.VisibleChanged;
begin
  Owner.RefreshVisibilityLists;
  if CanVisible then
  begin
    BringToTopInRecentList(False);
    if BarControl <> nil then
    begin
      CreateControl;
      Control.VisibleChanged;
    end;
  end
  else
  begin
    FUseCount := 0;
    SendToBottomInRecentList;
    if Control <> nil then
    begin
      Control.VisibleChanged;
      DestroyControl;
    end;
  end;
end;

function TdxBarItemLink.CanDelete(ADestruction: Boolean = False): Boolean;
begin
  Result := True;
end;

procedure TdxBarItemLink.DeleteSelection(var AReference: IdxBarSelectableItem; ADestruction: Boolean);
begin
  if CanDelete(ADestruction) then
  begin
    AReference := nil;
    Free;
  end;
end;

procedure TdxBarItemLink.ExecuteCustomizationAction(ABasicAction: TdxBarCustomizationAction);
begin
  case ABasicAction of
    caReset:
      UserDefine := [];
    caChangeCaption:
      Item.Caption := BarDesignController.CustomizingItemLink.Caption;
    caChangeButtonPaintStyle:
      UserPaintStyle := BarDesignController.CustomizingItemLink.UserPaintStyle;
    caChangePosition:
      Position := BarDesignController.CustomizingItemLink.Position;
    caChangeViewLevels:
      ViewLevels := BarDesignController.CustomizingItemLink.ViewLevels;
    caChangeButtonGroup:
      ButtonGroup := BarDesignController.CustomizingItemLink.ButtonGroup;
    caChangeDistributed:
      Distributed := BarDesignController.CustomizingItemLink.Distributed;
    caChangeBeginGroup:
      BeginGroup := BarDesignController.CustomizingItemLink.BeginGroup;
    caChangeVisible:
      Visible := BarDesignController.CustomizingItemLink.Visible;
    caChangeRecentList:
      MostRecentlyUsed := BarDesignController.CustomizingItemLink.MostRecentlyUsed;
  end;
end;

function TdxBarItemLink.GetBarManager: TdxBarManager;
begin
  Result := Owner.BarManager;
end;

function TdxBarItemLink.GetInstance: TPersistent;
begin
  Result := Self;
end;

procedure TdxBarItemLink.GetMasterObjects(AList: TdxObjectList);
begin
  AList.Add(BarControl.GetSelectableObject);
  AList.Add(FItem);
end;

function TdxBarItemLink.GetNextSelectableItem: IdxBarSelectableItem;
begin
  Result := GetNext;
end;

function TdxBarItemLink.GetSelectableParent: TPersistent;
begin
  if BarControl <> nil then
    Result := BarControl.GetSelectableObject
  else
    Result := nil;
end;

function TdxBarItemLink.GetSelectionStatus: TdxBarSelectionStatus;
begin
  Result := BarManager.GetSelectionStatus(Self);
end;

function TdxBarItemLink.GetSupportedActions: TdxBarCustomizationActions;
begin
  Result := Item.GetSupportedActions;
end;

procedure TdxBarItemLink.Invalidate;
begin
  RepaintItemControl(Control);
end;

function TdxBarItemLink.IsComplex: Boolean;
begin
  Result := False;
end;

function TdxBarItemLink.IsComponentSelected: Boolean;
begin
  Result := BarManager.IsComponentSelected(Self) or BarManager.IsComponentSelected(Item);
end;

procedure TdxBarItemLink.SelectComponent(ASelectionOperation: TdxBarSelectionOperation = soExclusive);
begin
  if ASelectionOperation = soExclude then
    BarManager.SelectComponent(Self, ASelectionOperation);
  BarManager.SelectComponent(Item, ASelectionOperation);
end;

function TdxBarItemLink.SelectParentComponent: Boolean;
begin
  Result := True;
  BarManager.InternalSetSelectedItem(nil); // otherwise HideAll will be executed
  BarControl.SetKeySelectedItem(nil);
  BarDesignController.SelectObject(GetSelectableParent);
end;

procedure TdxBarItemLink.SelectionChanged;
begin
  Item.SelectionChanged;
end;

procedure TdxBarItemLink.Assign(Source: TPersistent);

  function IsInheritanceUpdating: Boolean;
  begin
    Result := (csUpdating in BarManager.ComponentState) or
      ((Owner.Owner is TdxBarCustomPopupMenu) or (Owner.Owner is TCustomdxBarSubItem) or (Owner.Owner is TdxBar)) and
      (csUpdating in TComponent(Owner.Owner).ComponentState);
  end;

var
  ALink: TdxBarItemLink;
begin
  if Source is TdxBarItemLink then
  begin
    ALink := TdxBarItemLink(Source);
    Data := ALink.Data;
    FUserCaption := ALink.FUserCaption;
    FUserGlyph.Assign(ALink.FUserGlyph);
    FUserPaintStyle := ALink.FUserPaintStyle;
    FUserWidth := ALink.FUserWidth;
    if ResettingToolbar then
      Item := TdxBarItem(BarManager.Owner.FindComponent(ALink.Item.Name))
    else
    begin
      if Assigned(ALink.Item) and IsInheritanceUpdating then
        Item := BarManager.GetItemByName(ALink.Item.Name)
      else
        Item := ALink.Item;
    end;
    UserDefine := ALink.UserDefine;
    BeginGroup := ALink.BeginGroup;
    ButtonGroup := ALink.ButtonGroup;
    Distributed := ALink.Distributed;
    ImageIndex := ALink.ImageIndex;
    Position := ALink.Position;
    ViewLayout := ALink.ViewLayout;
    ViewLevels := ALink.ViewLevels;
    Visible := ALink.Visible;
    // do not assign MostRecentlyUsed property
    FCreatedFromMergingWith := FMergingWith;
  end
  else inherited Assign(Source);
end;

procedure TdxBarItemLink.BringToTopInRecentList(IncCount: Boolean);
var
  PrevVisibleIndex: Integer;
  AParentItem: TdxBarItem;
begin
  if not CanVisible then Exit;

  PrevVisibleIndex := VisibleIndex;
  InternalBringToTopInRecentList(IncCount);
  if CanVisibleIndex > -1 then
  begin
    if (PrevVisibleIndex = -1) and (BarControl <> nil) then
      BarControl.LayoutChanged;

    AParentItem := nil;
    if BarControl is TdxBarSubMenuControl then
      AParentItem := GetItemByControl(TdxBarSubMenuControl(BarControl).ParentItemControl);

    if AParentItem <> nil then
      with AParentItem do
        if (CurItemLink <> nil) and (CurItemLink.RealItemLink <> nil) then
          CurItemLink.RealItemLink.BringToTopInRecentList(IncCount);
  end;
end;

procedure TdxBarItemLink.CreateControl;
begin
  if (FControl = nil) and (Item <> nil) and
    (BarControl <> nil) and not BarControl.IsDestroying then
      FControl := Item.GetControlClass(BarControl.IsVertical).Create(Self);
end;

procedure TdxBarItemLink.DestroyControl;
begin
  FreeAndNil(FControl);
end;

procedure TdxBarItemLink.RecreateControl;
begin
  if not BarManager.IsUpdateLocked then
  begin
    DestroyControl;
    CreateControl;
  end;
end;

procedure TdxBarItemLink.SendToBottomInRecentList;
var
  PrevVisibleIndex: Integer;
begin
  PrevVisibleIndex := VisibleIndex;
  RecentIndex := Owner.FRecentItems.Count - 1;
  if (PrevVisibleIndex > -1) and (BarControl <> nil) then
    BarControl.LayoutChanged;
end;

{ TdxBarItemLinks }

constructor TdxBarItemLinks.Create(ABarManager: TdxBarManager; ALinksOwner: IdxBarLinksOwner);
begin
  inherited Create(GetItemLinkClass);
  FBarManager := ABarManager;
  FLinksOwner := ALinksOwner;
  FAvailableItems := TList.Create;
  FCanVisibleItems := TList.Create;
  FVisibleItems := TList.Create;
  FRecentItems := TList.Create;
  FRecentItemCount := -1;
  FUseRecentItems := True;
  FScaleFactor := TdxScaleFactor.Create;
  FItemOptions := TdxBarItemOptions.Create(Self);
  FPrimaryForDistributionItems := TList.Create;

  FFreeNotificator := TcxFreeNotificator.Create(nil);
  FFreeNotificator.OnFreeNotification := FreeNotification;
end;

destructor TdxBarItemLinks.Destroy;
begin
  FreeAndNil(FFreeNotificator);

  FreeAndNil(FPrimaryForDistributionItems);
  FreeAndNil(FItemOptions);
  if (FBarControl <> nil) and not (bsDestroying in FBarControl.FState) then
    FreeAndNil(FBarControl);
  FreeAndNil(FRecentItems);
  FreeAndNil(FVisibleItems);
  FreeAndNil(FCanVisibleItems);
  FreeAndNil(FAvailableItems);
  FreeAndNil(FScaleFactor);
  inherited;
end;

procedure TdxBarItemLinks.DesignerModified;
begin
  if Owner is TdxBarCustomPopupMenu then
    TdxBarCustomPopupMenu(Owner).OwnerDesignerModified
  else
    BarManager.DesignerModified;
end;

function TdxBarItemLinks.GetAvailableItem(Index: Integer): TdxBarItemLink;
begin
  Result := TdxBarItemLink(FAvailableItems[Index]);
end;

function TdxBarItemLinks.GetAvailableItemCount: Integer;
begin
  Result := FAvailableItems.Count;
end;

function TdxBarItemLinks.GetCanVisibleItem(Index: Integer): TdxBarItemLink;
begin
  Result := TdxBarItemLink(FCanVisibleItems[Index]);
end;

function TdxBarItemLinks.GetCanVisibleItemCount: Integer;
begin
  Result := FCanVisibleItems.Count;
end;

function TdxBarItemLinks.GetIndexByItemName(const AItemName: string): Integer;
var
  I: Integer;
begin
  Result := -1;
  for I := 0 to Count - 1 do
    if Items[I].Item.Name = AItemName then
    begin
      Result := I;
      Break;
    end;
end;

function TdxBarItemLinks.GetItem(Index: Integer): TdxBarItemLink;
begin
  Result := TdxBarItemLink(inherited Items[Index]);
end;

function TdxBarItemLinks.GetMostRecentItemCount: Integer;
var
  AMinCount, AMaxCount, I, ALevel: Integer;
  AItemLink: TdxBarItemLink;
begin
  if CanUseRecentItems then
  begin
    AMinCount := MaxInt;
    AMaxCount := 0;
    for I := 0 to CanVisibleItemCount - 1 do
    begin
      AMinCount := Min(AMinCount, CanVisibleItems[I].FUseCount);
      AMaxCount := Max(AMaxCount, CanVisibleItems[I].FUseCount);
    end;
    ALevel := AMinCount + MulDiv(AMaxCount - AMinCount, 100 - BarManager.MostRecentItemsPercents, 100);
    Result := 0;
    for I := CanVisibleItemCount - 1 downto 0 do
    begin
      AItemLink := TdxBarItemLink(FRecentItems[I]);
      if (AItemLink.FUseCount >= ALevel) and (AItemLink.Owner = Self) then
      begin
        Result := I + 1;
        Break;
      end;
    end;
    if Result = CanVisibleItemCount then
      Result := -1;
  end
  else
    Result := -1;
end;

function TdxBarItemLinks.GetParentLinks: TdxBarItemLinks;
begin
  if (BarControl <> nil) and (BarControl.ParentBar <> nil) then
    Result := BarControl.ParentBar.ItemLinks
  else
    Result := nil;
end;

function TdxBarItemLinks.GetRealVisibleItemCount: Integer;
var
  R, AItemRect, ResultR: TRect;
  I: Integer;
begin
  Result := VisibleItemCount;
  if not IsScrollable then
  begin
    R := BarControl.ClientRect;
    for I := 0 to Result - 1 do
    begin
      AItemRect := VisibleItems[I].ItemRect;
      IntersectRect(ResultR, R, AItemRect);
      if not EqualRect(AItemRect, ResultR) or IsRectEmpty(AItemRect) then
      begin
        Result := I;
        Break;
      end;
    end;
  end;
end;

function TdxBarItemLinks.GetItemShowDescriptions: Boolean;
begin
  Result := GetOptionsValue(ioShowDescriptions, Self) <> 0;
end;

function TdxBarItemLinks.GetItemShowShortCuts: Boolean;
begin
  Result := GetOptionsValue(ioShowShortCuts, Self) <> 0;
end;

function TdxBarItemLinks.GetItemSize: TdxBarMenuItemSize;
begin
  Result := TdxBarMenuItemSize(GetOptionsValue(ioSize, Self));
end;

function TdxBarItemLinks.GetVisibleItem(Index: Integer): TdxBarItemLink;
begin
  Result := TdxBarItemLink(FVisibleItems[Index]);
end;

function TdxBarItemLinks.GetVisibleItemCount: Integer;
begin
  Result := FVisibleItems.Count;
end;

procedure TdxBarItemLinks.SetImages(AValue: TCustomImageList);
begin
  if FImages <> AValue then
  begin
    cxRemoveFreeNotification(FFreeNotificator, FImages);
    FImages := AValue;
    cxAddFreeNotification(FFreeNotificator, FImages);
    Changed;
  end;
end;

procedure TdxBarItemLinks.SetItem(Index: Integer; Value: TdxBarItemLink);
begin
  Items[Index].Assign(Value);
end;

procedure TdxBarItemLinks.SetItemOptions(AValue: TdxBarItemOptions);
begin
  FItemOptions.Assign(AValue);
end;

procedure TdxBarItemLinks.SetRecentItemCount(Value: Integer);
begin
  if not CanUseRecentItems then
    Value := -1;
  FPrevRecentItemCount := FRecentItemCount;
  if FRecentItemCount <> Value then
  begin
    FRecentItemCount := Value;
    RefreshVisibilityLists;
  end;
end;

function VisibleItemsCompare(Item1, Item2: Pointer): Integer;
begin
  Result := TdxBarItemLink(Item1).CanVisibleIndex - TdxBarItemLink(Item2).CanVisibleIndex;
end;

function TdxBarItemLinks.IsUpdateLocked: Boolean;
begin
  Result := UpdateCount > 0;
end;

procedure TdxBarItemLinks.RefreshVisibilityLists;

  procedure InternalRefreshVisibilityLists;
  var
    AIsDesignTime: Boolean;
    I: Integer;
    AItemLink: TdxBarItemLink;
    AItem: TdxBarItem;
  begin
    if FAvailableItems = nil then
      Exit;
    FAvailableItems.Clear;
    FCanVisibleItems.Clear;
    FVisibleItems.Clear;
    AIsDesignTime := BarManager.Designing;
    for I := 0 to Count - 1 do
    begin
      AItemLink := Items[I];
      AItem := AItemLink.Item;
      if (AItem <> nil) and
        ({Item.AlwaysVisible or }AIsDesignTime or AItem.ActuallyVisible) then
      begin
        FAvailableItems.Add(AItemLink);
        if {Item.AlwaysVisible or }AIsDesignTime or AItemLink.Visible then
        begin
          FCanVisibleItems.Add(AItemLink);
          if {Item.AlwaysVisible or }AIsDesignTime or (RecentItemCount = -1) then
            FVisibleItems.Add(AItemLink);
        end;
      end;
    end;
    if not AIsDesignTime and (RecentItemCount > 0) then
    begin
      for I := 0 to FRecentItems.Count - 1 do
        if CanVisibleIndexOf(FRecentItems[I]) <> -1 then
        begin
          FVisibleItems.Add(FRecentItems[I]);
          if FVisibleItems.Count = RecentItemCount then Break;
        end;
      FVisibleItems.Sort(VisibleItemsCompare);
    end;
  end;

  procedure RefreshSeparatorsVisibility;

    function IsSeparator(ALink: TObject): Boolean;
    begin
      Result := TdxBarItemLink(ALink).Item is TdxBarSeparator;
    end;

    procedure HideSeparator(ALink: TdxBarItemLink);
    begin
      FCanVisibleItems.Remove(ALink);
      FVisibleItems.Remove(ALink);
    end;

  var
    I: Integer;
    APrevIsSeparator, ACurrentIsSeparator: Boolean;
  begin
    APrevIsSeparator := True;
    for I := FVisibleItems.Count - 1 downto 0 do
    begin
      ACurrentIsSeparator := IsSeparator(FVisibleItems[I]);
      if ACurrentIsSeparator and APrevIsSeparator then
        HideSeparator(FVisibleItems[I]);
      APrevIsSeparator := ACurrentIsSeparator;
    end;
  end;

begin
  if BarManager = nil then
    Exit;
  InternalRefreshVisibilityLists;
  if not BarManager.IsCustomizing and not IsUpdateLocked then
    RefreshSeparatorsVisibility;
end;

procedure TdxBarItemLinks.RestoreRecentItemCount;
begin
  FRecentItemCount := FPrevRecentItemCount;
  RefreshVisibilityLists;
end;

procedure TdxBarItemLinks.Loaded(CheckVisible: Boolean);
var
  J, I: Integer;
  AItemLink: TdxBarItemLink;
begin
  for J := Count - 1 downto 0 do
    with Items[J] do
      if Item = nil then
        //Free
      else
        CheckMostRecentlyUsed;
  if CheckVisible then
    for J := Count - 1 downto 0 do
      with Items[J] do
        Visible := FLoadedVisible;
  for I := 0 to Count - 1 do
    for J := 0 to Count - 1 do
    begin
      AItemLink := Items[J];
      if AItemLink.FLoadedRecentIndex = I then
      begin
        AItemLink.FUseCount := AItemLink.FLoadedUseCount;
        AItemLink.RecentIndex := AItemLink.FLoadedRecentIndex;
        AItemLink.FLoadedRecentIndex := -1;
      end;
    end;
  if FBarControl <> nil then
    FBarControl.CreateControls;
end;

procedure TdxBarItemLinks.CheckVisibleIntegrity;
var
  I, J: Integer;
  ItemLink: TdxBarItemLink;
begin
  for I := 0 to FRecentItems.Count - 1 do
  begin
    ItemLink := TdxBarItemLink(FRecentItems[I]);
    if ItemLink.CanVisibleIndex = -1 then Break;
  end;
  for J := I + 1 to FRecentItems.Count - 1 do
  begin
    ItemLink := TdxBarItemLink(FRecentItems[J]);
    if ItemLink.CanVisibleIndex > -1 then
    begin
      ItemLink.RecentIndex := I;
      Inc(I);
    end;
  end;
end;

procedure TdxBarItemLinks.FreeNotification(AComponent: TComponent);
begin
  if AComponent = Images then
    FImages := nil;
end;

procedure TdxBarItemLinks.EmptyItemRects;
var
  I: Integer;
begin
  for I := 0 to Count - 1 do
    SetRectEmpty(Items[I].FItemRect);
end;

procedure TdxBarItemLinks.BeginCalcItemRects;
begin
  Inc(FItemRectsLockCount);
end;

procedure TdxBarItemLinks.EndCalcItemRects;

  procedure CalcItemParts;
  var
    I: Integer;
  begin
    for I := 0 to Count - 1 do
      if Items[I].Control <> nil then
        Items[I].Control.DoCalculateParts;
  end;

begin
  Dec(FItemRectsLockCount);
  if FItemRectsLockCount = 0 then
    CalcItemParts;
end;

function TdxBarItemLinks.CanUseRecentItems: Boolean;
begin
  Result := BarManager.CanShowRecentItems and FUseRecentItems and ((ParentLinks = nil) or (ParentLinks.CanUseRecentItems));
end;

procedure TdxBarItemLinks.InitiateActions;
var
  I: Integer;
begin
  for I := 0 to Count - 1 do Items[I].InitiateAction;
end;

function TdxBarItemLinks.IsShortCut(AShortCut: TShortCut): Boolean;
var
  I: Integer;
begin
  Result := False;
  if AShortCut = 0 then Exit;
  InitiateActions;
  for I := 0 to AvailableItemCount - 1 do
  begin
    Result := AvailableItems[I].Item.IsShortCut(AShortCut);
    if Result then Break;
  end;
end;

function TdxBarItemLinks.IsScrollable: Boolean;
begin
  Result := not (Owner is TdxBar);
end;

function TdxBarItemLinks.DoFindItemWithAccel(AKey: Word; AShift: TShiftState; ACurrentLink: TdxBarItemLink): TdxBarItemLink;
var
  I: Integer;
begin
  Result := nil;
  if CanVisibleItemCount = 0 then
    Exit;

  if ACurrentLink = nil then
    ACurrentLink := CanVisibleItems[0];
  for I := 0 to CanVisibleItemCount - 1 do
  begin
    if ACurrentLink = CanVisibleItems[CanVisibleItemCount - 1] then
      ACurrentLink := CanVisibleItems[0]
    else
      ACurrentLink := CanVisibleItems[ACurrentLink.CanVisibleIndex + 1];
    if ACurrentLink.Item.HasAccel(ACurrentLink) and ACurrentLink.IsAccel(AKey, AShift) then
    begin
      Result := ACurrentLink;
      Break;
    end;
  end;
end;

function TdxBarItemLinks.FindItemWithAccel(AKey: Word; AShift: TShiftState; ACurrentLink: TdxBarItemLink): TdxBarItemLink;
begin
  AShift := AShift - [ssAlt];
  Result := DoFindItemWithAccel(AKey, AShift, ACurrentLink);
end;

function TdxBarItemLinks.First: TdxBarItemLink;
var
  I: Integer;
begin
  for I := 0 to RealVisibleItemCount - 1 do
  begin
    Result := VisibleItems[I];
    if Result.Control.CanSelect then Exit;
  end;
  Result := nil;
end;

function TdxBarItemLinks.Last: TdxBarItemLink;
var
  I: Integer;
begin
  for I := RealVisibleItemCount - 1 downto 0 do
  begin
    Result := VisibleItems[I];
    if Result.Control.CanSelect then Exit;
  end;
  Result := nil;
end;

function TdxBarItemLinks.Next(Current: TdxBarItemLink; AAnyone: Boolean = False): TdxBarItemLink;
var
  CurrentIndex, I, ACount: Integer;
begin
  if Current = nil then
    Result := First
  else
  begin
    CurrentIndex := Current.VisibleIndex;
    I := CurrentIndex;
    ACount := RealVisibleItemCount;
    repeat
      Inc(I);
      if I > ACount - 1 then I := 0;
      Result := VisibleItems[I];
      if AAnyone or Result.Control.CanSelect then Exit;
    until I = CurrentIndex;
    Result := nil;
  end;
end;

function TdxBarItemLinks.Prev(Current: TdxBarItemLink; AAnyone: Boolean = False): TdxBarItemLink;
var
  CurrentIndex, I: Integer;
begin
  if Current = nil then Result := Last
  else
  begin
    CurrentIndex := Current.VisibleIndex;
    I := CurrentIndex;
    repeat
      Dec(I);
      if I = -1 then I := RealVisibleItemCount - 1;
      Result := VisibleItems[I];
      if AAnyone or Result.Control.CanSelect then Exit;
    until I = CurrentIndex;
    Result := nil;
  end;
end;

procedure TdxBarItemLinks.CheckLinks(ASource: TCustomIniFile; const ABaseSection: string);
var
  I: Integer;
begin
  for I := 0 to Count - 1 do
    Items[I].Item.CheckLinks(ASource, ABaseSection);
end;

procedure TdxBarItemLinks.LoadFromIni(ASource: TCustomIniFile; const ASection: string; AStoringKind: TdxBarStoringKind);
var
  ACount: Integer;
  ANewItemLinkCount: Integer;
  I: Integer;
begin
  BeginUpdate;
  try
    ANewItemLinkCount := 0;
    if (BarManager.FNewItems = nil) or (BarManager.FNewItems.Count = 0) then
      Clear
    else
      for I := Count - 1 downto 0 do
        if BarManager.FNewItems.IndexOf(Items[I].Item.Name) < 0 then
          Delete(I)
        else
        begin
          Items[I].FCreatedFromMergingWith := nil;
          Inc(ANewItemLinkCount);
          if I > 0 then
            Items[I].FPrevItemName := Items[I - 1].Item.Name;
        end;
    try
      ACount := ASource.ReadInteger(ASection, 'ItemLinkCount', 0);
      for I := ACount - 1 downto 0 do
        Insert(0).LoadFromIni(ASource, ASection, I, AStoringKind);
      for I := Count - ANewItemLinkCount to Count - 1 do
        if Items[I].FPrevItemName = '' then
          Move(I, 0)
        else
          if GetIndexByItemName(Items[I].FPrevItemName) > -1 then
            Move(I, GetIndexByItemName(Items[I].FPrevItemName) + 1);
      RefreshVisibilityLists;
    finally
      Loaded(True);
    end;
  finally
    EndUpdate;
  end;
end;

procedure TdxBarItemLinks.LoadUsageData(ASource: TCustomIniFile; ASection: string);
var
  ALinkCount, I: Integer;
begin
  // TODO search by unique ID, check merging
  ALinkCount := ASource.ReadInteger(ASection, 'ItemLinkCount', 0);
  for I := 0 to Count - 1 do
    if I < ALinkCount then
      Items[I].LoadUsageData(ASource, ASection, I);
  Loaded(False);
  CheckVisibleIntegrity;
end;

procedure TdxBarItemLinks.SaveToIni(ADestination: TCustomIniFile; const ASection: string; AStoringKind: TdxBarStoringKind);
var
  AItem: TdxBarItemLink;
  I, ACount: Integer;
begin
  ACount := 0;
  for I := 0 to Count - 1 do
  begin
    AItem := Items[I];
    if (AItem.Item <> nil) and (AItem.Item.Name <> '') and (AItem.CreatedFromMergingWith = nil) then
    begin
      AItem.SaveToIni(ADestination, ASection, ACount, AStoringKind);
      Inc(ACount);
    end;
  end;
  ADestination.WriteInteger(ASection, 'ItemLinkCount', ACount);
end;

procedure TdxBarItemLinks.ChangeScale(M, D: Integer);
var
  I: Integer;
begin
  ScaleFactor.Change(M, D);
  for I := 0 to Count - 1 do
    Items[I].ChangeScale(M, D);
end;

procedure TdxBarItemLinks.Merge(AItemLinks: TdxBarItemLinks);

  procedure CheckMergeOperationParameters(AMergingLink: TdxBarItemLink; var AKind: TdxBarItemMergeKind; var ALinkIndex: Integer);
  begin
    if ALinkIndex < 0 then
      AKind := mkNone;
    if (AKind = mkMergeByCaption) and ((ALinkIndex >= Count) or not Items[ALinkIndex].Item.CanMergeWith(AMergingLink.Item)) then
      AKind := mkNone;
    if (AKind = mkAdd) and (ALinkIndex > Count) then
      AKind := mkNone;
    if (AKind <> mkNone) and not CanContainItem(AMergingLink.Item) then
      AKind := mkNone;
  end;

  function CanMergeByCaption(ATargetItemLink, ASourceItemLink: TdxBarItemLink): Boolean;
  begin
    Result := (ATargetItemLink.Item.MergeKind = mkMergeByCaption) and
      (ASourceItemLink.Item.MergeKind = mkMergeByCaption) and
      (ATargetItemLink.Caption = ASourceItemLink.Caption) and // TODO Accel chars
       ATargetItemLink.Item.CanMergeWith(ASourceItemLink.Item);
  end;

  procedure GetMergeOperationParameters(AMergingLink: TdxBarItemLink;
    out AKind: TdxBarItemMergeKind; out ALinkIndex: Integer);
  var
    AItem: TdxBarItem;
    I: Integer;
  begin
    ALinkIndex := -1;
    AKind := AMergingLink.Item.MergeKind;
    if AKind <> mkNone then
    begin
      for I := 0 to Count - 1 do
      begin
        if CanMergeByCaption(Items[I], AMergingLink) then
          ALinkIndex := I;
      end;
      if ALinkIndex <> -1 then
        AKind := mkMergeByCaption
      else
      begin
        for I := 0 to Count - 1 do
        begin
          AItem := Items[I].Item;
          if AItem.MergeOrder <= AMergingLink.Item.MergeOrder then
            if (ALinkIndex = -1) or (AItem.MergeOrder >= Items[ALinkIndex].Item.MergeOrder) then
              ALinkIndex := I;
        end;
        Inc(ALinkIndex);
        AKind := mkAdd;
      end;
    end;
    BarManager.DoMergeItemLink(Self, AItemLinks, AMergingLink, AKind, ALinkIndex);
    CheckMergeOperationParameters(AMergingLink, AKind, ALinkIndex);
  end;

var
  AItemLink: TdxBarItemLink;
  AMergeKind: TdxBarItemMergeKind;
  AMergeLinkIndex, I: Integer;
begin
  for I := 0 to AItemLinks.Count - 1 do
  begin
    GetMergeOperationParameters(AItemLinks[I], AMergeKind, AMergeLinkIndex);
    if AMergeKind = mkMergeByCaption then
      Items[AMergeLinkIndex].Item.GetItemLinks.Merge(AItemLinks[I].Item.GetItemLinks)
    else
      if AMergeKind = mkAdd then
      begin
        AItemLink := Insert(AMergeLinkIndex);
        AItemLink.Assign(AItemLinks[I]);
      end;
  end;
end;

procedure TdxBarItemLinks.Unmerge(ABar: TdxBar);
var
  AItemLink: TdxBarItemLink;
  I: Integer;
begin
  for I := Count - 1 downto 0 do
  begin
    AItemLink := Items[I];
    if (AItemLink.CreatedFromMergingWith <> nil) and ((ABar = nil) or (AItemLink.CreatedFromMergingWith = ABar)) then
      AItemLink.Free
    else
      if AItemLink.Item.GetItemLinks <> nil then
        AItemLink.Item.GetItemLinks.Unmerge(ABar);
  end;
end;

function TdxBarItemLinks.AddItem(AItemClass: TdxBarItemClass; AOwner: TComponent): TdxBarItemLink;
var
  M57B33AA24674E22A5A0DA3EDB50B6D5: TdxBarItem;
begin
  Result := Add;
  if AOwner = nil then
    AOwner := BarManager;
  M57B33AA24674E22A5A0DA3EDB50B6D5 := AItemClass.Create(AOwner);
  try
    Result.Item := M57B33AA24674E22A5A0DA3EDB50B6D5;
  except
    M57B33AA24674E22A5A0DA3EDB50B6D5.Free;
    raise;
  end;
end;

function TdxBarItemLinks.GetItemLinkClass: TdxBarItemLinkClass;
begin
  Result := TdxBarItemLink;
end;

function TdxBarItemLinks.GetOwner: TPersistent;
begin
  Result := GetOwnerComponent;
end;

function TdxBarItemLinks.GetOwnerComponent: TComponent;
begin
  if FLinksOwner <> nil then
    Result := FLinksOwner.GetInstance
  else
    Result := nil;
end;

procedure TdxBarItemLinks.LoadItemNames;
var
  I: Integer;
begin
  BeginUpdate;
  try
    for I := Count - 1 downto 0 do
      Items[I].LoadItemName;
  finally
    EndUpdate;
  end;
  Loaded(True);
end;

procedure TdxBarItemLinks.Update(Item: TCollectionItem);
begin
{ #DG
  if (Owner is TComponent) and not (Owner is TdxBar) and
    (csDestroying in TComponent(Owner).ComponentState) then
    Exit;
}
  if Item = nil then
    RefreshVisibilityLists;
  if csDestroying in Owner.ComponentState then
    Exit;

  inherited Update(Item);
  if not Internal then
    DesignerModified;
  if Item <> nil then
    BarManager.DoItemLinkChange(TdxBarItemLink(Item))
  else
  begin
    if (BarControl <> nil) and BarControl.Enabled then // #DG Enabled - why???
      BarControl.RepaintBar;
    CallNotify(OnChange, Self);
  end;
end;

function TdxBarItemLinks.IsLoading: Boolean;
begin
  Result := FLinksOwner.IsLoading;
end;

function TdxBarItemLinks.GetCurrentImages: TCustomImageList;
begin
  Result := LinksOwner.GetImages;
end;

function TdxBarItemLinks.GetDefaultValue(AOption: TdxBarItemOptionValue): Integer;
begin
  case AOption of
    ioShowDescriptions:
      Result := 0;
    ioShowShortCuts:
      Result := 1;
  else {ioSize}
    Result := Ord(misNormal);
  end;
end;

function TdxBarItemLinks.GetOptionsValue(AOption: TdxBarItemOptionValue; AItemLinks: TdxBarItemLinks): Integer;
var
  AParentLinks: TdxBarItemLinks;
begin
  if not ItemOptions.IsValueStored(AOption) then
  begin
    AParentLinks := GetParentLinks;
    if AParentLinks <> nil then
      Exit(AParentLinks.GetOptionsValue(AOption, AItemLinks));
  end;
  Result := ItemOptions.GetValue(AOption);
end;

function TdxBarItemLinks.Add: TdxBarItemLink;
begin
  Result := TdxBarItemLink(inherited Add);
end;

function TdxBarItemLinks.Add(AItem: TdxBarItem): TdxBarItemLink;
begin
  BeginUpdate;
  try
    Result := Add;
    Result.Item := AItem;
  finally
    EndUpdate;
  end;
end;

function TdxBarItemLinks.AddItem(AItemClass: TdxBarItemClass): TdxBarItemLink;
begin
  Result := Add(BarManager.AddItem(AItemClass));
end;

function TdxBarItemLinks.AddButton: TdxBarItemLink;
begin
  Result := Add(BarManager.AddButton);
end;

function TdxBarItemLinks.AddSubItem: TdxBarItemLink;
begin
  Result := Add(BarManager.AddSubItem);
end;

procedure TdxBarItemLinks.Assign(Source: TPersistent);
var
  ContainsMDISystemMenu: Boolean;
  SystemMenuSubItem: TSystemMenuSubItem;
  I: Integer;
begin
  ContainsMDISystemMenu :=
    (Count <> 0) and (Items[0].Item is TSystemMenuSubItem);
  if ContainsMDISystemMenu then
    SystemMenuSubItem := TSystemMenuSubItem(Items[0].Item)
  else
    SystemMenuSubItem := nil;
  FAssigning := True;
  try
    inherited Assign(Source);
  finally
    FAssigning := False;
    for I := 0 to Count - 1 do
      with Items[I] do
        Visible := FLoadedVisible;
    if ContainsMDISystemMenu then
      with Add do
      begin
        Item := SystemMenuSubItem;
        Index := 0;
      end;
  end;
end;

function TdxBarItemLinks.AvailableIndexOf(Value: TdxBarItemLink): Integer;
begin
  Result := FAvailableItems.IndexOf(Value);
end;

function TdxBarItemLinks.CanContainItem(AItem: TdxBarItem): Boolean;
var
  AErrorText: string;
begin
  Result := CanContainItem(AItem, AErrorText);
end;

function TdxBarItemLinks.CanContainItem(AItem: TdxBarItem; out AErrorText: string): Boolean;
begin
  Result := FLinksOwner.CanContainItem(AItem, AErrorText);
end;

function TdxBarItemLinks.CanVisibleIndexOf(Value: TdxBarItemLink): Integer;
begin
  Result := FCanVisibleItems.IndexOf(Value);
end;

procedure TdxBarItemLinks.CreateBarControl;
begin
  FBarControl := FLinksOwner.CreateBarControl;
  FBarControl.ItemLinks := Self;
end;

procedure TdxBarItemLinks.DestroyBarControl;
begin
  FreeAndNil(FBarControl);
end;

function TdxBarItemLinks.FindByItem(AItem: TdxBarItem): TdxBarItemLink;
var
  I: Integer;
begin
  Result := nil;
  if HasItem(AItem) then
    for I := 0 to Count - 1 do
      if Items[I].Item = AItem then
      begin
        Result := Items[I];
        Break;
      end;
end;

procedure TdxBarItemLinks.FreeForeignItems(ForeignBarManager: TdxBarManager);
var
  I: Integer;
begin
  if Owner is TdxBar then
    TdxBar(Owner).BarManager.BeginUpdate;
  for I := 0 to Count - 1 do
    if (ForeignBarManager <> nil) and (Items[I].BarManager = ForeignBarManager) or
      (ForeignBarManager = nil) and (Items[I].BarManager <> BarManager) then
      begin
        Items[I].Free;
        Items[I] := nil;
      end;
  if Owner is TdxBar then
    TdxBar(Owner).BarManager.EndUpdate;
end;

function TdxBarItemLinks.HasItem(AItem: TdxBarItem): Boolean;
var
  I: Integer;
begin
  Result := False;
  for I := 0 to Count - 1 do
    if Items[I].HasItem(AItem) then
    begin
      Result := True;
      Break;
    end;
end;

function TdxBarItemLinks.IsControlExists(AItem: TdxBarItemControl): Boolean;
var
  I: Integer;
begin
  Result := False;
  for I := 0 to Count - 1 do
    if Items[I].Control = AItem then
    begin
      Result := True;
      Break;
    end;
end;

function TdxBarItemLinks.IsReferencedBy(ALinksOwner: IdxBarLinksOwner): Boolean;
var
  I: Integer;
begin
  Result := Self = ALinksOwner.GetItemLinks;
  if not Result then
    for I := 0 to Count - 1 do
      if Items[I].IsReferencedBy(ALinksOwner) then
      begin
        Result := True;
        Break;
      end;
end;

function TdxBarItemLinks.IndexOf(Value: TdxBarItemLink): Integer;
begin
  if (Value <> nil) and (Value.Collection = Self) then
    Result := Value.Index
  else
    Result := -1;
end;

function TdxBarItemLinks.Insert(AIndex: Integer): TdxBarItemLink;
begin
  Result := TdxBarItemLink(inherited Insert(AIndex));
end;

procedure TdxBarItemLinks.Move(ACurIndex, ANewIndex: Integer);
begin
  BeginUpdate;
  try
    if (ACurIndex < Count) and (ACurIndex > -1) and
       (ANewIndex < Count) and (ANewIndex > -1) and
       (ACurIndex <> ANewIndex) then
      Items[ACurIndex].SetIndex(ANewIndex);
  finally
    EndUpdate;
  end;
  if BarControl <> nil then BarControl.RepaintBar;
end;

function TdxBarItemLinks.VisibleIndexOf(Value: TdxBarItemLink): Integer;
begin
  Result := FVisibleItems.IndexOf(Value);
end;

{ TdxBarControlItemLinks }

function TdxBarControlItemLinks.DoFindItemWithAccel(AKey: Word; AShift: TShiftState; ACurrentLink: TdxBarItemLink): TdxBarItemLink;
var
  I: Integer;
begin
  Result := nil;
  if IsControlVisible(BarControl) then
  begin
    for I := 0 to FVisibleItems.Count - 1 do
    begin
      ACurrentLink := Next(ACurrentLink);
      if (ACurrentLink = nil) or ACurrentLink.Item.HasAccel(ACurrentLink) and ACurrentLink.IsAccel(AKey, AShift) and ACurrentLink.Control.CanSelect then
      begin
        Result := ACurrentLink;
        Break;
      end;
    end;
  end;
end;

{ TdxBarSubMenuControlItemLinks }

function TdxBarSubMenuControlItemLinks.IsScrollable: Boolean;
begin
  Result := True;
end;

{ TdxBarInternalLinksOwner }

constructor TdxBarInternalLinksOwner.Create(ABarManager: TdxBarManager; ABarControlClass: TCustomdxBarControlClass);
begin
  inherited Create(nil);
  FBarManager := ABarManager;
  FBarControlClass := ABarControlClass;
  FItemLinks := TdxBarInternalItemLinks.Create(ABarManager, Self);
end;

destructor TdxBarInternalLinksOwner.Destroy;
begin
  FreeAndNil(FItemLinks);
  inherited;
end;

function TdxBarInternalLinksOwner.GetBarControl: TCustomdxBarControl;
begin
  Result := ItemLinks.BarControl;
end;

function TdxBarInternalLinksOwner.CanContainItem(AItem: TdxBarItem; out AErrorText: string): Boolean;
begin
  Result := True;
end;

function TdxBarInternalLinksOwner.CreateBarControl: TCustomdxBarControl;
begin
  Result := FBarControlClass.Create(FBarManager);
end;

function TdxBarInternalLinksOwner.GetBarManager: TdxBarManager;
begin
  Result := FBarManager;
end;

function TdxBarInternalLinksOwner.GetInstance;
begin
  Result := Self;
end;

function TdxBarInternalLinksOwner.GetItemLinks: TdxBarItemLinks;
begin
  Result := FItemLinks;
end;

function TdxBarInternalLinksOwner.GetImages: TCustomImageList;
begin
  Result := nil;
end;

function TdxBarInternalLinksOwner.IsLoading: Boolean;
begin
  Result := FBarManager.IsLoading;
end;

{ TdxBarInternalItemLinks }

constructor TdxBarInternalItemLinks.Create(ABarManager: TdxBarManager; ALinksOwner: IdxBarLinksOwner);
begin
  inherited;
  FInternal := True;
end;


{ TdxBarCustomPopupComponent }

constructor TdxBarCustomPopupComponent.Create(AOwner: TComponent);
begin
  inherited;
  if dxBarManagerList.Count = 0 then
    raise EdxException.Create(cxGetResourceString(@dxSBAR_NOBARMANAGERS));
  BarManager := GetBarManagerByComponent(AOwner);
  if FBarManager = nil then
    BarManager := TdxBarManager(dxBarManagerList[0]);

  FScaleFactor := TdxScaleFactor.Create;
  FItemLinks := GetItemLinksClass.Create(FBarManager, Self);
end;

destructor TdxBarCustomPopupComponent.Destroy;
begin
  FreeAndNil(FItemLinks);
  FreeAndNil(FScaleFactor);
  inherited;
end;

procedure TdxBarCustomPopupComponent.DefineProperties(Filer: TFiler);
begin
  inherited;
  Filer.DefineProperty('PixelsPerInch', ReadPixelsPerInch, WritePixelsPerInch, True);
end;

procedure TdxBarCustomPopupComponent.Loaded;
begin
  inherited Loaded;
  BarDesignController.LockDesignerModified;
  try
    FItemLinks.LoadItemNames;
  finally
    BarDesignController.UnLockDesignerModified;
  end;
  ScaleForPPI(dxGetCurrentDPI(Owner));
end;

procedure TdxBarCustomPopupComponent.Notification(AComponent: TComponent; Operation: TOperation);
begin
  inherited;
  if (AComponent = FBarManager) and (Operation = opRemove) then
  begin
    BarDesignController.LockDesignerModified;
    try
      FItemLinks.Clear;
      BarManager := nil;
    finally
      BarDesignController.UnLockDesignerModified;
    end;
  end;
end;

function TdxBarCustomPopupComponent.GetControlClass: TCustomdxBarControlClass;
begin
  Result := TdxBarSubMenuControl;
end;

function TdxBarCustomPopupComponent.GetItemLinksClass: TdxBarItemLinksClass;
begin
  Result := TdxBarSubMenuControlItemLinks;
end;

procedure TdxBarCustomPopupComponent.ChangeScale(M, D: Integer);
begin
  if M <> D then
    ChangeScaleCore(M, D);
end;

procedure TdxBarCustomPopupComponent.ChangeScaleCore(M, D: Integer);
begin
  ScaleFactor.Change(M, D);
  ItemLinks.ChangeScale(M, D);
end;

procedure TdxBarCustomPopupComponent.ScaleForPPI(TargetPPI: Integer);
begin
  if (BarManager = nil) or BarManager.Scaled then
    ChangeScale(TargetPPI, ScaleFactor.Apply(dxDefaultDPI));
end;

function TdxBarCustomPopupComponent.GetScaleFactor: TdxScaleFactor;
begin
  Result := FScaleFactor;
end;

// IdxBarLinksOwner
function TdxBarCustomPopupComponent.CanContainItem(AItem: TdxBarItem; out AErrorText: string): Boolean;
begin
  Result := AItem.CanBePlacedOn(pkSubItemOrPopupMenu, nil, AErrorText);
  if Result then
  begin
    Result := (GetOwnedLinks(AItem) = nil) or not GetOwnedLinks(AItem).IsReferencedBy(Self);
    if not Result then
      AErrorText := cxGetResourceString(@dxSBAR_RECURSIVEMENUS);
  end;
end;

function TdxBarCustomPopupComponent.CreateBarControl: TCustomdxBarControl;
begin
  Result := GetControlClass.Create(BarManager);
end;

function TdxBarCustomPopupComponent.GetItemLinks: TdxBarItemLinks;
begin
  Result := FItemLinks;
end;

function TdxBarCustomPopupComponent.GetImages: TCustomImageList;
begin
  Result := ItemLinks.Images;
end;

function TdxBarCustomPopupComponent.IsLoading: Boolean;
begin
  Result := csLoading in ComponentState;
end;

procedure TdxBarCustomPopupComponent.SetImages(AImages: TCustomImageList);
begin
  ItemLinks.Images := AImages;
end;

procedure TdxBarCustomPopupComponent.SetItemLinks(Value: TdxBarItemLinks);
begin
  FItemLinks.Assign(Value);
end;

procedure TdxBarCustomPopupComponent.ReadPixelsPerInch(Reader: TReader);
begin
  ScaleFactor.Assign(Reader.ReadInteger, dxDefaultDPI);
end;

procedure TdxBarCustomPopupComponent.WritePixelsPerInch(Writer: TWriter);
begin
  Writer.WriteInteger(ScaleFactor.Apply(dxDefaultDPI));
end;

{ TdxBarCustomPopupMenuComponent }

constructor TdxBarCustomPopupMenuComponent.Create(AOwner: TComponent);
begin
  inherited;
  FFont := TFont.Create;
  FFont.Assign(BarManager.Font);
  FFont.OnChange := FontChanged;
end;

destructor TdxBarCustomPopupMenuComponent.Destroy;
begin
  FreeAndNil(FFont);
  inherited;
end;

function TdxBarCustomPopupMenuComponent.IsShortCut(AShortCut: TShortCut): Boolean;
begin
  Result := False;
end;

function TdxBarCustomPopupMenuComponent.IsShortCutKey(var Message: TWMKey): Boolean;
var
  AShortCut: TShortCut;
begin
  AShortCut := GetShortCutFromMessageData(TMessage(Message).WParam, TMessage(Message).LParam);
  Result := (AShortCut <> 0) and ItemLinks.IsShortCut(AShortCut);
end;

procedure TdxBarCustomPopupMenuComponent.PopupFromCursorPos;
begin
  with GetMouseCursorPos do
    Popup(X, Y);
end;

procedure TdxBarCustomPopupMenuComponent.FontChanged(Sender: TObject);
begin
  if not FInternalFontChange then
    FUseOwnFont := True;
end;

procedure TdxBarCustomPopupMenuComponent.InternalUpdateFont;
begin
  FInternalFontChange := True;
  try
    if FUseOwnFont then
      FontChanged(nil)
    else
      Font := BarManager.Font;
  finally
    FInternalFontChange := False;
  end;
end;

procedure TdxBarCustomPopupMenuComponent.SetBarManager(Value: TdxBarManager);
begin
  if FBarManager <> Value then
  begin
    if FBarManager <> nil then
    begin
      FBarManager.FPopupMenus.Remove(Self);
      cxRemoveFreeNotification(Self, FBarManager);
    end;
    inherited;
    if FBarManager <> nil then
    begin
      FBarManager.FPopupMenus.Add(Self);
      cxAddFreeNotification(Self, FBarManager);
    end;
  end;
end;

procedure TdxBarCustomPopupMenuComponent.ChangeScaleCore(M, D: Integer);
begin
  inherited ChangeScaleCore(M, D);
  if UseOwnFont or not ScaleFactor.Equals(BarManager.ScaleFactor) then
    Font.Height := MulDiv(Font.Height, M, D);
end;

procedure TdxBarCustomPopupMenuComponent.SetFont(Value: TFont);
begin
  Font.Assign(Value);
end;

procedure TdxBarCustomPopupMenuComponent.SetUseOwnFont(Value: Boolean);
begin
  if FUseOwnFont <> Value then
  begin
    FUseOwnFont := Value;
    InternalUpdateFont;
  end;
end;

{ TdxBarPopupMenu }

constructor TdxBarCustomPopupMenu.Create(AOwner: TComponent);
begin
  inherited;
  FBackgroundBitmap :=  cxCreateBitmap(0, 0);
  FEditFont := TFont.Create;
  UseRecentItems := False;
  FShowAnimation := True;
  FUseOwnMessageLoop := True;
end;

destructor TdxBarCustomPopupMenu.Destroy;
begin
  FreeAndNil(FEditFont);
  FreeAndNil(FBackgroundBitmap);
  inherited Destroy;
end;

function TdxBarCustomPopupMenu.GetItemOptions: TdxBarItemOptions;
begin
  Result := ItemLinks.ItemOptions;
end;

function TdxBarCustomPopupMenu.GetSubMenuControl: TdxBarSubMenuControl;
begin
  Result := TdxBarSubMenuControl(ItemLinks.BarControl);
end;

function TdxBarCustomPopupMenu.GetUseRecentItems: Boolean;
begin
  Result := ItemLinks.FUseRecentItems;
end;

procedure TdxBarCustomPopupMenu.SetBackgroundBitmap(Value: TBitmap);
begin
  FBackgroundBitmap.Assign(Value);
end;

procedure TdxBarCustomPopupMenu.DoShow;
begin
  CallNotify(OnShow, Self);
end;

procedure TdxBarCustomPopupMenu.FontChanged(Sender: TObject);
begin
  inherited;
  if UseOwnFont then
    CreateEditFontHandle(Font, FEditFont, False, ScaleFactor);
end;

procedure TdxBarCustomPopupMenu.SetBarSize(Value: Integer);
begin
  FBarSize := Max(Value, 0);
end;

procedure TdxBarCustomPopupMenu.SetItemOptions(Value: TdxBarItemOptions);
begin
  ItemLinks.ItemOptions := Value;
end;

procedure TdxBarCustomPopupMenu.SetUseRecentItems(Value: Boolean);
begin
  ItemLinks.FUseRecentItems := Value;
end;

procedure TdxBarCustomPopupMenu.SubMenuCloseUp(Sender: TObject; AReason: TdxBarCloseUpReason);
begin
  FPopupMenuVisible := False;
  DoCloseUp;
  if Assigned(OnCloseUpEx) then
    OnCloseUpEx(Self, AReason);
end;

procedure TdxBarCustomPopupMenu.SubMenuPopup(Sender: TObject);
begin
  FPopupMenuVisible := True;
  DoPopup;
end;

procedure TdxBarCustomPopupMenu.SubMenuShow(Sender: TObject);
begin
  DoShow;
end;

procedure TdxBarCustomPopupMenu.OwnerDesignerModified;
begin
  if [csDesigning, csLoading, csDestroying, csUpdating] * ComponentState = [csDesigning] then
    BarDesignController.DesignerModified(GetComponentForm(Self));
end;

function TdxBarCustomPopupMenu.GetEnabled: Boolean;
begin
  Result := True;
end;

procedure TdxBarCustomPopupMenu.DoCloseUp;
begin
  CallNotify(OnCloseUp, Self);
end;

procedure TdxBarCustomPopupMenu.DoPopup;
begin
  CallNotify(OnPopup, Self);
end;

procedure TdxBarCustomPopupMenu.InternalPopup(X, Y: Integer; const AOwnerBounds: TRect; APopupAlignment: TPopupAlignment);
var
  APrevPopupAlignment: TPopupAlignment;
  R: TRect;
begin
  APrevPopupAlignment := PopupAlignment;
  try
    PopupAlignment := APopupAlignment;
    R := AOwnerBounds;
    PopupEx(X, Y, 0, cxRectHeight(AOwnerBounds), True, @R);
  finally
    PopupAlignment := APrevPopupAlignment;
  end;
end;

// IdxBarSubMenuOwner
function TdxBarCustomPopupMenu.GetBarSize: Integer;
begin
  Result := FBarSize;
end;

procedure TdxBarCustomPopupMenu.DoPaintBar(Canvas: TCanvas; const R: TRect);
begin
  if Assigned(FOnPaintBar) then FOnPaintBar(Self, Canvas, R);
end;

procedure TdxBarCustomPopupMenu.Popup(X, Y: Integer);

  function PrepareSubMenuControl: TdxBarSubMenuControl;
  begin
    ItemLinks.CreateBarControl;
    Result := ItemLinks.BarControl as TdxBarSubMenuControl;
    Result.Left := X;
    Result.Top := Y;

    if FOwnerItemControl <> nil then
      FOwnerItemControl.Parent.ChildBar := Result.FItemLinks.BarControl;
    if Owner is TWinControl then
      Result.FParentWnd := TWinControl(Owner).Handle;

    if FOwnerBounds <> nil then
      Result.OwnerBounds := FOwnerBounds^;
    Result.OwnerWidth := FOwnerWidth;
    Result.OwnerHeight := FOwnerHeight;
    Result.FShowAnimation := FShowAnimation;
    Result.FOwnerControl := FOwnerControl;
    Result.FMinWidth := FMinWidth;
    Result.FPopupAlignment := PopupAlignment;

    Result.OnPopup := SubMenuPopup;
    Result.OnCloseUp := SubMenuCloseUp;
    Result.OnShow := SubMenuShow;
  end;

  function GetTargetDPI(const P: TPoint): Integer;
  var
    AScaleFactor: TdxScaleFactor;
  begin
    if dxTryGetScaleFactorForControl(FOwnerControl, AScaleFactor) then
      Exit(AScaleFactor.TargetDPI);
    if FOwnerItemControl = nil then
    begin
      if dxTryGetScaleFactorForControl(FindControl(WindowFromPoint(P)), AScaleFactor) then
        Exit(AScaleFactor.TargetDPI);
    end;
    Result := dxGetMonitorDPI(P);
  end;

  procedure MessageLoop;
  var
    AMessage: TMsg;
  begin
    repeat
      case Integer(GetMessage(AMessage, 0, 0, 0)) of
        -1: Break;
        0: begin
            PostQuitMessage(AMessage.wParam);
            Break;
          end;
      end;
      if not FPopupMenuVisible then
        PostMessage(AMessage.hwnd, AMessage.message, AMessage.wParam, AMessage.lParam)
      else
        if AMessage.message <> WM_COMMAND then
        begin
          TranslateMessage(AMessage);
          DispatchMessage(AMessage);
        end;
    until not FPopupMenuVisible;
  end;

  procedure ShowSubMenuControl(ASubMenuControl: TdxBarSubMenuControl);
  begin
    try
      ASubMenuControl.Show;
    except
      ASubMenuControl.HideAll;
      raise;
    end;
  end;

var
  ACurrentDPI: Integer;
  AIsMessageForMeaningParent: Boolean;
  ASavedUseOwnFont: Boolean;
begin
  if ItemLinks.BarControl <> nil then
    Exit;

  dxBar.SendCancelMode;
  if not BarManager.IsCustomizing and (GetCapture <> 0) then
  begin
    SendMessage(GetCapture, CM_CANCELMODE, 0, 0);
    ReleaseCapture;
  end;

  if (FOwnerControl = nil) and (ActiveBarControl <> nil) then
  begin
    if not ProcessMessage(GetFocus, AIsMessageForMeaningParent) then
      ActiveBarControl.HideAll;
  end;

  ASavedUseOwnFont := UseOwnFont;
  try
    ACurrentDPI := ScaleFactor.TargetDPI;
    ScaleForPPI(GetTargetDPI(Point(X, Y)));
    try
      ShowSubMenuControl(PrepareSubMenuControl);
      if FUseOwnMessageLoop then
        MessageLoop;
    finally
      ScaleForPPI(ACurrentDPI);
    end;
  finally
    UseOwnFont := ASavedUseOwnFont;
  end;
end;

procedure TdxBarCustomPopupMenu.PopupEx(X, Y, AOwnerWidth, AOwnerHeight: Integer;
  AShowAnimation: Boolean; AOwnerBounds: PRect; AUseOwnMessageLoop: Boolean = True;
  AOwnerControl: TWinControl = nil);
begin
  FOwnerWidth := AOwnerWidth;
  FOwnerHeight := AOwnerHeight;
  FShowAnimation := AShowAnimation;
  FOwnerBounds := AOwnerBounds;
  FOwnerControl := AOwnerControl;
  FUseOwnMessageLoop := AUseOwnMessageLoop;
  Popup(X, Y);
  FUseOwnMessageLoop := True;
  FOwnerControl := nil;
  FOwnerWidth := 0;
  FOwnerHeight := 0;
  FShowAnimation := True;
end;

{ TdxBarShadowPart }

constructor TdxBarShadowPart.CreateEx(AOwner: TdxBarShadow);
begin
  FOwner := AOwner;
  Create(FOwner.Owner);
end;

procedure TdxBarShadowPart.UpdateBounds(const ABounds: TRect);
begin
  BoundsRect := ABounds;
  if FOwner.Visible then
    Show;
end;

{ TdxBarShadow }

constructor TdxBarShadow.Create(AOwner: TWinControl);
begin
  inherited Create;
  FOwner := AOwner;
end;

procedure TdxBarShadow.CreateParts;

  function CreateRegionFromBitmap(ABarControl: TdxBarControl; const ARect: TRect): TcxRegion;
  var
    ABitmap: TcxBitmap32;
    ABitmap1: TcxBitmap32;
    AMarkDrawState: TdxBarMarkState;
  begin
    ABitmap := TcxBitmap32.CreateSize(cxRectWidth(ARect), cxRectHeight(ARect));
    ABitmap1 := TcxBitmap32.CreateSize(cxRectWidth(ARect), cxRectHeight(ARect));
    try
      ABitmap.Clear;
      ABitmap1.Clear;
      AMarkDrawState := ABarControl.MarkState;
      ABarControl.FMarkState := msSelected;
      try
        ABarControl.Painter.BarDrawMarkBackground(ABarControl,
          ABitmap.Canvas.Handle, ARect, ABarControl.ToolbarBrush);
      finally
        ABarControl.FMarkState := AMarkDrawState;
      end;
      ABarControl.FillBackground(ABitmap1.Canvas.Handle, ARect, ABarControl.ToolbarBrush, clNone, True);
      cxBitBlt(ABitmap.Canvas.Handle, ABitmap1.Canvas.Handle, ARect, Point(0, 0), SRCINVERT);
      Result := TcxRegion.Create(cxCreateRegionFromBitmap(ABitmap, clBlack));
    finally
      FreeAndNil(ABitmap);
      FreeAndNil(ABitmap1);
    end;
  end;

  procedure CombineShadowsEdge(var AOffset: Integer; var ARegion, ACutRegion: TcxRegion);
  begin
    ACutRegion.Offset(ShadowSize, 0);
    AOffset := AOffset + ShadowSize;
    ARegion.Combine(ACutRegion, roSubtract, False);
  end;

  function IsNeedCombineShadows(const ARect1, ARect2: TRect): Boolean;
  begin
    Result := Horizontal and (ARect1.Right >= ARect2.Right) and (ARect1.Left <= ARect2.Right) or
      not Horizontal and (ARect1.Bottom >= ARect2.Bottom) and (ARect1.Top <= ARect2.Bottom);
  end;

  procedure CombineShadows(var ARect1, ARect2: TRect;
    var ARegion1, ARegion2, AWindowRegion2: TcxRegion);
  var
    ATempRegion: TcxRegion;
    AOffset: TPoint;
  begin
    if IsNeedCombineShadows(ARect1, ARect2) then
    begin
      ATempRegion := TcxRegion.Create(cxNullRect);
      try
        ATempRegion.Combine(ARegion2, roSet, False);
        AOffset := cxPointOffset(ARect2.TopLeft, -(ARect1.Left + ShadowSize),
          -(ARect1.Top + ShadowSize));
        ATempRegion.Offset(AOffset);
        ARegion1.Combine(ATempRegion, roSubtract, False);
        if Horizontal then
        begin
          if ARect1.Right = ARect2.Right then
            CombineShadowsEdge(AOffset.X, ARegion1, ATempRegion);

          ARegion2.Offset(0, 2 * ShadowSize);
          ARect2.Top := ARect2.Top - 2 * ShadowSize;
          AOffset.Y := AOffset.Y - ShadowSize;
        end
        else
        begin
          if ARect1.Bottom = ARect2.Bottom then
            CombineShadowsEdge(AOffset.Y, ARegion1, ATempRegion);

          ARegion2.Offset(2 * ShadowSize, 0);
          ARect2.Left := ARect2.Left - 2 * ShadowSize;
          AOffset.X := AOffset.X - ShadowSize;
        end;
        ATempRegion.Offset(cxPointInvert(AOffset));
        AWindowRegion2.Combine(ARegion2, roSet, False);
        ARegion2.Combine(ATempRegion, roAdd, False);
      finally
        FreeAndNil(ATempRegion);
      end;
    end;
  end;

  procedure CalculateShadows(var ARect1, ARect2: TRect;
    var ARegion1, ARegion2, AWindowRegion1, AWindowRegion2: TcxRegion);
  begin
    if (ARect1.Bottom = ARect2.Top) or (ARect1.Right = ARect2.Left)  then
      CombineShadows(ARect1, ARect2, ARegion1, ARegion2, AWindowRegion2)
    else
      if (ARect2.Bottom = ARect1.Top) or (ARect2.Right = ARect1.Left)  then
        CombineShadows(ARect2, ARect1, ARegion2, ARegion1, AWindowRegion1);
  end;

  procedure CreateShadowPart(AIndex: Integer;
    const ARect: TRect; AShadowRegion, AWindowRegion: TcxRegion);
  begin
    AWindowRegion.Offset(-ShadowSize, - ShadowSize);
    AShadowRegion.Combine(AWindowRegion, roSubtract, False);
    FShadowPart[AIndex] := TdxBarShadowPart.CreateEx(Self);
    FShadowPart[AIndex].Transparent := Transparent;
    SetWindowRgn(FShadowPart[AIndex].Handle, AShadowRegion.Handle, False);
    FShadowPart[AIndex].UpdateBounds(cxRectOffset(ARect, ShadowSize, ShadowSize));
  end;

  procedure GenerateAdditionalShadowPart(var ABarRect: TRect; AParentBar:
    TdxBarControl; ABasicShadowRegion, ABasicWindowRegion: TcxRegion);
  var
    AAdditionalShadowRegion, AWindowRegion: TcxRegion;
    AParentBarRect: TRect;
  begin
    AParentBarRect := FParentBarBounds;
    AAdditionalShadowRegion := TcxRegion.Create;
    if AParentBar.MarkState = msPressed then
      AWindowRegion := CreateRegionFromBitmap(AParentBar, cxRectSetNullOrigin(AParentBarRect))
    else
      AWindowRegion := TcxRegion.Create(CreateRectRgnIndirect(cxRectSetNullOrigin(AParentBarRect)));

    AAdditionalShadowRegion.Combine(AWindowRegion, roSet, False);
    try
      CalculateShadows(ABarRect, AParentBarRect, ABasicShadowRegion, AAdditionalShadowRegion,
        ABasicWindowRegion, AWindowRegion);
      CreateShadowPart(1, AParentBarRect, AAdditionalShadowRegion, AWindowRegion);
    finally
      FreeAndNil(AWindowRegion);
      FreeAndNil(AAdditionalShadowRegion);
    end;
  end;

var
  AShadowRegion: TcxRegion;
  AWindowRegion: TcxRegion;
  ABarRect: TRect;
begin
  ABarRect := FBarBounds;
  AShadowRegion := TcxRegion.Create;
  AWindowRegion := TcxRegion.CreateFromWindow(Owner.Handle);
  AShadowRegion.Combine(AWindowRegion, roSet, False);
  try
    if not cxRectIsEmpty(FParentBarBounds) and (Owner is TCustomdxBarControl) and
      (TCustomdxBarControl(Owner).ParentBar is TdxBarControl) then
        GenerateAdditionalShadowPart(ABarRect, TdxBarControl(TCustomdxBarControl(Owner).ParentBar),
          AShadowRegion, AWindowRegion);

    CreateShadowPart(0, ABarRect, AShadowRegion, AWindowRegion);
  finally
    FreeAndNil(AWindowRegion);
    FreeAndNil(AShadowRegion);
  end;
end;

destructor TdxBarShadow.Destroy;
begin
  DestroyParts;
  inherited Destroy;
end;

procedure TdxBarShadow.DestroyParts;
begin
  FreeAndNil(FShadowPart[0]);
  FreeAndNil(FShadowPart[1]);
end;

function TdxBarShadow.GetShadowSize: Integer;
begin
  if Transparent then
    Result := dxBarTransparentShadowSize
  else
    Result := dxBarOpaqueShadowSize;
end;

function TdxBarShadow.GetTransparent: Boolean;
begin
  Result := dxCanUseTransparentShadows;
end;

procedure TdxBarShadow.SetVisible(Value: Boolean);
begin
  if FVisible <> Value then
  begin
    FVisible := Value;
    if FVisible then
      Show
    else
      Hide;
  end;
end;

procedure TdxBarShadow.Hide;
begin
  FShadowPart[0].Hide;
  if FShadowPart[1] <> nil then
    FShadowPart[1].Hide;
end;

procedure TdxBarShadow.Show;
begin
  Refresh;
end;

procedure TdxBarShadow.Refresh;
begin
  DestroyParts;
  CreateParts;
end;

procedure TdxBarShadow.SetOwnerBounds(const AR1, AR2: TRect);

  procedure SetRects;
  begin
    FBarBounds := AR2;
    FParentBarBounds := AR1;
  end;

var
  ANeedRefresh: Boolean;
begin
  FHorizontal := IsRectEmpty(AR1) or (AR1.Bottom = AR2.Top) or (AR1.Top = AR2.Bottom);
  ANeedRefresh := not cxRectIsNull(FParentBarBounds) or not cxSizeIsEqual(cxRectSize(FBarBounds), cxRectSize(AR2));
  SetRects;
  if Visible then
  begin
    if ANeedRefresh then
      Refresh
    else
      if (FShadowPart[0] <> nil) then
        FShadowPart[0].BoundsRect := cxRectOffset(FBarBounds, ShadowSize, ShadowSize);
  end;
end;

{ TdxDockControl }

constructor TdxDockControl.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  ParentBiDiMode := False;
  FBackgroundBitmap := dxBarCreateBitmap(BitmapChanged);
  FBackgroundTempBitmap := TcxBitmap.CreateSize(0, 0, cxDoubleBufferedBitmapPixelFormat);
  ParentColor := True;
  FAllowDocking := True;
  FRowMarginSize := InsertZone;
  FRowList := TList.Create;
end;

constructor TdxDockControl.CreateEx(AOwner: TComponent;
  ABarManager: TdxBarManager; ADockStyle: TdxBarDockingStyle);
const
  Styles: array[dsLeft..dsBottom] of TAlign =
    (alLeft, alTop, alRight, alBottom);
begin
  Create(AOwner);
  Align := Styles[ADockStyle];
  ControlStyle := [csDoubleClicks, csNoDesignVisible];
  FDockingStyle := ADockStyle;
  BarManager := ABarManager;
  BiDiMode := BarManager.BiDiMode;
end;

destructor TdxDockControl.Destroy;
begin
  BarAccessibilityHelperOwnerObjectDestroyed(FIAccessibilityHelper);
  if BarManager <> nil then
    BarManager.RemoveDockControl(Self);
  if IsInternal then
    Bars.FDockControls[FDockingStyle] := nil;
  while RowCount <> 0 do
  begin
    while Rows[0].ColCount <> 0 do
      Rows[0].DeleteCol(0);
    Rows[0].Free;
    RowList.Delete(0);
  end;
  FreeAndNil(FRowList);
  FreeAndNil(FBackgroundTempBitmap);
  FreeAndNil(FBackgroundBitmap);
  inherited Destroy;
end;

procedure TdxDockControl.BitmapChanged(Sender: TObject);
begin
  Invalidate;
  UpdateDoubleBuffered;
  RepaintBarControls;
end;

function TdxDockControl.GetBars: TdxBars;
begin
  if FBarManager = nil then
    Result := nil
  else
    Result := FBarManager.Bars;
end;

function TdxDockControl.GetDockingStyle: TdxBarDockingStyle;
const
  Styles: array[TAlign] of TdxBarDockingStyle =
    (dsTop, dsTop, dsBottom, dsLeft, dsRight, dsTop, dsTop);
begin
  Result := Styles[Align];
end;

function TdxDockControl.GetHorizontal: Boolean;
begin
  Result := DockingStyle in [dsTop, dsBottom];
end;

function TdxDockControl.GetIAccessibilityHelper: IdxBarAccessibilityHelper;
begin
  if FIAccessibilityHelper = nil then
    FIAccessibilityHelper := GetAccessibilityHelperClass.Create(Self);
  Result := FIAccessibilityHelper;
end;

function TdxDockControl.GetIsDesigning: Boolean;
begin
  Result := csDesigning in ComponentState;
end;

function TdxDockControl.GetIsInternal: Boolean;
begin
  Result := (FDockingStyle <> dsNone) and (Bars <> nil) and (Bars.FDockControls[FDockingStyle] = Self);
end;

function TdxDockControl.GetIsLoading: Boolean;
begin
  Result := csLoading in ComponentState;
end;

function TdxDockControl.GetMain: Boolean;
begin
  Result := FDockingStyle <> dsNone;
end;

function TdxDockControl.GetRow(Index: Integer): TdxDockRow;
begin
  Result := FRowList[Index];
end;

function TdxDockControl.GetRowCount: Integer;
begin
  Result := FRowList.Count;
end;

function TdxDockControl.GetTopLeft: Boolean;
begin
  Result := DockingStyle in [dsLeft, dsTop];
end;

function TdxDockControl.GetVertical: Boolean;
begin
  Result := DockingStyle in [dsLeft, dsRight];
end;

procedure TdxDockControl.SetBarManager(Value: TdxBarManager);
begin
  if FBarManager <> Value then
  begin
    if FBarManager <> nil then
      FBarManager.RemoveDockControl(Self);
    FBarManager := Value;
    if FBarManager <> nil then
      FBarManager.AddDockControl(Self);
    BarManagerChanged;
  end;
end;

procedure TdxDockControl.SetBackgroundBitmap(Value: TBitmap);
begin
  FBackgroundBitmap.Assign(Value);
end;

procedure TdxDockControl.WMDestroy(var Message: TMessage);
begin
  if FBarManager <> nil then
    FBarManager.CreateBarRestoringList;
  inherited;
end;

procedure TdxDockControl.WMEraseBkgnd(var Message: TWMEraseBkgnd);
var
  R: TRect;
begin
  R := ClientRect;
  FillBackground(Message.DC, R, R, 0, Color);
  Message.Result := 1;
end;

procedure TdxDockControl.WMGetObject(var Message: TMessage);
begin
//  if CanReturnAccessibleObject(Message) then
//    Message.Result := WMGetObjectResultFromIAccessibilityHelper(Message, IAccessibilityHelper)
//  else
    inherited;
end;

procedure TdxDockControl.WMLButtonDblClk(var Message: TWMLButtonDblClk);
begin
  if CanCustomize then
    FBarManager.Customizing(True);
  Message.Result := 0;
end;

procedure TdxDockControl.WMMouseActivate(var Message: TWMMouseActivate);
begin
  inherited;
  if (FBarManager <> nil) and not IsDesigning and (dxBarGetParentPopupWindow(Self, True) = nil) then
  begin
    Message.Result := MA_NOACTIVATE;
    dxSetZOrder(MainForm.Handle, HWND_TOP, True);
  end;
end;

procedure TdxDockControl.WMNCCalcSize(var Message: TWMNCCalcSize);
begin
  inherited;
  if SunkenBorder then
    InflateRect(Message.CalcSize_Params.rgrc[0], -1, -1);
end;

procedure TdxDockControl.WMNCPaint(var Message: TWMNCPaint);
var
  R: TRect;
  DC: HDC;
begin
  inherited;
  if SunkenBorder then
  begin
    R := cxGetWindowRect(Handle);
    OffsetRect(R, -R.Left, -R.Top);
    DC := GetWindowDC(Handle);
    DrawEdge(DC, R, BDR_SUNKENOUTER, BF_RECT);
    ReleaseDC(Handle, DC);
  end;
end;

procedure TdxDockControl.WMSize(var Message: TWMSize);
begin
  DisableAlign;
  try
    ResetBackground;
    inherited;
  finally
    EnableAlign;
  end;
  Realign;
end;

procedure TdxDockControl.WMRButtonDown(var Message: TWMRButtonDown);
begin
  inherited;
  if (FBarManager <> nil) and not FBarManager.IsCustomizing then
    ShowCustomizePopup;
end;

procedure TdxDockControl.WMWindowPosChanged(var Message: TWMWindowPosChanged);
var
  I, J: Integer;
begin
  inherited;
  if (BarManager <> nil) and
    (Message.WindowPos^.flags and (SWP_NOMOVE or SWP_NOSIZE) <> SWP_NOMOVE or SWP_NOSIZE) then
  begin
    Inc(BarManager.FLockUpdateCount);
    try
      if DockingStyle = dsBottom then
        for I := 0 to RowCount - 1 do
          for J := 0 to Rows[I].ColCount - 1 do
            with Rows[I].Cols[J].BarControl do
              if Bar.IsStatusBar then RebuildBar;
    finally
      Dec(BarManager.FLockUpdateCount);
    end;
    if IsTransparent then
      RepaintBarControls;
  end;
end;

procedure TdxDockControl.CMBiDiModeChanged(var Message: TMessage);
var
  APrevWParam: Integer;
begin
  APrevWParam := Message.WParam;
  try
    Message.wParam := 1;
    inherited;
  finally
    Message.wParam := APrevWParam;
  end;
end;

procedure TdxDockControl.CMSysColorChange(var Message: TMessage);
begin
  inherited;
  if IsWin9X and Main and (DockingStyle = dsLeft) then
    BarManager.OwnerWndProc(0, WM_SYSCOLORCHANGE, 0, 0);
end;

procedure TdxDockControl.AlignControls(AControl: TControl; var Rect: TRect);
begin
  if (BarManager <> nil) and not BarManager.IsLoading then
    UpdateDock;
end;

procedure TdxDockControl.CreateParams(var Params: TCreateParams);
begin
  inherited CreateParams(Params);
  with Params do
  begin
    Style := WS_CHILD or WS_CLIPCHILDREN or WS_CLIPSIBLINGS;
    ExStyle := 0;
    WindowClass.Style := CS_DBLCLKS;
  end;
end;

procedure TdxDockControl.DestroyHandle;
var
  I, J: Integer;
  ADockRow: TdxDockRow;
  AList: TList<TdxBarControl>;
  ABarControl: TdxBarControl;
begin
  if not (csDestroying in ComponentState) and (FBarManager <> nil) then
  begin
    AList := TList<TdxBarControl>.Create;
    try
      for I := 0 to RowCount - 1 do
      begin
        ADockRow := Rows[I];
        for J := 0 to ADockRow.ColCount - 1 do
        begin
          ABarControl := ADockRow.Cols[J].BarControl;
          if ABarControl.NeedHideBarOnDestroyHandle then
            AList.Add(ABarControl)
          else
            ADockRow.Cols[J].BarControl.DestroyHandle;
        end;
      end;

      if AList.Count > 0 then
      begin
        FBarManager.DoBeginUpdate(False);
        IsBarHandleDestroying := True;
        try
          FBarManager.CreateBarRestoringList;
          for I := 0 to AList.Count - 1 do
            AList[I].DestroyHandle;
          for I := 0 to AList.Count - 1 do
           AList[I].HideBar;
        finally
          IsBarHandleDestroying := False;
          FBarManager.DoCancelUpdate(False)
        end;
      end;
    finally
      AList.Free;
    end;
  end;

  inherited;
end;

procedure TdxDockControl.Notification(AComponent: TComponent;
  Operation: TOperation);
begin
  inherited;
  if (Operation = opRemove) and (AComponent = BarManager) then
    BarManager := nil;
end;

procedure TdxDockControl.RequestAlign;
begin
  if not (csDestroyingHandle in ControlState) then
    inherited;
end;

procedure TdxDockControl.AddBarControl(ABarControl: TdxBarControl; APos: TPoint;
  ANeedUpdate: Boolean);

  function GetRow(out ANeedInsert: Boolean): Integer;
  var
    I: Integer;
  begin
    ANeedInsert := False;
    Result := 0;
    if ABarControl <> nil then
    begin
      if not ABarControl.InternallyLocked then
        Result := GetRowAtPos(APos, ANeedInsert)
      else
      begin
        if ABarControl.Bar <> nil then
        begin
          if IsMultiRow then
            Result := ABarControl.Bar.Row
          else
            Result := 0;
          ANeedInsert := ABarControl.Bar.OneOnRow;
        end;
        if (BarManager.BarsLoading or BarManager.IsHandleCreating) and (Result > FRowList.Count - 1) then
          for I := FRowList.Count to Result do
            FRowList.Insert(I, TdxDockRow.Create(Self))
      end;
      if (ABarControl.Bar <> nil) and ABarControl.Bar.WholeRow then
        ANeedInsert := True;
    end;

    if Result > FRowList.Count - 1 + Byte(ANeedInsert) then
      Result := FRowList.Count - Byte(not ANeedInsert){!};
    if Result < 0 then
      Result := 0;
  end;

  procedure CorrectNeedInsert(ARow: Integer; var ANeedInsert: Boolean);
  var
    AColItem: TdxDockCol;
    ARowItem: TdxDockRow;
    I: Integer;
  begin
    if ARow >= FRowList.Count then
      ANeedInsert := True;
    if not ANeedInsert then
    begin
      ARowItem := Rows[ARow];
      for I := 0 to ARowItem.ColCount - 1 do
      begin
        AColItem := ARowItem.Cols[I];
        if AColItem.BarControl.Bar.WholeRow and (AColItem.BarControl <> ABarControl) then
        begin
          ANeedInsert := True;
          Break;
        end;
      end;
    end;
  end;

  function AddNewCol(ARow: Integer; ANeedInsertRow: Boolean): TdxDockCol;
  var
    ADockRow: TdxDockRow;
    ACol: Integer;
  begin
    if ANeedInsertRow then
    begin
      if ABarControl.InternallyLocked and (BarManager.BarsLoading or BarManager.IsHandleCreating) then
        ADockRow := Rows[ARow]
      else
      begin
        ADockRow := TdxDockRow.Create(Self);
        FRowList.Insert(ARow, ADockRow);
      end;
      Result := ADockRow.AddCol(ABarControl);
      ABarControl.FBar.SetDockRow(ADockRow);
    end
    else
    begin
      ADockRow := TdxDockRow(FRowList[ARow]);
      Result := TdxDockCol.Create(ADockRow, ABarControl);
      ACol := GetColAtPos(ARow, APos);
      Rows[ARow].ColList.Insert(ACol, Result);
      Rows[ARow].UpdateOneOnRows;
      ABarControl.FBar.SetDockRow(Rows[ARow]);
    end;
  end;

  procedure CorrectPosition;
  begin
    if not ABarControl.InternallyLocked then
    begin
      if Bars.FMoving then
        APos := cxPointOffset(APos, Bars.FMovingOffset, False);
      APos := cxPointOffset(APos, ABarControl.GetDragPointOffset(ABarControl.DockingStyle), False);
    end;

    Windows.ScreenToClient(Handle, APos);
    APos.X := GetBarControlPos(APos.X, ABarControl.Width);
    if Horizontal then
      APos.X := Max(0, APos.X)
    else
      APos.Y := Max(0, APos.Y);
  end;

  procedure UpdateControls(ADockCol: TdxDockCol);
  begin
    if not ABarControl.FMoving then
    begin
      APos.X := GetBarControlPos(APos.X, ABarControl.Width);
      ABarControl.Left := APos.X;
      ABarControl.Top := APos.Y;
    end;
    UpdateDock;
    if not BarManager.BarsLoading and not BarManager.IsHandleCreating then
      ADockCol.AssignPosition;
  end;

var
  ANeedInsertRow: Boolean;
  ARow: Integer;
  ADockCol: TdxDockCol;
begin
  if BarManager = nil then
    Exit;

  ARow := GetRow(ANeedInsertRow);
  CorrectNeedInsert(ARow, ANeedInsertRow);
  ADockCol := AddNewCol(ARow, ANeedInsertRow);
  CorrectPosition;
  ADockCol.FPos := APos;

  if ANeedUpdate then
    UpdateControls(ADockCol);
end;

procedure TdxDockControl.DeleteBarControl(ABarControl: TdxBarControl; ADockCol: TObject;
  Update: Boolean);
var
  I, J: Integer;

  procedure DeleteCol;
  begin
    Rows[I].DeleteCol(J);
    if Update then
      UpdateDock;
  end;

var
  ADockRow: TdxDockRow;
begin
  if BarManager = nil then
    Exit;
  for I := 0 to RowCount - 1 do
  begin
    ADockRow := Rows[I];
    if ADockCol <> nil then
    begin
      J := ADockRow.ColList.IndexOf(ADockCol);
      if J > -1 then
      begin
        DeleteCol;
        Exit;
      end;
    end
    else
      for J := 0 to ADockRow.ColCount - 1 do
        if ADockRow.Cols[J].BarControl = ABarControl then
        begin
          DeleteCol;
          Exit;
        end;
  end;
end;

procedure TdxDockControl.MoveBarControl(ABarControl: TdxBarControl; APos: TPoint);
var
  DockCol: Pointer;
begin
  if FBarManager = nil then Exit;
  DockCol := Rows[ABarControl.GetRow].Cols[ABarControl.GetCol];
  DeleteBarControl(ABarControl, DockCol, False);
  AddBarControl(ABarControl, APos, True);
  if IsTransparent then
  begin
    ResetBackground;
    RepaintBarControls;
  end;
end;

procedure TdxDockControl.AssignPositions;
var
  I, J: Integer;
begin
  for I := 0 to RowCount - 1 do
    with Rows[I] do
      for J := 0 to ColCount - 1 do
        Cols[J].AssignPosition;
end;

procedure TdxDockControl.BarManagerChanged;
begin
  ResetBackground;
end;

procedure TdxDockControl.CalcLayout;
var
  AClientSize, I: Integer;
begin
  if Vertical then
    AClientSize := ClientHeight
  else
    AClientSize := ClientWidth;
  for I := 0 to RowCount - 1 do
    if Rows[I].Visible then
      CalcRowToolbarPositions(I, AClientSize);
end;

procedure TdxDockControl.CalcRowToolbarPositions(ARowIndex: Integer;
  AClientSize: Integer);

  function RotatePoint(const APoint: TPoint): TPoint;
  begin
    Result := Point(APoint.Y, APoint.X);
  end;

  function RotateSize(const ASize: TSize): TSize;
  begin
    Result := Size(ASize.cy, ASize.cx);
  end;

  function GetMinSize(ABarControl: TdxBarControl): Integer;
  begin
    if Vertical then
      Result := ABarControl.GetMinHeight(DockingStyle)
    else
      Result := ABarControl.GetMinWidth(DockingStyle);
  end;

  function GetMaxSizeX(ABarControl: TdxBarControl): Integer;
  begin
    if Vertical then
      Result := ABarControl.GetMaxHeight(DockingStyle)
    else
      Result := ABarControl.GetMaxWidth(DockingStyle);
  end;

  function GetMaxSizeY(ABarControl: TdxBarControl): Integer;
  begin
    if Vertical then
      Result := ABarControl.GetMaxWidth(DockingStyle)
    else
      Result := ABarControl.GetMaxHeight(DockingStyle);
  end;

  function NCSizeX(ABarControl: TdxBarControl): Integer;
  begin
    if Vertical then
      Result := ABarControl.Bar.BarNCSizeY(DockingStyle)
    else
      Result := ABarControl.Bar.BarNCSizeX(DockingStyle);
  end;

  function NCSizeY(ABarControl: TdxBarControl): Integer;
  begin
    if Vertical then
      Result := ABarControl.Bar.BarNCSizeX(DockingStyle)
    else
      Result := ABarControl.Bar.BarNCSizeY(DockingStyle);
  end;

  function GetFullSize(ABarControl: TdxBarControl; ASize: Integer): TSize;
  begin
    Dec(ASize, NCSizeX(ABarControl));
    if not Painter.BarAllowQuickCustomizing then
      Dec(ASize, ABarControl.GetMarkSize);
    if Vertical then
      Result := RotateSize(ABarControl.GetSizeForHeight(DockingStyle, ASize))
    else
      Result := ABarControl.GetSizeForWidth(DockingStyle, ASize);
  end;

  procedure CalcDefaultParams(ARow: TdxDockRow; out AWidthSum: Integer);
  var
    I: Integer;
    ABarControl: TdxBarControl;
  begin
    AWidthSum := 0;
    for I := 0 to ARow.ColCount - 1 do
    begin
      ABarControl := ARow.Cols[I].BarControl;
      ABarControl.FTruncated := False;
      ABarControl.ItemLinks.RecentItemCount := -1;
      ABarControl.FMinSize := GetMinSize(ABarControl) + NCSizeX(ABarControl);
      ABarControl.FMaxSize := GetMaxSizeX(ABarControl) + NCSizeX(ABarControl);
      if not ABarControl.MarkExists and (ABarControl.FMinSize <> ABarControl.FMaxSize) then
        Inc(ABarControl.FMinSize, ABarControl.MarkSize);
      Inc(AWidthSum, ABarControl.FMaxSize);
    end;
  end;

  procedure CalcNewBoundsForWholeRowBar(ARow: TdxDockRow; const ARowBounds: TRect; ARowWidth: Integer; var AMaxHeight: Integer);
  var
    ABarControl: TdxBarControl;
  begin
    ABarControl := ARow.Cols[0].BarControl;
    ABarControl.NewLeft := ARowBounds.Left;
    ABarControl.NewTop := ARowBounds.Top;
    ABarControl.NewWidth := Max(ARowWidth, ABarControl.FMinSize);
    ABarControl.NewHeight := GetFullSize(ABarControl, ABarControl.NewWidth).cy + NCSizeY(ABarControl);
    ABarControl.FTruncated := not ABarControl.MultiLine and (ABarControl.NewWidth < ABarControl.FMaxSize);
    AMaxHeight := Max(AMaxHeight, ABarControl.NewHeight);
  end;

  procedure CalcNewBoundsForLocatedBars(ARow: TdxDockRow; const ARowBounds: TRect; ARowWidth: Integer; var AMaxHeight: Integer);
  var
    I, J: Integer;
    AMargin, AFixedSize, ANewLeft: Integer;
    ACol: TdxDockCol;
    ABarControl: TdxBarControl;
  begin
    AMargin := ARowWidth;
    for I := ARow.ColCount - 1 downto 0 do
    begin
      ACol := ARow.Cols[I];
      ABarControl := ACol.BarControl;
      ABarControl.NewTop := ARowBounds.Top;
      ABarControl.NewWidth := ABarControl.FMaxSize;
      if ABarControl.MultiLine then
        ABarControl.NewHeight := GetFullSize(ABarControl, ABarControl.NewWidth).cy
      else
        ABarControl.NewHeight := GetMaxSizeY(ABarControl);
      Inc(ABarControl.NewHeight, NCSizeY(ABarControl));
      AMaxHeight := Max(AMaxHeight, ABarControl.NewHeight);

      AFixedSize := 0;
      for J := 0 to I - 1 do
        Inc(AFixedSize, ARow.Cols[J].BarControl.FMaxSize);
      ANewLeft := IfThen(Vertical, ACol.Pos.Y, ACol.Pos.X);
      if ANewLeft + ABarControl.NewWidth > AMargin then
        ANewLeft := AMargin - ABarControl.NewWidth;
      ABarControl.NewLeft := Max(ANewLeft, AFixedSize);
      AMargin := ABarControl.NewLeft;
    end;
  end;

  procedure CalcNewBoundsForNonLocatedBars(ARow: TdxDockRow; const ARowBounds: TRect; ARowWidth: Integer; var AMaxHeight: Integer);
  var
    I, K: Integer;
    ASize, ARestSize, AFixedSize, AMaxFixedSize, AMinSize, AMaxSize: Integer;
    ACol, APrevCol: TdxDockCol;
    ABarControl, APrevBarControl: TdxBarControl;
  begin
    ASize := ARowWidth;
    for I := ARow.ColCount - 1 downto 0 do
    begin
      ACol := ARow.Cols[I];
      ABarControl := ACol.BarControl;
      if Vertical then
        AFixedSize := ACol.Pos.Y
      else
        AFixedSize := ACol.Pos.X;
      AMinSize := 0;
      AMaxSize := 0;
      for K := I - 1 downto 0 do
      begin
        Inc(AMinSize, ARow.Cols[K].BarControl.FMinSize);
        Inc(AMaxSize, ARow.Cols[K].BarControl.FMaxSize);
      end;
      AFixedSize := Min(Max(AFixedSize, AMinSize), AMaxSize);
      if (I > 0) and (ARow.Cols[I - 1].BarControl = Bars.FMovingBarControl) then
      begin
        APrevCol := ARow.Cols[I - 1];
        APrevBarControl := APrevCol.BarControl;
        AMaxFixedSize := IfThen(Vertical, APrevCol.Pos.Y, APrevCol.Pos.X);
        AMaxFixedSize := Max(AMaxFixedSize, AMinSize - APrevBarControl.FMinSize);
        Inc(AMaxFixedSize, APrevBarControl.FMaxSize);
        if AFixedSize > AMaxFixedSize then
        begin
          if Vertical then
            ACol.FPos.Y := AMaxFixedSize
          else
            ACol.FPos.X := AMaxFixedSize;
          AFixedSize := AMaxFixedSize;
        end;
      end;
      ARestSize := ASize - AFixedSize;

      if ARestSize >= ABarControl.FMaxSize then
      begin
        ABarControl.NewWidth := ABarControl.FMaxSize;
        if ABarControl.MultiLine then
          ABarControl.NewHeight := GetFullSize(ABarControl, ABarControl.NewWidth).cy
        else
          ABarControl.NewHeight := GetMaxSizeY(ABarControl);
      end
      else
      begin
        ABarControl.FTruncated := not ABarControl.MultiLine and (ABarControl.FMinSize <> ABarControl.FMaxSize);
        ABarControl.NewWidth := Max(ARestSize, ABarControl.FMinSize);
        ABarControl.NewHeight := GetFullSize(ABarControl, ABarControl.NewWidth).cy;
      end;

      if (I = 0) and (ABarControl.NewWidth < ASize) then
        ABarControl.NewWidth := ASize;
      ABarControl.NewLeft := Min(Max(ASize - ABarControl.NewWidth, AMinSize), AMaxSize);
      ABarControl.NewTop := ARowBounds.Top;
      Inc(ABarControl.NewHeight, NCSizeY(ABarControl));
      AMaxHeight := Max(AMaxHeight, ABarControl.NewHeight);

      Dec(ASize, ABarControl.NewWidth);
    end;
  end;

  procedure CalcNewBoundsForAutoAlignBars(ARow: TdxDockRow);
  var
    I: Integer;
    ABarControl: TdxBarControl;
  begin
    for I := 0 to ARow.ColCount - 1 do
    begin
      ABarControl := ARow.Cols[I].BarControl;
      if ABarControl.Bar.UseRestSpace or BarManager.AutoAlignBars then
      begin
        if I = 0 then
          ABarControl.NewLeft := 0
        else
          ABarControl.NewLeft := ARow.Cols[I - 1].BarControl.NewLeft + ARow.Cols[I - 1].BarControl.NewWidth;
      end;

      if ABarControl.Bar.UseRestSpace then
      begin
        if I = ARow.ColCount - 1 then
          ABarControl.NewWidth := AClientSize - ABarControl.NewLeft
        else
          ABarControl.NewWidth := ARow.Cols[I + 1].BarControl.NewLeft - ABarControl.NewLeft;
        ABarControl.NewWidth := Max(ABarControl.NewWidth, ABarControl.FMinSize);
      end;
    end;
  end;

  procedure SetNewBounds(ARow: TdxDockRow; AMaxHeight: Integer);
  var
    I, ATemp: Integer;
    ABarControl: TdxBarControl;
  begin
    for I := 0 to ARow.ColCount - 1 do
    begin
      ABarControl := ARow.Cols[I].BarControl;
      if ABarControl.FTruncated and (I = ARow.ColCount - 1) then
        ABarControl.NewWidth := Max(AClientSize - ABarControl.NewLeft, ABarControl.FMinSize);
      ABarControl.NewHeight := AMaxHeight;
      // for the RecentItemCount calculating
      GetFullSize(ABarControl, ABarControl.NewWidth);
      if Vertical then
      begin
        ATemp := ABarControl.NewLeft;
        ABarControl.NewLeft := ABarControl.NewTop;
        ABarControl.NewTop := ATemp;
        ATemp := ABarControl.NewWidth;
        ABarControl.NewWidth := ABarControl.NewHeight;
        ABarControl.NewHeight := ATemp;
      end;
      ABarControl.NewLeft := GetBarControlPos(ABarControl.NewLeft, ABarControl.NewWidth);
      ABarControl.SetNewBounds;
      ABarControl.CalcLayout;
    end;
  end;

var
  AWidthSum, ARowWidth, AMaxHeight: Integer;
  ARow: TdxDockRow;
  R: TRect;
begin
  ARow := Rows[ARowIndex];
  if ARow.ColCount = 0 then
    Exit;
  R := GetRectForRow(ARowIndex);
  if Vertical then
    R.TopLeft := RotatePoint(R.TopLeft);
  ARowWidth := AClientSize;
  AMaxHeight := 0;

  CalcDefaultParams(ARow, AWidthSum);

  if ARow.Cols[0].BarControl.Bar.WholeRow then
    CalcNewBoundsForWholeRowBar(ARow, R, ARowWidth, AMaxHeight)
  else
    if AWidthSum <= ARowWidth then
      CalcNewBoundsForLocatedBars(ARow, R, ARowWidth, AMaxHeight)
    else
      CalcNewBoundsForNonLocatedBars(ARow, R, ARowWidth, AMaxHeight);

  CalcNewBoundsForAutoAlignBars(ARow);

  SetNewBounds(ARow, AMaxHeight);
end;

function TdxDockControl.CanCustomize: Boolean;
begin
  Result := (FBarManager <> nil) and FBarManager.CanCustomize;
end;

function TdxDockControl.CanDocking(Bar: TdxBar): Boolean;
begin
  Result := FAllowDocking;
end;

procedure TdxDockControl.ColorChanged;
begin
  if (FBarManager = nil) or FBarManager.AutoDockColor then
    ParentColor := True
  else
    Color := FBarManager.DockColor;
end;

function TdxDockControl.GetBarControlPos(AControlPos: Integer; AControlWidth: Integer): Integer;
begin
  if UseRightToLeftAlignment and Horizontal then
    Result := ClientWidth - AControlPos - AControlWidth
  else
    Result := AControlPos;
end;

function TdxDockControl.GetDockZoneBounds: TRect;
begin
  Result := cxRect(0, 0, Width, Height);
  InflateRect(Result, Bars.DockingZoneSize, Byte(Horizontal) * Bars.DockingZoneSize);
  Result := dxMapWindowRect(Handle, 0, Result);
end;

procedure TdxDockControl.GetDockZoneMargins(Row, ZoneNumber: Integer; var M1, M2: Integer);
var
  IM1, IM2: Integer;
begin
  M1 := 0;
  M2 := 0;
  if Row = -1 then
    if TopLeft then
    begin
      M1 := -Bars.DockingZoneSize;
      M2 := 0;
    end
    else
    begin
      if DockingStyle = dsRight then
        M1 := ClientWidth
      else
        M1 := ClientHeight;
      M1 := M1 - GetClientSize - Bars.DockingZoneSize;
      M2 := M1 + Bars.DockingZoneSize;
    end
  else
    if Row = FRowList.Count then
      if TopLeft then
      begin
        M1 := GetClientSize;
        M2 := M1 + Bars.DockingZoneSize;
      end
      else
      begin
        if DockingStyle = dsRight then
          M1 := ClientWidth
        else
          M1 := ClientHeight;
        M2 := M1 + Bars.DockingZoneSize;
      end
    else
      with GetRectForRow(Row) do
        if Horizontal then
        begin
          M1 := Top;
          M2 := Bottom;
        end
        else
        begin
          M1 := Left;
          M2 := Right;
        end;
  case DockingStyle of
    dsLeft, dsTop:
      IM1 := M1 + (Bars.DockingZoneSize - InsertZone div 2) div 2;
    dsRight, dsBottom:
      IM1 := M2 - (Bars.DockingZoneSize - InsertZone div 2) div 2 - InsertZone div 2;
    else
      IM1 := 0;
  end;
  IM2 := IM1 + InsertZone div 2;

  case ZoneNumber of
    0: M2 := IM1;
    1: begin
         M1 := IM1;
         M2 := IM2;
       end;
    2: M1 := IM2;
  end;
end;

function TdxDockControl.GetRectForRow(ARow: Integer): TRect;
var
  I: Integer;
  Origin, Size: Integer;

  function GetRowHeight(ARowIndex: Integer): Integer;
  var
    J: Integer;
    ARow: TdxDockRow;
    ACol: TdxDockCol;
    ABarControl: TdxBarControl;
  begin
    Result := 0;
    ARow := Rows[ARowIndex];
    if not ARow.Visible then
      Exit;
    for J := 0 to ARow.ColCount - 1 do
    begin
      ACol := ARow.Cols[J];
      ABarControl := ACol.BarControl;
      case DockingStyle of
        dsLeft, dsRight: if Result < ABarControl.Width then Result := ABarControl.Width;
        dsTop, dsBottom: if Result < ABarControl.Height then Result := ABarControl.Height;
      end;
    end;
    if  ARowIndex < RowCount - 1 then
      Inc(Result, Painter.BarDockedGetRowIndent);
  end;

begin
  SetRectEmpty(Result);
  if (ARow < 0) or (ARow > FRowList.Count - 1) then Exit;
  Size := 0;
  if not Bars.FMoving or (DockingStyle in [dsLeft, dsTop]) then
  begin
    Origin := 0;
    for I := 0 to ARow do
    begin
      Inc(Origin, Size);
      Size := GetRowHeight(I);
    end;
  end
  else
  begin
    if DockingStyle = dsRight then
      Origin := ClientWidth
    else
      Origin := ClientHeight;
    for I := FRowList.Count - 1 downto ARow do
    begin
      Size := GetRowHeight(I);
      Dec(Origin, Size);
    end;
  end;
  case DockingStyle of
    dsLeft, dsRight:
      Result := Bounds(Origin, 0, Size, ClientHeight);
    dsTop, dsBottom:
      Result := Bounds(0, Origin, ClientWidth, Size);
  end;
end;

function TdxDockControl.GetClientSize: Integer;
var
  I: Integer;
  R: TRect;
begin
  Result := 0;
  case DockingStyle of
    dsLeft, dsRight:
      for I := 0 to FRowList.Count - 1 do
      begin
        R := GetRectForRow(I);
        Inc(Result, R.Right - R.Left);
      end;
    dsTop, dsBottom:
      for I := 0 to FRowList.Count - 1 do
      begin
        R := GetRectForRow(I);
        Inc(Result, R.Bottom - R.Top);
      end;
  end;
end;

function TdxDockControl.GetSize: Integer;
begin
  Result := GetClientSize;
  if (Result > 0) and SunkenBorder then Inc(Result, 2);
end;

function TdxDockControl.GetRowAtPos(APos: TPoint; out ANeedInsert: Boolean): Integer;
var
  I, J, Z, M1, M2: Integer;
  AFound: Boolean;
begin
  if FRowList.Count = 0 then
  begin
    Result := 0;
    ANeedInsert := True;
    Exit;
  end;

  Result := -1;
  ANeedInsert := False;
  Windows.ScreenToClient(Handle, APos);
  if Vertical then
    Z := APos.X
  else
    Z := APos.Y;
  AFound := False;
  for I := -1 to FRowList.Count - 1 do
  begin
    for J := 0 to 2 do
    begin
      GetDockZoneMargins(I, J, M1, M2);
      if (M1 <= Z)  and (Z < M2) then
      begin
        Result := I + Byte(J > 0);
        ANeedInsert := J = 1;
        AFound := True;
        Break;
      end;
    end;
    if AFound then Break;
  end;

  if Result = -1 then
  begin
    ANeedInsert := True;
    if Z >= GetClientSize then
      Result := FRowList.Count
    else
      Result := 0;
  end
  else
    if Result >= RowCount then
      ANeedInsert := True;
end;

function TdxDockControl.GetColAtPos(ARow: Integer; APos: TPoint): Integer;
var
  I: Integer;
  ADragPointOffset: TPoint;
  ADockRow: TdxDockRow;
  ADockCol: TdxDockCol;
  ABar: TdxBar;
begin
  Result := 0;
  ADockRow := Rows[ARow];
  if (ADockRow = nil) or
    (ADockRow.ColCount = 0) then Exit;
  if Bars.FMoving and not Bars.FMovingBarControl.InternallyLocked then
  begin
    ADragPointOffset := Bars.FMovingBarControl.GetDragPointOffset(DockingStyle);
    case DockingStyle of
      dsLeft, dsRight:
        Dec(APos.Y, ADragPointOffset.Y);
      dsTop, dsBottom:
        Dec(APos.X, ADragPointOffset.X);
    end;
  end;
  Windows.ScreenToClient(Handle, APos);
  if Bars.FMoving and not Bars.FMovingBarControl.InternallyLocked then
    APos.X := GetBarControlPos(APos.X, Bars.FMovingBarControl.Width)
  else
    if UseRightToLeftAlignment and Horizontal then
      APos.X := TdxRightToLeftLayoutConverter.ConvertXCoordinate(APos.X, ClientRect);
  for I := 0 to ADockRow.ColCount - 1 do
  begin
    ADockCol := ADockRow.Cols[I];
    ABar := ADockCol.BarControl.Bar;
    case DockingStyle of
      dsLeft, dsRight:
        if APos.Y <= ABar.DockedTop then
        begin
          Result := I;
          Exit;
        end;
      dsTop, dsBottom:
        if APos.X <= ABar.DockedLeft then
        begin
          Result := I;
          Exit;
        end;
    end;
  end;
  Result := ADockRow.ColCount;
end;

procedure TdxDockControl.GetPosForRow(Row: Integer; OneOnRow: Boolean; var P: TPoint);
var
  M1, M2, Temp: Integer;
begin
  if OneOnRow and (Row = FRowList.Count) then OneOnRow := False;
  if OneOnRow then
    GetDockZoneMargins(Row - 1, 1, M1, M2)
  else
  begin
    GetDockZoneMargins(Row - 1, 2, M1, Temp);
    GetDockZoneMargins(Row, 0, Temp, M2);
    if Temp - M1 > M2 - Temp then M1 := Temp - (M2 - Temp);
  end;
  Temp := (M1 + M2) div 2;
  Windows.ScreenToClient(Handle, P);
  if Vertical then
    P.X := Temp
  else
    P.Y := Temp;
  Windows.ClientToScreen(Handle, P);
end;

function TdxDockControl.GetSunkenBorder: Boolean;
begin
  if BarManager = nil then
    Result := False
  else
    Result := BarManager.SunkenBorder;
end;

function TdxDockControl.GetMainForm: TCustomForm;
begin
  Result := dxBarGetControlForm(Self, fkMain);
  if (Result = nil) and (BarManager <> nil) then // Result.HandleAllocated?
    Result := BarManager.GetMainForm;
end;

function TdxDockControl.GetMasterForm: TCustomForm;
begin
  Result := dxBarGetControlForm(Self, fkMainOrMDIChild);
  if (Result = nil) and (BarManager <> nil) then // Result.HandleAllocated?
    Result := BarManager.MasterForm;
end;

function TdxDockControl.GetParentForm: TCustomForm;
begin
  Result := dxBarGetControlForm(Self, fkAny);
  if (Result = nil) and (BarManager <> nil) then // Result.HandleAllocated?
    Result := BarManager.ParentForm;
end;

function TdxDockControl.IsMultiRow: Boolean;
begin
  Result := True;
end;

procedure TdxDockControl.NCChanged;
var
  I, J: Integer;
begin
  if not HandleAllocated then Exit;
  dxRecalculateNonClientPart(Handle);
  for I := 0 to RowCount - 1 do
    for J := 0 to Rows[I].ColCount - 1 do
      Rows[I].Cols[J].BarControl.FrameChanged{RebuildBar};
  UpdateDock;
end;

procedure TdxDockControl.PaintBarControls;
begin
  if (RowList = nil) or (BarManager = nil) or BarManager.BarsLoading or BarManager.IsDestroying then
    Exit;

  if not BarManager.Designing and HandleAllocated then
    dxSetZOrder(Handle, HWND_TOP);

  DisableAlign;
  try
    CalcLayout;
  finally
    EnableAlign;
  end;
  Repaint;
end;

procedure TdxDockControl.SetSize;

  function Appropriate(var Variable; Value: TObject): Boolean;
  begin
    TObject(Variable) := TObject(Value);
    Result := True;
  end;

  function IsCurrentDockControl(AParentBar: TCustomdxBarControl): Boolean;
  begin
    Result := (AParentBar <> nil) and
      not ((AParentBar is TdxBarControl) and (Self is TdxBarDockControl) and
      not (TdxBarControl(AParentBar).DockControl is TdxBarDockControl) or
      (AParentBar.BarManager <> BarManager) and (Forms.GetParentForm(Self) <> nil));
  end;

var
  ASize, PrevSize: Integer;
  AParentBar: TCustomdxBarControl;
begin
  ASize := GetSize;
  PrevSize := 0;
  case DockingStyle of
    dsLeft, dsRight:
      begin
        PrevSize := Width;
        if DockingStyle = dsRight then
        begin
          Parent.DisableAlign;
          Left := Left - (ASize - Width);
        end;
        Width := ASize;
        if DockingStyle = dsRight then Parent.EnableAlign;
      end;
    dsTop, dsBottom:
      begin
        PrevSize := Height;
        if DockingStyle = dsBottom then
        begin
          Parent.DisableAlign;
          Top := Top - (ASize - Height);
        end;
        Height := ASize;
        if DockingStyle = dsBottom then Parent.EnableAlign;
      end;
  end;
  if Visible and (ASize <> PrevSize) and (ActiveBarControl <> nil) and
    Appropriate(AParentBar, GetParentBarForBar(ActiveBarControl)) and not (AParentBar is TdxBarQuickControl) and
    ActiveBarControl.HandleAllocated and (ActiveBarControl.Handle <> GetCapture) and IsCurrentDockControl(AParentBar)
  then
    ActiveBarControl.HideAll;
end;

procedure TdxDockControl.ShowCustomizePopup;
begin
  BarDesignController.ShowToolbarsPopup(FBarManager, Painter);
end;

procedure TdxDockControl.UpdateDock;
begin
  if (BarManager <> nil) and not (BarManager.IsUpdateLocked or BarManager.IsDestroying or IsUpdateLocked) then
  begin
    PaintBarControls;
    SetSize;
  end;
end;

procedure TdxDockControl.BeginUpdate;
begin
  Inc(FLockCount);
end;

procedure TdxDockControl.EndUpdate;
begin
  Dec(FLockCount);
end;

function TdxDockControl.IsUpdateLocked: Boolean;
begin
  Result := FLockCount > 0;
end;

function TdxDockControl.GetDockedBarControlClass: TdxBarControlClass;
begin
  Result := TdxBarControl;
end;

function TdxDockControl.GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass;
begin
  Result := TdxDockControlAccessibilityHelper;
end;

function TdxDockControl.GetPainter: TdxBarPainter;
begin
  Result := BarManager.DefaultPainter;
end;

function TdxDockControl.GetScaleFactor: TdxScaleFactor;
var
  AIntf: IdxScaleFactor;
begin
  if Supports(Parent, IdxScaleFactor, AIntf) then
    Result := AIntf.Value
  else
    Result := BarManager.ScaleFactor;
end;

procedure TdxDockControl.FillBackground(DC: HDC; const ADestR, ASourceR: TRect; ABrush: HBRUSH; AColor: TColor);
var
  CR: TRect;
begin
  if not (BackgroundBitmap.Empty and IsBarManagerValid) then
    FillBackgroundRect(DC, ADestR, ASourceR, ABrush, AColor, BackgroundBitmap)
  else
  begin
    if not BarManager.Backgrounds.Bar.Empty then
      FillBackgroundRect(DC, ADestR, ASourceR, ABrush, AColor, BarManager.Backgrounds.Bar)
    else
    begin
      CR := ClientRect;
      if not IsRectEmpty(CR) then
        Painter.DockControlFillBackground(Self, DC, ADestR, ASourceR, CR, ABrush, AColor)
    end;
  end;
end;

function TdxDockControl.IsBackgroundBitmap: Boolean;
begin
  Result := not BackgroundBitmap.Empty;
end;

function TdxDockControl.IsDrawDesignBorder: Boolean;
begin
  Result := IsDesigning;
end;

function TdxDockControl.IsBarManagerValid: Boolean;
begin
  Result := (BarManager <> nil) and not BarManager.IsDestroying;
end;

function TdxDockControl.IsTransparent: Boolean;
begin
  Result := not BackgroundBitmap.Empty or (IsBarManagerValid and
    (Painter.IsNativeBackground or not BarManager.Backgrounds.Bar.Empty));
end;

procedure TdxDockControl.RepaintBarControls;
var
  I, J: Integer;
begin
  for I := 0 to RowCount - 1 do
    for J := 0 to Rows[I].ColCount - 1 do
      Rows[I].Cols[J].BarControl.FullRepaint;
end;

procedure TdxDockControl.ResetBackground;
begin
  FBackgroundTempBitmap.Assign(nil);
end;

procedure TdxDockControl.UpdateDoubleBuffered;
begin
  DoubleBuffered := IsTransparent;
end;

{ TdxBarDockControl }

constructor TdxBarDockControl.Create(AOwner: TComponent);
begin
  inherited;
  Align := dalTop;
  if IsDesigning then
    BarManager := GetBarManagerByComponent(AOwner);
end;

procedure TdxBarDockControl.AfterConstruction;
begin
  inherited;
  SetMinSize;
end;

function TdxBarDockControl.GetAlign: TdxBarDockAlign;
begin
  Result := TdxBarDockAlign(inherited Align);
end;

function TdxBarDockControl.GetColor: TColor;
begin
  Result := inherited Color;
end;

function TdxBarDockControl.GetIsLoading: Boolean;
begin
  Result := (csLoading in ComponentState) or (BarManager <> nil) and BarManager.BarsLoading;
end;

function TdxBarDockControl.GetParentColor: Boolean;
begin
  Result := inherited ParentColor;
end;

procedure TdxBarDockControl.SetAlign(Value: TdxBarDockAlign);
const
  Styles: array[TdxBarDockAlign] of TdxBarDockingStyle =
    (dsTop, dsTop, dsBottom, dsLeft, dsRight);
var
  I, J: Integer;
begin
  if Align <> Value then
  begin
    if BarManager <> nil then
      BarManager.BeginUpdate;
    try
      for I := 0 to RowCount - 1 do
        for J := 0 to Rows[I].ColCount - 1 do
          Rows[I].Cols[J].BarControl.DockingStyle := Styles[Value];
      inherited Align := TAlign(Value);
    finally
      if BarManager <> nil then
      begin
        BarManager.EndUpdate;
        for I := 0 to RowCount - 1 do
          for J := 0 to Rows[I].ColCount - 1 do
            Rows[I].Cols[J].BarControl.RepaintBar;
        if Parent <> nil then Parent.Invalidate;
      end;
    end;
  end;
end;

procedure TdxBarDockControl.SetAllowZeroSizeInDesignTime(Value: Boolean);
begin
  if FAllowZeroSizeInDesignTime <> Value then
  begin
    FAllowZeroSizeInDesignTime := Value;
    Perform(WM_SIZE, 0, 0);
  end;
end;

procedure TdxBarDockControl.SetColor(Value: TColor);
begin
  if Color <> Value then
  begin
    inherited Color := Value;
    if not IsLoading then UseOwnColor := True;
  end;
end;

procedure TdxBarDockControl.SetParentColor(Value: Boolean);
begin
  if ParentColor <> Value then
  begin
    inherited ParentColor := Value;
    if not IsLoading then UseOwnColor := True;
  end;
end;

procedure TdxBarDockControl.SetSunkenBorder(Value: Boolean);
begin
  if SunkenBorder <> Value then
  begin
    FSunkenBorder := Value;
    FUseOwnSunkenBorder := True;
    NCChanged;
  end;
end;

procedure TdxBarDockControl.SetUseOwnColor(Value: Boolean);
begin
  if FUseOwnColor <> Value then
  begin
    FUseOwnColor := Value;
    if not Value then ColorChanged;
  end;
end;

procedure TdxBarDockControl.SetUseOwnSunkenBorder(Value: Boolean);
var
  PrevSunkenBorder: Boolean;
begin
  if FUseOwnSunkenBorder <> Value then
  begin
    PrevSunkenBorder := SunkenBorder;
    FUseOwnSunkenBorder := Value;
    if Value then
      FSunkenBorder := PrevSunkenBorder
    else
      if SunkenBorder <> PrevSunkenBorder then NCChanged;
  end;
end;

procedure TdxBarDockControl.SetMinSize;
begin
  if Horizontal then
    Height := GetMinSize
  else
    Width := GetMinSize;
end;

function TdxBarDockControl.IsColorStored: Boolean;
begin
  Result := FUseOwnColor and not ParentColor;
end;

function TdxBarDockControl.IsWidthStored: Boolean;
begin
  Result := Horizontal or (ClientWidth <> GetMinSize);
end;

function TdxBarDockControl.IsHeightStored: Boolean;
begin
  Result := Vertical or (ClientHeight <> GetMinSize);
end;

procedure TdxBarDockControl.WMCreate(var Message: TWMCreate);
begin
  inherited;
  if BarManager <> nil then
    BarManager.ShowBarsFromRestoringList(Self);
end;

procedure TdxBarDockControl.WMSize(var Message: TWMSize);
begin
  inherited;
  if not IsLoading and (RowCount = 0) then
    SetMinSize;
end;

function TdxBarDockControl.AllowUndockWhenLoadFromIni: Boolean;
begin
  Result := True;
end;

procedure TdxBarDockControl.CreateParams(var Params: TCreateParams);
begin
  inherited;
  if IsDesigning then
    with Params do
      WindowClass.Style := WindowClass.Style or CS_HREDRAW or CS_VREDRAW;
end;

procedure TdxBarDockControl.Paint;
begin
  inherited;
  if IsDrawDesignBorder then
  begin
    Canvas.Brush.Style := bsClear;
    Canvas.Pen.Style := psDot;
    Canvas.Rectangle(0, 0, ClientWidth, ClientHeight);
    Canvas.Pen.Style := psSolid;
    Canvas.Brush.Style := bsSolid;
  end;
end;

procedure TdxBarDockControl.BarManagerChanged;
begin
  inherited;
  if not (csDestroying in ComponentState) then
  begin
    ColorChanged;
    NCChanged;
  end;
end;

function TdxBarDockControl.CanDocking(Bar: TdxBar): Boolean;
begin
  Result := inherited CanDocking(Bar) and
    ((Bar.Control = nil) or not dxHasAsParent(Handle, Bar.Control.Handle));
end;

procedure TdxBarDockControl.ColorChanged;
begin
  if not FUseOwnColor then
  begin
    inherited;
    FUseOwnColor := False;
  end;
end;

function TdxBarDockControl.GetClientSize: Integer;
begin
  if IsLoading then
    if Horizontal then
      Result := ClientHeight
    else
      Result := ClientWidth
  else
  begin
    Result := inherited GetClientSize;
    if Result = 0 then Result := GetMinSize;
  end;
end;

function TdxBarDockControl.GetMinSize: Integer;
begin
  if IsDesigning and not AllowZeroSizeInDesignTime then
    Result := MinDockSize
  else
    Result := 0;
end;

function TdxBarDockControl.GetSunkenBorder: Boolean;
begin
  if FUseOwnSunkenBorder then
    Result := FSunkenBorder
  else
    Result := inherited GetSunkenBorder;
end;

{ TdxDockRow }

constructor TdxDockRow.Create(ADockControl: TdxDockControl);
begin
  inherited Create;
  FDockControl := ADockControl;
  FColList := TList.Create;
  FBars := TList.Create;
end;

destructor TdxDockRow.Destroy;
var
  I: Integer;
begin
  for I := ColCount - 1 downto 0 do
    Cols[I].Free;
  FreeAndNil(FColList);
  while FBars.Count <> 0 do
    TdxBar(FBars[0]).RemoveFromDockRow(False);
  FreeAndNil(FBars);
  inherited;
end;

function TdxDockRow.AddCol(ABarControl: TdxBarControl): TdxDockCol;
begin
  Result := TdxDockCol.Create(Self, ABarControl);
  ColList.Add(Result);
  UpdateOneOnRows;
end;

procedure TdxDockRow.DeleteCol(ABarControl: TdxBarControl);
var
  I: Integer;
begin
  if FColList = nil then
    Exit;
  for I := 0 to ColCount - 1 do
    if Cols[I].BarControl = ABarControl then
    begin
      DeleteCol(I);
      Break;
    end;
end;

procedure TdxDockRow.DeleteCol(AIndex: Integer);
begin
  Cols[AIndex].Free;
  ColList.Delete(AIndex);
  UpdateOneOnRows;
end;

procedure TdxDockRow.AddBar(ABar: TdxBar);
var
  I: Integer;
  ACol: TdxDockCol;
begin
  FBars.Add(ABar);
  if (FBars.Count > ColCount) and (ABar.Control <> nil) and (ABar.RealDockControl = DockControl) then
  begin
    for I := 0 to ColCount - 1 do
      if TdxDockCol(ColList[I]).BarControl = ABar.Control then Exit;
    ACol := TdxDockCol.Create(Self, ABar.Control);
    ColList.Add(ACol);
    UpdateOneOnRows;
    ACol.Pos := Point(ABar.DockedLeft, ABar.DockedTop);
  end;
end;

procedure TdxDockRow.DeleteBar(ABar: TdxBar; ADestroyEmptyDockRow: Boolean);
begin
  if FBars.IndexOf(ABar) < 0 then
    Exit;
  FBars.Delete(FBars.IndexOf(ABar));
  if ABar.Control <> nil then
    DeleteCol(ABar.Control);
  if (FBars.Count = 0) and ADestroyEmptyDockRow then
  begin
    FDockControl.RowList.Delete(FDockControl.RowList.IndexOf(Self));
    Free;
  end;
end;

function TdxDockRow.GetCol(Index: Integer): TdxDockCol;
begin
  Result := FColList[Index];
end;

function TdxDockRow.GetColCount: Integer;
begin
  Result := FColList.Count;
end;

function TdxDockRow.GetVisible: Boolean;
var
  ABarControl: TdxBarControl;
  I: Integer;
begin
  Result := False;
  for I := 0 to FBars.Count - 1 do
  begin
    ABarControl := TdxBar(FBars[I]).Control;
    if (ABarControl <> nil) and (ABarControl.DockingStyle <> dsNone) then
    begin
      Result := True;
      Break;
    end;
  end;
end;

procedure TdxDockRow.UpdateOneOnRows;
var
  I: Integer;
begin
  for I := 0 to ColCount - 1 do
    Cols[I].BarControl.Bar.OneOnRow := ColCount = 1;
end;

{ TdxBarControlMarkFadingHelper }

constructor TdxBarControlMarkFadingHelper.Create(AOwner: TdxBarControl);
begin
  FOwner := AOwner;
end;

destructor TdxBarControlMarkFadingHelper.Destroy;
var
  AFader: TdxFader;
begin
  AFader := Owner.Fader;
  if AFader <> nil then
    AFader.Remove(Self);
  inherited Destroy;
end;

function TdxBarControlMarkFadingHelper.CanFade: Boolean;
begin
  with Owner do
    Result := IsFadingAvailable and MarkExists and (MarkState <> msPressed);
end;

procedure TdxBarControlMarkFadingHelper.DrawFadeImage;
begin
  Owner.InvalidateMark;
end;

procedure TdxBarControlMarkFadingHelper.GetFadingImages(
  out AFadeOutImage, AFadeInImage: TcxBitmap);
var
  AFadingHelper: IdxFadingPainterHelper;
  R: TRect;
begin
  if Supports(Owner.Painter, IdxFadingPainterHelper, AFadingHelper) then
  begin
    R := Owner.MarkRect;
    OffsetRect(R, -R.Left, -R.Top);
    AFadeInImage := TcxBitmap32.CreateSize(R, True);
    AFadeOutImage := TcxBitmap32.CreateSize(R, True);
    AFadingHelper.DrawBarMarkState(Owner, AFadeOutImage.Canvas.Handle, R, msNone);
    AFadingHelper.DrawBarMarkState(Owner, AFadeInImage.Canvas.Handle, R, msSelected);
    if AFadingHelper.BarMarkIsOpaque then
    begin
      TcxBitmap32(AFadeInImage).MakeOpaque;
      TcxBitmap32(AFadeOutImage).MakeOpaque;
    end;
  end;
end;

{ TdxBarControlMDIButtonFadingHelper }

constructor TdxBarControlMDIButtonFadingHelper.Create(AOwner: TdxBarControl;
  AMDIButton: TdxBarMDIButton);
begin
  FMDIButton := AMDIButton;
  FOwner := AOwner;
end;

destructor TdxBarControlMDIButtonFadingHelper.Destroy;
var
  AFader: TdxFader;
begin
  AFader := Owner.Fader;
  if AFader <> nil then
    AFader.Remove(Self);
  inherited Destroy;
end;

function TdxBarControlMDIButtonFadingHelper.CanFade: Boolean;
begin
  Result := Owner.IsFadingAvailable and Owner.MDIButtonsOnBar;
end;

procedure TdxBarControlMDIButtonFadingHelper.DrawFadeImage;
begin
  if Owner.HandleAllocated then
    cxInvalidateRect(Owner.Handle, Owner.RectMDI(MDIButton));
end;

procedure TdxBarControlMDIButtonFadingHelper.FadeIn;
begin
  if CanFade then
    Owner.Fader.FadeIn(Self);
end;

procedure TdxBarControlMDIButtonFadingHelper.FadeOut;
begin
  if CanFade then
    Owner.Fader.FadeOut(Self);
end;

procedure TdxBarControlMDIButtonFadingHelper.GetFadingImages(
  out AFadeOutImage, AFadeInImage: TcxBitmap);
var
  AFadingHelper: IdxFadingPainterHelper;
  R: TRect;
begin
  if Supports(Owner.Painter, IdxFadingPainterHelper, AFadingHelper) then
  begin
    R := Owner.RectMDI(MDIButton);
    OffsetRect(R, -R.Left, -R.Top);
    AFadeInImage := TcxBitmap32.CreateSize(R, True);
    AFadeOutImage := TcxBitmap32.CreateSize(R, True);
    Owner.Painter.BarDrawMDIButton(Owner, MDIButton, DXBAR_HOT,
      AFadeInImage.Canvas.Handle, R);
    Owner.Painter.BarDrawMDIButton(Owner, MDIButton, DXBAR_NORMAL,
      AFadeOutImage.Canvas.Handle, R);
    if AFadingHelper.BarMarkIsOpaque then
    begin
      TcxBitmap32(AFadeInImage).MakeOpaque;
      TcxBitmap32(AFadeOutImage).MakeOpaque;
    end;
  end;
end;

{ TdxBarDockedControl }

function TdxBarDockedControl.GetCurrentCursor(const AMousePos: TPoint): TCursor;
begin
  if FIsItemResizing or CanResizeSelectedLink(AMousePos) then
    Result := crdxBarEditSizing
  else
    Result := inherited;
end;

procedure TdxBarDockedControl.Resize;
begin
  inherited;
  if HasCaptionButtons then
    UpdateCaptionButton(nil);
end;

procedure TdxBarDockedControl.BeginInternal;
begin
  Inc(FInternalLockCount);
end;

procedure TdxBarDockedControl.EndInternal;
begin
  if FInternalLockCount > 0 then
    Dec(FInternalLockCount);
end;

function TdxBarDockedControl.GetInternallyLocked: Boolean;
begin
  Result := FInternalLockCount <> 0;
end;

procedure TdxBarDockedControl.CustomizePrepare(APoint: TPoint; ASecondClick: Boolean);
begin
  if ASecondClick and CanResizeSelectedLink(APoint) then
  begin
    FIsItemResizing := True;
    SelectedControlAtDesign.BeginResize(APoint);
    SetCapture(Handle);
  end
  else
    inherited;
end;

procedure TdxBarDockedControl.DoBarMouseMove(Shift: TShiftState; const APoint: TPoint; AItemControl: TdxBarItemControl);
begin
//    if IsCustomizing and FIsResizing and (GetCapture = Handle) then
    if FIsItemResizing then
      SelectedControlAtDesign.Resizing(APoint);
  inherited;
end;

procedure TdxBarDockedControl.DoBarMouseLeave;
begin
  inherited;
  UpdateCaptionButtons(cxInvalidPoint);
end;

function TdxBarDockedControl.GetCaptionButtonIndex(const APoint: TPoint): Integer;
begin
  Result := CaptionButtons.GetButtonIndex(APoint);
end;

function TdxBarDockedControl.HasCaptionButtons: Boolean;
begin
  Result := CaptionButtons.Count > 0;
end;

procedure TdxBarDockedControl.DoBeforeCaptionButtonClick;
begin
//do nothing
end;

procedure TdxBarDockedControl.CaptionButtonClick(AIndex: Integer);
var
  AButton: TdxBarCaptionButton;
begin
  AButton := MasterBar.CaptionButtons[AIndex];
  DoBeforeCaptionButtonClick;
  AButton.Click;
end;

procedure TdxBarDockedControl.UpdateCaptionButtons(const AMousePos: TPoint;
  AMousePressed: Boolean; AActiveButtonIndex: Integer);
begin
  if HasCaptionButtons then
    CaptionButtons.UpdateButtonStates(AMousePos, AMousePressed);
end;

procedure TdxBarDockedControl.UpdateCaptionButton(ACaptionButton: TdxBarCaptionButton);
begin
// do nothing
end;

function TdxBarDockedControl.GetMasterBar: TdxBar;
begin
  Result := Bar;
end;

procedure TdxBarDockedControl.InitializeForDock(ABar: TdxBar);
begin
  FBar := ABar;
end;

function TdxBarDockedControl.CanResizeSelectedLink(APoint: TPoint): Boolean;
begin
  Result := (SelectedControlAtDesign <> nil) and SelectedControlAtDesign.CanResize(APoint);
end;

function TdxBarDockedControl.NeedActivateOwnerOnCaptionButtonClick: Boolean;
begin
  Result := not BarManager.HideFloatingBarsWhenInactive and (dxBarGetParentPopupWindow(Self, True) = nil);
end;

function TdxBarDockedControl.NeedHideOnNCMouseClick: Boolean;
begin
  Result := dxBarGetParentPopupWindow(Self, True) = nil;
end;

function TdxBarDockedControl.GetCaptionButtons: TdxBarCaptionButtons;
begin
  Result := FBar.CaptionButtons;
end;

procedure TdxBarDockedControl.WMCaptureChanged(var Message: TMessage);
begin
  inherited;
  if FIsItemResizing then
  begin
    FIsItemResizing := False;
    SelectedControl.EndResize(False);
  end;
end;

procedure TdxBarDockedControl.WMLButtonUp(var Message: TWMLButtonUp);
begin
  if FIsItemResizing then
  begin
    FIsItemResizing := False;
    SelectedControl.EndResize(True);
    ReleaseCapture;
  end
  else
    inherited;
end;

procedure TdxBarDockedControl.WMNCLButtonDown(var Message: TWMNCLButtonDown);

  function GetWindowCursorPos: TPoint;
  begin
    Result := cxPointOffset(GetMouseCursorPos, cxPointInvert(WindowRect.TopLeft));
  end;

var
  AActiveButtonID: Integer;
  ACaptureWnd: HWND;
  AMsg: TMsg;
  ASuccessfulDragging: Boolean;
begin
  if NeedHideOnNCMouseClick then
    HideAll;

  if not BarControlExists(Self) then
    Exit;

  AActiveButtonID := GetCaptionButtonIndex(GetWindowCursorPos);

  if AActiveButtonID <> -1 then
  begin
    if NeedActivateOwnerOnCaptionButtonClick then
      SetActiveWindow(BarManager.Owner.Handle);

    UpdateCaptionButtons(GetWindowCursorPos, True, AActiveButtonID);
    ASuccessfulDragging := False;

    ACaptureWnd := Handle;
    SetCapture(ACaptureWnd);
    try
      while GetCapture = ACaptureWnd do
      begin
        case Integer(GetMessage(AMsg, 0, 0, 0)) of
          -1: Break;
          0: begin
              PostQuitMessage(AMsg.wParam);
              Break;
            end;
        end;
        case AMsg.message of
          WM_LBUTTONUP:
            begin
              ASuccessfulDragging := GetCaptionButtonIndex(GetWindowCursorPos) = AActiveButtonID;
              Break;
            end;
          WM_MOUSEMOVE:
            if PtInRect(WindowRect, GetMouseCursorPos) then
            begin
              if cxPointIsEqual(FLastMousePos, cxInvalidPoint) then
                DoBarMouseEnter([], cxInvalidPoint, nil);
              FLastMousePos := GetMouseCursorPos;

              UpdateCaptionButtons(GetWindowCursorPos, True, AActiveButtonID);
            end;
        else
          TranslateMessage(AMsg);
          DispatchMessage(AMsg);
        end;
      end;
    finally
      if GetCapture = ACaptureWnd then
        ReleaseCapture;
      UpdateCaptionButtons(GetWindowCursorPos, False, AActiveButtonID);
//      CloseButtonState := msNone;
      if ASuccessfulDragging then
        CaptionButtonClick(AActiveButtonID);
    end;
  end
  else
    inherited;
end;

{ TdxBarControl }

constructor TdxBarControl.Create(AOwner: TComponent);
var
  AButton: TdxBarMDIButton;
begin
  inherited;
  FMarkFadingHelper := TdxBarControlMarkFadingHelper.Create(Self);
  for AButton := Low(TdxBarMDIButton) to High(TdxBarMDIButton) do
    FMDIButtonFadingHelper[AButton] := TdxBarControlMDIButtonFadingHelper.Create(Self, AButton);
end;

destructor TdxBarControl.Destroy;
var
  AButton: TdxBarMDIButton;
begin
  BarAccessibilityHelperOwnerObjectDestroyed(FMarkIAccessibilityHelper);
  if (FBar <> nil) and (FBar.Bars <> nil) and (DockingStyle <> dsNone) then
  begin
    FBar.Bars.UnregFromDock(FDockingStyle, FDockControl, Self);
  end;

  BarLostFocus; //  HideAll; //#DG TODO: CHECK IT!!!

  for AButton := Low(TdxBarMDIButton) to High(TdxBarMDIButton) do
    FreeAndNil(FMDIButtonFadingHelper[AButton]);
  FreeAndNil(FMarkFadingHelper);
  inherited;
end;

function TdxBarControl.ClientToScreen(const APoint: TPoint): TPoint;
begin
  Result := APoint;
  Windows.ClientToScreen(Handle, Result);
end;

procedure TdxBarControl.Hide;
begin
  SetWindowPos(Handle, 0, 0, 0, 0, 0,
    SWP_NOZORDER or SWP_NOMOVE or SWP_NOSIZE or SWP_HIDEWINDOW or SWP_NOACTIVATE);

  if SelectedControl <> nil then
    SelectedControl.ParentVisibleChange(False);
end;

function TdxBarControl.GetCaptionBkColor: COLORREF;
begin
  Result := Painter.BarCaptionBkColor(Self, BarManager.MainFormActive);
end;

function TdxBarControl.GetCaptionColor: COLORREF;
begin
  Result := Painter.BarCaptionColor(Self);
end;

function TdxBarControl.GetHorizontal: Boolean;
begin
  Result := DockingStyle in [dsTop, dsBottom];
end;

function TdxBarControl.GetIsFadingAvailable: Boolean;
begin
  Result := Painter.IsFadingAvailable and (Fader <> nil);
end;

function TdxBarControl.GetMarkIAccessibilityHelper: IdxBarAccessibilityHelper;
begin
  if FMarkIAccessibilityHelper = nil then
    FMarkIAccessibilityHelper := GetMarkAccessibilityHelperClass.Create(Self);
  Result := FMarkIAccessibilityHelper;
end;

function TdxBarControl.GetVertical: Boolean;
begin
  Result := DockingStyle in [dsLeft, dsRight];
end;

procedure TdxBarControl.SetCloseButtonState(Value: TdxBarMarkState);
var
  DC: HDC;
begin
  if FCloseButtonState <> Value then
  begin
    FCloseButtonState := Value;
    if HandleAllocated then
    begin
      DC := GetWindowDC(Handle);
      DrawCloseButton(DC);
      ReleaseDC(Handle, DC);
    end;
  end;
end;

procedure TdxBarControl.SetNewBounds;

  function NeedInvalidate: Boolean;
  var
    I: Integer;
  begin
    Result := False;
    for I := 0 to ItemLinks.Count - 1 do
    begin
      Result := Result or (ItemLinks[I].Control <> nil) and ItemLinks[I].Control.NeedUpdateWhenResize;
      if Result then
        Break;
    end;
  end;

var
  ARegion: TcxRegion;
begin
  if (Left <> NewLeft) or (Top <> NewTop) or (Width <> NewWidth) or (Height <> NewHeight) then
  begin
    SetWindowPos(Handle, 0, NewLeft, NewTop, NewWidth, NewHeight, SWP_NOZORDER or SWP_NOACTIVATE);
    if NeedInvalidate then
    begin
      ARegion := TcxRegion.Create;
      try
        if GetUpdateRgn(Handle, ARegion.Handle, True) = NULLREGION then
          Paint;
      finally
        ARegion.Free;
      end;
    end;
  end;
end;

procedure TdxBarControl.SetMoving(Value: Boolean);
var
  I: Integer;
  KillingHandle: HWND;
begin
  if FMoving <> Value then
  begin
    FMovingChanging := True;
    try
      FMoving := Value;
      if Value then
        FBar.Bars.FMovingBarControl := Self
      else
        FBar.Bars.FMovingBarControl := nil;
//      SetCursorForMoving(Value);
      for I := 0 to ItemLinks.CanVisibleItemCount - 1 do
        if ItemLinks.CanVisibleItems[I].Control is TdxBarWinControl then
          if FMoving then
            TdxBarWinControl(ItemLinks.CanVisibleItems[I].Control).DestroyInnerEdit
          else
            TdxBarWinControl(ItemLinks.CanVisibleItems[I].Control).CreateInnerEdit;
      if FMoving then
      begin
        if FDockingStyle = dsNone then
        begin
          FFloatingHandle := Handle;
          FDockingStyle := dsLeft;
          FDockControl := FBar.Bars.DockControls[dsLeft];
          DestroyControls;
          WindowHandle := 0;
          CreateHandle;
          FDockedHandle := Handle;
          WindowHandle := 0;
          FDockingStyle := Bar.DockingStyle;
          FDockControl := nil;
          BeginInternal;
          try
            CreateHandle;
          finally
            EndInternal;
          end;
          Windows.SetParent(FDockedHandle, 0);
        end
        else
        begin
          FDockedHandle := Handle;
          FDockingStyle := dsNone;
          DestroyControls;
          WindowHandle := 0;
          CreateHandle;
          FFloatingHandle := Handle;
          WindowHandle := 0;
          FDockingStyle := Bar.DockingStyle;
          BeginInternal;
          try
            CreateHandle;
          finally
            EndInternal;
          end;
        end;
        // this code creates problems with other relative popup menus
//        SetWindowPos(FFloatingHandle, HWND_TOPMOST, 0, 0, 0, 0,
//          SWP_NOMOVE or SWP_NOSIZE or SWP_NOACTIVATE);
      end
      else
      begin
        // this code makes top-most windows normal
        //SetWindowPos(FFloatingHandle, HWND_NOTOPMOST, 0, 0, 0, 0,
        //  SWP_NOMOVE or SWP_NOSIZE or SWP_NOACTIVATE);
        if FDockingStyle = dsNone then
          KillingHandle := FDockedHandle
        else
          KillingHandle := FFloatingHandle;
        dxSetWindowProc(KillingHandle, DefWndProc);
        DestroyWindow(KillingHandle);
        SavePos;
      end;
      SetCursorForMoving(Value);
      Perform(WM_SIZE, 0, 0);  // to store normal size
      RepaintBar;
    finally
      FMovingChanging := False;
    end;
  end;
end;

procedure TdxBarControl.ChangeStyleWinTo(AStyle: TdxBarDockingStyle; ADockControl: TdxDockControl);

  procedure CheckScaleFactor;
  begin
    if DockingStyle = dsNone then
      ScaleForPPI(dxGetTargetDPI(Self))
    else
      ScaleForPPI(dxGetCurrentDPI(DockControl));
  end;

begin
  if (FBar = nil) or (FBar.Bars = nil) or IsDestroying then
    Exit;

  if (AStyle = DockingStyle) and (DockControl = ADockControl) then
    CheckScaleFactor
  else
    if FMoving then
    begin
      if AStyle = dsNone then
        Windows.SetParent(FDockedHandle, 0);
      DockControl := ADockControl;
      DockingStyle := AStyle;
      WindowHandle := 0;
      BeginInternal;
      try
        CreateHandle;
      finally
        EndInternal;
      end;
      if AStyle <> dsNone then
        Windows.SetParent(Handle, FDockControl.Handle);

      CheckScaleFactor;
      RepaintBar;
    end
    else
    begin
      BeginInternal;
      try
        DestroyHandle;
      finally
        EndInternal;
      end;
      DockControl := ADockControl;
      if not ADockControl.HandleAllocated then
        ADockControl.HandleNeeded;
      DockingStyle := AStyle;
      CreateHandle;
      CheckScaleFactor;
      FrameChanged;
    end;
end;

function TdxBarControl.GetDragPointOffset(Style: TdxBarDockingStyle): TPoint;
begin
  if (Style <> dsNone) and (Self = Bar.Bars.FMovingBarControl) and (Style = Bar.Bars.FMovingBarOriginalDockingStyle) then
    if Vertical then
      Result := Point(-Bar.Bars.FMovingOffset.X, Bar.Bars.FMovingStaticOffset.Y)
    else
      Result := Point(Bar.Bars.FMovingStaticOffset.X, -Bar.Bars.FMovingOffset.Y);
    with GetTrackSize(Style) do
    begin
      Result.X := MulDiv(cx, RX.X, RX.Y);
      Result.Y := MulDiv(cy, RY.X, RY.Y);
    end;
end;

function TdxBarControl.GetCaptionNCRect: TRect;
var
  R: TRect;
begin
  R := NCRect;
  Result := Painter.GetToolbarCaptionRect(Self, R);
  if UseRightToLeftAlignment then
    Result := TdxRightToLeftLayoutConverter.ConvertRect(Result, R);
end;

procedure TdxBarControl.HideBar;
begin
  BarManager.AddBarToRestoringList(Bar);
  FBar.Visible := False;
end;

function TdxBarControl.NeedHideBarOnDestroyHandle: Boolean;
begin
  Result := not (bsDestroying in FState) and (FBar <> nil) and not InternallyLocked and not IsInternal and FBar.Visible and not BarManager.IsDestroying;
end;

procedure TdxBarControl.DrawCloseButton(DC: HDC);
begin
  Painter.BarDrawCloseButton(Self, DC, CloseButtonRectNC);
end;

procedure TdxBarControl.DrawMark(DC: HDC);
begin
  Painter.BarDrawMark(Self, DC, MarkNCRect);
end;

procedure TdxBarControl.DrawMDIButton(AButton: TdxBarMDIButton; ASelected, APressed: Boolean);

  function GetMDIButtonState: Integer;
  begin
    Result := DXBAR_NORMAL;
    if not MDIButtonEnabled(AButton, MF_GRAYED) then
      Result := DXBAR_DISABLED
    else
      if ASelected or APressed then
        if ASelected and APressed then
          Result := DXBAR_PRESSED
        else
          if ASelected then
            Result := DXBAR_HOT
          else
            Result := DXBAR_ACTIVE
  end;

var
  R: TRect;
  DC: HDC;
begin
  R := RectMDI(AButton);
  DC := Canvas.Handle;
  Painter.BarDrawMDIButton(Self, AButton, GetMDIButtonState, DC, R);
end;

function TdxBarControl.GetMDIAreaSize: TSize;
begin
  if RealMDIButtonsOnBar then
    if IsRealVertical then
      Result := Size(MDIButtonWidth, 3 * MDIButtonHeight + 2)
    else
      Result := Size(3 * MDIButtonWidth + 2, MDIButtonHeight)
  else
    Result := Size(MDIButtonWidth, MDIButtonHeight);
end;

function TdxBarControl.GetMDIWidth: Integer;
begin
  Result := GetMDIAreaSize.cx;
end;

function TdxBarControl.GetMDIHeight: Integer;
begin
  Result := GetMDIAreaSize.cy;
end;

type
  TReverseSize = class
  private
    FSize: TSize;
    FReverse: Boolean;
    function GetX: Integer;
    procedure SetX(Value: Integer);
    function GetY: Integer;
    procedure SetY(Value: Integer);
  public
    constructor Create(AReverse: Boolean); overload;
    constructor Create(AReverse: Boolean; const ASize: TSize); overload;

    property Size: TSize read FSize write FSize;
    property Reverse: Boolean read FReverse write FReverse;
    property X: Integer read GetX write SetX;
    property Y: Integer read GetY write SetY;
  end;

constructor TReverseSize.Create(AReverse: Boolean);
begin
  inherited Create;
  FReverse := AReverse;
end;

constructor TReverseSize.Create(AReverse: Boolean; const ASize: TSize);
begin
  Create(AReverse);
  FSize := ASize;
end;

function TReverseSize.GetX: Integer;
begin
  Result := IfThen(Reverse, Size.cy, Size.cx);
end;

procedure TReverseSize.SetX(Value: Integer);
begin
  if Reverse then
    FSize.cy := Value
  else
    FSize.cx := Value;
end;

function TReverseSize.GetY: Integer;
begin
  Result := IfThen(Reverse, Size.cx, Size.cy);
end;

procedure TReverseSize.SetY(Value: Integer);
begin
  if Reverse then
    FSize.cx := Value
  else
    FSize.cy := Value;
end;

function GetValue(const ASize: TSize; AOrdinate: Boolean): Integer;
begin
  if AOrdinate then
    Result := ASize.cy
  else
    Result := ASize.cx;
end;

procedure SetValue(var ASize: TSize; AValue: Integer; AOrdinate: Boolean);
begin
  if AOrdinate then
    ASize.cy := AValue
  else
    ASize.cx := AValue;
end;

function GetSize(AX, AY: Integer; AOrdinate: Boolean): TSize;
begin
  if AOrdinate then
    Result := Size(AY, AX)
  else
    Result := Size(AX, AY);
end;

function TdxBarControl.RectMDI(Button: TdxBarMDIButton): TRect;

  function MDIButtonsHaveOwnRow(AVertical: Boolean; AOffset: Integer): Boolean;
  var
    I, L: Integer;
  begin
    Result := False;
    L := ItemLinks.VisibleItemCount - 1;
    for I := L downto 0 do
      with ItemLinks.VisibleItems[I] do
      begin
        if Control.FLastInRow and (I <> L) then
        begin
          Result := True;
          Break;
        end;
        if AVertical then
          if ItemRect.Left < AOffset then Break
          else
        else
          if ItemRect.Bottom > AOffset then Break;
        if I = 0 then Result := True;
      end;
  end;

var
  AVertical: Boolean;
  AWidth, AHeight, AMDIButtonWidth, AMDIButtonHeight, AMDIAreaSize, Offset: Integer;
begin
  SetRectEmpty(Result);

  AVertical := Vertical;
  if AVertical then
  begin
    AWidth := ClientHeight;
    AHeight := ClientWidth;
    AMDIButtonWidth := MDIButtonHeight;
    AMDIButtonHeight := MDIButtonWidth;
    AMDIAreaSize := GetMDIHeight;
  end
  else
  begin
    AWidth := ClientWidth;
    AHeight := ClientHeight;
    AMDIButtonWidth := MDIButtonWidth;
    AMDIButtonHeight := MDIButtonHeight;
    AMDIAreaSize := GetMDIWidth;
  end;
  if DockingStyle <> dsNone then
    Dec(AWidth, GetMarkSize);

  if MultiLine then
  begin
    if AVertical then
      Offset := AMDIButtonHeight
    else
      Offset := AHeight - AMDIButtonHeight;
    if not MDIButtonsHaveOwnRow(AVertical, Offset) then
      if ItemLinks.VisibleItemCount = 0 then
        Offset := (AHeight - AMDIButtonHeight) div 2
      else
        Offset := AHeight -
          (ItemLinks.VisibleItems[ItemLinks.VisibleItemCount - 1].RowHeight - AMDIButtonHeight) div 2 - AMDIButtonHeight
    else
      if AVertical then
        Offset := AHeight - Offset;
  end
  else
    Offset := (AHeight - AMDIButtonHeight) div 2;

  if RealMDIButtonsOnBar then
  begin
    Result := Bounds(AWidth - AMDIAreaSize + AMDIButtonWidth * Ord(Button), Offset, AMDIButtonWidth, AMDIButtonHeight);
    if Button = mdibClose then
      OffsetRect(Result, 2, 0);
  end
  else
    Result := Bounds(AWidth - AMDIButtonWidth, Offset, AMDIButtonWidth, AMDIButtonHeight);

  if AVertical then
    with Result do
    begin
      AMDIButtonWidth := Left;
      Left := AHeight - Bottom;
      Bottom := Right;
      Right := AHeight - Top;
      Top := AMDIButtonWidth;
    end;
end;

function TdxBarControl.RealMDIButtonsOnBar: Boolean;
begin
  Result := IsMainMenu and BarManager.IsMDIMaximized and (GetSystemMenu(BarManager.ActiveMDIChild, False) <> 0);
end;

function TdxBarControl.GetScaleFactor: TdxScaleFactor;
begin
  if MasterBar <> nil then
    Result := MasterBar.ScaleFactor
  else
    Result := DockControl.ScaleFactor;
end;

function TdxBarControl.MDIButtonsOnBar: Boolean;
begin
  Result := RealMDIButtonsOnBar or IsMainMenu and BarManager.ShowCloseButton;
end;

function TdxBarControl.MDIButtonEnabled(AButton: TdxBarMDIButton; State: Integer): Boolean;
begin
  Result :=
    (AButton = mdibRestore) or
    (AButton = mdibClose) and not RealMDIButtonsOnBar and MDIButtonsOnBar or
    (GetMenuState(GetSystemMenu(BarManager.ActiveMDIChild, False),
     MDIButtonCommands[AButton], MF_BYCOMMAND) and State = 0);
end;

procedure MoreButtonsHintTimerProc(Wnd: HWND; Msg: UINT; idEvent: UINT; Time: DWORD); stdcall;
var
  BarControl: TdxBarControl;
begin
  BarControl := TdxBarControl(FindControl(Wnd));
  with BarControl do
    if not IsWindowVisible(Handle) or not MouseOnMark then
      FinishMoreButtonsHintTimer;
end;

procedure TdxBarControl.StartMoreButtonsHintTimer;
begin
  FMoreButtonsHintTimer := SetTimer(Handle, 1, 50, @MoreButtonsHintTimerProc);
end;

procedure TdxBarControl.FinishMoreButtonsHintTimer;
begin
  if dxKillTimer(0, FMoreButtonsHintTimer) and (MarkState = msSelected) then
    MarkState := msNone;
end;

procedure TdxBarControl.WMDestroy(var Message: TMessage);
var
  ADockControl: TdxDockControl;
begin
  ADockControl := DockControl;
  if (ADockControl <> nil) and ADockControl.IsBarHandleDestroying then
    inherited
  else
  begin
    if ADockControl <> nil then
      ADockControl.IsBarHandleDestroying := True;
    try
      FinishMoreButtonsHintTimer;
      inherited;
      if NeedHideBarOnDestroyHandle then
        HideBar;
    finally
      if ADockControl <> nil then
        ADockControl.IsBarHandleDestroying := False;
    end;
  end;
end;

procedure TdxBarControl.WMDpiChanged(var Message: TMessage);
begin
  ScaleForPPI(Message.WParamLo);
  Message.Result := 0;
end;

procedure TdxBarControl.WMGetDlgCode(var Message: TWMGetDlgCode);
begin
  Message.Result := DLGC_WANTALLKEYS or DLGC_WANTARROWS or DLGC_WANTTAB;
end;

procedure TdxBarControl.WMGetMinMaxInfo(var Message: TWMGetMinMaxInfo);
begin
  inherited;
  with Message.MinMaxInfo^ do
  begin
    ptMinTrackSize := Point(10, 10);
    ptMaxTrackSize := Point(30000, 30000);  // because of Win95/98
    ptMaxSize := ptMaxTrackSize;
    ptMaxPosition := ptMaxSize;
  end;
end;

procedure TdxBarControl.WMGetObject(var Message: TMessage);
begin
//  if CanReturnAccessibleObject(Message) then
//    Message.Result := WMGetObjectResultFromIAccessibilityHelper(Message, IAccessibilityHelper)
//  else
    inherited;
end;

procedure TdxBarControl.WMMouseActivate(var Message: TWMMouseActivate);
begin
  inherited;
  if not IsActive and (DockingStyle = dsNone) then
    dxSetZOrder(Handle, HWND_TOP);
  //ProcessPaintMessages;
end;

procedure TdxBarControl.WMNCCalcSize(var Message: TWMNCCalcSize);
var
  AContentOffsets: TRect;
begin
  if not FMovingChanging then
    FHasSizeGrip := (FBar <> nil) and FBar.HasSizeGrip;
  AContentOffsets := Painter.GetToolbarContentOffsets(Bar, DockingStyle, ScaleFactor, FHasSizeGrip);
  if UseRightToLeftAlignment and Horizontal then
    AContentOffsets := TdxRightToLeftLayoutConverter.ConvertOffsets(AContentOffsets);

  with Message.CalcSize_Params^.rgrc[0] do
  begin
    Inc(Left, AContentOffsets.Left);
    Inc(Top, AContentOffsets.Top);
    Dec(Right, AContentOffsets.Right);
    Dec(Bottom, AContentOffsets.Bottom);
  end;
end;

procedure TdxBarControl.WMNCHitTest(var Message: TWMNCHitTest);
var
  P: TPoint;
  AControl: TdxBarItemControl;

  function MouseAboveMDIButtons: Boolean;
  begin
    Result := MDIButtonsOnBar and
      (RealMDIButtonsOnBar and
       (PtInRect(RectMDI(mdibMinimize), P) or PtInRect(RectMDI(mdibRestore), P)) or
       PtInRect(RectMDI(mdibClose), P));
  end;

  function NoControl: Boolean;
  begin
    Result := (AControl = nil) or not IsCustomizing and not AControl.HotPartWantMouse;
  end;

  procedure CheckResizingHitTest(var AHitTest: LRESULT; P: TPoint);
  var
    R, RW: TRect;
    ASizingBorders: TSize;
  begin
    if AHitTest = HTNOWHERE then
    begin
      ASizingBorders.cx := Painter.BorderSizeX(ScaleFactor);
      ASizingBorders.cy := Painter.BorderSizeY(ScaleFactor);
      RW := WindowRect;
      Dec(P.X, RW.Left);
      Dec(P.Y, RW.Top);
      OffsetRect(RW, -RW.Left, -RW.Top);
      R := RW;
      R.Bottom := R.Top + ASizingBorders.cy;
      if cxRectPtIn(R, P) then
        AHitTest := HTTOP
      else
      begin
        R := RW;
        R.Left := R.Right - ASizingBorders.cx;
        if cxRectPtIn(R, P) then
          AHitTest := HTRIGHT
        else
        begin
          R := RW;
          R.Top := R.Bottom - ASizingBorders.cy;
          if cxRectPtIn(R, P) then
            AHitTest := HTBOTTOM
          else
          begin
            R := RW;
            R.Right := R.Left + ASizingBorders.cx;
            if cxRectPtIn(R, P) then
              AHitTest := HTLEFT;
          end;
        end;
      end;
    end;
  end;

begin
  inherited;
  if bboUnmoved in BehaviorOptions then
  begin
    FHitTest := Message.Result;
    Exit;
  end;
  FHitTest := 0;
  P := SmallPointToPoint(Message.Pos);
  Windows.ScreenToClient(Handle, P);
  with Message do
    if DockingStyle = dsNone then
    begin
      case Result of
        HTCLIENT:
          begin
            AControl := ItemAtPos(P);
            if NoControl and not MouseAboveMDIButtons then
            begin
              FHitTest := HTCAPTION;
              Result := HTCLIENT;
            end;
          end;
        HTNOWHERE:
          begin
            CheckResizingHitTest(Result, GetMouseCursorPos);
            if Result <> HTNOWHERE then
            begin
              FHitTest := Result;
              Exit;
            end;
            if not IsCustomizing and MarkExists and MouseOnMark(P) then
              FHitTest := HTCLIENT
            else
              if PtInRect(CloseButtonRect, P) then
                if not Painter.BarUseSystemClose then
                  FHitTest := HTCLOSE
                else
                begin
                  FHitTest := HTCLIENT;
                  Result := HTCLOSE;
                  Exit;
                end
              else
                FHitTest := HTCAPTION;
            Result := HTCLIENT;
          end;
      else
        FHitTest := Result;
      end
    end
    else  // DockingStyle <> dsNone
    begin
      if Result = HTCLIENT then
        AControl := ItemAtPos(P)
      else
        AControl := nil;
      if (Result = HTCLIENT) and NoControl or (Result = HTNOWHERE) then
      begin
        if not Vertical and (UseRightToLeftAlignment and (P.X > ClientWidth) or not UseRightToLeftAlignment and (P.X < 0)) or Vertical and (P.Y < 0) or
          NoControl and not MouseAboveMDIButtons and
          (not MarkExists or not MouseOnMark(P)) then
            if FHasSizeGrip and PtInRect(SizeGripRect, P) then
              if UseRightToLeftAlignment then
              begin
//                FHitTest := HTBOTTOMLEFT;   // #Ch RTL bug
//                Result := HTBOTTOMLEFT;
              end
              else
              begin
                FHitTest := HTBOTTOMRIGHT;
                Result := HTBOTTOMRIGHT;
              end
            else
            begin
              FHitTest := HTCAPTION;
              Result := HTCLIENT;
            end;
      end
      else
      begin
        FHitTest := Result;
        Result := HTCLIENT;
      end;
    end;
end;

procedure TdxBarControl.WMSize(var Message: TWMSize);
begin
  if IsDestroying then Exit;
  inherited;
  CalcLayout;
end;

procedure TdxBarControl.WMSizing(var Message: TMessage);
var
  ASize: TSize;
  NCSize: Integer;
begin
  inherited;
  if DockingStyle = dsNone then
    with Message, PRect(lParam)^ do
    begin
      case wParam of
        WMSZ_LEFT, WMSZ_RIGHT:
          begin
            NCSize := Bar.BarNCSizeX(dsNone);
            ASize := GetSizeForWidth(DockingStyle, Right - Left - NCSize);
            if wParam = WMSZ_LEFT then
              Left := Right - ASize.cx - NCSize
            else
              Right := Left + ASize.cx + NCSize;
            Bottom := Top + ASize.cy + Bar.BarNCSizeY(dsNone);
          end;
        WMSZ_TOP, WMSZ_BOTTOM:
          begin
            NCSize := Bar.BarNCSizeY(dsNone);
            ASize := GetSizeForHeight(DockingStyle, Bottom - Top - NCSize);
            Right := Left + ASize.cx + Bar.BarNCSizeX(dsNone);
            if wParam = WMSZ_TOP then
              Top := Bottom - ASize.cy - NCSize
            else
              Bottom := Top + ASize.cy + NCSize;
          end;
      else
        PRect(lParam)^ := BoundsRect;
        Result := 1;
      end;
      // against windows' bug:
      if Top < -15 then OffsetRect(PRect(lParam)^, 0, -15 - Top);
      Result := 1;
    end;
end;

procedure TdxBarControl.WMWindowPosChanging(var Message: TWMWindowPosChanging);

  procedure CalcCoords(const AWindowPos: TWindowPos; var ALeft, ATop, AWidth, AHeight: Integer);
  begin
    if AWindowPos.flags and SWP_NOMOVE = 0 then
    begin
      ALeft := AWindowPos.x;
      ATop := AWindowPos.y;
    end
    else
    begin
      ALeft := Left;
      ATop := Top;
    end;
    if AWindowPos.flags and SWP_NOSIZE = 0 then
    begin
      AWidth := AWindowPos.cx;
      AHeight := AWindowPos.cy;
    end
    else
    begin
      AWidth := Width;
      AHeight := Height;
    end;
  end;

var
  L, T, W, H: Integer;
  I: Integer;
  AIntersect: Boolean;
  P: TPoint;
  R, ABarRect, ARect: TRect;
begin
  inherited;
  if DockingStyle <> dsNone then Exit;
  if (Message.WindowPos^.flags and SWP_NOMOVE = 0) or
    (Message.WindowPos^.flags and SWP_NOSIZE = 0) then
  begin
    CalcCoords(Message.WindowPos^, L, T, W, H);

    ABarRect := Bounds(L, T, W, H);
    AIntersect := False;
    for I := 0 to Screen.MonitorCount - 1 do
    begin
      // begin BoundsRect
      P := Point(Screen.Monitors[I].Left, Screen.Monitors[I].Top);
      R := GetWorkArea(P);
      // end BoundsRect
      if IntersectRect(ARect, R, ABarRect) then
      begin
        AIntersect := True;
        Break;
      end;
    end;

    if not AIntersect then
    begin
      R := GetWorkArea(GetMouseCursorPos);
      with Message.WindowPos^ do
      begin
        with R do
        begin
          if L + W <= Left then
          begin
            x := Left;
            y := T;
            flags := flags and not SWP_NOMOVE;
          end;
          if T + H <= Top then
          begin
            x := L;
            y := Top;
            flags := flags and not SWP_NOMOVE;
          end;
          if L >= Right then
          begin
            x := Right - W;
            y := T;
            flags := flags and not SWP_NOMOVE;
          end;
          if T >= Bottom then
          begin
            x := L;
            y := Bottom - H;
            flags := flags and not SWP_NOMOVE;
          end;
        end;
      end;
    end;
  end;
end;

procedure TdxBarControl.CMEnabledChanged(var Message: TMessage);
begin
  inherited;
  if not InternallyLocked then
    RepaintBar;
end;

procedure TdxBarControl.CMFontChanged(var Message: TMessage);
begin
  UpdateCanvasFont;
  if not HandleAllocated then
    Exit;
  CalcDrawingConsts;
  if not InternallyLocked then
  begin
    SetMouseSelectedItem(nil);
    RepaintBar;
  end;
  inherited;
end;

procedure TdxBarControl.CreateParams(var Params: TCreateParams);
begin
  inherited CreateParams(Params);
  with Params do
  begin
    Style := WS_CLIPCHILDREN or WS_CLIPSIBLINGS;
    WindowClass.Style := CS_DBLCLKS or CS_HREDRAW or CS_VREDRAW;
    ExStyle := 0;
    if DockingStyle = dsNone then
    begin
      Style := (Style or WS_POPUP) and not WS_BORDER;
      WndParent := BarManager.Owner.Handle;
    end
    else
    begin
      Style := Style or WS_CHILD;
      WndParent := FDockControl.Handle;
    end;
  end;
end;

procedure TdxBarControl.CreateWnd;
begin
  if FMoving and InternallyLocked then
    if FDockingStyle = dsNone then
      WindowHandle := FFloatingHandle
    else
      WindowHandle := FDockedHandle
  else
    inherited;
  Text := GetCaption;
  SendMessage(Handle, WM_NCACTIVATE, WPARAM(True), 0);  // don't remove (AV in ntdll.dll)
end;

procedure TdxBarControl.Paint;
var
  APrevRegion: TcxRegion;
begin
  APrevRegion := Canvas.GetClipRegion;
  try
    inherited;
    DoPaint;
    if BarManager.IsUncustomizable then
    begin
      Canvas.SetClipRegion(APrevRegion, roSet, False);
      DrawDisablingHatch(Canvas.Handle, ClientRect);
    end;
  finally
    APrevRegion.Free;
  end;
end;

procedure TdxBarControl.WindowPosChanged(var Message: TWMWindowPosChanged);
begin
  inherited;
  if (FBar = nil) or InternallyLocked then
    Exit;
  FBar.ChangeDockingStyle(DockingStyle, DockControl);
  if not FBar.Bars.FScaling then
    SavePos;
  with Message.WindowPos^ do
  begin
    if ((flags and SWP_NOSIZE = 0) or (flags and SWP_NOMOVE = 0)) and (FQuickPopup <> nil) then
    begin
      FQuickPopup.OwnerBounds := MarkScreenRect;
      FQuickPopup.ResizeShadow;
      SendMessage(FQuickPopup.Handle, WM_NCPAINT, 0, 0);
    end;
    if (flags and SWP_NOSIZE <> 0) and (flags and SWP_NOMOVE = 0) and (FHasSizeGrip <> FBar.HasSizeGrip) then
      RebuildBar;
  end;
end;

procedure TdxBarControl.LayoutChanged;
begin
  if BarManager.CanShowRecentItems and (DockingStyle <> dsNone) then
    PostMessage(Handle, DXM_BAR_REPAINTBAR, 0, 0);
end;

procedure TdxBarControl.DoKeyDown(var Message: TWMKey);
begin
  case Message.CharCode of
    VK_ESCAPE:
      begin
        Message.CharCode := 0;
        HideAllByEscape;
      end;
    else
      inherited;
  end;
end;

procedure TdxBarControl.DoLButtonUp(var Message: TWMLButtonUp);
var
  P: TPoint;
  AButton: TdxBarMDIButton;
begin
  P := Point(Message.XPos, Message.YPos);
  if MDIButtonsOnBar and FIsMDIButtonPressed then
  begin
    ReleaseCapture;
    FIsMDIButtonPressed := False;
    FIsMouseOverMDIButton := False;
    RepaintMDIButtons;
    if not RealMDIButtonsOnBar then
    begin
      if PtInRect(RectMDI(mdibClose), P) then
        BarManager.DoCloseButtonClick;
    end
    else
    begin
      for AButton := Low(TdxBarMDIButton) to High(TdxBarMDIButton) do
        if PtInRect(RectMDI(AButton), P) then
        begin
          if AButton = FPressedMDIButton then
            BarManager.DoMDIButtonCommand(AButton);
          Break;
        end;
    end;
  end;
  inherited;
end;

procedure TdxBarControl.CalcControlsPositions;
begin
  inherited CalcControlsPositions;
  CalcItemRects(GetPaintType);
end;

procedure TdxBarControl.CalcRowItemRects;
var
  ARowSize, AFirstInRow, X, Y, ARowHeight, ABeginGroupSize, ASize, VerSize, AWidth, AHeight: Integer;
  AMultiLine, AVertical, ItemControlAlignApplied: Boolean;
  AItemLink: TdxBarItemLink;
  AItemLinkBounds: TDictionary<TdxBarItemLink, TRect>;

  function GetMDIButtonSize(AIsVertical: Boolean): Integer;
  begin
    if not MDIButtonsOnBar then
      Result := 0
    else
      if AIsVertical then
        Result := GetMDIHeight
      else
        Result := GetMDIWidth;
  end;

  procedure InitValues;
  begin
    X := 0;
    Y := 0;
    VerSize := 0;
    AItemLink := nil;
    AMultiLine := MultiLine;
    AVertical := Vertical;

    if AVertical then
      ASize := ClientHeight
    else
      ASize := ClientWidth;

    ARowSize := ASize;

    if DockingStyle <> dsNone then
      Dec(ASize, GetMarkSize);

    if AMultiLine then
    begin
      if AVertical then
        VerSize := ClientWidth;
      ARowHeight := 0;
      AFirstInRow := 0;
    end
    else
    begin
      if AVertical then
        ARowHeight := ClientWidth
      else
        ARowHeight := ClientHeight;
      Dec(ASize, GetMDIButtonSize(AVertical));
    end;
  end;

  procedure InitItemControlValues;
  var
    ASize: TSize;
  begin
    AItemLink.Control.FLastInRow := False;
    ASize := AItemLink.Control.GetRealSize;
    if AVertical then
    begin
      AWidth := ASize.cy;
      AHeight := ASize.cx;
    end
    else
    begin
      AWidth := ASize.cx;
      AHeight := ASize.cy;
    end;
    if AItemLink.BeginGroup and (X > 0) then
      ABeginGroupSize := BeginGroupSize
    else
      ABeginGroupSize := 0;
  end;

  function ItemControlBreaksRow: Boolean;
  begin
    Result := ((X > 0) or not AMultiLine and CanHideAllItemsInSingleLine) and (X + ABeginGroupSize + AWidth > ASize) or
      AMultiLine and AItemLink.Control.FBreakingRow;
  end;

  procedure ArrangeControlsOnRow(ALastInRow: Integer);
  var
    I: Integer;
    ALink: TdxBarItemLink;
    AItemRect: TRect;
  begin
    for I := AFirstInRow to ALastInRow do
    begin
      ALink := ItemLinks.VisibleItems[I];
      AItemRect := AItemLinkBounds[ALink];
      if AVertical then
        AItemRect := cxRectOffset(AItemRect, -(ARowHeight - cxRectWidth(AItemRect)) div 2, 0)
      else
        AItemRect := cxRectOffset(AItemRect, 0, (ARowHeight - cxRectHeight(AItemRect)) div 2);
      AItemLinkBounds.AddOrSetValue(ALink, AItemRect);
      ALink.RowHeight := ARowHeight;
    end;
    AFirstInRow := ALastInRow + 1;
  end;

  function GetItemControlRect: TRect;

    procedure ApplyAlign;

      procedure CheckSize;
      var
        AMDISize: Integer;
      begin
        if AMultiLine and (AItemLink.Control.Align <> iaLeft) and MDIButtonsOnBar then
        begin
          if AVertical then
            AMDISize := GetMDIHeight
          else
            AMDISize := GetMDIWidth;
          if Result.Right + AMDISize <= ASize then
            Dec(ASize, AMDISize);
        end;
      end;

    begin
      CheckSize;
      ItemControlAlignApplied := True;
      case AItemLink.Control.Align of
        iaLeft:
          ItemControlAlignApplied := False;
        iaCenter:
          if AVertical then
            OffsetRect(Result, 0, (ASize - Result.Bottom) div 2)
          else
            OffsetRect(Result, (ASize - Result.Right) div 2, 0);
        iaRight:
          if AVertical then
            OffsetRect(Result, 0, ASize - Result.Bottom)
          else
            OffsetRect(Result, ASize - Result.Right, 0);
        iaClient:
          with Result do
            if AVertical then
            begin
              Bottom := ASize;
              if Bottom - Top < AItemLink.Control.MinWidth then
                Bottom := Top + AItemLink.Control.MinWidth;
            end
            else
            begin
              Right := ASize;
              if Right - Left < AItemLink.Control.MinWidth then
                Right := Left + AItemLink.Control.MinWidth;
            end;
      end;
    end;

  begin
    if AMultiLine then
      if AVertical then
        Result := Bounds(VerSize - Y - AHeight, X + ABeginGroupSize, AHeight, AWidth)
      else
        Result := Bounds(X + ABeginGroupSize, Y, AWidth, AHeight)
    else
      case DockingStyle of
        dsTop, dsBottom:
          Result :=
            Bounds(X + ABeginGroupSize, (ARowHeight - AHeight) div 2, AWidth, AHeight);
        dsLeft, dsRight:
          Result :=
            Bounds((ARowHeight - AHeight) div 2, X + ABeginGroupSize, AHeight, AWidth);
      end;
    ApplyAlign;
  end;

  procedure CalcX(ALinkIndex: Integer);
  begin
    if ItemControlAlignApplied then
    begin
      X := ASize;
      if ALinkIndex < ItemLinks.VisibleItemCount - 1 then
        FTruncated := True;
    end
    else
      Inc(X, ABeginGroupSize + AWidth);
  end;

var
  I: Integer;
begin
  AItemLinkBounds := TDictionary<TdxBarItemLink, TRect>.Create;
  try
    InitValues;
    for I := 0 to ItemLinks.VisibleItemCount - 1 do
    begin
      AItemLink := ItemLinks.VisibleItems[I];
      if AItemLink.Control = nil then
        AItemLink.CreateControl;
      AItemLinkBounds.AddOrSetValue(AItemLink, AItemLink.ItemRect);
      InitItemControlValues;
      if ItemControlBreaksRow then
        if AMultiLine then
        begin
          ItemLinks.VisibleItems[I - 1].Control.FLastInRow := True;
          ArrangeControlsOnRow(I - 1);
          Inc(Y, ARowHeight + ABeginGroupSize);
          X := 0;
          ABeginGroupSize := 0;
          ARowHeight := 0;
        end
        else
        begin
          if I = 0 then
            AItemLink := nil
          else
            AItemLink := ItemLinks.VisibleItems[I - 1];
          Break;
        end;
      AItemLinkBounds.AddOrSetValue(AItemLink, GetItemControlRect);
      AItemLink.RowHeight := ARowHeight;
      CalcX(I);
      if ARowHeight < AHeight then ARowHeight := AHeight;
    end;
    if AItemLink <> nil then
      AItemLink.Control.FLastInRow := True;
    if AMultiLine then
      ArrangeControlsOnRow(ItemLinks.VisibleItemCount - 1);

    for I := 0 to ItemLinks.VisibleItemCount - 1 do
    begin
      AItemLink := ItemLinks.VisibleItems[I];
      if AItemLinkBounds.ContainsKey(AItemLink) then
        if UseRightToLeftAlignment and not Vertical then
          AItemLink.ItemRect := TdxRightToLeftLayoutConverter.ConvertRect(AItemLinkBounds[AItemLink], cxRect(cxSize(ARowSize, 0)))
        else
          AItemLink.ItemRect := AItemLinkBounds[AItemLink];
    end;
  finally
    AItemLinkBounds.Free;
  end;
end;

procedure TdxBarControl.CalcDrawingConsts;
begin
  inherited CalcDrawingConsts;
  FMDIButtonWidth := dxGetSystemMetrics(SM_CXMENUSIZE, ScaleFactor) - 2;
  FMDIButtonHeight := dxGetSystemMetrics(SM_CYMENUSIZE, ScaleFactor) - 2 * 2;
  FMarkSize := Painter.MarkSizeX(Self);

  dxAdjustToTouchableSize(FMarkSize, ScaleFactor);
  dxAdjustToTouchableSize(FMDIButtonWidth, ScaleFactor);
  dxAdjustToTouchableSize(FMDIButtonHeight, ScaleFactor);
end;

procedure TdxBarControl.CalcDragOverParameters(const ACursorPos: TPoint;
  var ADragOverItemLink: TdxBarItemLink;
  var AIsBeginGroup, AIsFirstPart, AIsVerticalDirection: Boolean);

  function GetRowLastItemControl(const ACursorPos: TPoint): TdxBarItemControl;
  var
    AControl: TdxBarItemControl;
    AItemRect: TRect;
    AVertical: Boolean;
    I: Integer;
  begin
    Result := nil;
    for I := 0 to ItemLinks.VisibleItemCount - 1 do
    begin
      AControl := ItemLinks.VisibleItems[I].Control;
      if AControl.CanCustomize and AControl.LastInRow then
      begin
        AItemRect := GetItemRect(AControl);
        AVertical := Vertical;
        if AVertical and (AItemRect.Left <= ACursorPos.X) and (ACursorPos.X < AItemRect.Right) or
          not AVertical and (AItemRect.Top <= ACursorPos.Y) and (ACursorPos.Y < AItemRect.Bottom) then
        begin
          Result := AControl;
          Break;
        end;
      end;
    end;
  end;

  function GetRowFirstItemControl(ARowLastItemControl: TdxBarItemControl): TdxBarItemControl;
  var
    AControl: TdxBarItemControl;
    I: Integer;
  begin
    Result := ARowLastItemControl;
    for I := ARowLastItemControl.ItemLink.VisibleIndex - 1 downto 0 do
    begin
      AControl := ItemLinks.VisibleItems[I].Control;
      if not AControl.CanCustomize then
        Continue;
      if AControl.LastInRow then
        Break
      else
        Result := AControl;
    end;
  end;

var
  AControl: TdxBarItemControl;
  AItemRect: TRect;
  AVertical: Boolean;
begin
  inherited CalcDragOverParameters(ACursorPos, ADragOverItemLink,
    AIsBeginGroup, AIsFirstPart, AIsVerticalDirection);
  if (ADragOverItemLink <> nil) or not PtInRect(ClientRect, ACursorPos) then
    Exit;
  AControl := GetRowLastItemControl(ACursorPos);
  if AControl <> nil then
  begin
    AItemRect := GetItemRect(AControl);
    AVertical := Vertical;
    if AVertical and (ACursorPos.Y < AItemRect.Top) or
      not AVertical and (ACursorPos.X < AItemRect.Left) then
    begin
      AIsFirstPart := True;
      if AControl.Align in [iaCenter, iaRight] then
        ADragOverItemLink := AControl.ItemLink
      else
        ADragOverItemLink := GetRowFirstItemControl(AControl).ItemLink;
    end
    else
      ADragOverItemLink := AControl.ItemLink;
  end;
end;

function TdxBarControl.CanAlignControl(AControl: TdxBarItemControl): Boolean;
begin
  with AControl.ItemLink do
    Result := Bar.UseRestSpace and (CanVisibleIndex = Owner.CanVisibleItemCount - 1);
end;

function TdxBarControl.CanCallInheritedNCCalcSize: Boolean; // obsolete
begin
  Result := (DockingStyle <> dsNone) or not Flat;
end;

function TdxBarControl.CanCustomizing: Boolean;
begin
  Result := inherited CanCustomizing or FBar.AllowCustomizing;
end;

function TdxBarControl.CanHideAllItemsInSingleLine: Boolean;
begin
  Result := False;
end;

function TdxBarControl.CanMoving: Boolean;
begin
  Result := Bar.CanMoving;
end;

function TdxBarControl.CanBeFocused: Boolean;
begin
  Result := IsWindowEnabled and IsWindowVisible(Handle);
end;

function TdxBarControl.CanProcessShortCut: Boolean;
begin
  Result := CanBeFocused;
end;

function TdxBarControl.CanSetMouseSelectedItem(
  const P: TPoint; AItemControl: TdxBarItemControl): Boolean;
begin
  Result := not IsActive or (AItemControl <> nil);
end;

function TdxBarControl.CanUpdateControlByMouseOnLostFocus: Boolean;
begin
  Result := True;
end;

function TdxBarControl.GetCaptionRect: TRect;
begin
  Result := dxMapWindowRect(0, Handle, cxRectOffset(GetCaptionNCRect, WindowRect.TopLeft));
end;

procedure TdxBarControl.CheckMarkState(const P: TPoint);
begin
  if IsMarkAccessible and MouseOnMark(P) then
    if MarkState = msPressed then
      MarkState := msSelected
    else
      MarkState := msPressed;
end;

function TdxBarControl.CloseButtonRect: TRect;
var
  ASize: TSize;
  RW, RH: Integer;
  R: TRect;
begin
  if HasCloseButton then
  begin
    R := GetCaptionRect;
    Result := R;
    Result.Left := Result.Right - Painter.BarCaptionSize(ScaleFactor);
    ASize := Painter.BarCloseButtonSize(ScaleFactor);
    RW := cxRectWidth(Result);
    if ASize.cx < RW then
    begin
      Result.Left := Result.Left + (RW div 2) - (ASize.cx div 2);
      Result.Right := Result.Left + ASize.cx;
    end;
    RH := cxRectHeight(Result);
    if ASize.cy < RH then
    begin
      Result.Top := Result.Top + (RH div 2) - (ASize.cy div 2);
      Result.Bottom := Result.Top + ASize.cy;
    end;
    if UseRightToLeftAlignment then
      Result := TdxRightToLeftLayoutConverter.ConvertRect(Result, R);
  end
  else
    Result := cxEmptyRect;
end;

function TdxBarControl.CloseButtonRectNC: TRect;
begin
  Result := dxMapWindowRect(Handle, 0, CloseButtonRect);
  OffsetRect(Result, -WindowRect.Left, -WindowRect.Top);
end;

function TdxBarControl.CheckLockUpdate: Boolean;
begin
  Result := inherited CheckLockUpdate;
  if Result and (Bar <> nil) then
    Bar.DoChanged;
end;

procedure TdxBarControl.DoBarGetFocus(ASelectedItem: TdxBarItemControl);
var
  AControl: TWinControl;
  ItemLink: TdxBarItemLink;
begin
  AControl := FindControl(cxWindowFromPoint(GetMouseCursorPos));
  if (AControl is TCustomdxBarControl) and (AControl <> Self) then
    TCustomdxBarControl(AControl).MouseLeave;

  dxBar.SendCancelMode;

  FBeforeBarGetFocusFocusedWnd := GetFocus;

  if not IsCustomizing and not (IsPopup and ParentBar.Focused) and (dxBarGetParentPopupWindow(Self, True) = nil) then
    dxSetZOrder(MasterForm.Handle, HWND_TOP, True);

  if ASelectedItem = nil then
  begin
    ItemLink := nil;
    repeat
      ItemLink := ItemLinks.Next(ItemLink);
    until (ItemLink = nil) or (ItemLink.Control <> nil) and
      not (ItemLink.Control is TSystemMenuSubItemControl); // !!!
    if ItemLink <> nil then
      ASelectedItem := ItemLink.Control;
  end;

  inherited DoBarGetFocus(ASelectedItem);

  if not IsFocused then
  begin
    dxFreeAndNilObjectLink(FPrevFocusedBarControlLink);
    if BarManager.FFocusedBarControl <> nil then
      FPrevFocusedBarControlLink := cxAddObjectLink(BarManager.FFocusedBarControl);
    BarManager.FFocusedBarControl := Self;
  end;
end;

procedure TdxBarControl.DoBarLostFocus;
begin
  if (FPrevFocusedBarControlLink <> nil) and (FPrevFocusedBarControlLink.Ref <> nil) then
  begin
    BarManager.FFocusedBarControl := TCustomdxBarControl(FPrevFocusedBarControlLink.Ref);
    dxFreeAndNilObjectLink(FPrevFocusedBarControlLink);
  end
  else
    BarManager.FFocusedBarControl := nil;

  inherited DoBarLostFocus;

  if CanUpdateControlByMouseOnLostFocus then
    BarManager.UpdateControlByMouse(nil);

  if Application.Active and IsFormActive(ParentForm) and  // -> bug with toolbars' hiding (without Application.Active)
    IsWindowVisible(FBeforeBarGetFocusFocusedWnd) then
    Windows.SetFocus(FBeforeBarGetFocusFocusedWnd);
end;

procedure TdxBarControl.DoBarMouseDown(Button: TMouseButton; Shift: TShiftState;
  const APoint: TPoint; AItemControl: TdxBarItemControl; APointInClientRect: Boolean);

  function CheckMDIButton(AButton: TdxBarMDIButton): Boolean;
  begin
    Result := PtInRect(RectMDI(AButton), APoint);
    if Result then
    begin
      FIsMDIButtonPressed := True;
      FIsMouseOverMDIButton := True;
      FPressedMDIButton := AButton;
      FSelectedMDIButton := FPressedMDIButton;
      DrawMDIButtons([AButton]);
      SetCapture(Handle);
    end
  end;

var
  AButton: TdxBarMDIButton;
  R: TRect;
begin
  case Button of
    mbLeft:
      begin
      // !!!
        if not BarManager.HideFloatingBarsWhenInactive and (not IsInternal and (DockingStyle = dsNone)) then
          SetActiveWindow(BarManager.Owner.Handle);
      end;
    mbRight:
      ReleaseCapture;
  end;

  inherited;

  if not BarControlExists(Self) then Exit;

  case Button of
    mbLeft:
      begin
        if MDIButtonsOnBar and not BarManager.IsCustomizing then
          if RealMDIButtonsOnBar then
            for AButton := Low(TdxBarMDIButton) to High(TdxBarMDIButton) do
              if MDIButtonEnabled(AButton, MF_DISABLED or MF_GRAYED) and
                CheckMDIButton(AButton) then Exit
              else
          else
            if CheckMDIButton(mdibClose) then Exit;

        if FHitTest = HTCAPTION then
        begin
          R := WindowRect;
          RX.X := GetMouseCursorPos.X - R.Left;
          RY.X := GetMouseCursorPos.Y - R.Top;
          RX.Y := R.Right - R.Left;
          RY.Y := R.Bottom - R.Top;
          FBar.Bars.Moving(Self);
        end
        else
        begin
          CheckMarkState(APoint);
          if not IsCustomizing and not APointInClientRect then
            SendMessage(Handle, WM_NCLBUTTONDOWN, FHitTest, dxPointToLParam(GetMouseCursorPos));
        end;
      end;
  end;
end;

procedure TdxBarControl.DoBarMouseLeave;
begin
  inherited;
  if not IsActive then
  begin
    CloseButtonState := msNone;
    // MDI
    if MDIButtonsOnBar then
    begin
      FIsMouseOverMDIButton := False;
      RepaintMDIButtons;
    end;
  end
  else
    if SelectedControl is TdxBarButtonControl then
      SelectedControl.Repaint;
end;

procedure TdxBarControl.DoBarMouseMove(Shift: TShiftState; const APoint: TPoint;
  AItemControl: TdxBarItemControl);
var
  PrevIsMouseOverMDIButton: Boolean;
  PrevSelectedMDIButton: TdxBarMDIButton;
  AButton: TdxBarMDIButton;
  AButtons: TdxBarMDIButtons;
  AChangeMark: Boolean;
begin
  if FIsMDIButtonPressed then
  begin
    PrevIsMouseOverMDIButton := FIsMouseOverMDIButton;
    FIsMouseOverMDIButton := PtInRect(RectMDI(FPressedMDIButton), APoint);
    if FIsMouseOverMDIButton <> PrevIsMouseOverMDIButton then
      DrawMDIButtons([FPressedMDIButton]);
  end
  else
  begin
    // check MDI
    if MDIButtonsOnBar then
    begin
      PrevIsMouseOverMDIButton := FIsMouseOverMDIButton;
      PrevSelectedMDIButton := FSelectedMDIButton;
      FIsMouseOverMDIButton := False;
      if not RealMDIButtonsOnBar then
      begin
        if MDIButtonEnabled(mdibClose, MF_GRAYED) and
          PtInRect(RectMDI(mdibClose), APoint) then
        begin
          FIsMouseOverMDIButton := True;
          FSelectedMDIButton := mdibClose;
        end
      end
      else
      begin
        for AButton := Low(TdxBarMDIButton) to High(TdxBarMDIButton) do
          if MDIButtonEnabled(AButton, MF_GRAYED) and
            PtInRect(RectMDI(AButton), APoint) then
          begin
            FIsMouseOverMDIButton := True;
            FSelectedMDIButton := AButton;
            Break;
          end;
      end;
      if (FIsMouseOverMDIButton <> PrevIsMouseOverMDIButton) or
        (FSelectedMDIButton <> PrevSelectedMDIButton) then
      begin
        AButtons := [PrevSelectedMDIButton];
        if PrevIsMouseOverMDIButton then
          FMDIButtonFadingHelper[PrevSelectedMDIButton].FadeOut;
        if FIsMouseOverMDIButton then
          FMDIButtonFadingHelper[FSelectedMDIButton].FadeIn;
        if FSelectedMDIButton <> PrevSelectedMDIButton then
          AButtons := AButtons + [FSelectedMDIButton];
        DrawMDIButtons(AButtons);
      end;
    end;

    AChangeMark := False;
    if not NotHandleMouseMove then
    begin
      UpdateCaptionButtons(cxPointOffset(APoint, NCOffset));
      if ActiveBarControl = nil then
      begin
        if Painter.BarAllowQuickCustomizing and MarkExists and (MarkState <> msPressed) then
          if MouseOnMark(APoint) then
            MarkState := msSelected
          else
            AChangeMark := True;

        if HasCloseButton and Painter.BarAllowHotTrack then
          if PtInRect(CloseButtonRect, APoint) then
            CloseButtonState := msSelected
          else
            CloseButtonState := msNone;
      end;
    end;
    inherited;
    if AChangeMark then
      MarkState := msNone;
  end;
end;

procedure TdxBarControl.DoHideAll(AReason: TdxBarCloseUpReason);
begin
  BarLostFocus;
  inherited;
end;

procedure TdxBarControl.DoRepaintBar(ARecreateControls: Boolean);
var
  ASize: TSize;
begin
  inherited DoRepaintBar(ARecreateControls);
  if DockingStyle = dsNone then
  begin
    if HandleAllocated then
    begin
      ASize := GetSizeForWidth(DockingStyle, ClientWidth);
      ClientWidth  := ASize.cx;
      ClientHeight := ASize.cy;
    end;
    CalcLayout;
  end
  else
    FDockControl.UpdateDock;
  //Repaint;

  if IsWindowVisible(Handle) then //!!!lcm
  begin
    Invalidate;
    if BarManager.IsUncustomizable then
      SendMessage(Handle, WM_NCPAINT, 1, 0)
    else
      if IsTransparent then
        SendMessage(Handle, WM_NCPAINT, 0, 0);
  end;
end;

procedure TdxBarControl.DoSetIsActive(AValue: Boolean);
begin
  if not AValue then
  begin
    if IsCustomizing and (SelectedControl <> nil) then
      SetMouseSelectedItem(nil);
    if IsActive and (SelectedControl is TdxBarButtonControl) and
      TdxBarButtonControl(SelectedControl).DroppedDown then
      SelectedControl.ControlInactivate(True);
    if IsDowned then
    begin
      IsDowned := False;
      if not IsCustomizing then {HideAll;//}BarLostFocus;
    end;
  end;
  inherited;

  BarLostFocus; // !!!
end;

procedure TdxBarControl.FocusItemControl(AItemControl: TdxBarItemControl);
var
  AProcessedByItemControl: Boolean;
  ALinkSelf: TcxObjectLink;
begin
  if (AItemControl <> nil) and AItemControl.Enabled and AItemControl.HotPartWantMouse then
  begin
    AProcessedByItemControl := False;
    ALinkSelf := cxAddObjectLink(Self);
    try
      if IsActive and not ((bboNeedsFocusWhenActive in BehaviorOptions) and not IsFocused) then
        AItemControl.ControlGetFocus(AItemControl = SelectedControl, AProcessedByItemControl)
      else
        BarGetFocus(AItemControl);

      if (ALinkSelf.Ref = nil) or AProcessedByItemControl then
        Exit;
    finally
      cxRemoveObjectLink(ALinkSelf);
    end;

    if IsActive and not AItemControl.HasWindow then
      IsDowned := True;

    if (SelectedControl <> nil) and SelectedControl.NeedCaptureMouse then
    begin
      FClickedControl := AItemControl;
      SetCapture(Handle);
      AItemControl.Repaint;
    end;
  end
  else
    IsActive := False;

  inherited;
end;

function TdxBarControl.GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass;
begin
  Result := TdxBarControlAccessibilityHelper;
end;

const
  CloseButtonID = -2;

function TdxBarControl.GetCaptionButtonIndex(const APoint: TPoint): Integer;
begin
  if PtInRect(CloseButtonRectNC, APoint) then
    Result := CloseButtonID
  else
    Result := inherited GetCaptionButtonIndex(APoint);
end;

procedure TdxBarControl.CaptionButtonClick(AIndex: Integer);
var
  ABar: TdxBar;
begin
  if AIndex = CloseButtonID then
  begin
    ABar := FBar;
    Bar.Visible := False;
    ABar.BarManager.DesignerModified;
    ABar.BarManager.DoBarClose(ABar);
  end
  else
    inherited;
end;

procedure TdxBarControl.UpdateCaptionButtons(const AMousePos: TPoint; AMousePressed: Boolean; AActiveButtonID: Integer);
begin
  if AActiveButtonID = CloseButtonID then
    if GetCaptionButtonIndex(AMousePos) = CloseButtonID then
      if AMousePressed then
        CloseButtonState := msPressed
      else
        CloseButtonState := msSelected
    else
      if AMousePressed then
        CloseButtonState := msSelected
      else
        CloseButtonState := msNone
  else
    inherited;
end;

function TdxBarControl.GetAlphaBlendValue: Byte;
begin
  if {not FMovingChanging and }(DockingStyle = dsNone) then
    Result := 200
  else
    Result := 255;
end;

function TdxBarControl.GetBackgroundBitmap: TGraphic;
begin
  Result := Bar.BackgroundBitmap;
end;

function TdxBarControl.GetBeginGroupSize: Integer;
begin
  Result := Painter.BarBeginGroupSize;
end;

function TdxBarControl.GetCol: Integer;
var
  I, J: Integer;
begin
  Result := 0;
  if (FBar = nil) or (FBar.Bars = nil) or (DockingStyle = dsNone) or
    (FDockControl = nil) then Exit;
  with FDockControl do
    for I := 0 to FRowList.Count - 1 do
      for J := 0 to Rows[I].ColCount - 1 do
        if Rows[I].Cols[J].BarControl = Self then
        begin
          Result := J;
          Exit;
        end;
end;

procedure TdxBarControl.WndProc(var Message: TMessage);
var
  AStyle: TdxBarDockingStyle;
  ADockControl: TdxDockControl;
begin
  FCurrentMessage := Message;

  if Message.Msg = WM_SETFOCUS then
    Exit;
  if (FIsMDIButtonPressed or FIsMouseOverMDIButton) and (Message.Msg = WM_CANCELMODE) then
  begin
    ReleaseCapture;
    FIsMDIButtonPressed := False;
    FIsMouseOverMDIButton := False;
    RepaintMDIButtons;
  end;
  if (Message.Msg = WM_LBUTTONDBLCLK) and (FHitTest = HTCAPTION) then
  begin
    if not BarManager.Designing then
      with Bar do
      begin
        ADockControl := nil;
        if DockingStyle = dsNone then
          if DockedDockingStyle <> dsNone then
          begin
            AStyle := DockedDockingStyle;
            ADockControl := DockedDockControl;
            if ADockControl = nil then
              ADockControl := Bars.DockControls[AStyle];
          end
          else
          begin
            AStyle := dsTop;
            ADockControl := Bars.DockControls[dsTop];
          end
        else
          AStyle := dsNone;
        if BarManager.DoDocking(Bar, AStyle, ADockControl) then
        begin
          Visible := False;
          if DockingStyle = dsNone then
          begin
            ChangeDockingStyle(AStyle, ADockControl);
            if DockedDockingStyle = dsNone then
            begin
              OneOnRow := True;
              Row := ADockControl.RowCount;
            end;
          end
          else
            DockingStyle := dsNone;
          Visible := True;
        end;
      end;
    Exit;
  end;
  inherited;
end;

function TdxBarControl.GetDockCol: TdxDockCol;
var
  I, J: Integer;
begin
  Result := nil;
  if (FBar = nil) or (FBar.Bars = nil) or (DockingStyle = dsNone) or
    (FDockControl = nil) then Exit;
  with FDockControl do
    for I := 0 to RowCount - 1 do
      for J := 0 to Rows[I].ColCount - 1 do
        if Rows[I].Cols[J].BarControl = Self then
        begin
          Result := Rows[I].Cols[J];
          Exit;
        end;
end;

function TdxBarControl.GetCurrentCursor(const AMousePos: TPoint): TCursor;
begin
  if not Moving and CanMoving and PtInRect(GetSizeAllCursorBounds, AMousePos) then
    Result := crSizeAll
  else
    Result := inherited;
end;

function TdxBarControl.GetHintItemText: string;
begin
  Result := GetMoreButtonsHint;
end;

function TdxBarControl.GetIsMainMenu: Boolean;
begin
  Result := (Bar <> nil) and Bar.IsMainMenu;
end;

function TdxBarControl.GetIsStatusBar: Boolean;
begin
  Result := (Bar <> nil) and Bar.IsStatusBar;
end;

function TdxBarControl.GetMarkAccessibilityHelperClass: TdxBarAccessibilityHelperClass;
begin
  Result := TdxBarControlMarkAccessibilityHelper;
end;

function TdxBarControl.GetMarkDrawState: TdxBarMarkState;
begin
  if MarkIAccessibilityHelper.IsSelected then
    Result := msSelected
  else
    Result := inherited GetMarkDrawState;
end;

function TdxBarControl.GetMoreButtonsHint: string;
begin
  Result := cxGetResourceString(@dxSBAR_MOREBUTTONS);
end;

function TdxBarControl.GetMultiLine: Boolean;
begin
  Result := (DockingStyle = dsNone) or FBar.MultiLine;
end;

function TdxBarControl.GetQuickControlClass: TdxBarPopupControlClass;
begin
  Result := TdxBarQuickControl;
end;

function TdxBarControl.GetRow: Integer;
var
  I, J: Integer;
begin
  Result := 0;
  if (FBar = nil) or (FBar.Bars = nil) or (DockingStyle = dsNone) or
    (FDockControl = nil) then Exit;
  with FDockControl do
    for I := 0 to RowCount - 1 do
      for J := 0 to Rows[I].ColCount - 1 do
        if Rows[I].Cols[J].BarControl = Self then
        begin
          Result := I;
          Exit;
        end;
end;

function TdxBarControl.GetViewInfoClass: TCustomdxBarControlViewInfoClass;
begin
  Result := TdxBarControlViewInfo;
end;

function TdxBarControl.GetNCDrawingDC(AUpdatedRgn: HRGN): HDC;
var
  CR: TRect;
begin
  FDrawBitmap := nil;
  FPrevClipRgn := nil;
  if BarManager.IsUncustomizable then
  begin
    if AUpdatedRgn = 1 then
      FPrevClipRgn := TcxRegion.Create(0, 0, Width, Height)
    else
    begin
      FPrevClipRgn := TcxRegion.Create;
      CombineRgn(FPrevClipRgn.Handle, FPrevClipRgn.Handle, AUpdatedRgn, RGN_OR);
      FPrevClipRgn.Offset(-WindowRect.Left, -WindowRect.Top);
      FPrevClipRgn.Combine(cxRect(0, 0, Width, Height), roIntersect);
    end;

    CR := cxRectOffset(ClientRect, GetClientOffset);
    FPrevClipRgn.Combine(CR, roSubtract);

    FDrawBitmap := cxCreateBitmap(Width, Height, cxDoubleBufferedBitmapPixelFormat);
    Result := FDrawBitmap.Canvas.Handle;

    SelectClipRgn(Result, FPrevClipRgn.Handle);
  end
  else
    Result := inherited GetNCDrawingDC(AUpdatedRgn);
end;

procedure TdxBarControl.ReleaseNCDrawingDC(ADC: HDC);
begin
  FreeAndNil(FDrawBitmap);
  FreeAndNil(FPrevClipRgn);
  if not BarManager.IsUncustomizable then
    inherited;
end;

function TdxBarControl.GetMasterForm: TCustomForm;
begin
  if DockControl <> nil then
    Result := DockControl.MasterForm
  else
    Result := BarManager.MasterForm;
end;

function TdxBarControl.GetParentForm: TCustomForm;
begin
  if DockControl <> nil then
    Result := DockControl.ParentForm
  else
    Result := BarManager.ParentForm;
end;

function TdxBarControl.GetSelectableObject: TPersistent;
begin
  Result := Bar;
end;

function TdxBarControl.AllowQuickCustomizing: Boolean;
begin
  Result := Bar.AllowQuickCustomizing;
end;

procedure TdxBarControl.HandleQuickAccessSubItemPopup(Sender: TObject);
begin
  BarDesignController.ClearOwnedItems(TdxBarSubItem(Sender).ItemLinks);
  InitAddRemoveSubItemPopup(TdxBarSubItem(Sender).ItemLinks);
end;

procedure TdxBarControl.InitQuickControl(AQuickControl: TdxBarPopupControl);
var
  I: Integer;
  AItemLink: TdxBarItemLink;
begin
  for I := 0 to ItemLinks.CanVisibleItemCount - 1 do
  begin
    AItemLink := ItemLinks.CanVisibleItems[I];
    if (AItemLink.VisibleIndex = -1) or
      (AItemLink.Control <> nil) and IsRectEmpty(AItemLink.ItemRect) then
    begin
      with AQuickControl.ItemLinks.Add do
      begin
        Assign(AItemLink);
        FOriginalItemLink := AItemLink;
      end;
    end;
  end;

  if AllowQuickCustomizing then
    InitQuickCustomizeItemLinks(AQuickControl);
end;

procedure TdxBarControl.InitQuickCustomizeItemLinks(AQuickControl: TdxBarPopupControl);
var
  AItemLink: TdxBarItemLink;
  AAddRemoveSubItem: TdxBarSubItem;
begin
  AItemLink := AQuickControl.ItemLinks.AddItem(TdxBarQuickAccessItem);
  BarDesignController.AddInternalItem(AItemLink.Item, AQuickControl.InternalItems);
  AItemLink.Item.Caption := cxGetResourceString(@dxSBAR_ADDREMOVEBUTTONS);
  AItemLink.BeginGroup := True;
  AAddRemoveSubItem := TdxBarSubItem(AItemLink.Item);
//    AAddRemoveSubItem.Enabled := AllowQuickCustomizing;
  AAddRemoveSubItem.OnPopup := HandleQuickAccessSubItemPopup;
end;

procedure TdxBarControl.InitAddRemoveSubItemPopup(AItemLinks: TdxBarItemLinks);
var
  I: Integer;
  AItemLink: TdxBarItemLink;
  AllowReset: Boolean;
  AQuickCustItem: TdxBarQuickCustItem;
begin
  AQuickCustItem := TdxBarQuickCustItem.Create(BarManager.Owner);
  BarDesignController.AddInternalItem(AQuickCustItem);

  for I := 0 to ItemLinks.AvailableItemCount - 1 do
  begin
    AItemLink := ItemLinks.AvailableItems[I];
    if (AItemLink.Control = nil) or AItemLink.Control.CanCustomize then
      with AItemLinks.Add do
      begin
        Item := AQuickCustItem;
        Data := TdxNativeInt(AItemLink);
      end;
  end;
  // add reset button
  AllowReset := BarManager.CanReset and Bar.CanReset;
  if AllowReset then
    BarDesignController.AddInternalItem(AItemLinks, TdxBarQuickCustExtButton,
      cxGetResourceString(@dxSBAR_RESETTOOLBAR), ResetToolbarClick).BeginGroup := True;
  // add customize button
  BarDesignController.AddCustomizeItem(AItemLinks, TdxBarQuickCustExtButton, not AllowReset);
end;

procedure TdxBarControl.ResetToolbarClick(Sender: TObject);
begin
  Bar.ResetWithConfirmation;
end;

function TdxBarControl.GetMinWidth(AStyle: TdxBarDockingStyle): Integer;
var
  I, AWidth: Integer;
begin
  Result := 0;
  if (AStyle in [dsLeft, dsRight]) or MultiLine then
  begin
    if ItemLinks.CanVisibleItemCount <> 0 then
    begin
      for I := 0 to ItemLinks.CanVisibleItemCount - 1 do
        Result := Max(Result, ItemLinks.CanVisibleItems[I].Control.Width);
    end
    else
      if AStyle <> dsNone then
        Result := Painter.GetButtonWidth(BarManager.GetGlyphSize(ScaleFactor), TextSize, ScaleFactor);

    if MDIButtonsOnBar then
      Result := Max(Result, GetMDIWidth);

    if AStyle = dsNone then
    begin
      AWidth := GetMarkSize;
      if HasCloseButton then
        Inc(AWidth, Painter.BarCloseButtonSize(ScaleFactor).cx);
      Result := Max(Result, Max(AWidth, dxBarFloatToolbarMinWidth));
    end;
  end
  else
  begin
    if ItemLinks.CanVisibleItemCount = 0 then
      Result := Painter.GetButtonWidth(BarManager.GetGlyphSize(ScaleFactor), TextSize, ScaleFactor)
    else
    begin
      ItemLinks.RecentItemCount := 1;
      Result := ItemLinks.VisibleItems[0].Control.Width;
      ItemLinks.RestoreRecentItemCount;
    end;
    if MDIButtonsOnBar then
      Inc(Result, GetMDIWidth);
  end;
  Inc(Result, cxMarginsWidth(GetItemsRectOffset));
  if Horizontal then
    Inc(Result, GetMarkSize);
  dxAdjustToTouchableSize(Result, ScaleFactor);
end;

function TdxBarControl.GetMinHeight(AStyle: TdxBarDockingStyle): Integer;
var
  I: Integer;
begin
  if (AStyle in [dsTop, dsBottom]) or MultiLine then
  begin
    if ItemLinks.CanVisibleItemCount = 0 then
      Result := Painter.GetButtonHeight(BarManager.GetGlyphSize(ScaleFactor), TextSize, ScaleFactor)
    else
    begin
      Result := 0;
      for I := 0 to ItemLinks.CanVisibleItemCount - 1 do
        Result := Max(Result, ItemLinks.CanVisibleItems[I].Control.Height);
    end;
    if MDIButtonsOnBar then
      Result := Max(Result, GetMDIHeight);
  end
  else
  begin
    if ItemLinks.CanVisibleItemCount = 0 then
      Result := Painter.GetButtonHeight(BarManager.GetGlyphSize(ScaleFactor), TextSize, ScaleFactor)
    else
    begin
      ItemLinks.RecentItemCount := 1;
      Result := ItemLinks.VisibleItems[0].Control.Height;
      ItemLinks.RestoreRecentItemCount;
    end;
    if MDIButtonsOnBar then
      Inc(Result, GetMDIHeight);
  end;
  Inc(Result, cxMarginsHeight(GetItemsRectOffset));
  if Vertical then
    Inc(Result, GetMarkSize);
  dxAdjustToTouchableSize(Result, ScaleFactor);
end;

function TdxBarControl.GetMaxSize(ADockingStyle: TdxBarDockingStyle; AOrdinate: Boolean): Integer;
begin
  if AOrdinate then
    Result := GetMaxHeight(ADockingStyle)
  else
    Result := GetMaxWidth(ADockingStyle);
end;

function TdxBarControl.GetMaxWidth(AStyle: TdxBarDockingStyle): Integer;
var
  AItemLink: TdxBarItemLink;
  I: Integer;
begin
  Result := 0;
  if (AStyle in [dsTop, dsBottom]) or MultiLine then
  begin
    ItemLinks.RecentItemCount := -1;
    for I := 0 to ItemLinks.VisibleItemCount - 1 do
    begin
      AItemLink := ItemLinks.VisibleItems[I];
      Inc(Result, AItemLink.Control.Width + GetItemControlOffset(AItemLink));
    end;
    ItemLinks.RestoreRecentItemCount;
    if MDIButtonsOnBar then
      Inc(Result, GetMDIWidth);
    if Horizontal then
      Inc(Result, GetMarkSize);
  end
  else
  begin
    for I := 0 to ItemLinks.CanVisibleItemCount - 1 do
      Result := Max(Result, ItemLinks.CanVisibleItems[I].Control.Width);
    if MDIButtonsOnBar then
      Result := Max(Result, GetMDIWidth);
  end;
  with GetItemsRectOffset do
    Inc(Result, Left + Right);
  Result := Max(Result, GetMinWidth(AStyle));
end;

function TdxBarControl.GetMaxHeight(AStyle: TdxBarDockingStyle): Integer;
var
  AItemLink: TdxBarItemLink;
  I: Integer;
begin
  Result := 0;
  if (AStyle in [dsLeft, dsRight]) or MultiLine then
  begin
    ItemLinks.RecentItemCount := -1;
    for I := 0 to ItemLinks.VisibleItemCount - 1 do
    begin
      AItemLink := ItemLinks.VisibleItems[I];
      Inc(Result, AItemLink.Control.Height + GetItemControlOffset(AItemLink));
    end;
    ItemLinks.RestoreRecentItemCount;
    if MDIButtonsOnBar then
      Inc(Result, GetMDIHeight);
    if Vertical then
      Inc(Result, GetMarkSize);
  end
  else
  begin
    for I := 0 to ItemLinks.CanVisibleItemCount - 1 do
      Result := Max(Result, ItemLinks.CanVisibleItems[I].Control.Height);
    if MDIButtonsOnBar then
      Result := Max(Result, GetMDIHeight);
  end;
  with GetItemsRectOffset do
    Inc(Result, Top + Bottom);
  Result := Max(Result, GetMinHeight(AStyle));
end;

procedure TdxBarControl.GetMultiLineBarWidth(ADockingStyle: TdxBarDockingStyle;
  AWishedWidth: Integer; var Result: TSize);
var
  ABeginGroupSize, ACount, ACurRowHeight, ACurX, ACurY,
  ALastItemLinkWithBeginGroupCurX, ALastItemLinkWithBeginGroupCurRowHeight,
  AMaxSize, I: Integer;
  AItemLink, ALastItemLinkWithBeginGroup: TdxBarItemLink;
  ABreakingRow, AEntireRow, AVertical: Boolean;

  AControlSize: TSize;
  AResult, AMDIAreaSize: TReverseSize;
begin
  AVertical := Vertical;
  AResult := TReverseSize.Create(AVertical, Result);
  AMDIAreaSize := TReverseSize.Create(AVertical, GetMDIAreaSize);
  try
    AWishedWidth := Max(AWishedWidth, AResult.X);
    if ADockingStyle <> dsNone then
      Dec(AWishedWidth, GetMarkSize);
    ACurX := 0;
    ACurY := 0;
    ACurRowHeight := 0;
    AMaxSize := 0;
    ALastItemLinkWithBeginGroup := nil;
    ALastItemLinkWithBeginGroupCurX := 0;
    ALastItemLinkWithBeginGroupCurRowHeight := 0;
    ABreakingRow := False;
    AEntireRow := True;

    ACount := ItemLinks.VisibleItemCount;
    I := 0;
    while I < ACount do
    begin
      AItemLink := ItemLinks.VisibleItems[I];
      if AItemLink.BeginGroup and (ACurX > 0) then
      begin
        ABeginGroupSize := BeginGroupSize;
        ALastItemLinkWithBeginGroup := AItemLink;
        ALastItemLinkWithBeginGroupCurX := ACurX;
        ALastItemLinkWithBeginGroupCurRowHeight := ACurRowHeight;
      end
      else
        ABeginGroupSize := 0;

      with AItemLink.Control do
        AControlSize := GetSize(Width, Height, AVertical);

      if (ACurX > 0) and (ACurX + ABeginGroupSize + AControlSize.cx > AWishedWidth) or
        ABreakingRow or (ABeginGroupSize > 0) and not AEntireRow then
      begin
        AEntireRow := True;
        AItemLink.Control.FBreakingRow := True;
        if ALastItemLinkWithBeginGroup = nil then
          AEntireRow := False
        else
          if ABreakingRow then
          begin
            ALastItemLinkWithBeginGroup := nil;
            ABreakingRow := False;
          end
          else
          begin
            I := ALastItemLinkWithBeginGroup.VisibleIndex;
            ACurX := ALastItemLinkWithBeginGroupCurX;
            ACurRowHeight := ALastItemLinkWithBeginGroupCurRowHeight;
            ABreakingRow := True;
            Continue;
          end;
        Inc(ACurY, ABeginGroupSize + ACurRowHeight);
        ACurRowHeight := 0;
        AMaxSize := Max(AMaxSize, ACurX);
        ACurX := AControlSize.cx;
      end
      else
      begin
        AItemLink.Control.FBreakingRow := False;
        Inc(ACurX, ABeginGroupSize + AControlSize.cx);
      end;
      ACurRowHeight := Max(ACurRowHeight, AControlSize.cy);
      Inc(I);
    end;
    if ItemLinks.VisibleItemCount > 0 then
      AResult.Y := ACurY + ACurRowHeight;
    if MDIButtonsOnBar then
    begin
      I := AMDIAreaSize.X;
      if ACurX + I <= AWishedWidth then
        Inc(ACurX, I)
      else
        AResult.Y := AResult.Y + AMDIAreaSize.Y;
    end;
    AMaxSize := Max(AMaxSize, ACurX);
    AResult.X := Max(AResult.X, AMaxSize);

    Result := AResult.Size;
  finally
    AMDIAreaSize.Free;
    AResult.Free;
  end;
  CalcLayout;  // because of a FBreakingRow
end;

function TdxBarControl.GetSizeAllCursorBounds: TRect;
begin
  if (DockingStyle = dsNone) or (Bar.BorderStyle = bbsNone) then
    Result := cxNullRect
  else
    if Horizontal then
      if UseRightToLeftAlignment then
        Result := Rect(ClientWidth, -100, ClientWidth + 100, 100)
      else
        Result := Rect(-100, -100, 0, 100)
    else
      Result := Rect(-100, -100, 100, 0);
end;

function TdxBarControl.CalculateSize(ACurrentSize: Integer; AOrdinate: Boolean; out ALackSize: Boolean): TSize;
var
  I: Integer;
  AItemLink: TdxBarItemLink;
  ABeginGroupSize: Integer;
  AResult, AControlSize: TReverseSize;
begin
  ALackSize := False;
  AResult := TReverseSize.Create(AOrdinate);
  AControlSize := TReverseSize.Create(AOrdinate);
  try
    for I := 0 to ItemLinks.VisibleItemCount - 1 do
    begin
      AItemLink := ItemLinks.VisibleItems[I];
      ABeginGroupSize := IfThen(AItemLink.BeginGroup, BeginGroupSize);
      AControlSize.Size := AItemLink.Control.GetRealSize;
      if (AResult.X + ABeginGroupSize + AControlSize.X > ACurrentSize) and (I <> 0) then
      begin
        ALackSize := True;
        Break;
      end;
      AResult.X := AResult.X + ABeginGroupSize + AControlSize.X;
      AResult.Y := Max(AControlSize.Y, AResult.Y);
    end;
    Result := AResult.Size;
  finally
    AControlSize.Free;
    AResult.Free;
  end;
end;

function TdxBarControl.GetMultilineSize(ADockingStyle: TdxBarDockingStyle; AWishedSize: Integer; AOptimal, AOrdinate: Boolean): TSize;

  function GetMultiLineBarHeight(ADockingStyle: TdxBarDockingStyle; AWishedHeight: Integer): TSize;
  var
    APrevSize: TSize;
    ASize: TReverseSize;
  begin
    ASize := TReverseSize.Create(AOrdinate, GetSizeForBounds(ADockingStyle, GetMaxSize(ADockingStyle, not AOrdinate), not AOrdinate));
    APrevSize := ASize.Size;
    try
      repeat
        if ASize.X >= AWishedHeight then
          Break;
        APrevSize := ASize.Size;
        ASize.Y := ASize.Y - 1;
        ASize.Size := GetSizeForBounds(ADockingStyle, ASize.Y, not AOrdinate);
      until ASize.Y = APrevSize.cx;
      if AOptimal then
      begin
        GetSizeForBounds(ADockingStyle, APrevSize.cx, not AOrdinate);
        Result := APrevSize;
      end
      else
        Result := ASize.Size;
    finally
      ASize.Free;
    end;
  end;

begin
  if AOrdinate and Vertical or not AOrdinate and not Vertical then
  begin
    Result := Size(GetMinWidth(ADockingStyle), GetMinHeight(ADockingStyle));
    GetMultiLineBarWidth(ADockingStyle, AWishedSize, Result);
  end
  else
    Result := GetMultiLineBarHeight(ADockingStyle, AWishedSize);
end;

function TdxBarControl.GetSizeForBounds(ADockingStyle: TdxBarDockingStyle; AWishedSize: Integer; AOrdinate: Boolean): TSize;
begin
  if AOrdinate then
    Result := GetSizeForHeight(ADockingStyle, AWishedSize)
  else
    Result := GetSizeForWidth(ADockingStyle, AWishedSize);
end;

function TdxBarControl.GetSizeForWidth(AStyle: TdxBarDockingStyle;
  AWishedWidth: Integer): TSize;

  function GetSingleLineSize: TSize;
  var
    J: Integer;
    Found: Boolean;
    APrevSize, ASize: TSize;
  begin
    case AStyle of
      dsTop, dsBottom:
        begin
          Result := Size(GetMinWidth(AStyle), GetMinHeight(AStyle));
          AWishedWidth := Max(AWishedWidth, Result.cx);
          if MDIButtonsOnBar then Dec(AWishedWidth, GetMDIWidth);
          ItemLinks.RecentItemCount := -1;
          if ItemLinks.CanVisibleItemCount > 0 then
          begin
            Dec(AWishedWidth, GetMarkSize);
            if ItemLinks.CanUseRecentItems and not BarManager.Designing then
            begin
              APrevSize := Result;
              Dec(APrevSize.cx, GetMarkSize);
              Found := False;
              for J := 1 to ItemLinks.CanVisibleItemCount do
              begin
                ItemLinks.RecentItemCount := J;
                ASize := CalculateSize(AWishedWidth, False, Found);
                if Found then
                begin
                  ItemLinks.RecentItemCount := J - 1;
                  ASize := APrevSize;
                  Break;
                end;
                APrevSize := ASize;
              end;
              if not Found then ItemLinks.RecentItemCount := -1;
            end
            else
              ASize := CalculateSize(AWishedWidth, False, Found);
            Inc(ASize.cx, GetMarkSize);

            Result.cx := Max(Result.cx, ASize.cx);
            Result.cy := ASize.cy;
            if MDIButtonsOnBar then
            begin
              Inc(Result.cx, GetMDIWidth);
              Result.cy := Max(Result.cy, GetMDIHeight);
            end;
          end;
        end;
      dsLeft, dsRight:
        Result := Size(GetMinWidth(AStyle), GetMaxHeight(AStyle));
    else
      Result := cxNullSize;
    end;
  end;

begin
//  if ItemLinks.RecentItemCount <> -1 then
  begin
    ItemLinks.RecentItemCount := -1;
    CalcLayout;
    ItemLinks.RestoreRecentItemCount;
  end;

  if MultiLine then
    Result := GetMultilineSize(AStyle, AWishedWidth, False, False)
  else
    Result := GetSingleLineSize;
end;

function TdxBarControl.GetSizeForHeight(AStyle: TdxBarDockingStyle;
  AWishedHeight: Integer; AOptimal: Boolean): TSize;

  function GetSingleLineSize: TSize;
  var
    J: Integer;
    Found: Boolean;
    APrevSize, ASize: TSize;
  begin
    case AStyle of
      dsTop, dsBottom:
        Result := Size(GetMaxWidth(AStyle), GetMinHeight(AStyle));
      dsLeft, dsRight:
        begin
          Result := Size(GetMinWidth(AStyle), GetMinHeight(AStyle));
          AWishedHeight := Max(AWishedHeight, Result.cy);
          if MDIButtonsOnBar then Dec(AWishedHeight, GetMDIHeight);
          ItemLinks.RecentItemCount := -1;
          if ItemLinks.CanVisibleItemCount > 0 then
          begin
            Dec(AWishedHeight, GetMarkSize);
            if ItemLinks.CanUseRecentItems and not BarManager.Designing then
            begin
              APrevSize := Result;
              Dec(APrevSize.cy, GetMarkSize);
              Found := False;
              for J := 1 to ItemLinks.CanVisibleItemCount do
              begin
                ItemLinks.RecentItemCount := J;
                ASize := CalculateSize(AWishedHeight, True, Found);
                if Found then
                begin
                  ItemLinks.RecentItemCount := J - 1;
                  ASize := APrevSize;
                  Break;
                end;
                APrevSize := aSize;
              end;
              if not Found then ItemLinks.RecentItemCount := -1;
            end
            else
              ASize := CalculateSize(AWishedHeight, True, Found);
            Inc(ASize.cy, GetMarkSize);

            Result.cy := Max(Result.cy, ASize.cy);
            Result.cx := ASize.cx;
            if MDIButtonsOnBar then
            begin
              Inc(Result.cy, GetMDIHeight);
              Result.cx := Max(Result.cx, GetMDIWidth);
            end;
          end;
        end;
    end;
  end;

begin
//  if ItemLinks.RecentItemCount <> -1 then
  begin
    ItemLinks.RecentItemCount := -1;
    CalcLayout;
    ItemLinks.RestoreRecentItemCount;
  end;

  if MultiLine then
    Result := GetMultilineSize(AStyle, AWishedHeight, AOptimal, True)
  else
    Result := GetSingleLineSize;
end;

function TdxBarControl.GetTrackSize(AStyle: TdxBarDockingStyle): TSize;
var
  PrevRecentItemCount: Integer;
begin
  if bboUnmoved in BehaviorOptions then
    AStyle := dsNone;
  Result.cx := 0;
  Result.cy := 0;
  PrevRecentItemCount := ItemLinks.RecentItemCount;
  case AStyle of
    dsNone:
      begin
        Result := GetSizeForWidth(AStyle, Bar.FloatClientWidth);
        Inc(Result.cx, Bar.BarNCSizeX(AStyle));
        Inc(Result.cy, Bar.BarNCSizeY(AStyle));
      end;
    dsTop, dsBottom:
      begin
        if (FBar <> nil) and FBar.WholeRow then
          Result.cx := FDockControl.ClientWidth - FBar.BarNCSizeX(AStyle)
        else
          Result.cx := GetMaxWidth(AStyle);
        Result := GetSizeForWidth(AStyle, Result.cx);
        if (FBar <> nil) and FBar.WholeRow then
          Result.cx := FDockControl.ClientWidth
        else
          Inc(Result.cx, Bar.BarNCSizeX(AStyle));
        Inc(Result.cy, Bar.BarNCSizeY(AStyle));
      end;
    dsLeft, dsRight:
      begin
        if (FBar <> nil) and FBar.WholeRow then
          Result.cy := FDockControl.ClientHeight - FBar.BarNCSizeY(AStyle)
        else
          Result.cy := GetMaxHeight(AStyle);
        Result := GetSizeForHeight(AStyle, Result.cy);
        Inc(Result.cx, Bar.BarNCSizeX(AStyle));
        if (FBar <> nil) and FBar.WholeRow then
          Result.cy := FDockControl.ClientHeight
        else
          Inc(Result.cy, Bar.BarNCSizeY(AStyle));
      end;
  end;
  if ItemLinks.RecentItemCount <> PrevRecentItemCount then
  begin
    ItemLinks.RecentItemCount := PrevRecentItemCount;
    CalcLayout;
  end;
end;

function TdxBarControl.HasCaption: Boolean;
begin
  Result := True;
end;

function TdxBarControl.HasCloseButton: Boolean;
begin
  Result := (DockingStyle = dsNone) and Bar.CanClose;
end;

procedure TdxBarControl.InvalidateMark;
begin
  if HandleAllocated then
    Painter.BarMarkRectInvalidate(Self);
end;

function TdxBarControl.IsMarkAccessible: Boolean;
begin
  Result := Painter.BarAllowQuickCustomizing and MarkExists;
end;

function TdxBarControl.GetMouseTrackingBounds: TRect;
begin
  Result := inherited GetMouseTrackingBounds;
  if DockControl <> nil then
  begin
    IntersectRect(Result, DockControl.ClientRect, Result);
    Result := cxRectOffset(Result, DockControl.ClientOrigin);
  end;
end;

function TdxBarControl.MarkExists: Boolean;
begin
  Result := Bar.ShowMark and (FTruncated or
    (Painter.BarAllowQuickCustomizing and Bar.AllowQuickCustomizing));
end;

function TdxBarControl.MarkNCRect: TRect;
begin
  Result := MarkScreenRect;
  OffsetRect(Result, -WindowRect.Left, -WindowRect.Top);
end;

function TdxBarControl.MarkRect: TRect;
begin
  Result := Painter.BarMarkRect(Self);
end;

function TdxBarControl.MarkScreenRect: TRect;
begin
  Result := dxMapWindowRect(Handle, 0, MarkRect);
end;

procedure TdxBarControl.SetMarkState(Value: TdxBarMarkState);
var
  ALinkSelf: TcxObjectLink;
  AOldMarkState: TdxBarMarkState;
begin
  if IsCustomizing then Exit;
  if FMarkState <> Value then
  begin
    AOldMarkState := FMarkState;
    FMarkState := Value;
    FinishMoreButtonsHintTimer;

    if FMarkState = msPressed then
    begin
      //PlaySound(psMenuPopup);
      BarDesignController.ShowQuickControl(Self, MarkScreenRect);
      FQuickPopup := BarDesignController.QuickControl;
      SendMessage(FQuickPopup.Bar.Control.Handle, DXM_UIADORNERMANAGERUPDATE, 0, 0);
    end
    else
    begin
      if FQuickPopup <> nil then
      begin
        ALinkSelf := cxAddObjectLink(Self);
        try
          FreeAndNil(FQuickPopup);
          if ALinkSelf.Ref = nil then
            Exit;
        finally
          cxRemoveObjectLink(ALinkSelf);
        end;
      end;
      if FMarkState = msSelected then
      begin
        if DockingStyle = dsNone then StartMoreButtonsHintTimer;
        ActivateHint;
      end
      else
        if SelectedControl = nil then
          BarManager.HideHint;
    end;
    if MarkFadingHelper.CanFade then
    begin
      if AOldMarkState = msSelected then
        Fader.FadeOut(MarkFadingHelper);
      if AOldMarkState = msNone then
        Fader.FadeIn(MarkFadingHelper);
    end;
    InvalidateMark;
  end;
end;

procedure TdxBarControl.SelectItemControl(AItemControl: TdxBarItemControl; AButton: TMouseButton; AShift: TShiftState);
begin
  if (AItemControl = nil) then
    IsActive := False;
  inherited;
end;

procedure TdxBarControl.ShowPopup(AItem: TdxBarItemControl);
begin
  if not BarManager.IsCustomizing then
    BarDesignController.ShowToolbarsPopup(BarManager, Painter)
  else
    inherited;
end;

function TdxBarControl.SizeGripRect: TRect;
begin
  Result.Left := ClientWidth;
  Result.Right := Result.Left + Painter.StatusBarGripSize(BarManager, ScaleFactor).cx;
  Result.Bottom := ClientHeight;
  Result.Top := Result.Bottom - Painter.StatusBarGripSize(BarManager, ScaleFactor).cy;
  if UseRightToLeftAlignment then
    Result := TdxRightToLeftLayoutConverter.ConvertRect(Result, ClientRect);
end;

procedure TdxBarControl.UpdateItem(AControl: TdxBarItemControl);
begin
  if AControl <> nil then
    AControl.Update;
end;

function TdxBarControl.AllowNCPaint: Boolean;
begin
  Result := not ((ClientHeight = Height) and (ClientWidth = Width) or IsDestroying);
end;

procedure TdxBarControl.BarManagerStyleChanged;
var
  ABar: TdxBar;
begin
  UpdateControlStyle;
  CalcDrawingConsts;
  if DockingStyle = dsNone then
  begin
    ABar := Bar;
    ABar.Visible := False;
    ABar.Visible := True;
  end
  else
    RebuildBar;
end;

procedure TdxBarControl.CaptionChanged;
begin
  Text := GetCaption;
  SendMessage(Handle, WM_NCPAINT, 0, 0);
end;

procedure TdxBarControl.DoDrawBeginGroup(const ASeparatorRect: TRect; AHorz: Boolean);
begin
  Painter.BarDrawBeginGroup(Self, Canvas.Handle, ASeparatorRect, ToolbarBrush, AHorz);
end;

procedure TdxBarControl.DoNCPaint(DC: HDC);

  procedure DrawStatusBar(const ARect: TRect; AToolbarBrush: HBRUSH);
  begin
    Painter.BarDrawStatusBarBorder(Self, DC, ARect, AToolbarBrush);
    if FHasSizeGrip then
      Painter.BarDrawStatusBarGrip(Self, DC, ARect, AToolbarBrush);
  end;

  procedure DrawBorders(const R: TRect; AToolbarBrush: HBRUSH);
  var
    AClipRgn: HRGN;
    AClipRgnExists: Boolean;
    CR: TRect;
  begin
    CR := ClientBounds;
    SaveClipRgn(DC, AClipRgn, AClipRgnExists);
    try
      ExcludeClipRect(DC, CR.Left, CR.Top, CR.Right, CR.Bottom);
      FillBackground(DC, R, AToolbarBrush, clNone, False);
      if DockingStyle = dsNone then
        Painter.BarDrawFloatingBarBorder(Self, DC, R, CR, AToolbarBrush)
      else
        Painter.BarDrawDockedBarBorder(Self, DC, R, AToolbarBrush);
    finally
      RestoreClipRgn(DC, AClipRgn, AClipRgnExists);
    end;
  end;

begin
  if Painter.IsCompoundPainting then
    Painter.DrawToolbarNonContentPart(Self, DC)
  else
    if (DockingStyle <> dsNone) and (FBar.BorderStyle = bbsNone) then
    begin
      if FBar.IsStatusBar then
        DrawStatusBar(NCRect, ToolbarBrush);
    end
    else
    begin
      DrawBorders(NCRect, ToolbarBrush);
      if (DockingStyle = dsNone) and HasCaption then
        Painter.BarDrawFloatingBarCaption(Self, DC, GetCaptionNCRect, GetCaptionNCRect, ToolbarBrush, ScaleFactor);
    end;
end;

procedure TdxBarControl.DoPaint;
var
  AButtons: TdxBarMDIButtons;
  AItemLink: TdxBarItemLink;
  I: Integer;
begin
  if not BarManager.Designing then
    for I := 0 to FItemLinks.CanVisibleItemCount - 1 do
    begin
      AItemLink := FItemLinks.CanVisibleItems[I];
      with AItemLink do
        if Item.NeedToBeHidden and (VisibleIndex = -1) then
          Item.HideControl(Control);
    end;

  Canvas.SaveClipRegion;
  try
    if Painter.IsCompoundPainting then
      DrawContentBackground;

    DrawItems;
    DrawBeginGroups;
    if MDIButtonsOnBar then
    begin
      if RealMDIButtonsOnBar then
        AButtons := [mdibMinimize, mdibRestore, mdibClose]
      else
        AButtons := [mdibClose];
      DrawMDIButtons(AButtons, True);
    end;
    if (DockingStyle <> dsNone) and MarkExists then
      DrawMarks;
    if not Painter.IsCompoundPainting then
      DrawContentBackground;
  finally
    Canvas.RestoreClipRegion;
  end;

  DrawSelection(Canvas.Handle);
end;

procedure TdxBarControl.DrawBeginGroups;
var
  I: Integer;
  ASeparatorRect: TRect;
begin
  for I := 0 to ViewInfo.SeparatorCount - 1 do
  begin
    ASeparatorRect := ViewInfo.SeparatorInfos[I].Bounds;
    DoDrawBeginGroup(ASeparatorRect, ViewInfo.SeparatorInfos[I].Kind = skHorizontal);
    Canvas.ExcludeClipRect(ASeparatorRect);
  end;
end;

procedure TdxBarControl.DrawContentBackground;
begin
  Painter.DrawToolbarContentPart(Self, Canvas);
end;

procedure TdxBarControl.DrawMarks;
var
  AMarkRect: TRect;
begin
  AMarkRect := Painter.BarMarkItemRect(Self);
  Painter.BarDrawMarks(Self, Canvas, AMarkRect, ToolbarBrush);
  Canvas.ExcludeClipRect(AMarkRect);
end;

procedure TdxBarControl.DrawMDIButtons(AButtons: TdxBarMDIButtons;
  AExcludeClipRect: Boolean = False);
var
  AButton: TdxBarMDIButton;
begin
  for AButton := Low(TdxBarMDIButton) to High(TdxBarMDIButton) do
    if AButton in AButtons then
    begin
      if not FMDIButtonFadingHelper[AButton].DrawImage(Canvas.Handle, RectMDI(AButton)) then
        DrawMDIButton(AButton, FIsMouseOverMDIButton and (AButton = FSelectedMDIButton),
          FIsMDIButtonPressed and (AButton = FPressedMDIButton));
      if AExcludeClipRect then
        Canvas.ExcludeClipRect(RectMDI(AButton));
    end;
end;

procedure TdxBarControl.DrawSelection(ADC: HDC);
begin
  if BarManager.Designing and (Bar <> nil) and Bar.IsComponentSelected then
  begin
    if BarDesignController.NeedDefaultSelection(Bar) then
      dxBarFrameRect(ADC, ClientRect, COLOR_WINDOWTEXT)
    else
      dxBarFocusRect(ADC, ClientRect);
  end;
end;

procedure TdxBarControl.FillBackground(ADC: HDC; const ARect: TRect; ABrush: HBRUSH;
  AColor: TColor; AIsClientArea: Boolean);
var
  R: TRect;
begin
  // calc rect
  if AIsClientArea then
    R := cxRectOffset(ARect, NCOffset)
  else
    R := ARect;
  Painter.BarDrawBackground(Self, ADC, ARect, R, ABrush, AColor);
end;

procedure TdxBarControl.FrameChanged;
begin
  if HandleAllocated then
    dxRecalculateNonClientPart(Handle);
end;

function TdxBarControl.GetCaption: TCaption;
begin
  Result := Bar.Caption;
end;

function TdxBarControl.GetEditFont: TFont;
begin
  if FBar.UseOwnFont then
    Result := FBar.FEditFont
  else
    Result := inherited GetEditFont;
end;

function TdxBarControl.GetFont: TFont;
begin
  Result := Bar.Font;
end;

function TdxBarControl.GetFullItemRect(Item: TdxBarItemControl): TRect;
begin
  Result := GetItemRect(Item);
  if Vertical then
  begin
    Result.Left := Result.Left - (Item.ItemLink.RowHeight - cxRectWidth(Result)) div 2;
    Result.Right := Result.Left + Item.ItemLink.RowHeight;
  end
  else
  begin
    Result.Top := Result.Top - (Item.ItemLink.RowHeight - cxRectHeight(Result)) div 2;
    Result.Bottom := Result.Top + Item.ItemLink.RowHeight;
  end;
end;

function TdxBarControl.GetItemRegion(Item: TdxBarItemControl): HRGN;
var
  Rgn: HRGN;
  ASeparatorIndex: Integer;
begin
  Result := CreateRectRgnIndirect(GetFullItemRect(Item));
  if ViewInfo.IsAssociatedWithSeparator(Item, ASeparatorIndex) then
  begin
    Rgn := CreateRectRgnIndirect(ViewInfo.SeparatorInfos[ASeparatorIndex].Bounds);
    CombineRgn(Result, Result, Rgn, RGN_OR);
    DeleteObject(Rgn);
  end;
end;

function TdxBarControl.GetToolbarBrush: HBRUSH;
begin
  Result := Painter.BarToolbarBrushEx(Self);
end;

procedure TdxBarControl.GlyphChanged;
begin
end;

function TdxBarControl.IsBackgroundBitmap: Boolean;
begin
  Result := inherited IsBackgroundBitmap or
    not Bar.BackgroundBitmap.Empty or
    not BarManager.Backgrounds.Bar.Empty;
end;

function TdxBarControl.IsTransparent: Boolean;
begin
  Result := (Bar <> nil) and ((Bar.Color <> clDefault) or not Bar.BackgroundBitmap.Empty) or
    not BarManager.Backgrounds.Bar.Empty or inherited IsTransparent or
    Painter.IsCompoundPainting;
end;

function TdxBarControl.NCOffset: TPoint;
begin
//  Result := inherited NCOffset;
//  if DockingStyle <> dsNone then
  Result := ClientBounds.TopLeft;
end;

procedure TdxBarControl.NCPaint(ADC: HDC);
var
  ATempDC: HDC;
begin
  DoNCPaint(ADC);
  if BarManager.IsUncustomizable then
  begin
    SelectClipRgn(ADC, FPrevClipRgn.Handle);
    DrawDisablingHatch(ADC, Rect(0, 0, Width, Height));
    ATempDC := GetWindowDC(Handle);
    try
      SelectClipRgn(ATempDC, FPrevClipRgn.Handle);
      BitBlt(ATempDC, 0, 0, Width, Height, ADC, 0, 0, SRCCOPY);
    finally
      ReleaseDC(Handle, ATempDC);
    end;
  end;
end;

function TdxBarControl.NotHandleMouseMove(ACheckLastMousePos: Boolean = True): Boolean;

  function ControlContainerActive: Boolean;
  begin
    Result := dxHasAsParent(GetActiveWindow, BarManager.Owner.Handle);
  end;

var
  AQuickControl: TdxBarPopupControl;
begin
  Result := inherited NotHandleMouseMove(ACheckLastMousePos) or
    (DockingStyle <> dsNone) and not IsFormActive(ParentForm) and not ControlContainerActive;
  if not Result then
  begin
    AQuickControl := BarDesignController.QuickControl;
    Result := (AQuickControl <> nil) and AQuickControl.LockHotTrackWhenPopup and
      not ((Self = AQuickControl) or AQuickControl.IsChildBar(Self));
  end;
end;

procedure TdxBarControl.RebuildBar;
begin
  UpdateDoubleBuffered;
  FrameChanged;
  RepaintBar;
end;

procedure TdxBarControl.RefreshShadow;
begin
  FShadow.Refresh;
end;

procedure TdxBarControl.RepaintMDIButtons;
var
  AButtons: TdxBarMDIButtons;
begin
  if RealMDIButtonsOnBar then
    AButtons := [mdibMinimize, mdibRestore, mdibClose]
  else
    AButtons := [mdibClose];
  DrawMDIButtons(AButtons);
end;

procedure TdxBarControl.SavePos;
begin
  if not FBar.Visible or FMoving or BarManager.IsDestroying then
    Exit;
  FPosSaving := True;
  BarManager.LockDesignerModified(True);
  try
    if DockingStyle = dsNone then
    begin
      Bar.FloatLeft := Left;
      Bar.FloatTop := Top;
      Bar.FloatClientWidth := ClientWidth;
      Bar.FloatClientHeight := ClientHeight;
    end
    else
      if (DockControl <> nil) and not DockControl.IsBarHandleDestroying and not BarManager.IsHandleCreating then
      begin
        Bar.DockedDockingStyle := DockingStyle;
        if DockControl.Main then
          Bar.DockedDockControl := nil
        else
          Bar.DockedDockControl := TdxBarDockControl(DockControl);
        if GetDockCol <> nil then
        begin
          Bar.OneOnRow := GetDockCol.DockRow.FBars.Count = 1;
//          FBar.Bars.BeginUpdate;
          try
            Bar.DockedLeft := DockControl.GetBarControlPos(Left, Width);
            Bar.DockedTop := Top;
          finally
//            FBar.Bars.EndUpdate;
          end;
        end;
      end;
  finally
    FPosSaving := False;
    BarManager.LockDesignerModified(False);
  end;
end;

procedure TdxBarControl.SetFont;
begin
  Font := GetFont;
end;

procedure TdxBarControl.SetDockingStyle(Value: TdxBarDockingStyle);
begin
  if DockingStyle <> Value then FTruncated := False;
  inherited;
end;

procedure TdxBarControl.SetKeySelectedItem(Value: TdxBarItemControl);
var
  APrevSelectedControl: TdxBarItemControl;
begin
  APrevSelectedControl := SelectedControl;
  inherited SetKeySelectedItem(Value);
  if (SelectedControl <> APrevSelectedControl) and (SelectedControl <> nil) and not
    (SelectedControl.IsActive or IsCustomizing)
  then
    if SelectedControl is TdxBarSubItemControl then
      SelectedControl.ControlClick(False)
    else
      SelectedControl.ControlActivate(True, False);
end;

procedure TdxBarControl.SetLayeredAttributes;
var
  AAlphaBlendValue: Byte;
begin
  if FMoving or ((DockingStyle = dsNone) and not IsInternal) then
    AAlphaBlendValue := Bar.AlphaBlendValue
  else
    AAlphaBlendValue := 255;
  if FMoving then
    cxSetLayeredWindowAttributes(FFloatingHandle, AAlphaBlendValue)
  else
    if HandleAllocated then
      cxSetLayeredWindowAttributes(Handle, AAlphaBlendValue);
end;

function TdxBarControl.IsRealVertical: Boolean;
begin
  Result := Vertical;
end;

function TdxBarControl.IsVertical: Boolean;
begin
  Result := IsRealVertical and Bar.RotateWhenVertical;
end;

function TdxBarControl.Kind: TdxBarKind;
begin
  Result := bkBarControl;
end;

procedure TdxBarControl.Repaint;
begin
  if (Bar <> nil) and Bar.BarManager.IsUpdateLocked then
    Bar.DoChanged
  else
    inherited;
end;

procedure TdxBarControl.ScaleForPPI(NewPPI: Integer);
begin
  if (NewPPI <> ScaleFactor.TargetDPI) and not FIsScaleChanging then
  begin
    FIsScaleChanging := True;
    try
      if Bar <> nil then
        Bar.ChangeScale(NewPPI, ScaleFactor.TargetDPI);
    finally
      FIsScaleChanging := False;
    end;
  end;
end;

procedure TdxBarControl.UpdateFont;
begin
  Font := GetFont;
  Perform(CM_FONTCHANGED, 0, 0);
end;

{ TdxBarControlViewInfo }

procedure TdxBarControlViewInfo.Calculate;
var
  AItemLink: TdxBarItemLink;
  I: Integer;
begin
  BarControl.CalcControlsPositions;
  inherited Calculate;
  for I := 0 to BarControl.ItemLinks.VisibleItemCount - 1 do
  begin
    AItemLink := BarControl.ItemLinks.VisibleItems[I];
    if AItemLink.Control = nil then
      Continue;
    AddItemControlViewInfo(AItemLink.Control.ViewInfo);
    AItemLink.Control.ViewInfo.SetBounds(BarControl.GetItemRect(AItemLink.Control));
    CalcSeparatorInfo(AItemLink);
    if IsLastVisibleItemControl(AItemLink.Control) then
      Break;
  end;
end;

procedure TdxBarControlViewInfo.CalcSeparatorInfo(AItemLink: TdxBarItemLink);
var
  AItemRect: TRect;
begin
  AItemRect := AItemLink.Control.ViewInfo.Bounds;
  if AItemLink.BeginGroup and not IsRectEmpty(AItemRect) then
    DoCalcSeparatorInfo(AItemLink, AItemRect);
end;

function TdxBarControlViewInfo.CanShowButtonGroups: Boolean;
begin
  Result := False;
end;

procedure TdxBarControlViewInfo.DoCalcSeparatorInfo(AItemLink: TdxBarItemLink; const AItemRect: TRect);

  function IsBeginGroupInVerticalDirection: Boolean;
  begin
    Result := not BarControl.Vertical and (AItemRect.Top > 0) and
      (BarControl.UseRightToLeftAlignment and (AItemRect.Right = BarControl.ClientWidth) or
       not BarControl.UseRightToLeftAlignment and (AItemRect.Left = 0)) or
       BarControl.Vertical and (AItemRect.Top > 0);
  end;

var
  R: TRect;
  AMarkSize: Integer;
  ALeft: Integer;
begin
  if BarControl.DockingStyle <> dsNone then
    AMarkSize := BarControl.GetMarkSize
  else
    AMarkSize := 0;
  if IsBeginGroupInVerticalDirection then
  begin
    if BarControl.Vertical then
      R := Bounds(AItemRect.Left - (AItemLink.FRowHeight - cxRectWidth(AItemRect)) div 2,
        AItemRect.Top - BarControl.BeginGroupSize, AItemLink.FRowHeight, BarControl.BeginGroupSize)
    else
      R := Bounds(
        0,
        AItemRect.Top - (AItemLink.FRowHeight - cxRectHeight(AItemRect)) div 2 - BarControl.BeginGroupSize,
        BarControl.ClientWidth - AMarkSize,
        BarControl.BeginGroupSize);
    AddSeparatorInfo(R, skHorizontal, AItemLink.Control);
  end
  else
  begin  // begin group in horizontal direction
    if BarControl.Vertical then
      R := Bounds(
        AItemRect.Right + (AItemLink.FRowHeight - cxRectWidth(AItemRect)) div 2, 0,
        BarControl.BeginGroupSize,
        BarControl.ClientHeight - AMarkSize)
    else
    begin
      if BarControl.UseRightToLeftAlignment then
        ALeft := AItemRect.Right
      else
        ALeft := AItemRect.Left - BarControl.BeginGroupSize;
      R := Bounds(
        ALeft,
        AItemRect.Top - (AItemLink.FRowHeight - cxRectHeight(AItemRect)) div 2,
        BarControl.BeginGroupSize, AItemLink.FRowHeight);
    end;
    AddSeparatorInfo(R, skVertical, AItemLink.Control);
  end;
end;

function TdxBarControlViewInfo.IsLastVisibleItemControl(
  AItemControl: TdxBarItemControl): Boolean;
begin
  Result := False;
end;

function TdxBarControlViewInfo.GetBarControl: TdxBarControl;
begin
  Result := TdxBarControl(FBarControl);
end;

{ TdxBarSubMenuControl }

type
  TdxBarAnimationInfo = record
    AnimationMenu: TdxBarSubMenuControl;
    AnimationType: TdxBarMenuAnimations;
    LeftDirection, TopDirection: Boolean;
    RealLeft, RealTop: Integer;
    RealClientWidth, RealClientHeight: Integer;
    BorderWidth, BorderHeight: Integer;
    FirstValue: Integer;
    Delta: Integer;
    Step: Integer;
    OldClientRect: TRect;
  end;

  TdxBarAnimationThread = class(TThread)
  private
    FAnimationInfo: TdxBarAnimationInfo;
    FAnimationWindowLink: TcxObjectLink;
    FPrevGDIObject: HGDIOBJ;
    FCompatibleDC: HDC;
    FNeedFinishAnimation: Boolean;
    FFinished: Boolean;

    procedure DoAnimation;
    procedure DoOneStepOfAnimation(AIteration: Integer);
    procedure DoFinishAnimation;
  protected
    procedure DoTerminate; override;
    procedure Execute; override;
  public
    constructor Create(const AAnimationInfo: TdxBarAnimationInfo);
    destructor Destroy; override;
    procedure TerminateAnimation(ANeedFinish: Boolean);
  end;

constructor TdxBarAnimationThread.Create(const AAnimationInfo: TdxBarAnimationInfo);
var
  ADC: HDC;
begin
  inherited Create(True);
  FreeOnTerminate := True;
  FAnimationInfo := AAnimationInfo;
  FNeedFinishAnimation := True;

  ADC := FAnimationInfo.AnimationMenu.Canvas.Handle;
  FCompatibleDC := CreateCompatibleDC(ADC);
  FPrevGDIObject := SelectObject(FCompatibleDC, CreateCompatibleBitmap(ADC, FAnimationInfo.RealClientWidth, FAnimationInfo.RealClientHeight));
  FAnimationInfo.AnimationMenu.PaintWindow(FCompatibleDC);

  FAnimationWindowLink := cxAddObjectLink(FAnimationInfo.AnimationMenu);
end;

destructor TdxBarAnimationThread.Destroy;
begin
  cxRemoveObjectLink(FAnimationWindowLink);

  ReverseGDIObject(FCompatibleDC, FPrevGDIObject);
  DeleteDC(FCompatibleDC);
  inherited;
end;

procedure TdxBarAnimationThread.TerminateAnimation(ANeedFinish: Boolean);
begin
  FNeedFinishAnimation := ANeedFinish;
  if FFinished then
    Exit;
  FreeOnTerminate := False;
  try
    Terminate;
    WaitFor;
  finally
    Free;
  end;
end;

procedure TdxBarAnimationThread.DoTerminate;
begin
  inherited;
  if FNeedFinishAnimation then
    Synchronize(DoFinishAnimation);
end;

procedure TdxBarAnimationThread.Execute;
begin
  DoAnimation;
  FFinished := True;
end;

procedure TdxBarAnimationThread.DoAnimation;
var
  AFirstTime: DWORD;
  I: Integer;
begin
  FAnimationInfo.AnimationMenu.UpdateDoubleBuffered;
  for I := 1 to FAnimationInfo.Delta div FAnimationInfo.Step do
  begin
    if Terminated then
      Break;
    AFirstTime := GetTickCount;
    DoOneStepOfAnimation(I);
    Sleep(1);
    while (GetTickCount - AFirstTime < 1) and not Terminated do {loop};
  end;
end;

procedure TdxBarAnimationThread.DoOneStepOfAnimation(AIteration: Integer);
var
  ANewLeft, ANewTop, ANewClientWidth, ANewClientHeight: Integer;
  R, R1, R2: TRect;
  DC: HDC;
begin
  with FAnimationInfo do
  begin
    if FirstValue >= 0 then
    begin
      ANewClientWidth := Step * AIteration;
      ANewClientHeight := FirstValue + ANewClientWidth;
      if AnimationType = maSlide then
        ANewClientWidth := AnimationMenu.ClientWidth;
    end
    else
    begin
      ANewClientHeight := Step * AIteration;
      ANewClientWidth := Abs(FirstValue) + ANewClientHeight;
    end;

    if LeftDirection then
      ANewLeft := AnimationMenu.Left - (ANewClientWidth - AnimationMenu.ClientWidth)
    else
      ANewLeft := AnimationMenu.Left;
    if TopDirection then
      ANewTop := AnimationMenu.Top - (ANewClientHeight - AnimationMenu.ClientHeight)
    else
      ANewTop := AnimationMenu.Top;

    SetWindowPos(AnimationMenu.Handle, 0, ANewLeft, ANewTop,
      BorderWidth + ANewClientWidth, BorderHeight + ANewClientHeight,
      SWP_NOZORDER or SWP_NOACTIVATE or SWP_SHOWWINDOW);

    DC := GetDC(AnimationMenu.Handle);
    AnimationMenu.PreparePalette(DC);

    R1 := OldClientRect;
    if TopDirection then
    begin
      R := Rect(0, 0, ANewClientWidth, ANewClientHeight);
      OffsetRect(R1, 0, ANewClientHeight - R1.Bottom);
      cxBitBlt(DC, DC, OldClientRect, R1.TopLeft, SRCCOPY);
      R1 := OldClientRect;

      BitBlt(DC, 0, R1.Bottom, AnimationMenu.ClientWidth, AnimationMenu.ClientHeight - R1.Bottom,
        FCompatibleDC, R.Left, R.Top + R1.Bottom, SRCCOPY);
      BitBlt(DC, R1.Right, R1.Top, AnimationMenu.ClientWidth - R1.Right, R1.Bottom - R1.Top,
        FCompatibleDC, R.Left + R1.Right, R.Top, SRCCOPY);
    end
    else
      if LeftDirection then
      begin
        R := Rect(RealClientWidth - AnimationMenu.ClientWidth, RealClientHeight - AnimationMenu.ClientHeight, RealClientWidth, RealClientHeight);
        OffsetRect(R1, AnimationMenu.ClientWidth - R1.Right, 0);
        R2 := R1;
        OffsetRect(R2, 0, AnimationMenu.ClientHeight - R1.Bottom);
        cxBitBlt(DC, DC, R2, R1.TopLeft, SRCCOPY);
        R1 := R2;

        BitBlt(DC, 0, 0, AnimationMenu.ClientWidth, R1.Top, FCompatibleDC, R.Left, R.Top, SRCCOPY);
        BitBlt(DC, 0, R1.Top, R1.Left, AnimationMenu.ClientHeight - R1.Top,
          FCompatibleDC, R.Left, R.Top + R1.Top, SRCCOPY);
      end
      else
      begin
        R := Rect(0, RealClientHeight - AnimationMenu.ClientHeight, AnimationMenu.ClientWidth, RealClientHeight);
        OffsetRect(R1, 0, AnimationMenu.ClientHeight - R1.Bottom);
        cxBitBlt(DC, DC, R1, OldClientRect.TopLeft, SRCCOPY);

        BitBlt(DC, 0, 0, AnimationMenu.ClientWidth, R1.Top, FCompatibleDC, R.Left, R.Top, SRCCOPY);
        BitBlt(DC, R1.Right, R1.Top, AnimationMenu.ClientWidth - R1.Right, AnimationMenu.ClientHeight - R1.Top,
          FCompatibleDC, R.Left + R1.Right, R.Top + R1.Top, SRCCOPY);
      end;
    OldClientRect := AnimationMenu.ClientRect;

    AnimationMenu.UnpreparePalette(DC);
    UpdateColors(DC);
    ReleaseDC(AnimationMenu.Handle, DC);
  end;
end;

procedure TdxBarAnimationThread.DoFinishAnimation;
begin
  if (FAnimationWindowLink.Ref <> nil) and not FAnimationInfo.AnimationMenu.IsDestroying then
  with FAnimationInfo do
  begin
    AnimationMenu.FShowAnimation := False;
    AnimationMenu.UpdateDoubleBuffered;
    SetWindowPos(AnimationMenu.Handle, 0, RealLeft, RealTop,
      BorderWidth + RealClientWidth,
      BorderHeight + RealClientHeight,
      SWP_NOZORDER or SWP_NOACTIVATE or SWP_SHOWWINDOW or SWP_FRAMECHANGED {to enforce WM_WINDOWPOSCHANGED});
    AnimationMenu.Repaint;
  end;
end;

{ TdxBarSubMenuControl }

constructor TdxBarSubMenuControl.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  Width := 0;
  FXDirection := xdRight;
  FYDirection := ydBottom;
end;

destructor TdxBarSubMenuControl.Destroy;
begin
  if BarManager.FChangedSubMenuControl = Self then
    BarManager.FChangedSubMenuControl := nil;
  IsActive := False;
  DestroyLightBrush;
  inherited Destroy;
end;

function TdxBarSubMenuControl.GetBandSize: Integer;
begin
  Result := Painter.SubMenuControlGetBandSize(Self);
end;

function TdxBarSubMenuControl.GetBarSize: Integer;
begin
  if GetSubMenuOwner <> nil then
    Result := GetSubMenuOwner.GetBarSize
  else
    Result := 0;
end;

function TdxBarSubMenuControl.GetBarRect: TRect;
begin
  if UseRightToLeftAlignment then
    Result := Rect(ItemsRect.Right, ItemsRect.Top, ItemsRect.Right + BarSize, ItemsRect.Bottom)
  else
    Result := Rect(ItemsRect.Left - BarSize, ItemsRect.Top, ItemsRect.Left, ItemsRect.Bottom);
end;

function TdxBarSubMenuControl.GetBottomVisibleItemIndex: Integer;
var
  AMaxVisibleItemCount: Integer;
begin
  AMaxVisibleItemCount := Max(MaxVisibleCount, 1);
  Result := TopIndex + AMaxVisibleItemCount - 1;
  if not UseScrollButtons and DownArrowExists then
    Dec(Result);
end;

function TdxBarSubMenuControl.GetBorderSize: Integer;
begin
  Result := Painter.SubMenuControlBorderSize;
end;

function TdxBarSubMenuControl.GetContentRect: TRect;
begin
  Result := cxRectContent(ClientRect, Painter.SubMenuControlContentRectOffset(Self));
end;

function TdxBarSubMenuControl.GetDetachCaptionSize: Integer;
begin
  Result := cxTextHeight(Canvas.Handle) div 2;
  if not Odd(Result) then Inc(Result);
end;

function TdxBarSubMenuControl.GetMaxVisibleCount: Integer;
var
  I: Integer;
begin
  for I := TopIndex to ItemLinks.VisibleItemCount - 1 do
    if ItemLinks.VisibleItems[I].ItemRect.Bottom = 0 then
    begin
      Result := I - TopIndex;
      Exit;
    end;
  Result := ItemLinks.VisibleItemCount - TopIndex;
end;

function TdxBarSubMenuControl.GetParentItemControl: TdxBarItemControl;
begin
  if FDropDownButton <> nil then
    Result := FDropDownButton
  else
    Result := FSubItem;
end;

function TdxBarSubMenuControl.GetSubMenuOwner: IdxBarSubMenuOwner;
begin
  Supports(ItemLinks.Owner, IdxBarSubMenuOwner, Result);
end;

function TdxBarSubMenuControl.GetToolbarItemsBrush: HBRUSH;
begin
  Result := Painter.SubMenuControlToolbarItemsBrush(Self);
end;

function TdxBarSubMenuControl.GetTopVisibleItemIndex: Integer;
begin
  Result := TopIndex;
  if not UseScrollButtons and UpArrowExists then
    Inc(Result);
end;

procedure TdxBarSubMenuControl.SetDetachCaptionSelected(AValue: Boolean);
begin
  if IsCustomizing or (GetCapture <> 0) then Exit;
  if FDetachCaptionSelected <> AValue then
  begin
    FDetachCaptionSelected := AValue;
    InvalidateDetachCaption;
    SetCursorForMoving(AValue);
    if AValue then
      ActivateHint
    else
      if SelectedControl = nil then
        BarManager.HideHint;
  end;
end;

procedure TdxBarSubMenuControl.SetTopIndex(AValue: Integer);
begin
  AValue := Min(AValue, ItemLinks.VisibleItemCount - 1);
  AValue := Max(AValue, 0);
  if FTopIndex <> AValue then
  begin
    FTopIndex := AValue;
    InvalidateItemsRect;
  end;
end;

procedure TdxBarSubMenuControl.CalcBounds(out ASize: TSize);

  procedure CalcItemSizeParams;
  var
    ARecentItemCount: Integer;
    AExtendedView: Boolean;
    ALastWasRecentItem: Boolean;
    I: Integer;
    AItemLink: TdxBarItemLink;
  begin
    ARecentItemCount := ItemLinks.MostRecentItemCount;
    if ARecentItemCount = -1 then
      ARecentItemCount := ItemLinks.CanVisibleItemCount;
    AExtendedView := ExtendedView;

    ALastWasRecentItem := True;
    for I := TopIndex to ItemLinks.VisibleItemCount - 1 do
    begin
      AItemLink := ItemLinks.VisibleItems[I];
      AItemLink.Control.FNonRecent := AExtendedView and (AItemLink.RecentIndex >= ARecentItemCount);
      AItemLink.Control.FChangeRecentGroup := AExtendedView and
        ((I > TopIndex) or Detachable) and (AItemLink.Control.FNonRecent = ALastWasRecentItem);
      ALastWasRecentItem := not AItemLink.Control.FNonRecent;
    end;
  end;

begin
  CalcItemSizeParams;
  CalcSize(ASize);
end;

procedure TdxBarSubMenuControl.CalcSize(out ASize: TSize);
begin
  DoCalcSize(ASize);

  if ASize.cy <= 2 then
    Inc(ASize.cy, TextSize);
  if MarkExists then
    Inc(ASize.cy, MarkSize);

  DoCorrectSize(ASize);
end;

procedure TdxBarSubMenuControl.CreateLightBrush;
var
  ALogPalette: TLogPalette;
  AColor: COLORREF;
  DC: HDC;
  R, G, B: Integer;
begin
  AColor := GetSysColor(COLOR_BTNFACE);
  R := Min(255, GetRValue(AColor) + dxBarNonRecentlyUsedItemsColorDelta);
  G := Min(255, GetGValue(AColor) + dxBarNonRecentlyUsedItemsColorDelta);
  B := Min(255, GetBValue(AColor) + dxBarNonRecentlyUsedItemsColorDelta);

  DC := GetDC(0);
  try
    if BarManager.ShowRecentItemsFirst and (GetDeviceCaps(DC, BITSPIXEL) <= 8) then
    begin
      ALogPalette.palVersion := $0300;
      ALogPalette.palNumEntries := 1;
      ALogPalette.palPalEntry[0].peRed := R;
      ALogPalette.palPalEntry[0].peGreen := G;
      ALogPalette.palPalEntry[0].peBlue := B;
      ALogPalette.palPalEntry[0].peFlags := 0;
      FLightPalette := CreatePalette(ALogPalette);
      FLightBrush := CreateSolidBrush(PaletteIndex(0));
    end
    else
      FLightBrush := CreateSolidBrush(RGB(R, G, B));
  finally
    ReleaseDC(0, DC);
  end;
end;

procedure TdxBarSubMenuControl.DestroyLightBrush;
begin
  DeleteGDIObject(FLightBrush);
  DeleteGDIObject(FLightPalette);
end;

procedure TdxBarSubMenuControl.PreparePalette(DC: HDC);
begin
  if FLightPalette <> 0 then
  begin
    SelectPalette(DC, FLightPalette, True);
    RealizePalette(DC);
  end;
end;

procedure TdxBarSubMenuControl.UnpreparePalette(DC: HDC);
begin
  if FLightPalette <> 0 then
  begin
    SelectPalette(DC, GetStockObject(DEFAULT_PALETTE), True);
    RealizePalette(DC);
  end;
end;

procedure TdxBarSubMenuControl.ExpandMenu;
begin
  if MarkExists then
  begin
    ShowFullMenus := True;
    FShowAnimation := True;
    FExpandingMenu := True;
    try
      DestroyWnd;
    finally
      FExpandingMenu := False;
    end;
    Left := FOnShowLeft;
    Top := FOnShowTop;
    Show;
  end;
end;

function TdxBarSubMenuControl.ExtendedView: Boolean;
begin
  Result := BarManager.ShowRecentItemsFirst and ShowFullMenus;
end;

procedure TdxBarSubMenuControl.InvalidateItemsRect;
begin
  cxInvalidateRect(Handle, ItemsRect, False);
end;

procedure TdxBarSubMenuControl.InvalidateDetachCaption;
var
  DC: HDC;
begin
  DC := GetWindowDC(Handle);
  Painter.SubMenuControlDrawDetachCaption(Self, DC, DetachCaptionRect);
  ReleaseDC(Handle, DC);
end;

function TdxBarSubMenuControl.MouseOnArrow(AArrowDirection: TcxArrowDirection): Boolean;
begin
  Result := PtInRect(Painter.SubMenuControlGetScrollBandBounds(Self, AArrowDirection), ScreenToClient(GetMouseCursorPos));
end;

function TdxBarSubMenuControl.MouseOnUpArrow: Boolean;
begin
  Result := MouseOnArrow(adUp);
end;

function TdxBarSubMenuControl.MouseOnDownArrow: Boolean;
begin
  Result := MouseOnArrow(adDown);
end;

procedure ExpandMenuTimerProc(Wnd: HWND; Msg: UINT; idEvent: UINT; Time: DWORD); stdcall;
begin
  with TdxBarSubMenuControl(FindControl(Wnd)) do
  begin
    KillExpandMenuTimer;
    if idEvent = 3 then
      MarkState := msPressed
    else
      if ChildBar = nil then
        MarkState := msSelected;
  end;
end;

procedure TdxBarSubMenuControl.SetExpandMenuTimer(Time: UINT; ExpandAfterDelay: Boolean);
begin
  FExpandMenuTimer := SetTimer(Handle, 2 + Byte(ExpandAfterDelay), Time, @ExpandMenuTimerProc);
end;

procedure TdxBarSubMenuControl.KillExpandMenuTimer;
begin
  if FExpandMenuTimer <> 0 then
    dxKillTimer(Handle, FExpandMenuTimer);
end;

procedure TdxBarSubMenuControl.KillScrollTimer;
begin
  if FScrollTimerID <> 0 then
    dxKillTimer(Handle, FScrollTimerID);
end;

function TdxBarSubMenuControl.IsAnimationRunning: Boolean;
begin
  Result := (FAnimationThread <> nil) and not FAnimationThread.Suspended;
end;

function TdxBarSubMenuControl.IsDoubleBufferedNeeded: Boolean;
begin
  Result := inherited IsDoubleBufferedNeeded and not IsAnimationRunning;
end;

procedure TdxBarSubMenuControl.OnTerminateAnimation(Sender: TObject);
begin
  FAnimationThread := nil;
end;

procedure TdxBarSubMenuControl.WMEraseBkgnd(var Message: TWMEraseBkgnd);
begin
  FillBackground(Message.DC, ClientRect, ToolbarBrush, clNone, True);
  Message.Result := 1;
end;

procedure TdxBarSubMenuControl.WMGetDlgCode;
begin
  Message.Result := DLGC_WANTALLKEYS or DLGC_WANTARROWS or DLGC_WANTTAB;
end;

procedure TdxBarSubMenuControl.WMKeyDown(var Message: TWMKeyDown);
var
  Shift: TShiftState;
begin
  TerminateAnimation(True);

  Shift := KeyDataToShiftState(Message.KeyData);
  if (Message.CharCode in [VK_DOWN, VK_TAB]) and MarkExists then
    if (Message.CharCode = VK_DOWN) and (Shift = [ssCtrl]) then
    begin
      MarkState := msPressed;
      Exit;
    end
    else
      if (Shift = []) and (SelectedControl <> nil) then
        with SelectedControl.ItemLink do
          if VisibleIndex = Owner.VisibleItemCount - 1 then
          begin
            MarkState := msPressed;
            SendMessage(Handle, WM_KEYDOWN, Message.CharCode, 1);
            Exit;
          end;

  inherited;
end;

procedure TdxBarSubMenuControl.WMLButtonDown(var Message: TWMLButtonDown);
begin
  if FScrollTimerId <> 0 then Exit;
  inherited;
  if not BarControlExists(Self) then Exit;
  if FIgnoreMouseClick then Exit;
  TerminateAnimation(True);
  if DetachCaptionSelected then
    DoDetachMenu
  else
    if MarkExists and MouseOnMark then
      if MarkState = msNone then
      begin
        SetKeySelectedItem(nil);
        MarkState := msSelected;
      end
      else
      begin
        FIgnoreMouseClick := True;
        MarkState := msPressed;
      end;
end;

procedure TdxBarSubMenuControl.WMNCCalcSize(var Message: TWMNCCalcSize);
begin
  inherited;
  with Message.CalcSize_Params^ do
    rgrc[0] := cxRectContent(rgrc[0], GetClientOffset);
end;

procedure TdxBarSubMenuControl.WMNCHitTest(var Message: TWMNCHitTest);
var
  ADetachCaptionRect: TRect;
begin
  if Detachable then
  begin
    ADetachCaptionRect := cxRectOffset(DetachCaptionRect, Left, Top);
    if PtInRect(ADetachCaptionRect, SmallPointToPoint(Message.Pos)) then
      Message.Result := HTCLIENT
    else
      inherited;
  end
  else
    inherited;
end;

procedure TdxBarSubMenuControl.WMPrint(var Message: TMessage);
begin
  inherited;
  NCPaint(Message.WParam);
end;

procedure TdxBarSubMenuControl.WMRButtonDown(var Message: TWMRButtonUp);
begin
  inherited;
  if IsContextMenu then
    with TMessage(Message) do
      SendMessage(Handle, WM_LBUTTONDOWN, WParam, LParam);
end;

procedure TdxBarSubMenuControl.WMRButtonUp(var Message: TWMRButtonUp);
begin
  inherited;
  if IsContextMenu then
    with TMessage(Message) do
      SendMessage(Handle, WM_LBUTTONUP, WParam, LParam);
end;

procedure TdxBarSubMenuControl.WMTimer(var Message: TWMTimer);

  procedure EndScrollingSubMenu;
  var
    P: TPoint;
  begin
    KillScrollTimer;
    FLastMousePos := cxInvalidPoint;
    P := GetMouseCursorPos;
    if BarManager.Dragging then
    begin
      Windows.ScreenToClient(BarManager.Owner.Handle, P);
      PostMessage(BarManager.Owner.Handle, WM_MOUSEMOVE, 0, MakeLParam(P.X, P.Y));
    end
    else
    begin
      Windows.ScreenToClient(Handle, P);
      SendMessage(Handle, WM_MOUSEMOVE, 0, MakeLParam(P.X, P.Y));
    end;
  end;

  procedure InternalScroll(ATopIndex: Integer);
  begin
    if BarNavigationController.IsKeyTipsWaiting or BarNavigationController.KeyTipsHandlingMode then
      BarNavigationController.StopKeyboardHandling;
    TopIndex := ATopIndex;
  end;

begin
  if UpArrowExists and MouseOnUpArrow then
    InternalScroll(TopIndex - 1)
  else
    if DownArrowExists and MouseOnDownArrow then
      InternalScroll(TopIndex + 1)
    else
      EndScrollingSubMenu;
end;

procedure TdxBarSubMenuControl.CMFontChanged(var Message: TMessage);
begin
  inherited;
  Canvas.Font := Font;
  CalcDrawingConsts;
end;

procedure TdxBarSubMenuControl.CreateParams(var Params: TCreateParams);
begin
  inherited CreateParams(Params);

  Params.Style := WS_CLIPCHILDREN or WS_CLIPSIBLINGS or WS_POPUP;
  Params.ExStyle := Params.ExStyle or WS_EX_TOPMOST;
  Params.WindowClass.Style := CS_DBLCLKS or CS_HREDRAW or CS_VREDRAW or CS_OWNDC or CS_SAVEBITS;
  if FParentWnd > 0 then
    Params.WndParent := FParentWnd
  else
    Params.WndParent := BarManager.Owner.Handle;
end;

procedure TdxBarSubMenuControl.CreateWnd;

  procedure SetupAnimationInfo(AChangeXDirection: Boolean;
    AChangeYDirection: Boolean; var AAnimationInfo: TdxBarAnimationInfo);
  begin
    with AAnimationInfo do
    begin
      RealLeft := Left;
      RealTop := Top;
      RealClientWidth := ClientWidth;
      RealClientHeight := ClientHeight;
      BorderWidth := Width - ClientWidth;
      BorderHeight := Height - ClientHeight;
      LeftDirection := ((FXDirection = xdLeft) and not AChangeXDirection) or
        ((FXDirection = xdRight) and AChangeXDirection);
      TopDirection := ((FYDirection = ydTop) and not AChangeYDirection) or
        ((FYDirection = ydBottom) and AChangeYDirection);
      AnimationType := FMenuAnimations;
      case AnimationType of
        maUnfold:
          begin
            FirstValue := ClientHeight - ClientWidth;
            if FirstValue > 0 then
            begin
              OldClientRect := Rect(0, 0, 0, FirstValue);
              Delta := ClientWidth;
            end
            else
            begin
              OldClientRect := Rect(0, 0, -FirstValue, 0);
              Delta := ClientHeight;
            end;
            Step := 8;
          end;
        maSlide:
          begin
            FirstValue := 0;
            OldClientRect := Rect(0, 0, ClientWidth, 0);
            Delta := ClientHeight;
            Step := 17;
          end;
      else
        begin
          FirstValue := 0;
          Delta := 128;
          Step := 1;
        end;
      end;
      AnimationMenu := Self;
    end;
  end;

var
  AAnimationInfo: TdxBarAnimationInfo;
  AChangeXDirection, AChangeYDirection: Boolean;
begin
  //ProcessPaintMessages; - destroys submenu because of PeekMessage
  CreateLightBrush;
  inherited CreateWnd;

  FOnShowLeft := Left;
  FOnShowTop := Top;
  IsActive := True;
  SetRecentItemCount;
  FTopIndex := -1;
  TopIndex := 0;
  SetSizeAndCheckBounds(cxNullSize, AChangeXDirection, AChangeYDirection);

  CallNotify(OnShow, Self);

  if FShowAnimation then
  begin
    SetupAnimationInfo(AChangeXDirection, AChangeYDirection, AAnimationInfo);
    FAnimationThread := TdxBarAnimationThread.Create(AAnimationInfo);
    FAnimationThread.OnTerminate := OnTerminateAnimation;
    FAnimationThread.Suspended := False;
  end;
  PlaySound(psMenuPopup);
end;

procedure TdxBarSubMenuControl.DestroyWindowHandle;
begin
  if BarManager.Dragging and (BarManager.DraggingItemLink <> nil) and
    (ItemLinks.IndexOf(BarManager.DraggingItemLink) > -1) and
    (BarManager.DragInfo.DraggingItemLinkParentHandle = 0) then
  begin
    BarManager.DragInfo.DraggingItemLinkParentHandle := WindowHandle;
    Perform(WM_DESTROY, 0, 0);
    dxSetWindowProc(WindowHandle, DefWndProc);
    ShowWindow(WindowHandle, SW_HIDE);
    DestroyControls;
    WindowHandle := 0;
  end
  else
    inherited;
end;

procedure TdxBarSubMenuControl.DestroyWnd;
begin
  if not HandleAllocated or (bsDestroyWindow in FState) then
    Exit;
  Include(FState, bsDestroyWindow);
  try
    TerminateAnimation(False);
    KillScrollTimer;
    KillExpandMenuTimer;
    if ChildBar <> nil then
      ChildBar.DestroyWnd;
    if not FExpandingMenu then
      IsActive := False;
    inherited DestroyWnd;
  //  ProcessPaintMessages;
    DoCloseUp;
    DestroyLightBrush;
  finally
    Exclude(FState, bsDestroyWindow);
  end;
end;

procedure TdxBarSubMenuControl.DoCloseUp;
begin
  if Assigned(OnCloseUp) then
    OnCloseUp(Self, FCloseUpReason);
end;

procedure TdxBarSubMenuControl.DoPopup;
begin
  CallNotify(FOnPopup, Self);
end;

procedure TdxBarSubMenuControl.Paint;
begin
  if IsAnimationRunning or IsDestroying then
    Exit;

  Canvas.SaveClipRegion;
  try
    SelectClipRgn(Canvas.Handle, 0); // because of CS_OWNDC
    Painter.SubMenuControlDrawClientBorder(Self, Canvas.Handle, ClientRect, ToolbarBrush);
    DrawContent;
    DrawBar;
  finally
    Canvas.RestoreClipRegion;
  end;
end;

procedure TdxBarSubMenuControl.NCPaint(ADC: HDC);
begin
  DoNCPaint(ADC, NCRect);
end;

procedure TdxBarSubMenuControl.DoKeyDown(var Message: TWMKey);
var
  AParentBarControl: TCustomdxBarControl;
  AParentBarLink: TcxObjectLink;
begin
  case Message.CharCode of
    VK_ESCAPE:
      if (ParentBar <> nil) and (ParentBar.SelectedControl <> nil) then
      begin
        FCloseUpReason := bcrEscape;
        AParentBarControl := ParentBar;
        AParentBarLink := cxAddObjectLink(AParentBarControl);
        try
          AParentBarControl.SelectedControl.ControlInactivate(True);
          if AParentBarLink.Ref <> nil then
            AParentBarControl.IsDowned := False
        finally
          cxRemoveObjectLink(AParentBarLink);
        end;
      end
      else
        HideByEscape;

    VK_LEFT:
      begin
        AParentBarControl := ParentBar;
        if (AParentBarControl <> nil) and (AParentBarControl.SelectedControl <> nil) then
          if AParentBarControl is TdxBarSubMenuControl then
            AParentBarControl.SelectedControl.ControlInactivate(True)
          else
          begin
            AParentBarControl := GetParentBarForBar(Self);
            if AParentBarControl <> nil then
              if AParentBarControl.IsRealVertical then
                Message.Result := SendMessage(Handle, WM_KEYDOWN, VK_ESCAPE, 0)
              else
                Message.Result := SendMessage(AParentBarControl.Handle, WM_KEYDOWN, VK_LEFT, 0);
          end;
      end;

    VK_RIGHT:
      begin
        AParentBarControl := GetParentBarForBar(Self);
        if AParentBarControl <> nil then
          Message.Result := SendMessage(AParentBarControl.Handle, WM_KEYDOWN, VK_RIGHT, 0);
      end;
  else
    inherited;
  end;
end;

procedure TdxBarSubMenuControl.CalcControlsPositions;
begin
  inherited;
  CalcItemRects(ptMenu, TopIndex);
  CalcLayout;
end;

procedure TdxBarSubMenuControl.CalcDrawingConsts;
begin
  inherited CalcDrawingConsts;
  Painter.SubMenuControlCalcDrawingConsts(Canvas, FTextSize, ScaleFactor, FMenuArrowWidth, FMarkSize);
  dxAdjustToTouchableSize(FMarkSize, ScaleFactor);
end;

procedure TdxBarSubMenuControl.CalcDragOverParameters(const ACursorPos: TPoint;
  var ADragOverItemLink: TdxBarItemLink;
  var AIsBeginGroup, AIsFirstPart, AIsVerticalDirection: Boolean);
begin
  if not (UpArrowExists and MouseOnUpArrow or
      DownArrowExists and MouseOnDownArrow or
      MarkExists and MouseOnMark) then
    inherited CalcDragOverParameters(ACursorPos, ADragOverItemLink, AIsBeginGroup, AIsFirstPart, AIsVerticalDirection);
end;

procedure TdxBarSubMenuControl.CalcItemsRect;
begin
  inherited CalcItemsRect;
  Dec(FItemsRect.Bottom, GetMarkSize);
end;

function TdxBarSubMenuControl.CanActiveChange: Boolean;
begin
  Result := True;
end;

function TdxBarSubMenuControl.CanCustomizing: Boolean;
begin
  Result := inherited CanCustomizing or
    (ItemLinks.Owner is TdxBarSubItem) and TdxBarSubItem(ItemLinks.Owner).AllowCustomizing or
    (ItemLinks.Owner is TdxBarCustomPopupMenu);
end;

function TdxBarSubMenuControl.CanDrawClippedItem(AItemRect: TRect): Boolean;
begin
  Result := AItemRect.Top < Painter.SubMenuControlGetScrollBandBounds(Self, adDown).Top;
end;

function TdxBarSubMenuControl.CanShowHint: Boolean;
begin
   Result := bboAllowShowHints in BehaviorOptions;
end;

function TdxBarSubMenuControl.CheckLockUpdate: Boolean;
begin
  Result := inherited CheckLockUpdate;
  if Result and
    ((BarManager.FChangedSubMenuControl = nil) or IsChildBar(BarManager.FChangedSubMenuControl)) then
    BarManager.FChangedSubMenuControl := Self;
end;

function TdxBarSubMenuControl.ChildrenHaveShadows: Boolean;
begin
  Result := False;
end;

procedure TdxBarSubMenuControl.CorrectVisibleItemsRectBottom;
begin
  if UseScrollButtons and DownArrowExists then
    Dec(FVisibleItemsRect.Bottom, Painter.SubMenuControlGetScrollBandSize(Self));
end;

procedure TdxBarSubMenuControl.CorrectVisibleItemsRectTop;
begin
  if UseScrollButtons and UpArrowExists then
    Inc(FVisibleItemsRect.Top, Painter.SubMenuControlGetScrollBandSize(Self));
end;

procedure TdxBarSubMenuControl.DoCreateControls;
begin
  if not IsCustomizing then
    ExpandContainerItems;
  inherited DoCreateControls;
end;

procedure TdxBarSubMenuControl.DoDestroyControls;
begin
  inherited DoDestroyControls;
  if not IsCustomizing then
    CollapseContainerItems;
end;

procedure TdxBarSubMenuControl.DoBarMouseLeave;
begin
  DetachCaptionSelected := False;
  if UpArrowExists or DownArrowExists then
    DrawScrollArea;
  inherited;
end;

procedure TdxBarSubMenuControl.DoBarMouseMove(Shift: TShiftState; const APoint: TPoint;
  AItemControl: TdxBarItemControl);
begin
  if not NotHandleMouseMove then
  begin
    TerminateAnimation(True);
    if not BarControlExists(Self) then Exit;
  end
  else
    if IsAnimationRunning then
      Exit;

  if WantMouse and (ParentBar <> nil) and (ParentItemControl <> nil) then
    ParentBar.SetMouseSelectedItem(ParentItemControl);

  if MarkExists then
    if MouseOnMark then
      MarkState := msSelected
    else
      MarkState := msNone;

  if UpArrowExists and MouseOnUpArrow or DownArrowExists and MouseOnDownArrow then
  begin
    if (FScrollTimerId = 0) and not cxPointIsEqual(FLastMousePos, ClientToScreen(APoint)) then
    begin
      if SelectedControl = BarManager.SelectedItem then
        BarManager.InternalSetSelectedItem(nil);  // otherwise BarManager will hide all
      SetKeySelectedItem(nil);
      FScrollTimerId := SetTimer(Handle, 1, GetScrollTime, nil);
    end;
  end
  else
  begin
    if (FScrollTimerId <> 0) and dxKillTimer(Handle, FScrollTimerId) then
    begin
      FLastMousePos := cxInvalidPoint;
      DrawScrollArea;
    end;
    inherited;
    if BarManager.IsHintActive and not cxPointIsEqual(ClientToScreen(APoint), FLastMousePos) then
      BarManager.HideHint;
  end;

  if Detachable then
    DetachCaptionSelected := MouseOnDetachCaption;
end;

procedure TdxBarSubMenuControl.DoDropFocus;
begin
  if FParentWnd <> 0 then
    Windows.SetFocus(FParentWnd)
  else
    inherited;
end;

procedure TdxBarSubMenuControl.DoNCPaint(DC: HDC; const ARect: TRect);
begin
  Painter.SubMenuControlDrawBorder(Self, DC, ARect);
end;

procedure TdxBarSubMenuControl.DoHideAll(AReason: TdxBarCloseUpReason);
begin
  if ParentBar = nil then
  begin
    ChildBar := nil;
    Hide;
    ProcessPaintMessages;
  end
  else
    inherited;
end;

procedure TdxBarSubMenuControl.DoPaintItem(AControl: TdxBarItemControl; ACanvas: TcxCanvas; const AItemRect: TRect);
var
  ASeparatorIndex: Integer;
  ANonRecent: Boolean;
begin
  if IsRectEmpty(AItemRect) then
    Exit;
  ANonRecent := not Painter.IgnoreNonRecentColor and AControl.FNonRecent;
  if ANonRecent then
  begin
    PreparePalette(ACanvas.Handle);
    FBkBrush := FLightBrush;
  end
  else
    Painter.SubMenuControlPrepareBkBrush(Self, FBkBrush);

  if ViewInfo.IsAssociatedWithSeparator(AControl, ASeparatorIndex) then
    Painter.SubMenuControlDrawBeginGroup(Self, AControl, ACanvas,
      ViewInfo.SeparatorInfos[ASeparatorIndex].Bounds);

  Painter.SubMenuControlDrawItemFrame(Self, AControl, ACanvas.Handle, AItemRect, AControl.ItemLink.VisibleIndex);

  inherited DoPaintItem(AControl, ACanvas, AItemRect);

  if ANonRecent then
    UnpreparePalette(ACanvas.Handle);
end;

procedure TdxBarSubMenuControl.DoRepaintBar(ARecreateControls: Boolean);
var
  AWasVisible, AChangeXDirection, AChangeYDirection, NeedRepaint: Boolean;
  PrevTopIndex: Integer;
begin
  AWasVisible := IsWindowVisible(Handle);

  inherited DoRepaintBar(ARecreateControls);

  SetRecentItemCount;
  if (Left <> FOnShowLeft) or (Top <> FOnShowTop) then
  begin
    ShowWindow(Handle, SW_HIDE);
    Left := FOnShowLeft;
    Top := FOnShowTop;
    NeedRepaint := False;
  end
  else
    NeedRepaint := True;
  SetSizeAndCheckBounds(cxNullSize, AChangeXDirection, AChangeYDirection);
  CalcControlsPositions;

  if UpArrowExists and not DownArrowExists then
  begin
    PrevTopIndex := FTopIndex;
    repeat
      Dec(FTopIndex);
      CalcControlsPositions;
    until DownArrowExists or (FTopIndex = 0);
    if DownArrowExists then Inc(FTopIndex);
    NeedRepaint := NeedRepaint or (FTopIndex <> PrevTopIndex);
  end;

  if AWasVisible then Show;
  if NeedRepaint then
  begin
    CalcControlsPositions;
    Invalidate;
  end;
end;

procedure TdxBarSubMenuControl.DoSetIsActive(AValue: Boolean);
begin
  inherited;
  if not BarControlExists(Self) then Exit;
  if IsActive and
    BarManager.ShowRecentItemsFirst and not ShowFullMenus and
    BarManager.ShowFullMenusAfterDelay then
    SetExpandMenuTimer(dxBarSlowExpandMenuTime, True);
end;

procedure TdxBarSubMenuControl.DragOver(X, Y: Integer; var Accept: Boolean);
begin
  SendMessage(Handle, WM_MOUSEMOVE, 0, MakeLParam(X, Y));
  if FScrollTimerID > 0 then
    Accept := False;
end;

function TdxBarSubMenuControl.AllowSelectionFrame: Boolean;
begin
  Result := True;
end;

function TdxBarSubMenuControl.ChangeSizeByChildItemControl(
  out ASize: TSize): Boolean;
begin
  ASize := cxNullSize;
  Result := False;
end;

function TdxBarSubMenuControl.GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass;
begin
  Result := TdxBarSubMenuControlAccessibilityHelper;
end;

function TdxBarSubMenuControl.GetBeginGroupSize: Integer;
begin
  Result := Painter.SubMenuControlBeginGroupSize;
end;

function TdxBarSubMenuControl.GetBehaviorOptions: TdxBarBehaviorOptions;
begin
  Result := inherited GetBehaviorOptions +
    [bboAllowSelectWindowItemsWithoutFocusing, bboExtendItemWhenAlignedToClient] -
    [bboMouseCantUnselectNavigationItem, bboSubMenuCaptureMouse];
end;

function TdxBarSubMenuControl.GetBottomItemControl: TdxBarItemControl;
begin
   Result := ItemLinks.VisibleItems[TopIndex + Max(MaxVisibleCount, 1) - 1].Control;
end;

function TdxBarSubMenuControl.GetDefaultItemHeight(AItem: TdxBarItemControl): Integer;
var
  AItemHeight: Integer;
begin
  AItemHeight := inherited GetDefaultItemHeight(AItem);
  case AItem.MenuItemSize of
    misNormal: Result := AItemHeight;
  else {misLarge}
      if ItemLinks.ItemShowDescriptions then
        Result := Trunc(AItemHeight * 2.5)
//        Result := Round(AItemHeight * 2.35)
      else
        Result := AItemHeight * 2;
  end;
end;

function TdxBarSubMenuControl.GetEditFont: TFont;
begin
  if ParentBar = nil then
    if (ItemLinks.Owner is TdxBarCustomPopupMenu) and
      TdxBarCustomPopupMenu(ItemLinks.Owner).UseOwnFont then
      Result := TdxBarCustomPopupMenu(ItemLinks.Owner).FEditFont
    else
      Result := inherited GetEditFont
  else
    Result := ParentBar.GetEditFont;
end;

function TdxBarSubMenuControl.GetIsContextMenu: Boolean;
begin
  Result :=
    (OwnerWidth = 0) and (OwnerHeight = 0) or
    (ParentBar is TdxBarSubMenuControl) and TdxBarSubMenuControl(ParentBar).IsContextMenu;
end;

function TdxBarSubMenuControl.GetIsCustomizing: Boolean;
begin
  if IsInternal {or  //#DG IsInternal should be recursive
    (GetItemByControl(FSubItem) is TdxBarSubItem) and TdxBarSubItem(GetItemByControl(FSubItem)).IsInternal} then
    Result := False
  else
    Result := inherited GetIsCustomizing;
end;

function TdxBarSubMenuControl.GetIsMainMenu: Boolean;
begin
  Result := False;
end;

function TdxBarSubMenuControl.GetIsStatusBar: Boolean;
begin
  Result := False;
end;

function TdxBarSubMenuControl.GetIsShadowVisible: Boolean;
begin
  Result := inherited GetIsShadowVisible and not FShowAnimation;
end;

function TdxBarSubMenuControl.GetItemControlOffset(AItemLink: TdxBarItemLink): Integer;
begin
  Result := 0;
  if AItemLink.Control.FChangeRecentGroup and Painter.SubMenuControlIsOffsetRecentGroupNeeded then
    Inc(Result);
  if AItemLink.BeginGroup and
    not ((AItemLink.VisibleIndex = TopIndex) or UpArrowExists and (AItemLink.VisibleIndex = TopIndex + 1)) then
    Inc(Result, BeginGroupSize);
end;

function TdxBarSubMenuControl.GetItemRectEx(Item: TdxBarItemControl;
  IsBeginGroup: Boolean): TRect;
var
  AIndex: Integer;
begin
  Result := inherited GetItemRectEx(Item, IsBeginGroup);
  if Item <> nil then
  begin
    if Item.FChangeRecentGroup and
      Painter.SubMenuControlIsOffsetRecentGroupNeeded then
      Dec(Result.Top);
    if IsBeginGroup and Item.ItemLink.BeginGroup then
    begin
      AIndex := Item.ItemLink.VisibleIndex;
      if (AIndex > TopIndex) and not (UpArrowExists and (AIndex = TopIndex + 1)) then
        Dec(Result.Top, BeginGroupSize);
    end;
  end;
end;

function TdxBarSubMenuControl.GetItemsPaneSize: TSize;
var
  AItemLink: TdxBarItemLink;
  AItemLinkControlSize: TSize;
  I: Integer;
begin
  Result := cxNullSize;
  for I := TopIndex to ItemLinks.VisibleItemCount - 1 do
  begin
    AItemLink := ItemLinks.VisibleItems[I];
    AItemLinkControlSize := AItemLink.Control.GetRealSize;
    Result.cx := Max(Result.cx, AItemLinkControlSize.cx);
    Result.cy := Result.cy + GetItemControlOffset(AItemLink) + AItemLinkControlSize.cy;
  end;
  if UseScrollButtons and UpArrowExists then
    Inc(Result.cy, Painter.SubMenuControlGetScrollBandSize(Self));
end;

function TdxBarSubMenuControl.GetHintItemText: string;
begin
  if FDetachCaptionSelected then
    Result := cxGetResourceString(@dxSBAR_DRAGTOMAKEMENUFLOAT)
  else
    if MarkState = msSelected then
      Result := cxGetResourceString(@dxSBAR_EXPAND)
    else
      Result := inherited GetHintItemText;
end;

function TdxBarSubMenuControl.GetPaintType: TdxBarPaintType;
begin
  Result := ptMenu;
end;

function TdxBarSubMenuControl.GetScaleFactor: TdxScaleFactor;
var
  AScaleFactor: IdxScaleFactor;
begin
  if (ParentBar = nil) and Supports(ItemLinks.Owner, IdxScaleFactor, AScaleFactor) then
    Result := AScaleFactor.Value
  else
    Result := inherited GetScaleFactor;
end;

function TdxBarSubMenuControl.GetSelectableObject: TPersistent;
begin
  if (ParentBar <> nil) and (ParentBar.SelectedControl <> nil) then
    Result := ParentBar.SelectedControl.ItemLink
  else
    Result := ItemLinks.Owner;
end;

function TdxBarSubMenuControl.GetTextSize: Integer;
begin
  Result := Painter.SubMenuControlTextSize(Canvas, ScaleFactor);
end;

function TdxBarSubMenuControl.GetTopItemControl: TdxBarItemControl;
begin
  Result := ItemLinks.VisibleItems[TopIndex].Control;
end;

function TdxBarSubMenuControl.GetViewInfoClass: TCustomdxBarControlViewInfoClass;
begin
  Result := TdxBarSubMenuControlViewInfo;
end;

function TdxBarSubMenuControl.NeedHideOnClick: Boolean;
begin
  Result := True;
end;

function TdxBarSubMenuControl.IsInternal: Boolean;
begin
  Result := (ParentBar <> nil) and (ParentBar.IsInternal);
end;

function TdxBarSubMenuControl.IsMeaningParent(AWnd: HWND): Boolean;
begin
  Result := (FOwnerControl <> nil) and FOwnerControl.HandleAllocated and (AWnd = FOwnerControl.Handle);
end;

function TdxBarSubMenuControl.IsPopup: Boolean;
begin
  Result := True;
end;

function TdxBarSubMenuControl.IsVerticalDirection: Boolean;
begin
  Result := True;
end;

function TdxBarSubMenuControl.MustFitInWorkAreaWidth: Boolean;
begin
  Result := False;
end;

function TdxBarSubMenuControl.NeedBufferedRepaint: Boolean;
begin
  Result := Painter.IsNativeBackground;
end;

function TdxBarSubMenuControl.NeedsSelectFirstItemOnDropDownByKey: Boolean;
begin
  Result := True;
end;

function TdxBarSubMenuControl.NotHandleMouseMove(ACheckLastMousePos: Boolean): Boolean;
begin
  Result := inherited NotHandleMouseMove(ACheckLastMousePos) or
    (ACheckLastMousePos and cxPointIsEqual(FLastMousePos, cxInvalidPoint) and
     cxPointIsEqual(FMousePosOnPopup, GetMouseCursorPos));
end;

procedure TdxBarSubMenuControl.SetFont;
begin
  if ParentBar = nil then
    if ItemLinks.Owner is TdxBarCustomPopupMenu then
      Font := TdxBarCustomPopupMenu(ItemLinks.Owner).Font
    else
      Font := BarManager.Font
  else
    Font := ParentBar.Font;
end;

procedure TdxBarSubMenuControl.SetRecentItemCount;
begin
  if ItemLinks.BarManager.ShowRecentItemsFirst and not ShowFullMenus then
    ItemLinks.RecentItemCount := ItemLinks.MostRecentItemCount
  else
    ItemLinks.RecentItemCount := -1;
end;

procedure TdxBarSubMenuControl.SetAccelSelectedItem(AItemLink: TdxBarItemLink; ADuplicate: Boolean);
var
  AHidden: Boolean;
begin
  AHidden := AItemLink.VisibleIndex = -1;
  if (BarManager.GetPaintStyle <> bmsStandard) and
    AHidden and (ADuplicate or not AItemLink.Control.CanDestroyOnClick) then
      MarkState := msPressed;
  inherited;
end;

procedure TdxBarSubMenuControl.SetControlVisible(AControl: TdxBarItemControl);

  function ScrollNeeded(AScrollDirection: TcxArrowDirection): Boolean;
  var
    AIndex: Integer;
  begin
    AIndex := AControl.ItemLink.VisibleIndex;
    case AScrollDirection of
      adUp:
        Result := (AIndex < TopVisibleItemIndex) or
          (not IsRectEmpty(AControl.ItemBounds) and (AControl.ItemBounds.Top < VisibleItemsRect.Top));
    else {adDown}
      Result := (AIndex > BottomVisibleItemIndex) or
        (TopIndex < ItemLinks.VisibleItemCount - 1) and
        (not IsRectEmpty(AControl.ItemBounds) and (AControl.ItemBounds.Bottom > VisibleItemsRect.Bottom));
    end;
  end;

  procedure Scroll(AScrollDirection: TcxArrowDirection);
  const
    AStep: array [TcxArrowDirection] of Integer = (-1, 1, 0, 0);
  begin
    repeat
      FTopIndex := Max(FTopIndex + AStep[AScrollDirection], 0);
      CalcControlsPositions;
    until not ScrollNeeded(AScrollDirection);
    InvalidateItemsRect;
  end;

begin
  if UpArrowExists and ScrollNeeded(adUp) then
    Scroll(adUp)
  else
    if DownArrowExists and ScrollNeeded(adDown) then
      Scroll(adDown);
end;

procedure TdxBarSubMenuControl.SetSelectedControl(Value: TdxBarItemControl);
begin
  if MarkState = msNone then
  begin
    KillExpandMenuTimer;
    if IsActive and BarManager.ShowRecentItemsFirst and
      not ShowFullMenus and BarManager.ShowFullMenusAfterDelay then
      SetExpandMenuTimer(dxBarSlowExpandMenuTime, False);
  end;
  if (Value <> nil) and not Value.FSelectedByMouse then
    SetControlVisible(Value);
  inherited SetSelectedControl(Value);
end;

procedure TdxBarSubMenuControl.SetSizeAndCheckBounds(
  const APredefinedSize: TSize; out AChangeXDirection, AChangeYDirection: Boolean);

  procedure CheckHorizontal(out AChangeXDirection: Boolean; var ASize: TSize; const AWorkArea: TRect);
  begin
    if Left + ASize.cx > AWorkArea.Right then
    begin
      if OwnerWidth = 0 then
      begin
        if (OwnerHeight = 0) and (Left - ASize.cx >= AWorkArea.Left) then
        begin
          Left := Left - ASize.cx;  // for PopupMenu
          AChangeXDirection := True;
        end
        else
          Left := AWorkArea.Right - ASize.cx;
      end
      else
        if Left - OwnerWidth - AWorkArea.Left > AWorkArea.Right - Left then
        begin
          Left := Left - OwnerWidth - ASize.cx;
          AChangeXDirection := True;
        end;
    end;

    if Left < AWorkArea.Left then
    begin
      if OwnerWidth = 0 then
        Left := AWorkArea.Left
      else
        if (FXDirection = xdLeft) and
          (AWorkArea.Right - (Left + ASize.cx + OwnerWidth) > Left + ASize.cx - AWorkArea.Left) then
        begin
          Left := Left + ASize.cx + OwnerWidth;
          AChangeXDirection := True;
        end;
    end;

    if Left + ASize.cx > AWorkArea.Right then
      Left := AWorkArea.Right - ASize.cx;
    if Left < AWorkArea.Left then
      Left := AWorkArea.Left;
    if MustFitInWorkAreaWidth and (Left + ASize.cx > AWorkArea.Right) then
      ASize.cx := AWorkArea.Right - Left;
  end;

  procedure CheckVertical(out AChangeYDirection: Boolean; var ASize: TSize; const AWorkArea: TRect);
  begin
    if Top + ASize.cy > AWorkArea.Bottom then
    begin
      if OwnerHeight = 0 then
      begin
        if (OwnerWidth = 0) and (Top - ASize.cy >= AWorkArea.Top) then  // for PopupMenu
        begin
          Top := Top - ASize.cy;
          AChangeYDirection := True;
        end
        else
          Top := AWorkArea.Bottom - ASize.cy;
      end
      else
        if Top - OwnerHeight - AWorkArea.Top > AWorkArea.Bottom - Top then
        begin
          Top := Top - OwnerHeight - ASize.cy;
          AChangeYDirection := True;
        end
        else
          ASize.cy := AWorkArea.Bottom - Top;
    end;

    if Top < AWorkArea.Top then
    begin
      if FYDirection = ydBottom then
      begin
        if AChangeYDirection and (OwnerHeight <> 0) then
        begin
          ASize.cy := ASize.cy - (AWorkArea.Top - Top);
          Top := AWorkArea.Top;
        end
        else
        begin
          Top := AWorkArea.Top;
          if Top + ASize.cy > AWorkArea.Bottom then
            ASize.cy := AWorkArea.Bottom - Top;
        end
      end
      else
        if (OwnerHeight <> 0) and
          (AWorkArea.Bottom - (Top + ASize.cy + OwnerHeight) > Top + ASize.cy - AWorkArea.Top) then
        begin
          Top := Top + ASize.cy + OwnerHeight;
          if Top + ASize.cy > AWorkArea.Bottom then ASize.cy := AWorkArea.Bottom - Top;
          AChangeYDirection := True;
        end;
    end;
  end;

var
  AReturnedChangeXDirection: Boolean;
  AReturnedChangeYDirection: Boolean;
  ASize: TSize;
  AWorkArea, ABounds: TRect;
  APopupAlignment: TPopupAlignment;
begin
  if (ParentBar = nil) or not ParentBar.CalcChildBarBounds(ABounds) then
  begin
    if cxSizeIsEqual(APredefinedSize, cxNullSize) then
    begin
      CalcBounds(ASize);
      APopupAlignment := FPopupAlignment;
      if UseRightToLeftAlignment then
      begin
        case APopupAlignment of
          paLeft:
            APopupAlignment := paRight;
          paRight:
            APopupAlignment := paLeft
        end;
        FXDirection := xdLeft;
      end
      else
        FXDirection := xdRight;
      case APopupAlignment of
        paRight:
          Left := Left - ASize.cx;
        paCenter:
          Left := Left - ASize.cx div 2;
      end;
    end
    else
      ASize := APredefinedSize;

    AChangeXDirection := False;
    AChangeYDirection := False;
    if FXDirection = xdLeft then
      AWorkArea := GetWorkArea(Point(Left + ASize.cx, Top))
    else
      AWorkArea := GetWorkArea(Point(Left, Top));
    CheckHorizontal(AChangeXDirection, ASize, AWorkArea);
    CheckVertical(AChangeYDirection, ASize, AWorkArea);
    ABounds := cxRectBounds(Left, Top, ASize.cx, ASize.cy);
  end;

  SetBounds(ABounds.Left, ABounds.Top, cxRectWidth(ABounds), cxRectHeight(ABounds));
  if not FLockChangeSizeByChildItemControl and ChangeSizeByChildItemControl(ASize) then
  begin
    FLockChangeSizeByChildItemControl := True;
    try
      SetSizeAndCheckBounds(ASize, AReturnedChangeXDirection, AReturnedChangeYDirection);
      AChangeXDirection := AChangeXDirection xor AReturnedChangeXDirection;
      AChangeYDirection := AChangeYDirection xor AReturnedChangeYDirection;
    finally
      FLockChangeSizeByChildItemControl := False;
    end;
  end;
end;

procedure TdxBarSubMenuControl.ShowPopup(AItem: TdxBarItemControl);
begin
  if not BarManager.IsCustomizing and (GetLinkByControl(AItem) <> nil) then
    BarDesignController.ShowCustomCustomizePopup(BarManager, InitCustomizationPopup, Painter, Self, GetLinkByControl(AItem))
  else
    if (ItemLinks.Count = 0) and (ParentBar <> nil) then
      DoShowPopup(ParentBar.SelectedControlAtDesign)
    else
      inherited;
end;

procedure TdxBarSubMenuControl.TerminateAnimation(ANeedFinish: Boolean);
var
  AAnimationThread: TThread;
begin
  if FAnimationThread <> nil then
  begin
    AAnimationThread := FAnimationThread;
    FAnimationThread := nil;
    AAnimationThread.OnTerminate := nil;
    TdxBarAnimationThread(AAnimationThread).TerminateAnimation(ANeedFinish);
  end;
end;

procedure TdxBarSubMenuControl.UpdateItem(AControl: TdxBarItemControl);

  function NeedsBufferedRepaint: Boolean;
  begin
    Result := NeedBufferedRepaint or AControl.NeedBufferedRepaint;
  end;

  function GetSeparatorBounds: TRect;
  var
    ASeparatorIndex: Integer;
  begin
    if ViewInfo.IsAssociatedWithSeparator(AControl, ASeparatorIndex) then
      Result := ViewInfo.SeparatorInfos[ASeparatorIndex].Bounds
    else
      Result := cxEmptyRect;
  end;

  procedure BufferedRepaint;
  var
    ABitmapRect: TRect;
    ABitmapCanvas: TcxCanvas;
  begin
    ABitmapRect := cxRectUnion(AControl.ViewInfo.Bounds, GetSeparatorBounds);
    BackgroundTempBitmap.SetSize(ABitmapRect);

    ABitmapCanvas := BackgroundTempBitmap.cxCanvas;
    ABitmapCanvas.WindowOrg := ABitmapRect.TopLeft;
    ABitmapCanvas.UseRightToLeftAlignment := Canvas.UseRightToLeftAlignment;
    ABitmapCanvas.TextFlags := Canvas.TextFlags;
    PaintItem(ABitmapCanvas, AControl);

    Canvas.SaveClipRegion;
    try
      Canvas.ExcludeClipRect(AControl.GetNonBufferedRect);
      cxBitBlt(Canvas.Handle, ABitmapCanvas.Handle, ABitmapRect, ABitmapRect.TopLeft, SRCCOPY);
    finally
      Canvas.RestoreClipRegion;
    end;
  end;

begin
  if CanControlPaint(AControl) then
  begin
    if NeedsBufferedRepaint then
      BufferedRepaint
    else
      PaintItem(Canvas, AControl);
  end;
end;

procedure TdxBarSubMenuControl.UpdateParentItemControl;
begin
  if IsCustomizing then
  begin
    SelectedLink := nil;
    if (ParentItemControl <> nil) and not ParentItemControl.IsDestroying then
    begin
      BarManager.InternalSetSelectedItem(ParentItemControl);
      ParentItemControl.FIsActive := False;
      ParentItemControl.Repaint;
    end;
  end;
end;

procedure TdxBarSubMenuControl.InitCustomizationPopup(AItemLinks: TdxBarItemLinks);
begin
  if ParentBar <> nil then
    ParentBar.InitCustomizationPopup(AItemLinks);
end;

function TdxBarSubMenuControl.CanDetach: Boolean;
begin
  Result := Detachable and
    (FSubItem.Item.GetDetachingBar <> nil) and
    ((GetParentBarForBar(FSubItem.Parent) = nil) or
     (GetParentBarForBar(FSubItem.Parent) <> FSubItem.Item.GetDetachingBar.Control));
end;

function TdxBarSubMenuControl.Detachable: Boolean;
begin
  Result := (bboAllowDetach in BehaviorOptions) and (FSubItem <> nil) and FSubItem.Item.Detachable;
end;

function TdxBarSubMenuControl.DetachCaptionAreaSize: Integer;
begin
  Result := Painter.SubMenuControlDetachCaptionAreaSize(Self);
end;

function TdxBarSubMenuControl.DetachCaptionRect: TRect;
begin
  Result := NCRect;
  Painter.SubMenuControlOffsetDetachCaptionRect(Self, Result);
  with Result do
    Bottom := Top + DetachCaptionSize;
end;

function TdxBarSubMenuControl.MouseOnDetachCaption: Boolean;
begin
  Result := PtInRect(DetachCaptionRect, cxPointOffset(GetMouseCursorPos, -Left, -Top));
end;

procedure TdxBarSubMenuControl.DoDetachMenu;
var
  ADetachingBar: TdxBar;
  ASubItem: TdxBarSubItemControl;
  NonDetachableArea: TRect;
  Success, Started: Boolean;
  PrevP, P: TPoint;
  CaptureWnd: HWND;
  Msg: TMsg;
  ABarCaptionAriaSize: Integer;
  AMessage: TMessage;
begin
  FSubItem.Item.DoDetaching;
  if not CanDetach then Exit;
  ADetachingBar := FSubItem.Item.GetDetachingBar;
  ASubItem := FSubItem;

  NonDetachableArea := DetachCaptionRect;
  OffsetRect(NonDetachableArea, Left, Top);
  InflateRect(NonDetachableArea, DetachAreaDelta, DetachAreaDelta);

  Success := False;
  Started := False;
  PrevP := GetMouseCursorPos;
  ABarCaptionAriaSize := Painter.BarCaptionAreaSize(ScaleFactor);

  Include(BarDesignController.FDesignStates, dsKeyAlreadyProcessed);
  CaptureWnd := ParentBar.Handle;
  SetCapture(CaptureWnd);
  try
    while GetCapture = CaptureWnd do
    begin
      case Integer(GetMessage(Msg, 0, 0, 0)) of
        -1: Break;
        0: begin
            PostQuitMessage(Msg.wParam);
            Break;
          end;
      end;
      case Msg.message of
        WM_KEYDOWN, WM_KEYUP:
          if Msg.wParam = VK_ESCAPE then
          begin
            ASubItem.ControlActivate(True, False);
            Break;
          end;
        WM_MOUSEMOVE:
          begin
            AMessage.LParam := Msg.lParam;
            P := SmallPointToPoint(TWMMouseMove(AMessage).Pos);
            Windows.ClientToScreen(Msg.hwnd, P);
            if (P.X <> PrevP.X) or (P.Y <> PrevP.Y) then
            begin
              if not Started and not PtInRect(NonDetachableArea, P) then
              begin
                ASubItem.ControlInactivate(True);
                if ADetachingBar.DockingStyle <> dsNone then
                begin
                  ADetachingBar.Visible := False;
                  ADetachingBar.DockingStyle := dsNone;
                end;
                if not ADetachingBar.Visible then
                begin
                  ADetachingBar.FloatLeft := P.X - 100;
                  ADetachingBar.FloatTop := P.Y - ABarCaptionAriaSize div 2;
                  ADetachingBar.Visible := True;
                end;
                Started := True;
              end;
              if Started then
                if PtInRect(NonDetachableArea, P) then
                begin
                  ADetachingBar.Visible := False;
                  ASubItem.ControlActivate(True, True);
                  Break;
                end
                else
                  with ADetachingBar.Control do
                    SetWindowPos(Handle,
                      0, P.X - Width div 2, P.Y - Painter.BarCaptionAreaSize(ScaleFactor) div 2, 0, 0,
                      SWP_NOZORDER or SWP_NOSIZE or SWP_NOACTIVATE);
              PrevP := P;
            end;
          end;
        WM_LBUTTONUP:
          begin
            Success := True;
            Break;
          end;
      else
        TranslateMessage(Msg);
        DispatchMessage(Msg);
      end;
    end;
  finally
    if GetCapture = CaptureWnd then ReleaseCapture;
    if Started then
      if Success then
        ADetachingBar.BarManager.HideAll
      else
        ADetachingBar.Visible := False;
    Exclude(BarDesignController.FDesignStates, dsKeyAlreadyProcessed);
  end;
end;

function TdxBarSubMenuControl.MarkArrowSize: Integer;
begin
  Result := Painter.SubMenuControlMarkArrowSize(MarkSize);
end;

function TdxBarSubMenuControl.MarkExists: Boolean;
begin
  Result := BarManager.ShowRecentItemsFirst and
    (ItemLinks.VisibleItemCount < ItemLinks.CanVisibleItemCount);
end;

function TdxBarSubMenuControl.MarkRect: TRect;
var
  AOffset: Integer;
begin
  Result := ClientRect;
  AOffset := Painter.SubMenuControlClientBorderSize;
  Inc(Result.Left, AOffset + BarSize);
  Dec(Result.Right, AOffset);
  Dec(Result.Bottom, AOffset);
  Result.Top := Result.Bottom - MarkSize;
  if UseRightToLeftAlignment then
    Result := TdxRightToLeftLayoutConverter.ConvertRect(Result, ClientRect);
end;

procedure TdxBarSubMenuControl.SetMarkState(Value: TdxBarMarkState);
begin
  if IsCustomizing or not BarManager.ShowRecentItemsFirst then Exit;
  if (Value = msSelected) and (SelectedControl <> nil) and SelectedControl.Focused then
    Value := msNone;
  if FMarkState <> Value then
  begin
    FMarkState := Value;
    if Value = msPressed then
      ExpandMenu
    else
      cxInvalidateRect(Handle, MarkRect, False);
    if BarManager.ShowFullMenusAfterDelay then
    begin
      KillExpandMenuTimer;
      if (FMarkState = msSelected) and MouseOnMark then
        SetExpandMenuTimer(BarManager.GetShowHintTime, True);
    end
    else
      if FMarkState = msSelected then
        ActivateHint
      else
        BarManager.HideHint;
  end;
end;

function TdxBarSubMenuControl.DownArrowExists: Boolean;
begin
  Result := (ItemLinks.VisibleItemCount - TopIndex > MaxVisibleCount) or
    (TopIndex < ItemLinks.VisibleItemCount - 1) and
    (ItemLinks.VisibleItemCount > 0) and
    (ItemLinks.VisibleItems[ItemLinks.VisibleItemCount - 1].ItemRect.Bottom > ItemsRect.Bottom);
end;

function TdxBarSubMenuControl.GetScrollTime: Integer;
begin
  if UseScrollButtons then
    Result := dxBarSmoothScrollMenuTime
  else
    Result := dxBarScrollMenuTime;
end;

function TdxBarSubMenuControl.UpArrowExists: Boolean;
begin
  Result := TopIndex > 0;
end;

function TdxBarSubMenuControl.UseScrollButtons: Boolean;
begin
  Result := Painter.SubMenuControlUseScrollButtons;
end;

procedure TdxBarSubMenuControl.DoCalcSize(out ASize: TSize);
begin
  ASize := GetItemsPaneSize;
  if ASize.cx = 0 then
    ASize.cx := dxBarEmptySubMenuControlContentWidth;
end;

procedure TdxBarSubMenuControl.DoCorrectSize(var ASize: TSize);

  procedure IncByOffset(const AOffset: TRect);
  begin
    Inc(ASize.cx, AOffset.Left + AOffset.Right);
    Inc(ASize.cy, AOffset.Top + AOffset.Bottom);
  end;

begin
  IncByOffset(GetClientOffset);
  IncByOffset(GetItemsRectOffset);
  ASize.cx := Max(ASize.cx, FMinWidth);
end;

procedure TdxBarSubMenuControl.DoShow;
const
  Shows: array[Boolean] of Integer = (0, SWP_SHOWWINDOW);
begin
  FMousePosOnPopup := GetMouseCursorPos;
  if (FMenuAnimations = maFade) and Assigned(SetLayeredWindowAttributes) and not IsWin9X then
  begin
    ProcessPaintMessages;
    dxBlendAnimateWindow(Handle, 150);
  end
  else
  begin
    SetWindowPos(Handle, 0, 0, 0, 0, 0,
      SWP_NOZORDER or SWP_NOMOVE or SWP_NOSIZE or SWP_NOACTIVATE or
      Shows[not FShowAnimation]);
    ProcessPaintMessages;
  end;
end;

procedure TdxBarSubMenuControl.RestoreSize;
begin
  SetBounds(Left, Top, FStoredWidth, FStoredHeight);
end;

procedure TdxBarSubMenuControl.StoreAndReduceSize;
begin
  FStoredHeight := Height;
  FStoredWidth := Width;
  SetBounds(Left, Top, 0, 0);
end;

procedure TdxBarSubMenuControl.DrawBar;
begin
  if BarManager.Designing then
    FillGradientRect(Canvas.Handle, BarRect, 0, clBlue, False)
  else
    if GetSubMenuOwner <> nil then
      GetSubMenuOwner.DoPaintBar(Canvas.Canvas, BarRect)
end;

procedure TdxBarSubMenuControl.DrawContent;
begin
  CalcControlsPositions;

  if (ItemLinks.CanVisibleItemCount > 0) or (ViewInfo.ItemControlCount > 0) then
  begin
    DrawScrollArea;
    DrawItems;
  end
  else
    FillBackground(Canvas.Handle, FItemsRect, ToolbarBrush, clNone, True);
end;

procedure TdxBarSubMenuControl.DrawItems;
var
  I: Integer;
  AControl: TdxBarItemControl;
begin
  for I := 0 to ItemLinks.VisibleItemCount - 1 do
  begin
    AControl := ItemLinks.VisibleItems[I].Control;
    AControl.RealVisibleChanging(ViewInfo.IsItemControlVisible(AControl));
  end;

  for I := 0 to ViewInfo.ItemControlCount - 1 do
    ViewInfo.ItemControlViewInfos[I].Control.FLastInRow := False;

  inherited;

  if ViewInfo.ItemControlCount > 0 then
    ViewInfo.ItemControlViewInfos[ViewInfo.ItemControlCount - 1].Control.FLastInRow := True;
end;

procedure TdxBarSubMenuControl.DrawScrollArea;

  procedure DrawBottomAreaBackground;
  var
    R: TRect;
    AControl: TdxBarItemControl;
  begin
    AControl := BottomItemControl;
    R := GetItemRectEx(AControl, True);
    R.Top := R.Bottom;
    R.Bottom := ItemsRect.Bottom;
    FillBackground(Canvas.Handle, R, ToolbarItemsBrush, clNone, True);
  end;

begin
  Canvas.SaveClipRegion;
  try
    if UpArrowExists then
      Painter.SubMenuControlDrawScrollBand(Self, Canvas, adUp);

    if DownArrowExists then
      Painter.SubMenuControlDrawScrollBand(Self, Canvas, adDown);

    if MarkExists then
      Painter.SubMenuControlDrawMarkBand(Self, MarkRect, MarkDrawState = msSelected);

    if ItemLinks.VisibleItemCount > 0 then
      DrawBottomAreaBackground;
  finally
    Canvas.RestoreClipRegion;
  end;
end;

procedure TdxBarSubMenuControl.FillBackground(DC: HDC; const ARect: TRect;
  ABrush: HBRUSH; AColor: TColor; AIsClientArea: Boolean);
begin
  cxPaintCanvas.BeginPaint(DC);
  try
    FillBackgroundEx(cxPaintCanvas, ARect, ABrush, AColor, AIsClientArea);
  finally
    cxPaintCanvas.EndPaint;
  end;
end;

procedure TdxBarSubMenuControl.DoFillBackgroundEx(ACanvas: TcxCanvas;
  const ARect: TRect; ABrush: HBRUSH; AColor: TColor; AIsClientArea: Boolean);
begin
  Painter.SubMenuControlDrawBackground(Self, ACanvas, ARect, ABrush, AColor);
end;

procedure TdxBarSubMenuControl.FillBackgroundEx(ACanvas: TcxCanvas;
  const ARect: TRect; ABrush: HBRUSH; AColor: TColor; AIsClientArea: Boolean);
begin
  ACanvas.SaveClipRegion;
  try
    ACanvas.IntersectClipRect(ARect);
    DoFillBackgroundEx(ACanvas, ARect, ABrush, AColor, AIsClientArea);
  finally
    ACanvas.RestoreClipRegion;
  end;
end;

function TdxBarSubMenuControl.GetBackgroundBitmap: TGraphic;
begin
  Result := BarManager.Backgrounds.SubMenu;
  if (ItemLinks.Owner is TdxBarCustomPopupMenu) and
    not TdxBarCustomPopupMenu(ItemLinks.Owner).BackgroundBitmap.Empty then
    Result := TdxBarCustomPopupMenu(ItemLinks.Owner).BackgroundBitmap;
end;

function TdxBarSubMenuControl.GetClientOffset(
  AIncludeDetachCaption: Boolean = True): TRect;
var
  AOffset: Integer;
begin
  AOffset := Painter.SubMenuControlNCBorderSize;
  Result := Rect(AOffset, AOffset, AOffset, AOffset);
  if AIncludeDetachCaption and Detachable then
    Result.Top := Result.Top + DetachCaptionAreaSize;
end;

function TdxBarSubMenuControl.GetIndent1: Integer;
begin
  // WARNING: sync with TdxBarButtonControl.GetDefaultHeight
  Result := Painter.SubMenuControlGetControlContentIndent(Self);
end;

function TdxBarSubMenuControl.GetIndent2: Integer;
begin
  // WARNING: sync with TdxBarButtonControl.GetDefaultHeight
  if NeedShowGlyphAndCheckForItem then
  begin
    Result := TextSize;
    Painter.CorrectButtonControlDefaultHeight(Result);
  end
  else
    Result := 0;
end;

function TdxBarSubMenuControl.GetItemsRectOffset: TRect;
begin
  Result := Painter.SubMenuControlContentRectOffset(Self);
  Result.Left := Result.Left + BarSize;
  if UseRightToLeftAlignment then
    Result := TdxRightToLeftLayoutConverter.ConvertOffsets(Result);
end;

function TdxBarSubMenuControl.IsTransparent: Boolean;
begin
  Result := (ItemLinks.Owner is TdxBarCustomPopupMenu) and
    not TdxBarCustomPopupMenu(ItemLinks.Owner).BackgroundBitmap.Empty or
    not BarManager.Backgrounds.SubMenu.Empty or Painter.IsCompoundPainting;
end;

function TdxBarSubMenuControl.GetMouseTrackingBounds: TRect;
begin
  Result := cxRectContent(inherited GetMouseTrackingBounds, GetClientOffset(False));
end;

procedure TdxBarSubMenuControl.Hide;
begin
  if not IsDestroying then
  begin
    Include(FState, bsHideAll);
    DestroyWnd;
    if BarNavigationController.UseSingleMenuWindowMode(ParentItemControl) then
      BarNavigationController.RestorePreviousSingleMenuLevel(ParentItemControl, ParentBar.Kind);
    Free;
  end;
end;

function TdxBarSubMenuControl.Kind: TdxBarKind;
begin
  Result := bkSubMenu;
end;

procedure TdxBarSubMenuControl.Show;
var
  AParentBar: TCustomdxBarControl;
  ARandom: Double;
begin
  DoPopup;
  AParentBar := GetParentBarForBar(Self);
  if AParentBar <> nil then
    FMenuAnimations := AParentBar.BarManager.MenuAnimations
  else
    FMenuAnimations := BarManager.MenuAnimations;
  // prepare AMenuAnimations
  if FMenuAnimations = maRandom then
  begin
    ARandom := Random(100);
    if ARandom < 33 then
      FMenuAnimations := maUnfold
    else
      if ARandom < 66 then
        FMenuAnimations := maSlide
      else
        FMenuAnimations := maFade;
  end;
  FShowAnimation := FShowAnimation and not (FMenuAnimations in [maNone, maFade]) and
    not ((ItemLinks.CanVisibleItemCount = 0) or BarManager.IsCustomizing);
  DoShow;
end;

procedure TdxBarSubMenuControlViewInfo.Calculate;

  procedure CalcSeparatorInfo(AIndex: Integer);
  var
    AItemLink: TdxBarItemLink;
    AItemRect: TRect;
  begin
    AItemLink := BarControl.ItemLinks.VisibleItems[AIndex];
    AItemRect := AItemLink.Control.ViewInfo.Bounds;
    if not IsRectEmpty(AItemRect) and AItemLink.BeginGroup and (AIndex > BarControl.TopIndex) and
      not (BarControl.UpArrowExists and (AIndex = BarControl.TopIndex + 1)) then
        AddSeparatorInfo(BarControl.Painter.SubMenuControlBeginGroupRect(
          BarControl, AItemLink.Control, AItemRect), skHorizontal, AItemLink.Control);
  end;

var
  AItemLink: TdxBarItemLink;
  I: Integer;
  AVisibleItemRect: TRect;
begin
  inherited Calculate;
  if BarControl.ItemLinks.CanVisibleItemCount > 0 then
  begin
    for I := BarControl.TopVisibleItemIndex to BarControl.BottomVisibleItemIndex do
    begin
      AItemLink := BarControl.ItemLinks.VisibleItems[I];
      AddItemControlViewInfo(AItemLink.Control.ViewInfo);
      AVisibleItemRect := BarControl.GetItemRect(AItemLink.Control);
      AVisibleItemRect.Bottom := Min(BarControl.VisibleItemsRect.Bottom, AVisibleItemRect.Bottom);
      AItemLink.Control.ViewInfo.SetBounds(AVisibleItemRect);
      CalcSeparatorInfo(I);
    end;
  end;
end;

function TdxBarSubMenuControlViewInfo.GetBarControl: TdxBarSubMenuControl;
begin
  Result := TdxBarSubMenuControl(FBarControl);
end;

function TdxBarInternalSubMenuControl.GetIsCustomizing: Boolean;
begin
  Result := False;
end;

function TdxBarInternalSubMenuControl.IsInternal: Boolean;
begin
  Result := True;
end;

{ TdxBarCustomizingPopup }
// TODO: remove to designer

constructor TdxBarCustomizingPopup.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FShowAnimation := False;
end;

{ TdxBarItemActionLink }

procedure TdxBarItemActionLink.AssignClient(AClient: TObject);
begin
  FClient := AClient as TdxBarItem;
end;

function TdxBarItemActionLink.IsCaptionLinked: Boolean;
begin
  Result := inherited IsCaptionLinked and
    (FClient.Caption = (Action as TCustomAction).Caption);
end;

function TdxBarItemActionLink.IsCheckedLinked: Boolean;
begin
  Result := inherited IsCheckedLinked and (FClient is TdxBarCustomButton) and
    (TdxBarCustomButton(FClient).Down = (Action as TCustomAction).Checked);
end;

function TdxBarItemActionLink.IsEnabledLinked: Boolean;
begin
  Result := inherited IsEnabledLinked and
    (FClient.Enabled = (Action as TCustomAction).Enabled);
end;

function TdxBarItemActionLink.IsHelpContextLinked: Boolean;
begin
  Result := inherited IsHelpContextLinked and
    (FClient.HelpContext = (Action as TCustomAction).HelpContext);
end;

function TdxBarItemActionLink.IsHintLinked: Boolean;
begin
  Result := inherited IsHintLinked and
    ((FClient.Hint = (Action as TCustomAction).Hint) or FClient.IsHintFromCaption);
end;

function TdxBarItemActionLink.IsImageIndexLinked: Boolean;
begin
  Result := inherited IsImageIndexLinked and
    (FClient.ActionImageIndex = (Action as TCustomAction).ImageIndex);
end;

function TdxBarItemActionLink.IsShortCutLinked: Boolean;
begin
  Result := inherited IsShortCutLinked and
    (FClient.ShortCut = (Action as TCustomAction).ShortCut);
end;

function TdxBarItemActionLink.IsVisibleLinked: Boolean;
begin
  Result := inherited IsVisibleLinked and
    (FClient.Visible = VisibleTodxBarVisible((Action as TCustomAction).Visible));
end;

function TdxBarItemActionLink.IsOnExecuteLinked: Boolean;
begin
  Result := inherited IsOnExecuteLinked and
    (@FClient.OnClick = @Action.OnExecute);
end;

procedure TdxBarItemActionLink.SetCaption(const Value: string);
begin
  if IsCaptionLinked then FClient.Caption := Value;
end;

procedure TdxBarItemActionLink.SetChecked(Value: Boolean);
begin
  if IsCheckedLinked and (FClient is TdxBarCustomButton) then
    TdxBarCustomButton(FClient).Down := Value;
end;

procedure TdxBarItemActionLink.SetEnabled(Value: Boolean);
begin
  if IsEnabledLinked then FClient.Enabled := Value;
end;

procedure TdxBarItemActionLink.SetHelpContext(Value: THelpContext);
begin
  if IsHelpContextLinked then FClient.HelpContext := Value;
end;

procedure TdxBarItemActionLink.SetHint(const Value: string);
begin
  if IsHintLinked then FClient.Hint := Value;
end;

procedure TdxBarItemActionLink.SetImageIndex(Value: Integer);
begin
  if IsImageIndexLinked then FClient.ActionImageIndex := Value;
end;

procedure TdxBarItemActionLink.SetShortCut(Value: TShortCut);
begin
  if IsShortCutLinked then FClient.ShortCut := Value;
end;

procedure TdxBarItemActionLink.SetVisible(Value: Boolean);
begin
  if IsVisibleLinked then FClient.Visible := VisibleTodxBarVisible(Value);
end;

procedure TdxBarItemActionLink.SetOnExecute(Value: TNotifyEvent);
begin
  if IsOnExecuteLinked then FClient.OnClick := Value;
end;

{ TdxBarItemStylesData }

constructor TdxBarItemStylesData.Create(AStyleCount: Integer);
var
  I: Integer;
begin
  inherited Create(nil);
  FStyleCount := AStyleCount;
  SetLength(FStylesData, AStyleCount);
  for I := 0 to AStyleCount - 1 do
  begin
    FStylesData[I].AssignedValues := [];
    FStylesData[I].Style := nil;
  end;
end;

destructor TdxBarItemStylesData.Destroy;
var
  I: Integer;
begin
  FIsDestroying := True;
  for I := 0 to StyleCount - 1 do
    Styles[I] := nil;
  inherited Destroy;
end;

procedure TdxBarItemStylesData.StyleChanged(AStyle: TcxCustomStyle);
begin
  InternalStyleChanged(TcxStyle(AStyle));
end;

procedure TdxBarItemStylesData.StyleRemoved(AStyle: TcxCustomStyle);
begin
  InternalStyleRemoved(TcxStyle(AStyle));
end;

procedure TdxBarItemStylesData.DoChange(AChangeKind: TdxBarItemStyleChangeKind);
begin
  if IsChangeEventLocked then
  begin
    if (AChangeKind <> FChangeKind) and (FChangeKind in [sckNone, sckDrawing]) then
      FChangeKind := AChangeKind;
  end
  else
    if Assigned(FOnChange) then
      FOnChange(AChangeKind);
end;

function TdxBarItemStylesData.GetStyle(AIndex: Integer): TcxStyle;
begin
  Result := FStylesData[AIndex].Style;
end;

function TdxBarItemStylesData.GetStyleReferenceCount(AStyle: TcxStyle): Integer;
var
  I: Integer;
begin
  Result := 0;
  for I := 0 to StyleCount - 1 do
    if Styles[I] = AStyle then
      Inc(Result);
end;

procedure TdxBarItemStylesData.InternalSetStyle(AIndex: Integer; Value: TcxStyle);
begin
  FStylesData[AIndex].Style := Value;
end;

procedure TdxBarItemStylesData.InternalStyleChanged(AIndex: Integer);

  procedure GetFontData(AFont: TFont; out AFontData: TFontData);
  begin
    AFontData.Height := AFont.Height;
    AFontData.Orientation := AFont.Orientation;
    AFontData.Pitch := AFont.Pitch;
    AFontData.Style := AFont.Style;
    AFontData.Charset := AFont.Charset;
    AFontData.Name := dxStringToShortString(AFont.Name);
  end;

  function IsFontChanged(const APrevFontData: TFontData; AFont: TFont): Boolean;
  begin
    Result := (APrevFontData.Height <> AFont.Height) or
      (APrevFontData.Orientation <> AFont.Orientation) or
      (APrevFontData.Pitch <> AFont.Pitch) or
      (APrevFontData.Style <> AFont.Style) or
      (APrevFontData.Charset <> AFont.Charset) or
      (dxShortStringToString(APrevFontData.Name) <> AFont.Name);
  end;

var
  AAssignedValues1, AAssignedValues2: TcxStyleValues;
  AColorChanged, AFontChanged, ATextColorChanged: Boolean;
  AStyle: TcxStyle;
begin
  if IsDestroying then
    Exit;

  AStyle := Styles[AIndex];
  AAssignedValues1 := FStylesData[AIndex].AssignedValues;
  AAssignedValues2 := [];
  if AStyle <> nil then
    AAssignedValues2 := AStyle.AssignedValues;

  AColorChanged := not (not (svColor in AAssignedValues1) and not (svColor in AAssignedValues2));
  if AColorChanged and (svColor in AAssignedValues1) and (svColor in AAssignedValues2) then
    AColorChanged := ColorToRGB(FStylesData[AIndex].Color) <> ColorToRGB(AStyle.Color);

  AFontChanged := not (not (svFont in AAssignedValues1) and not (svFont in AAssignedValues2));
  if AFontChanged and (svFont in AAssignedValues1) and (svFont in AAssignedValues2) then
    AFontChanged := IsFontChanged(FStylesData[AIndex].FontData, AStyle.Font);

  ATextColorChanged := not (not (svTextColor in AAssignedValues1) and not (svTextColor in AAssignedValues2));
  if ATextColorChanged and (svTextColor in AAssignedValues1) and (svTextColor in AAssignedValues2) then
    ATextColorChanged := ColorToRGB(FStylesData[AIndex].TextColor) <> ColorToRGB(AStyle.TextColor);

  FStylesData[AIndex].AssignedValues := AAssignedValues2;
  if svColor in AAssignedValues2 then
    FStylesData[AIndex].Color := AStyle.Color;
  if svFont in AAssignedValues2 then
    GetFontData(AStyle.Font, FStylesData[AIndex].FontData);
  if svTextColor in AAssignedValues2 then
    FStylesData[AIndex].TextColor := AStyle.TextColor;

  if AFontChanged then
    DoChange(sckStructure)
  else
    if AColorChanged or ATextColorChanged then
      DoChange(sckDrawing);
end;

procedure TdxBarItemStylesData.InternalStyleChanged(AStyle: TcxStyle);
var
  I: Integer;
begin
  LockChangeEvent(True);
  try
    for I := 0 to StyleCount - 1 do
      if Styles[I] = AStyle then
        InternalStyleChanged(I);
  finally
    LockChangeEvent(False);
  end;
end;

procedure TdxBarItemStylesData.InternalStyleRemoved(AStyle: TcxStyle);
var
  I: Integer;
begin
  LockChangeEvent(True);
  try
    for I := 0 to StyleCount - 1 do
      if Styles[I] = AStyle then
        Styles[I] := nil;
  finally
    LockChangeEvent(False);
  end;
end;

function TdxBarItemStylesData.IsChangeEventLocked: Boolean;
begin
  Result := FChangeEventLockCount > 0;
end;

procedure TdxBarItemStylesData.LockChangeEvent(ALock: Boolean);
begin
  if ALock then
  begin
    if FChangeEventLockCount = 0 then
      FChangeKind := sckNone;
    Inc(FChangeEventLockCount);
  end
  else
  begin
    Dec(FChangeEventLockCount);
    if (FChangeEventLockCount = 0) and (FChangeKind <> sckNone) then
      DoChange(FChangeKind);
  end;
end;

procedure TdxBarItemStylesData.SetStyle(AIndex: Integer; Value: TcxStyle);
var
  AStyleValue: TcxStyle;
begin
  AStyleValue := Styles[AIndex];
  if Value <> AStyleValue then
  begin
    InternalSetStyle(AIndex, Value);
    if (AStyleValue <> nil) and (GetStyleReferenceCount(AStyleValue) = 0) then
      AStyleValue.RemoveListener(Self);
    if (Value <> nil) and (GetStyleReferenceCount(Value) = 1) then
      Value.AddListener(Self);
    InternalStyleChanged(AIndex);
  end;
end;


{ TdxBarCustomHintViewInfo }

function TdxBarCustomHintViewInfo.IsScreenTip: Boolean;
begin
  Result := False;
end;

procedure TdxBarCustomHintViewInfo.SetWindowDrawParams(AWindow: TdxBarHintWindow);
begin
  AWindow.IsScreenTipWindow := IsScreenTip;
  AWindow.HandleNeeded;
end;

{ TdxBarHintViewInfoHelper }

constructor TdxBarHintViewInfoHelper.Create(ABarManager: TdxBarManager;
  const AHint, AShortCut: string; const ACursorPos: TPoint);
begin
  inherited Create(AHint, AShortCut, ACursorPos);
  FBarManager := ABarManager;
end;

function TdxBarHintViewInfoHelper.GetScaleFactor: TdxScaleFactor;
begin
  if FBarManager <> nil then
    Result := FBarManager.ScaleFactor
  else
    Result := inherited GetScaleFactor;
end;

procedure TdxBarHintViewInfoHelper.PrepareCanvasFont(ACanvas: TCanvas);
begin
  if (FBarManager <> nil) and not FBarManager.UseSystemFont then
    ACanvas.Font := FBarManager.Font
  else
    inherited PrepareCanvasFont(ACanvas);
end;

{ TdxBarHintViewInfo }

constructor TdxBarHintViewInfo.Create(ABarManager: TdxBarManager; const AHint, AShortCut: string;
  const ACursorPos: TPoint);
begin
  FBarManager := ABarManager;
  FHint := AHint;
  FShortCut := AShortCut;
  FCursorPos := ACursorPos;
  inherited Create;
end;

procedure TdxBarHintViewInfo.CreateHelper;
begin
  FHelper := TdxBarHintViewInfoHelper.Create(FBarManager, FHint, FShortCut, FCursorPos);
end;

procedure TdxBarHintViewInfo.SetWindowDrawParams(AWindow: TdxBarHintWindow);
begin
  inherited SetWindowDrawParams(AWindow);
  AWindow.Caption := TdxBarHintViewInfoHelper(FHelper).Text;
  AWindow.Color := Application.HintColor;
end;

{ TdxBarScreenTipPainter }

constructor TdxBarScreenTipPainter.Create(APainter: TdxBarPainter);
begin
  inherited Create(nil);
  FPainter := APainter;
end;

procedure TdxBarScreenTipPainter.DrawBackground(ACanvas: TcxCanvas; const ARect: TRect);
begin
  FPainter.ScreenTipDrawBackground(ACanvas, ARect);
end;

procedure TdxBarScreenTipPainter.DrawFooterLine(ACanvas: TcxCanvas; const ARect: TRect);
begin
  FPainter.ScreenTipDrawFooterLine(ACanvas, ARect);
end;

function TdxBarScreenTipPainter.GetColorPalette: IdxColorPalette;
begin
  Result := FPainter.ScreenTipGetColorPalette;
end;

function TdxBarScreenTipPainter.GetDescriptionTextColor: TColor;
begin
  Result := FPainter.ScreenTipGetDescriptionTextColor;
end;

function TdxBarScreenTipPainter.GetFooterLineSize: Integer;
begin
  Result := FPainter.ScreenTipGetFooterLineSize;
end;

function TdxBarScreenTipPainter.GetTitleTextColor: TColor;
begin
  Result := FPainter.ScreenTipGetTitleTextColor;
end;

{ TdxBarLikeHintScreenTipViewInfoHelper }

constructor TdxBarLikeHintScreenTipViewInfoHelper.Create(ABarManager: TdxBarManager;
  APainter: TdxScreenTipPainter; const AHint, AShortCut: string; const ACursorPos: TPoint);
begin
  inherited Create(APainter, AHint, AShortCut, ACursorPos);
  FBarManager := ABarManager;
end;

function TdxBarLikeHintScreenTipViewInfoHelper.GetScaleFactor: TdxScaleFactor;
begin
  if FBarManager <> nil then
    Result := FBarManager.ScaleFactor
  else
    Result := inherited GetScaleFactor;
end;

procedure TdxBarLikeHintScreenTipViewInfoHelper.PrepareCanvasFont(ACanvas: TCanvas);
begin
  if (FBarManager <> nil) and not FBarManager.UseSystemFont then
    ACanvas.Font := FBarManager.Font
  else
    inherited PrepareCanvasFont(ACanvas);
end;

{ TdxBarLikeHintScreenTipViewInfo }

constructor TdxBarLikeHintScreenTipViewInfo.Create(ABarManager: TdxBarManager;
  APainter: TdxBarPainter; const AHint, AShortCut: string; const ACursorPos: TPoint);
begin
  FPainter := TdxBarScreenTipPainter.Create(APainter);
  inherited Create(ABarManager, AHint, AShortCut, ACursorPos);
end;

procedure TdxBarLikeHintScreenTipViewInfo.CreateHelper;
begin
  FHelper := TdxBarLikeHintScreenTipViewInfoHelper.Create(FBarManager, FPainter, FHint, FShortCut, FCursorPos);
end;

procedure TdxBarLikeHintScreenTipViewInfo.DestroyHelper;
begin
  inherited DestroyHelper;
  FreeAndNil(FPainter);
end;

function TdxBarLikeHintScreenTipViewInfo.IsScreenTip: Boolean;
begin
  Result := True;
end;

{ TdxBarScreenTipViewInfo }

constructor TdxBarScreenTipViewInfo.Create(AScreenTip: TdxScreenTip;
  APainter: TdxBarPainter; const AHintText: string; AShortCut: string = '');
begin
  FHint := AHintText;
  FShortCut := AShortCut;
  FScreenTip := AScreenTip;
  FPainter := TdxBarScreenTipPainter.Create(APainter);
  inherited Create;
end;

procedure TdxBarScreenTipViewInfo.CreateHelper;
begin
  FHelper := TdxScreenTipViewInfoHelper.Create(FScreenTip, FPainter, FHint,
    FShortCut);
end;

procedure TdxBarScreenTipViewInfo.DestroyHelper;
begin
  inherited DestroyHelper;
  FreeAndNil(FPainter);
end;

function TdxBarScreenTipViewInfo.IsScreenTip: Boolean;
begin
  Result := True;
end;

{ TdxBarHintWindow }

constructor TdxBarHintWindow.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  Color := clInfoBk;
  NeedEraseBackground := True;
  AnimationStyle := cxhaNone;
end;

destructor TdxBarHintWindow.Destroy;
begin
  FreeAndNil(FViewInfo);
  inherited Destroy;
end;

function TdxBarHintWindow.CalcHintRect(MaxWidth: Integer; const AHint: string;
  AData: Pointer): TRect;
var
  AHintKeeper: IdxBarHintKeeper;
  ABarManager: TdxBarManager;
  AHintText, AShortCut: string;
begin
  FreeAndNil(FViewInfo);
  AHintText := AHint;
  ABarManager := TdxBarManager(AData);
  AShortCut := ABarManager.FShortCut;

  AHintKeeper := ABarManager.GetHintKeeper;

  if AHintKeeper <> nil then
    FViewInfo := AHintKeeper.CreateHintViewInfo(AHintText, AShortCut)
  else
    FViewInfo := TdxBarHintViewInfo.Create(ABarManager, AHintText, AShortCut, GetMouseCursorPos);

  FViewInfo.UseRightToLeftAlignment := UseRightToLeftAlignment;
  FViewInfo.UseRightToLeftReading := UseRightToLeftReading;
  FViewInfo.SetWindowDrawParams(Self);
  FViewInfo.Calculate(Canvas);
  Result := FViewInfo.BoundsRect;
end;

procedure TdxBarHintWindow.AdjustActivateRect(var ARect: TRect);
begin
  if HasWindowRegion then
  begin
    Inc(ARect.Right);
    Inc(ARect.Bottom);
  end;
  inherited AdjustActivateRect(ARect);
end;

procedure TdxBarHintWindow.EnableRegion;
var
  ARegion: HRGN;
begin
  ARegion := CreateRoundRectRgn(0, 0, Width, Height, 2, 2);
  SetWindowRgn(Handle, ARegion, True);
end;

function TdxBarHintWindow.HasWindowRegion: Boolean;
begin
  Result := FIsScreenTipWindow;
end;

function TdxBarHintWindow.GetHideHintTime: Integer;
begin
  if FIsScreenTipWindow then
    Result := 200000
  else
    Result := dxBarWaitForHideHintTime;
end;

function TdxBarHintWindow.GetShowHintTime: Integer;
begin
  if FIsScreenTipWindow then
    Result := 900
  else
    Result := dxBarWaitForShowHintTime;
end;

procedure TdxBarHintWindow.Paint;
begin
  if not HasWindowRegion then
    DisableRegion;
  FViewInfo.Paint(Canvas);
end;

procedure TdxBarHintWindow.WMShowWindow(var Message: TWMShowWindow);
begin
  if not Message.Show then
    FreeAndNil(FViewInfo);
end;

{ TCustomdxBarControl }

constructor TCustomdxBarControl.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  Initialize;
  AddBarControl(Self);
  ControlStyle := ControlStyle - [csCaptureMouse];
  UpdateControlStyle;
  Color := clBtnFace;
  FLastMousePos := cxInvalidPoint;
  Visible := False;
  SetBounds(100, 100, 30, 50);
  FViewState := bvsNormal;
  if BarManager <> nil then
    BiDiMode := BarManager.BiDiMode;
end;

destructor TCustomdxBarControl.Destroy;
begin
  if bsDestroyWindowHandle in FState then
    raise EdxException.Create('TCustomdxBarControl.Destroy fails');

  if ActiveBarControl = Self then
    FActiveBarControl := nil;
  BarAccessibilityHelperOwnerObjectDestroyed(FIAccessibilityHelper);
  BarManager.EndMouseTracking(Self);
  DoDestroy;
  if (BarManager <> nil) and (BarManager.FSelectedItem <> nil) and
    (BarManager.FSelectedItem.Parent = Self) then
  begin
    BarManager.InternalSetSelectedItem(nil);
    BarManager.HideHint;
  end;

  DestroyControls;
  if WindowHandle <> 0 then
    DestroyHandle;

  if FItemLinks <> nil then
    FItemLinks.FBarControl := nil;
  UpdateParentItemControl;
  RemoveBarControl(Self);
  cxClearObjectLinks(Self);
  Finalize;
  Include(FState, bsDestroyed);
  inherited Destroy;
end;

procedure TCustomdxBarControl.BarGetFocus(ASelectedItem: TdxBarItemControl);
begin
  DoBarGetFocus(ASelectedItem);
end;

procedure TCustomdxBarControl.BarLostFocus;
begin
  if IsFocused then
    DoBarLostFocus;
end;

procedure TCustomdxBarControl.BeforeDestruction;
begin
  inherited;
  Include(FState, bsDestroying);
  if (ChildBar <> nil) and not (bsDestroying in ChildBar.FState) then
    FreeAndNil(FChildBar);
  if ParentBar <> nil then
    ParentBar.ChildBar := nil;
end;

procedure TCustomdxBarControl.MouseDownNotifyControls(
  ALinkAtPos: TdxBarItemLink; const AMousePos: TPoint; Button: TMouseButton;
  Shift: TShiftState);
begin
  if GetControlByLink(ALinkAtPos) <> nil then
    GetControlByLink(ALinkAtPos).MouseDown(Button, Shift, AMousePos.X, AMousePos.Y);
end;

procedure TCustomdxBarControl.MouseNotifyControls(ALinkAtPos: TdxBarItemLink;
  const AMousePos: TPoint; Shift: TShiftState);
begin
  if FPrevTrackedLink <> ALinkAtPos then
  begin
    if GetControlByLink(FPrevTrackedLink) <> nil then
      GetControlByLink(FPrevTrackedLink).MouseLeave;
    FPrevTrackedLink := ALinkAtPos;
    if GetControlByLink(ALinkAtPos) <> nil then
      GetControlByLink(ALinkAtPos).MouseEnter(Shift, AMousePos.X, AMousePos.Y);
  end;
  if GetControlByLink(ALinkAtPos) <> nil then
    GetControlByLink(ALinkAtPos).MouseMove(Shift, AMousePos.X, AMousePos.Y);
end;

procedure TCustomdxBarControl.MouseUpNotifyControls(ALinkAtPos: TdxBarItemLink;
  const AMousePos: TPoint; Button: TMouseButton; Shift: TShiftState);
begin
  if GetControlByLink(ALinkAtPos) <> nil then
    GetControlByLink(ALinkAtPos).MouseUp(Button, Shift, AMousePos.X, AMousePos.Y);
end;

function TCustomdxBarControl.GetActiveCanvas: TcxCanvas;
begin
  if HandleAllocated then
  begin
    if FActiveCanvas <> nil then
    begin
      FreeAndNil(FActiveCanvas);
      UpdateCanvasFont;
    end;
    Result := FCanvas;
  end
  else
  begin
    if FActiveCanvas = nil then
    begin
      FActiveCanvas := TcxScreenCanvas.Create;
      UpdateCanvasFont;
    end;
    Result := FActiveCanvas;
  end;
end;

function TCustomdxBarControl.GetBarControlOwnerBrush: HBRUSH;
begin
  Result := Painter.BarControlOwnerBrush(BarManager);
end;

function TCustomdxBarControl.GetBarManager: TdxBarManager;
begin
  Result := Owner as TdxBarManager;
end;

function TCustomdxBarControl.GetCanvas: TcxCanvas;
begin
  Result := ActiveCanvas;
end;

function TCustomdxBarControl.GetFlat: Boolean;
begin
  // TODO: obsolete
  Result := BarManager.Flat;
end;

function TCustomdxBarControl.GetIsDestroying: Boolean;
begin
  Result := csDestroying in ComponentState;
end;

function TCustomdxBarControl.GetOwnerLinkBounds(AOwnerPart: Boolean): TRect;
var
  AOwnerBounds: TRect;
  AFirstCase: Boolean;

  procedure ConvertRects;

    procedure ConvertRect(var R: TRect);

      procedure ConvertPoint(var P: TPoint);
      var
        APrevX: Integer;
      begin
        with P do
        begin
          APrevX := X;
          X := Y;
          Y := APrevX;
        end;
      end;

    begin
      ConvertPoint(R.TopLeft);
      ConvertPoint(R.BottomRight);
    end;

  begin
    if not FShadow.Horizontal then
    begin
      ConvertRect(Result);
      ConvertRect(AOwnerBounds);
    end;
  end;

begin
  if IsRectEmpty(FOwnerBounds) or not IsLinkedToOwner then
    SetRectEmpty(Result)
  else
  begin
    Result := WindowRect;
    AOwnerBounds := FOwnerBounds;
    with Result do
    begin
      OffsetRect(AOwnerBounds, -Left, -Top);
      OffsetRect(Result, -Left, -Top);
      ConvertRects;

      AFirstCase := AOwnerBounds.Bottom = Top;
      if AFirstCase then
        Bottom := Top + 1
      else
        Top := Bottom - 1;
      if AOwnerPart then
        OffsetRect(Result, 0, -(2 * Ord(AFirstCase) - 1));

      if Left < AOwnerBounds.Left + 1 then
        Left := AOwnerBounds.Left + 1
      else
        Inc(Left);
      if Right > AOwnerBounds.Right - 1 then
        Right := AOwnerBounds.Right - 1
      else
        Dec(Right);

      ConvertRects;
    end;
    if AOwnerPart then
      OffsetRect(Result, Left, Top);
  end;
end;

function TCustomdxBarControl.GetPainterClass: TdxBarPainterClass;
begin
  Result := TdxBarPainterClass(Painter.ClassType);
end;

function TCustomdxBarControl.GetSelectedControlAtDesign: TdxBarItemControl;
begin
  if (BarManager.LastSelectedLinkAtDesign <> nil) and (BarManager.LastSelectedLinkAtDesign.BarControl = Self) then
    Result := BarManager.LastSelectedLinkAtDesign.Control
  else
    Result := nil;
end;

function TCustomdxBarControl.GetSelectedControl: TdxBarItemControl;
begin
  Result := GetControlByLink(SelectedLink);
end;

function TCustomdxBarControl.ItemAtMousePos: TdxBarItemControl;
begin
  Result := ItemAtPos(ScreenToClient(GetMouseCursorPos));
end;

procedure TCustomdxBarControl.SetChildBar(Value: TCustomdxBarControl);

  procedure InternalSetParentBar(AParent, AChild: TCustomdxBarControl);
  begin
    if AChild <> nil then
      AChild.ParentBar := AParent;
  end;

//var
//  APrevChildBar: TCustomdxBarControl;
begin

  FChildBar := Value;
  if (Value <> nil) and (Value.ParentBar <> Self) then
    Value.ParentBar := Self;

{
  if FChildBar <> Value then
  begin
    APrevChildBar := FChildBar;
    FChildBar := Value;
    InternalSetParentBar(nil, APrevChildBar);
    InternalSetParentBar(Self, FChildBar);
  end;
}
end;

procedure TCustomdxBarControl.SetDockControl(Value: TdxDockControl);
begin
  FDockControl := Value;
  UpdateDoubleBuffered; //!
end;

procedure TCustomdxBarControl.SetIsActive(Value: Boolean);
begin
  BarManager.HideHint;
  if (FIsActive <> Value) and CanActiveChange or IsCustomizing and not Value then
    DoSetIsActive(Value);
end;

procedure TCustomdxBarControl.SetParentBar(Value: TCustomdxBarControl);

  procedure InternalSetChildBar(AParent, AChild: TCustomdxBarControl);
  begin
    if AParent <> nil then
      AParent.ChildBar := AChild;
  end;

//var
//  APrevParentBar: TCustomdxBarControl;
begin
  FParentBar := Value;
  if (Value <> nil) and (Value.ChildBar <> Self) then
    Value.ChildBar := Self;

{
  if FParentBar <> Value then
  begin
    APrevParentBar := FParentBar;
    FParentBar := Value;
    InternalSetChildBar(APrevParentBar, nil);
    InternalSetChildBar(FParentBar, Self);
  end;
}
end;

procedure TCustomdxBarControl.SetViewState(Value: TdxBarViewState);
var
  APrevViewState: TdxBarViewState;
begin
  if (Value <> FViewState) and not IsCustomizing then
  begin
    APrevViewState := FViewState;
    FViewState := Value;
    ViewStateChanged(APrevViewState);
  end;
end;

procedure TCustomdxBarControl.WMCaptureChanged(var Message: TMessage);
begin
  inherited;
  if FDragDown then
  begin
    BarManager.DraggingItem := nil;
    BarManager.DraggingItemLink := nil;
    FDragDown := False;
  end;
  FClickedControl := nil;
end;

procedure TCustomdxBarControl.WMClose(var Message: TMessage);
begin
  if BarManager.IsParentFormAvailable then
    SendMessage(BarManager.ParentForm.Handle, WM_CLOSE, 0, 0);
end;

procedure TCustomdxBarControl.WMDestroy(var Message: TMessage);
begin
  if not IsDestroying then
  begin
    MarkState := msNone;
    BeforeDestroyHandle;
  end;
  inherited;
end;

procedure TCustomdxBarControl.WMEraseBkgnd(var Message: TWMEraseBkgnd);
begin
//  if FItemLinks.CanVisibleItemCount = 0 then // else Fill Rgn is called
//    FillBackground(Message.DC, ClientRect, ToolbarBrush, clNone, True);
  Message.Result := 1;
end;

procedure TCustomdxBarControl.WMKeyDown(var Message: TWMKeyDown);
var
  ALinkSelf: TcxObjectLink;
begin
  ALinkSelf := cxAddObjectLink(Self);
  try
    inherited;
    if (ALinkSelf.Ref = nil) or (ActiveBarControl = nil) then Exit;
    NavigationHandler(Message.CharCode, KeyDataToShiftState(Message.KeyData));
    if (ALinkSelf.Ref = nil) or (ActiveBarControl = nil) or SelectedItemWantsKey(Message.CharCode) then Exit;
    DoKeyDown(Message);
  finally
    cxRemoveObjectLink(ALinkSelf);
  end;
end;

procedure TCustomdxBarControl.WMLButtonDblClk(var Message: TWMLButtonDblClk);
begin
  if not FIgnoreMouseClick then
    inherited;
end;

procedure TCustomdxBarControl.WMLButtonDown(var Message: TWMLButtonDown);
begin
  if not FIgnoreMouseClick then
    inherited;
end;

procedure TCustomdxBarControl.WMLButtonUp(var Message: TWMLButtonUp);
begin
  if FIgnoreMouseClick then
    FIgnoreMouseClick := False
  else
  begin
    inherited;
    DoLButtonUp(Message);
  end;
end;

procedure TCustomdxBarControl.WMMouseActivate(var Message: TWMMouseActivate);
begin
  inherited;
  Message.Result := MA_NOACTIVATE;
end;

procedure TCustomdxBarControl.WMMouseMove(var Message: TWMMouseMove);
var
  ALinkSelf: TcxObjectLink;
begin
  ALinkSelf := cxAddObjectLink(Self);
  try
    inherited;
    if ALinkSelf.Ref <> nil then
      AfterMouseMove(KeysToShiftState(Message.Keys), Message.XPos, Message.YPos);
  finally
    cxRemoveObjectLink(ALinkSelf);
  end;
end;

procedure TCustomdxBarControl.WMNCPaint(var Message: TMessage);
var
  ADC: HDC;
begin
  if AllowNCPaint then
  begin
    ADC := GetNCDrawingDC(Message.WParam);
    try
      inherited;
      NCPaint(ADC);
    finally
      ReleaseNCDrawingDC(ADC);
    end;
  end
  else
    inherited;
end;

procedure TCustomdxBarControl.WMPaint(var Message: TWMPaint);
begin
  if not IsDestroying then
    inherited;
end;

procedure TCustomdxBarControl.WMPrint(var Message: TMessage);
begin
  inherited;
  NCPaint(Message.WParam);
end;

procedure TCustomdxBarControl.WMPrintClient(var Message: TMessage);
begin
  inherited;
  PaintWindow(Message.WParam);
end;

procedure TCustomdxBarControl.WMRepaintBar(var Message: TMessage);
begin
  RepaintBar;
end;

procedure TCustomdxBarControl.WMSetCursor(var Message: TWMSetCursor);

  function InternalSetCursor: Boolean;
  var
    ACursor: TCursor;
  begin
    ACursor := crDefault;
    if (Screen.Cursor = crDefault) then
      ACursor := GetCurrentCursor(ScreenToClient(GetMouseCursorPos));
    Result := ACursor <> crDefault;
    if Result then
      SetCursor(Screen.Cursors[ACursor]);
  end;

begin
  if (Message.CursorWnd <> Handle) or not InternalSetCursor then
    inherited;
end;

procedure TCustomdxBarControl.WMSize(var Message: TWMSize);
begin
//  ResetBackground;
  inherited;
end;

procedure TCustomdxBarControl.WMWindowPosChanged(var Message: TWMWindowPosChanged);
begin
  inherited;
  if not IsDestroying then
    WindowPosChanged(Message);
end;

procedure TCustomdxBarControl.DXMHideAll(var Message: TMessage);
begin
  HideAll(TdxBarCloseUpReason(Message.LParam));
end;

procedure TCustomdxBarControl.AdjustSize;
begin
// do nothing
end;

procedure TCustomdxBarControl.AdjustHintWindowPosition(var APos: TPoint; const ABoundsRect: TRect; AHeight: Integer);
var
  AHintOffset: Integer;
begin
  AHintOffset := ScaleFactor.Apply(HintOffset);
  if APos.Y + AHintOffset + AHeight > GetDesktopWorkArea(APos).Bottom then
    APos.Y := ClientToScreen(cxNullPoint).Y - AHeight
  else
    APos.Y := APos.Y + AHintOffset;
end;

procedure TCustomdxBarControl.AfterControlEscape(AControl: TdxBarItemControl);
begin
  if bboAllowSelectWindowItemsWithoutFocusing in BehaviorOptions then
    SelectedControl := AControl
  else
    HideAllByEscape;
end;

procedure TCustomdxBarControl.AfterMouseMove(Shift: TShiftState; X, Y: Integer);
begin
  if not NotHandleMouseMove then
    FLastMousePos := ClientToScreen(Point(X, Y)) // FLastMousePos := GetMouseCursorPos - incorrect (SC B20836)
  else
    if NotHandleMouseMove(False) then
      MouseLeave;
end;

procedure TCustomdxBarControl.CreateHandle;
begin
  if bsCreatingWindow in FState then
    raise EdxTestException.Create('TCustomdxBarControl.CreateHandle fails');
  Include(FState, bsCreatingWindow);
  try
    inherited;
  finally
    Exclude(FState, bsCreatingWindow);
  end;
end;

procedure TCustomdxBarControl.CreateWindowHandle(const Params: TCreateParams);
begin
  inherited;
  CreateControls;
  SetLayeredAttributes;
end;

procedure TCustomdxBarControl.CreateWnd;
begin
  inherited;
  SetFont;
  CalcDrawingConsts;
end;

procedure TCustomdxBarControl.DestroyWindowHandle;
begin
  if bsDestroyWindowHandle in FState then
    raise EdxTestException.Create('TCustomdxBarControl.DestroyWindowHandle fails');

  Include(FState, bsDestroyWindowHandle);
  try
    if WindowHandle <> 0 then
      BeforeDestroyHandle;
    DestroyControls;
    inherited DestroyWindowHandle;
  finally
    Exclude(FState, bsDestroyWindowHandle);
  end;
end;

function TCustomdxBarControl.IsResizing: Boolean;
begin
  Result := False;
end;

procedure TCustomdxBarControl.MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer);

  procedure CorrectCurrentMessage;
  begin
    case FCurrentMessage.Msg of
      WM_LBUTTONDBLCLK: FCurrentMessage.Msg := WM_LBUTTONDOWN;
      WM_RBUTTONDBLCLK: FCurrentMessage.Msg := WM_RBUTTONDOWN;
      WM_MBUTTONDBLCLK: FCurrentMessage.Msg := WM_MBUTTONDOWN;
    end;
  end;

var
  P: TPoint;
  AItemControl: TdxBarItemControl;
begin
  inherited;
  P := Point(X, Y);
  AItemControl := ItemAtPos(P);

  if (cxPointIsEqual(FLastMousePos, cxInvalidPoint) or (BarManager.FMouseTrackingBarControl <> Self)) and not IsCustomizing then
    DoBarMouseEnter(Shift, P, AItemControl);

  if (ssDouble in Shift) and (AItemControl <> nil) and (AItemControl = SelectedControl) and AItemControl.WantsDblClick then
    DblClickOnItem(AItemControl)
  else
  begin
    CorrectCurrentMessage;
    DoBarMouseDown(Button, Shift, P, AItemControl, PtInRect(ClientRect, P));
  end;
end;

procedure TCustomdxBarControl.MouseLeave;
begin
  FLastMousePos := cxInvalidPoint;
  if BarManager.IsMouseTracking(Self) and not IsResizing then
  begin
    BarManager.EndMouseTracking(Self);
    DoBarMouseLeave;
  end;
end;

procedure TCustomdxBarControl.MouseMove(Shift: TShiftState; X, Y: Integer);

  function DragAndDrop(const P: TPoint): Boolean;

    function DragRect: TRect;
    begin
      Result := Bounds(0, 0, dxGetSystemMetrics(SM_CXDRAG, ScaleFactor), dxGetSystemMetrics(SM_CYDRAG, ScaleFactor));
      OffsetRect(Result, FDragPoint.X - Result.Right div 2, FDragPoint.Y - Result.Bottom div 2);
    end;

  begin
    Result := FDragDown and not PtInRect(DragRect, P);
    if Result then
    begin
      FDragDown := False;
      ReleaseCapture;
      with BarManager do
      begin
        DraggingItemLink.Control.ControlInactivate(True);
        DragAndDrop(DraggingItem, DraggingItemLink);
      end;
    end;
  end;

var
  P: TPoint;
  AItemControl: TdxBarItemControl;
begin
  inherited;
  P := Point(X, Y);
  if IsDestroying or DragAndDrop(P) then
    Exit;

  AItemControl := ItemAtPos(P);
  if cxPointIsEqual(FLastMousePos, cxInvalidPoint) and not NotHandleMouseMove then
    DoBarMouseEnter(Shift, P, AItemControl);
  DoBarMouseMove(Shift, P, AItemControl);
end;

procedure TCustomdxBarControl.MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
  P: TPoint;
  AItemControl: TdxBarItemControl;
begin
  inherited;

  FreeAndNil(FButtonPressTimer);
  P := Point(X, Y);
  AItemControl := ItemAtPos(P);
  DoBarMouseUp(Button, Shift, P, AItemControl, PtInRect(ClientRect, P));
end;

function TCustomdxBarControl.NeedsMouseWheel: Boolean;
begin
  Result := False;
end;

procedure TCustomdxBarControl.ProcessMouseDownMessageForMeaningParent(AWnd: HWND; AMsg: UINT; const AMousePos: TPoint);
begin
end;

function TCustomdxBarControl.PtInCaller(const P: TPoint): Boolean;

   function PtInItemControl: Boolean;
   var
     AItemControl: TdxBarItemControl;
   begin
     AItemControl := ItemAtPos(P);
     Result := AItemControl <> nil;
   end;

begin
  if IsFocused then
    Result := PtInRect(GetMouseTrackingBounds, ClientToScreen(P))
  else
    Result := (cxWindowFromPoint(ClientToScreen(P)) = Handle) or PtInItemControl;
end;

procedure TCustomdxBarControl.Resize;
begin
  inherited;
  if IsPopup then
    Painter.SetWindowRgn(Handle, NCRect, True);
end;

procedure TCustomdxBarControl.WindowPosChanged(var Message: TWMWindowPosChanged);
begin
  with Message.WindowPos^ do
    if (flags and SWP_NOSIZE = 0) or (flags and SWP_NOMOVE = 0) then
      ResizeShadow;
  FShadow.Visible := IsShadowVisible;
  ResetBackground;
end;

procedure TCustomdxBarControl.WndProc(var Message: TMessage);

  function FindEditControl(AHandle: HWND): TdxBarEditControl;
  var
    AEditControl: TdxBarEditControl;
    I: Integer;
  begin
    Result := nil;
    for I := 0 to ItemLinks.Count - 1 do
      if ItemLinks[I].Control is TdxBarEditControl then
      begin
        AEditControl := TdxBarEditControl(ItemLinks[I].Control);
        if AEditControl.HandleAllocated and (AEditControl.Handle = AHandle) then
        begin
          Result := AEditControl;
          Break;
        end;
      end;
  end;

var
  AEditControl: TdxBarCustomEditControl;
begin
  case Message.Msg of
    WM_CTLCOLOREDIT, WM_CTLCOLORSTATIC: //don't use VCL-like method
      begin
        AEditControl := FindEditControl(Message.LParam);
        if AEditControl = nil then
          inherited
        else
        begin
          SetBkColor(Message.WParam, ColorToRGB(Painter.EditGetBkColor(AEditControl.DrawParams)));
          SetTextColor(Message.WParam, ColorToRGB(Painter.EditGetTextColor(AEditControl)));
          Message.Result := AEditControl.EditBkBrush;
          if IsOnGlass and not AEditControl.InnerControlBufferedPaint then
          begin
            AEditControl.InnerControlBufferedPaint := True;
            PostMessage(Message.LParam, DXM_BUFFEREDPAINTONGLASS, 0, 0);
          end;
        end;
      end;
    WM_KILLFOCUS:
      begin
        inherited;
        if Message.wParam = 0 then
          HideAll;
      end;
    WM_NCACTIVATE:
      begin
        if TWMNCActivate(Message).Active and not BarManager.IsCustomizing then
          SendMessage(GetParent(Handle), WM_NCACTIVATE, WPARAM(True), 0);
        Message.wParam := WPARAM(True);
        inherited;
      end;
    WM_SETFOCUS:
      if not (SelectedControl is TdxBarWinControl) then
        DoDropFocus
      else
        inherited;
    WM_MOUSEFIRST..WM_MOUSELAST, WM_NCMOUSEMOVE..WM_NCMBUTTONDBLCLK:
      if CanProcessMouseMessage then
        inherited;
    WM_COMMAND:
      begin
        inherited;
        if (Message.Result = 0) and (HiWord(Message.wParam) = EN_CHANGE) and (Message.lParam <> 0) then
          Message.Result := SendMessage(Message.lParam, Message.Msg, Message.wParam, Message.lParam);
      end;
    else
      inherited;
  end;
end;

procedure TCustomdxBarControl.BeginUpdate;
begin
  Inc(FLockCount);
end;

procedure TCustomdxBarControl.CancelUpdate;
begin
  Dec(FLockCount);
end;

procedure TCustomdxBarControl.EndUpdate;
begin
  Dec(FLockCount);
  if FLockCount = 0 then
    CalcLayout;
end;

function TCustomdxBarControl.CalcChildBarBounds(out ARect: TRect): Boolean;
begin
  Result := False;
end;

procedure TCustomdxBarControl.CalcControlsPositions;
begin
  CalcItemsRect;
end;

procedure TCustomdxBarControl.CalcDragOverParameters(const ACursorPos: TPoint;
  var ADragOverItemLink: TdxBarItemLink;
  var AIsBeginGroup, AIsFirstPart, AIsVerticalDirection: Boolean);
var
  ACalcVerticalDirection: Boolean;
  AControl: TdxBarItemControl;
  AItemRect: TRect;
  ASeparatorIndex, I: Integer;
  ARgn: HRGN;
begin
  AIsVerticalDirection := IsVerticalDirection;

  for I := 0 to FItemLinks.VisibleItemCount - 1 do
  begin
    AControl := FItemLinks.VisibleItems[I].Control;
    if AControl.CanCustomize then
    begin
      ARgn := GetItemRegion(AControl);
      try
        if cxPtInRegion(ARgn, ACursorPos) then
        begin
          ADragOverItemLink := AControl.ItemLink;
          AItemRect := GetFullItemRect(AControl);

          ACalcVerticalDirection := AIsVerticalDirection;

          if not PtInRect(AItemRect, ACursorPos) and
            ViewInfo.IsAssociatedWithSeparator(AControl, ASeparatorIndex) then
          begin
            AIsBeginGroup := True;
            if ACursorPos.Y < AItemRect.Top then
              ACalcVerticalDirection := True;

            AItemRect := ViewInfo.SeparatorInfos[ASeparatorIndex].Bounds;
          end;
          if ACalcVerticalDirection then
            AIsFirstPart := (ACursorPos.Y - AItemRect.Top) < (AItemRect.Bottom - ACursorPos.Y)
          else
            AIsFirstPart := (ACursorPos.X - AItemRect.Left) < (AItemRect.Right - ACursorPos.X);

          Break;
        end;
      finally
        DeleteObject(ARgn);
      end;
    end;
  end;
end;

procedure TCustomdxBarControl.CalcDrawingConsts;
var
  ASize: TSize;
begin
  FTextSize := GetTextSize;
  FRatio := Max(1, FTextSize / GetNormalItemHeight);

  FMenuArrowHeight := Max(4, FTextSize div 5);
  FIconAreaSize := GetIconAreaSize;

  ASize := cxTextExtent(EditFont, '0');
  FEditTextSize := Painter.EditTextSize(Self, ASize.cy);
  FComboBoxArrowWidth := Painter.ComboBoxArrowWidth(Self, ASize.cx);
end;

procedure TCustomdxBarControl.CalcItemsRect;
begin
  FItemsRect := cxRectContent(ClientRect, GetItemsRectOffset);
end;

function TCustomdxBarControl.CalcColumnItemRect(AItemLink: TdxBarItemLink; const AItemsRect: TRect): TRect;
begin
  Result := cxRectSetHeight(AItemsRect, AItemLink.Control.Height);
  OffsetRect(Result, 0, GetItemControlOffset(AItemLink));
end;

procedure TCustomdxBarControl.CalcColumnItemRects(ATopIndex: Integer; out ALastItemBottom: Integer);
var
  AItemLink: TdxBarItemLink;
  AItemsRect, R: TRect;
  I: Integer;
begin
  AItemsRect := VisibleItemsRect;
  ALastItemBottom := AItemsRect.Top;
  for I := ATopIndex to ItemLinks.VisibleItemCount - 1 do
  begin
    AItemsRect.Top := ALastItemBottom;
    AItemLink := ItemLinks.VisibleItems[I];
    R := CalcColumnItemRect(AItemLink, AItemsRect);
    if R.Bottom > VisibleItemsRect.Bottom then
    begin
      if CanDrawClippedItem(R) then
      begin
        AItemLink.ItemRect := R;
        ALastItemBottom := VisibleItemsRect.Bottom;
      end;
      Break;
    end;
    ALastItemBottom := R.Bottom;
    AItemLink.ItemRect := R;
  end;
end;

procedure TCustomdxBarControl.CalcRowItemRects;
begin
// do nothing
end;

procedure TCustomdxBarControl.CalcItemRects(APaintStyle: TdxBarPaintType; ATopIndex: Integer);
var
  ALastItemBottom: Integer;
begin
  FVisibleItemsRect := ItemsRect;
  CorrectVisibleItemsRectTop;

  ItemLinks.BeginCalcItemRects;
  try
    ItemLinks.EmptyItemRects;
    case APaintStyle of
      ptHorz, ptVert: CalcRowItemRects;
      ptMenu: CalcColumnItemRects(ATopIndex, ALastItemBottom);
    end;
  finally
    ItemLinks.EndCalcItemRects;
  end;

  CorrectVisibleItemsRectBottom;
end;

procedure TCustomdxBarControl.CalcLayout;
begin
  if FLockCount = 0 then
  begin
    ViewInfo.Calculate;
    if (FDockingStyle = dsNone) and BarManager.IsParentFormAvailable then
      SendMessage(BarManager.ParentForm.Handle, DXM_UIADORNERMANAGERUPDATE, 0, 0);
  end;
end;

procedure TCustomdxBarControl.BeforeDestroyHandle;
var
  I: Integer;
begin
  if not IsDestroying then
  begin
    MouseLeave;
    BarLostFocus;
  end;
  for I := 0 to ItemLinks.CanVisibleItemCount - 1 do
    with ItemLinks.CanVisibleItems[I] do
      if Control <> nil then Control.BeforeDestroyParentHandle;
end;

procedure TCustomdxBarControl.CreateControls;
begin
  if ([bsCreatingControls, bsDestroyingControls] * FState <> []) then
    Exit;
  Include(FState, bsCreatingControls);
  try
    DoCreateControls;
  finally
    Exclude(FState, bsCreatingControls);
  end;
end;

procedure TCustomdxBarControl.DestroyControls;
begin
  if ([bsCreatingControls, bsDestroyingControls] * FState <> []) then
    Exit;
  Include(FState, bsDestroyingControls);
  try
    DoDestroyControls;
  finally
    Exclude(FState, bsDestroyingControls);
  end;
end;

procedure TCustomdxBarControl.ExpandContainerItems;
var
  ADoneItems: TList;
  I: Integer;
  AItemLink: TdxBarItemLink;
  AFirstCall, AHideWhenRun: Boolean;
  ALinkData: TdxBarContainerLinkData;
begin
  if FItemLinks <> nil then
  begin
    ADoneItems := TList.Create;
    try
      I := 0;
      while I <= FItemLinks.CanVisibleItemCount - 1 do
      begin
        AItemLink := FItemLinks.CanVisibleItems[I];
        if AItemLink.Item is TCustomdxBarContainerItem then
        begin
          if FExpandedItemLinks = nil then
            FExpandedItemLinks := TObjectList.Create;


          ALinkData := TdxBarContainerLinkData.Create;
          ALinkData.FItem := TCustomdxBarContainerItem(AItemLink.Item);
          ALinkData.FItemLink := AItemLink;
          ALinkData.FItemIndex := AItemLink.Index;
          FExpandedItemLinks.Add(ALinkData);

          AFirstCall := ADoneItems.IndexOf(AItemLink.Item) = -1;
          if AFirstCall then
            ADoneItems.Add(AItemLink.Item);

          AHideWhenRun := TCustomdxBarContainerItem(AItemLink.Item).HideWhenRun;
          if AHideWhenRun then
            AItemLink.SaveRecentIndex;

          TCustomdxBarContainerItem(AItemLink.Item).AddListedItemLinks(FItemLinks, ALinkData, AItemLink.Index + 1);
          if AHideWhenRun then
          begin
            AItemLink.SendToBottomInRecentList;
            AItemLink.Collection := nil;
            Dec(I);
          end;
        end;
        Inc(I);
      end;
    finally
      ADoneItems.Free;
    end;
  end;
end;

procedure TCustomdxBarControl.CollapseContainerItems;
var
  I: Integer;
  AHideWhenRun: Boolean;
begin
  if FExpandedItemLinks <> nil then
  begin
    try
      for I := 0 to FExpandedItemLinks.Count - 1 do
        if FExpandedItemLinks[I] <> nil then
          (TObject(FExpandedItemLinks[I]) as TdxBarContainerLinkData).FItem.NeedClearItemList;

      for I := FExpandedItemLinks.Count - 1 downto 0 do
        with (TObject(FExpandedItemLinks[I]) as TdxBarContainerLinkData) do
        begin
          FItem.DeleteListedItemLinks(FExpandedItemLinks[I]);
          AHideWhenRun := TCustomdxBarContainerItem(FItem).HideWhenRun;
          if AHideWhenRun then
          begin
            FItemLink.Collection := FItemLinks;
            FItemLink.Index := FItemIndex;
            FItemLink.RestoreRecentIndex;
          end;
        end;
    finally
      FreeAndNil(FExpandedItemLinks);
    end;
  end;
end;

procedure TCustomdxBarControl.LayoutChanged;
begin
// do nothing
end;

procedure TCustomdxBarControl.RecreateControls;
begin
  if DockControl <> nil then
    DockControl.BeginUpdate;
  try
    DestroyControls;
    CreateControls;
  finally
    if DockControl <> nil then
      DockControl.EndUpdate;
  end;
  BarManager.UpdateControlByMouse(Self);
end;

procedure TCustomdxBarControl.DoKeyDown(var Message: TWMKey);

  procedure ClickSelectedControl(ASelectedControl: TdxBarItemControl);
  begin
    if BarNavigationController.IsKeyTipsWaiting or BarNavigationController.KeyTipsHandlingMode then
      BarNavigationController.StopKeyboardHandling;
    ASelectedControl.Click(False);
  end;

begin
  case Message.CharCode of
    VK_RETURN:
      if SelectedControl <> nil then
        ClickSelectedControl(SelectedControl);
  end;
end;

procedure TCustomdxBarControl.DoLButtonUp(var Message: TWMLButtonUp);
var
  P: TPoint;
  Item, AClickedControl: TdxBarItemControl;
begin
  if FDragDown then
    ReleaseCapture
  else
  begin
    P.X := Message.XPos;
    P.Y := Message.YPos;
    AClickedControl := FClickedControl;
    if AClickedControl <> nil then
      ReleaseCapture;
    if PtInRect(ClientRect, P) and IsActive then
    begin
      Item := ItemAtPos(P);
      if not IsCustomizing and (Item <> nil) and Item.HotPartWantMouse then
        if Item.Enabled and (Item = SelectedControl) then
        begin
          if Item is TdxBarWinControl then
            TdxBarWinControl(Item).TransferMessage(Handle, TMessage(Message));
          Item.ControlUnclick(True);
        end
        else
          if not Item.Enabled and (Item <> SelectedControl) and (Self is TdxBarControl) and
            not ((SelectedControl is TdxBarButtonControl) and
                 TdxBarButtonControl(SelectedControl).DroppedDown) then
            TdxBarControl(Self).HideAll;//BarLostFocus;
    end;
    if (AClickedControl <> nil) and BarControlExists(Self) then
      HideAll;
  end;
end;

function TCustomdxBarControl.CanActiveChange: Boolean;
begin
  Result := IsApplicationActive or IsWindowEnabled or IsCustomizing;
end;

function TCustomdxBarControl.CanAlignControl(AControl: TdxBarItemControl): Boolean;
begin
  Result := False;
end;

function TCustomdxBarControl.CanCallInheritedNCCalcSize: Boolean; // obsolete
begin
  Result := True;
end;

function TCustomdxBarControl.CanControlPaint(AControl: TdxBarItemControl): Boolean;
begin
  Result := not IsDestroying and (AControl <> nil) and (AControl.ItemLink <> nil) and
    (AControl.ItemLink.Control <> nil) and not AControl.ItemLink.Item.IsDestroying and
    not (bsPaintItem in FState) and not CheckLockUpdate and ViewInfo.IsItemControlVisible(AControl);
end;

function TCustomdxBarControl.CanCustomizing: Boolean;
begin
  Result := BarManager.Designing;
end;

function TCustomdxBarControl.CanDeactivate(ABarManager: TdxBarManager; AActiveWindow: HWND): Boolean;
begin
  Result := ABarManager.IsCustomizing and (BarManager.Owner = dxBarCustomizingForm) and (Handle <> AActiveWindow) or
    (SelectedControl = nil) or SelectedControl.CanDeselect(ABarManager);
end;

function TCustomdxBarControl.CanDrawClippedItem(AItemRect: TRect): Boolean;
begin
  Result := False;
end;

function TCustomdxBarControl.CanHideOnDeactivate: Boolean;
begin
  Result := ((SelectedControl = nil) or (SelectedControl.CanHide)) and
    ((ChildBar = nil) or ChildBar.CanHideOnDeactivate);
end;

function TCustomdxBarControl.CanProcessMouseMessage: Boolean;
var
  AControl: TCustomdxBarControl;
begin
  AControl := ActiveBarControl;
  Result := AControl = nil;
  while not Result and (AControl <> nil) do
  begin
    Result := AControl = Self;
    AControl := AControl.GetEquivalentParentBar;
  end;
end;

function TCustomdxBarControl.CanShowPopupMenuOnMouseClick(AMousePressed: Boolean): Boolean;

  function CanShowOnMouseDown: Boolean;
  begin
    Result := not ((bboItemCustomizePopup in BehaviorOptions) or IsInternal) or IsCustomizing;
  end;

  function CanShowOnMouseUp: Boolean;
  begin
    Result := (bboItemCustomizePopup in BehaviorOptions);
  end;

begin
  Result := (bboCanShowPopupMenuOnMouseClick in BehaviorOptions) and
    (AMousePressed and CanShowOnMouseDown or not AMousePressed and CanShowOnMouseUp and not CanShowOnMouseDown);
end;

function TCustomdxBarControl.CanSetMouseSelectedItem(
  const P: TPoint; AItemControl: TdxBarItemControl): Boolean;
begin
  Result := True;
end;

function TCustomdxBarControl.CanShowHint: Boolean;
begin
  Result := not IsActive;
end;

function TCustomdxBarControl.CheckLockUpdate: Boolean;
begin
  Result := BarManager.IsUpdateLocked or (FLockCount > 0);
end;

function TCustomdxBarControl.ChildrenHaveShadows: Boolean;
begin
  Result := Painter.BarChildrenHaveShadows(Self);
end;

procedure TCustomdxBarControl.CorrectVisibleItemsRectTop;
begin
// do nothing
end;

procedure TCustomdxBarControl.CorrectVisibleItemsRectBottom;
begin
// do nothing
end;

procedure TCustomdxBarControl.CustomizePrepare(APoint: TPoint; ASecondClick: Boolean);
begin
  if (SelectedControlAtDesign <> nil) and SelectedControlAtDesign.CanCustomize then
  begin
    FDragPoint := APoint;
    BarManager.DraggingItem := GetItemByControl(SelectedControlAtDesign);
    BarManager.DraggingItemLink := GetLinkByControl(SelectedControlAtDesign);
    FDragDown := True;
    SetCapture(Handle);
  end;
end;

procedure TCustomdxBarControl.DblClickOnItem(AItemControl: TdxBarItemControl);
begin
  if BarManager.Designing then
    AItemControl.Item.ShowDefaultEventHandler
  else
    if AItemControl.IsExpandable then
      with TCustomdxBarSubItem(AItemControl.Item).ItemLinks do
        if (BarControl <> nil) and BarControl.MarkExists then
          BarControl.MarkState := msPressed
        else
    else
      AItemControl.DblClick;
end;

procedure TCustomdxBarControl.DoBarGetFocus(ASelectedItem: TdxBarItemControl);
begin
  SetKeySelectedItem(ASelectedItem);
  IsActive := True;
end;

procedure TCustomdxBarControl.DoBarLostFocus;
begin
  SetKeySelectedItem(nil); //TODO CHECK
  IsActive := False;
end;

procedure TCustomdxBarControl.DoBarMouseEnter(Shift: TShiftState; const APoint: TPoint; AItemControl: TdxBarItemControl);
begin
  BarManager.BeginMouseTracking(Self);
  MouseNotifyControls(GetLinkByControl(AItemControl), APoint, Shift);
  ViewState := bvsHot;
end;

procedure TCustomdxBarControl.DoBarMouseDown(Button: TMouseButton; Shift: TShiftState;
  const APoint: TPoint; AItemControl: TdxBarItemControl; APointInClientRect: Boolean);
var
  APrevSelectedControl: TdxBarItemControl;
begin
  if IsCustomizing and (AItemControl <> nil) and not AItemControl.CanCustomize then
    Exit;
  if not NotHandleMouseMove(False) then
    MouseDownNotifyControls(GetLinkByControl(AItemControl), APoint, Button, Shift);
  APrevSelectedControl := SelectedControlAtDesign;
  if IsCustomizing then
    SelectItemControl(AItemControl, Button, Shift);
  case Button of
    mbLeft:
      DoBarMouseLeftButtonDown(Shift, APoint, AItemControl, APrevSelectedControl, APointInClientRect);
    mbRight:
      DoBarMouseRightButtonDown(Shift, APoint, AItemControl, APrevSelectedControl, APointInClientRect)
  end;
end;

procedure TCustomdxBarControl.DoBarMouseLeftButtonDown(Shift: TShiftState;
  const APoint: TPoint; AItemControl, APrevSelectedControl: TdxBarItemControl;
  APointInClientRect: Boolean);
begin
  if IsCustomizing then
    CustomizePrepare(APoint, APrevSelectedControl = SelectedControlAtDesign)
  else
    FocusItemControl(AItemControl);
end;

procedure TCustomdxBarControl.DoBarMouseRightButtonDown(Shift: TShiftState;
  const APoint: TPoint; AItemControl, APrevSelectedControl: TdxBarItemControl;
  APointInClientRect: Boolean);
begin
  if SelectedControl <> AItemControl then
    BarLostFocus;
  if CanShowPopupMenuOnMouseClick(True) then
    ShowPopup(AItemControl)
end;

procedure TCustomdxBarControl.DoBarMouseLeave;
begin
  ViewState := bvsNormal;

  MouseNotifyControls(nil, cxInvalidPoint, []);

  if MarkState = msSelected then
    MarkState := msNone;

  if (FClickedControl = nil) and (SelectedControl <> nil) and not SelectedControl.IsDroppedDown and not IsCustomizing then
    SetMouseSelectedItem(nil)
end;

procedure TCustomdxBarControl.DoBarMouseMove(
  Shift: TShiftState; const APoint: TPoint; AItemControl: TdxBarItemControl);
var
  FocusedControlExists: Boolean;
begin
  if not NotHandleMouseMove then
  begin
    MouseNotifyControls(GetLinkByControl(AItemControl), APoint, Shift);

    FocusedControlExists := (BarManager.SelectedItem <> nil) and BarManager.SelectedItem.Focused;

{
  //#DG <BarManager.SelectedItem>
    if (ActiveBarControl = nil) or (ActiveBarControl = Self) then
      if (AItemControl is TdxBarWinControl) and
        PtInRect(TdxBarWinControl(AItemControl).WindowRect, APoint) and
        (not FocusedControlExists or (AItemControl = BarManager.SelectedItem)) then
        Cursor := crIBeam
      else
        Cursor := crDefault;
}

    if FocusedControlExists then Exit;

    if (AItemControl <> nil) and not AItemControl.CanMouseSelect then
      AItemControl := nil;

    if CanSetMouseSelectedItem(APoint, AItemControl) then
    begin
      if (FClickedControl = nil) and ((AItemControl <> nil) or (ChildBar = nil)) then
        SetMouseSelectedItem(AItemControl);
    end;

  {#DG
    // TODO if Item <> nil
    if (SelectedControl <> nil) and SelectedControl.FSelectedByMouse then
      SelectedControl.MouseMove(KeysToShiftState(Message.Keys), P.X, P.Y);
  }
  end;
end;

procedure TCustomdxBarControl.DoBarMouseUp(Button: TMouseButton; Shift: TShiftState;
  const APoint: TPoint; AItemControl: TdxBarItemControl; APointInClientRect: Boolean);
begin
  if not NotHandleMouseMove(False) then
    MouseUpNotifyControls(GetLinkByControl(AItemControl), APoint, Button, Shift);
  if (Button = mbRight) and CanShowPopupMenuOnMouseClick(False) then
    ShowPopup(AItemControl);
end;

procedure TCustomdxBarControl.DoCreateControls;
var
  I: Integer;
begin
  if FItemLinks <> nil then
    for I := 0 to FItemLinks.CanVisibleItemCount - 1 do
      FItemLinks.CanVisibleItems[I].CreateControl;
end;

procedure TCustomdxBarControl.DoDestroy;
begin
  CallNotify(OnDestroy, Self);
end;

procedure TCustomdxBarControl.DoDestroyControls;
var
  I: Integer;
begin
{
  if FItemLinks <> nil then
    for I := 0 to FItemLinks.CanVisibleItemCount - 1 do
      FItemLinks.CanVisibleItems[I].DestroyControl;
}
  if FItemLinks <> nil then
    for I := 0 to FItemLinks.Count - 1 do
      FItemLinks[I].DestroyControl;
end;

procedure TCustomdxBarControl.DoDropFocus;
begin
  if IsCustomizing and (dxBarCustomizingForm <> nil) then
  begin
    dxSetZOrder(Handle);
    Windows.SetFocus(dxBarCustomizingForm.Handle);
    dxSetZOrder(Handle, HWND_NOTOPMOST);
  end
  else
    if IsControlVisible(BarManager.Owner) then
      Windows.SetFocus(BarManager.Owner.Handle)
    else
      Windows.SetFocus(GetNextWindow(BarManager.Owner.Handle, GW_HWNDNEXT));
end;

procedure TCustomdxBarControl.DoHideAll(AReason: TdxBarCloseUpReason);
var
  ALinkSelf: TcxObjectLink;
begin
  ALinkSelf := cxAddObjectLink(Self);
  try
    IsActive := False;
    if (ALinkSelf.Ref <> nil) and (ParentBar <> nil) {#DG and not ClosedByEscape} then
      ParentBar.HideAll(FCloseUpReason);
  finally
    cxRemoveObjectLink(ALinkSelf);
  end;
end;

procedure TCustomdxBarControl.DoPaintItem(
  AControl: TdxBarItemControl; ACanvas: TcxCanvas; const AItemRect: TRect);
begin
  ACanvas.SaveClipRegion;
  try
    ACanvas.IntersectClipRect(AControl.ViewInfo.Bounds);
    AControl.Paint(ACanvas, AItemRect, GetPaintType);
  finally
    ACanvas.RestoreClipRegion;
  end;
  DrawSelectedItem(ACanvas.Handle, AControl, AItemRect);
end;

procedure TCustomdxBarControl.DoRepaintBar(ARecreateControls: Boolean);
begin
  if ARecreateControls then
    RecreateControls;
end;

procedure TCustomdxBarControl.DoSetIsActive(AValue: Boolean);
begin
  FIsActive := AValue;
  if FIsActive then
  begin
    if FActiveBarControl = nil then
      ShowFullMenus := IsCustomizing;
    FPrevActiveBarControl := FActiveBarControl;
    FActiveBarControl := Self;
    if not IsCustomizing then
      ItemLinks.InitiateActions;
  end
  else
  begin
    if IsCustomizing then
      SelectedLink := nil
    else
      SetKeySelectedItem(nil);
    if FActiveBarControl = Self then
      FActiveBarControl := FPrevActiveBarControl;
    if (FActiveBarControl <> nil) and not
      (BarControlExists(FActiveBarControl) and FActiveBarControl.IsActive)
    then
      FActiveBarControl := nil;
  end;
end;

procedure TCustomdxBarControl.DrawItems;
var
  I: Integer;
  AItemControlViewInfo: TdxBarItemControlViewInfo;
begin
  for I := 0 to ViewInfo.ItemControlCount - 1 do
  begin
    AItemControlViewInfo := ViewInfo.ItemControlViewInfos[I];
    if CanControlPaint(AItemControlViewInfo.Control) then
      PaintItem(Canvas, AItemControlViewInfo.Control);
    Canvas.ExcludeClipRect(AItemControlViewInfo.Bounds);
  end;
end;

procedure TCustomdxBarControl.DrawSelectedItem(ADC: HDC; AControl: TdxBarItemControl; const AItemRect: TRect);
var
  ALink: TdxBarItemLink;
begin
  ALink := GetLinkByControl(AControl);
  if (ALink <> nil) and ALink.IsComponentSelected then
  begin
    if BarDesignController.NeedDefaultSelection(ALink) then
      dxBarFrameRect(ADC, AItemRect, COLOR_WINDOWTEXT)
    else
      dxBarFocusRect(ADC, AItemRect);
  end;
end;

procedure TCustomdxBarControl.DragOver(X, Y: Integer; var Accept: Boolean);
begin
// do nothing
end;

function TCustomdxBarControl.DoFindLinkWithAccel(AKey: Word; AShift: TShiftState; ACurrentLink: TdxBarItemLink): TdxBarItemLink;
begin
  Result := ItemLinks.FindItemWithAccel(AKey, AShift, ACurrentLink);
end;

function TCustomdxBarControl.FindLinkWithAccel(AKey: Word; AShift: TShiftState; ACurrentLink: TdxBarItemLink; out ADuplicate: Boolean): TdxBarItemLink;
begin
  Result := DoFindLinkWithAccel(AKey, AShift, ACurrentLink);
  if (Result <> nil) and Result.Item.Enabled then
    ADuplicate := DoFindLinkWithAccel(AKey, AShift, Result) <> Result
  else
    Result := nil;
end;

procedure TCustomdxBarControl.FocusItemControl(AItemControl: TdxBarItemControl);
var
  ABarButtonControl: TdxBarButtonControl;
  ALinkSelf: TcxObjectLink;
begin
  if (AItemControl <> nil) and AItemControl.Enabled and AItemControl.HotPartWantMouse then
  begin
    SetKeySelectedItem(AItemControl);
    BarManager.HideHint;
    if SelectedControl is TdxBarButtonLikeControl then
      TdxBarButtonLikeControl(SelectedControl).FShowAnimation := True;
    if SelectedControl.HasWindow then // is focusable
      SetControlVisible(SelectedControl);
    ALinkSelf := cxAddObjectLink(Self);
    try
      AItemControl.ControlClick(True);
      if (ALinkSelf.Ref <> nil) and IsControlExists(AItemControl) then
      begin
        if SelectedControl is TdxBarButtonControl then
        begin
          ABarButtonControl := TdxBarButtonControl(SelectedControl);
          ABarButtonControl.FShowAnimation := False;
          // ***
      //        if (ABarButtonControl.AItemControl.FDropDownMenu <> nil) and
      //          (ABarButtonControl.AItemControl.FDropDownMenu.SubMenuControl <> nil) then
      //          ABarButtonControl.AItemControl.FDropDownMenu.SubMenuControl.ParentBar := Self;
         end;
      end;
    finally
      cxRemoveObjectLink(ALinkSelf);
    end;
  end;
end;

procedure TCustomdxBarControl.FocusNextBarControl(AForward: Boolean);
var
  ABarControl: TdxBarControl;
begin
  ABarControl := GetNextBarControl(AForward);
  if ABarControl <> nil then
  begin
    TdxBarControl(GetParentBarForBar(Self)).BarLostFocus;
    ABarControl.BarGetFocus(ABarControl.Bar.ItemLinks.First.Control);
  end;
end;

procedure TCustomdxBarControl.NavigationHandler(var ACharCode: Word; AShiftState: TShiftState);
var
  AKey: Word;
  AIsTabKey, ADuplicate: Boolean;
  AItemLink: TdxBarItemLink;
  ATabForward: Boolean;
begin
  AKey := ACharCode;

  if IsRealVertical then
  begin
    case AKey of
      VK_LEFT:
        AKey := VK_UP;
      VK_RIGHT:
        AKey := VK_DOWN;
      VK_UP:
        AKey := VK_LEFT;
      VK_DOWN:
        AKey := VK_RIGHT;
    end;
    ACharCode := AKey;
  end;

  if Self is TdxBarSubMenuControl then
    case AKey of
      VK_LEFT, VK_RIGHT:
        AKey := 0;
      VK_UP:
        AKey := VK_LEFT;
      VK_DOWN:
        AKey := VK_RIGHT;
    end;

  AIsTabKey := AKey = VK_TAB;
  ATabForward := False;
  if AIsTabKey then
  begin
    if GetKeyState(VK_CONTROL) < 0 then
      ATabForward := not (GetKeyState(VK_SHIFT) < 0)
    else
      if GetKeyState(VK_SHIFT) < 0 then
        AKey := VK_LEFT
      else
        AKey := VK_RIGHT;
  end;

  case AKey of
    VK_TAB: // + Ctrl
      FocusNextBarControl(ATabForward);
    VK_F10, VK_MENU:
      if (AKey = VK_MENU) or BarManager.UseF10ForMenu then
      begin
        ACharCode := 0;
        HideAll;
      end;
    VK_LEFT:
      begin
        if SelectedLink = nil then
          AItemLink := ItemLinks.First
        else
          AItemLink := ItemLinks.Prev(SelectedLink);

        if AItemLink <> nil then
          SetKeySelectedItem(AItemLink.Control);
        if AIsTabKey and SelectedControl.HasWindow then
          SelectedControl.Click(False);
      end;
    VK_RIGHT:
      begin
        if SelectedLink = nil then
          AItemLink := ItemLinks.First
        else
          AItemLink := ItemLinks.Next(SelectedLink);
        if AItemLink <> nil then
        begin
          SetKeySelectedItem(AItemLink.Control);
          if AIsTabKey and SelectedControl.HasWindow then
            SelectedControl.Click(False);
        end;
      end;
    VK_HOME:
      begin
        AItemLink := ItemLinks.First;
        if AItemLink <> nil then
          SetKeySelectedItem(AItemLink.Control);
      end;
    VK_END:
      begin
        AItemLink := ItemLinks.Last;
        if AItemLink <> nil then
          SetKeySelectedItem(AItemLink.Control);
      end;
  else
    begin
      if IsTextCharForKeyTip(AKey) then
      begin
        AItemLink := FindLinkWithAccel(AKey, AShiftState, GetLinkByControl(SelectedControl), ADuplicate);
        if AItemLink <> nil then
          SetAccelSelectedItem(AItemLink, ADuplicate);
      end;
    end;
  end;
end;

function TCustomdxBarControl.GetIAccessibilityHelper: IdxBarAccessibilityHelper;
begin
  if (FIAccessibilityHelper = nil) and (GetAccessibilityHelperClass <> nil) then
    FIAccessibilityHelper := GetAccessibilityHelperClass.Create(Self);
  Result := FIAccessibilityHelper;
end;

function TCustomdxBarControl.GetBehaviorOptions: TdxBarBehaviorOptions;
begin
  if ParentBar <> nil then
    Result := ParentBar.BehaviorOptions
  else
    Result := [bboAllowSelectWindowItemsWithoutFocusing, bboExtendItemWhenAlignedToClient,
      bboAllowDetach, bboCanShowPopupMenuOnMouseClick];
end;

function TCustomdxBarControl.GetClientOffset: TPoint;
begin
  with ClientOrigin do
    Result := Point(X - WindowRect.Left, Y - WindowRect.Top);
end;

function TCustomdxBarControl.GetCurrentImages: TCustomImageList;
begin
  Result := ItemLinks.GetCurrentImages;
  if (Result = nil) and (ParentBar <> nil) then
    Result := ParentBar.GetCurrentImages;
end;

function TCustomdxBarControl.GetCurrentCursor(const AMousePos: TPoint): TCursor;
var
  AItemControl: TdxBarItemControl;
begin
  AItemControl := ItemAtPos(AMousePos);
  if not BarManager.IsDesigning and (AItemControl <> nil) and AItemControl.Enabled then
    Result := AItemControl.GetCurrentCursor(AMousePos)
  else
    Result := Cursor;
end;

function TCustomdxBarControl.GetDefaultItemHeight(AItem: TdxBarItemControl): Integer;
begin
  Result := AItem.GetTextSize;
  if Result = 0 then
    Result := TextSize;
end;

function TCustomdxBarControl.GetDefaultItemGlyph: TdxSmartGlyph;
begin
  Result := nil;
end;

function TCustomdxBarControl.GetEditFont: TFont;
begin
  Result := BarManager.FEditFont;
end;

function TCustomdxBarControl.GetClientBounds: TRect;
begin
  Result := cxRectOffset(ClientRect, cxPointOffset(ClientToScreen(cxNullPoint), cxPointInvert(WindowRect.TopLeft)));
end;

function TCustomdxBarControl.GetMouseTrackingBounds: TRect;
begin
//  Result := GetWindowRect;
  Result := BoundsRect;
end;

function TCustomdxBarControl.GetNCRect: TRect;
begin
  Result := WindowRect;
  OffsetRect(Result, -Result.Left, -Result.Top);
end;

function TCustomdxBarControl.GetEditFontHandle: HFONT;
begin
  Result := GetEditFont.Handle;
end;

function TCustomdxBarControl.GetEquivalentParentBar: TCustomdxBarControl;
begin
  if IsInternal and (ParentBar <> nil) and not ParentBar.IsInternal then
    Result := nil
  else
    Result := ParentBar;
end;

function TCustomdxBarControl.GetFader: TdxFader;
begin
  Result := dxFader;
end;

function TCustomdxBarControl.GetFullItemRect(Item: TdxBarItemControl): TRect;
begin
  Result := GetItemRect(Item);
end;

function TCustomdxBarControl.GetHintItemText: string;
begin
  Result := '';
end;

function TCustomdxBarControl.GetIsCustomizing;
begin
  Result := BarManager.IsCustomizing;
end;

function TCustomdxBarControl.GetIsFadingAvailable: Boolean;
begin
  Result := False;
end;

function TCustomdxBarControl.GetIsFocused: Boolean;
begin
  Result := BarManager.FocusedBarControl = Self;
end;

function TCustomdxBarControl.GetIsShadowVisible: Boolean;
begin
  Result := HasShadow and IsWindowVisible(Handle);
end;

function TCustomdxBarControl.GetParentForm: TCustomForm;
begin
  Result := BarManager.ParentForm;
end;

function TCustomdxBarControl.GetItemControlDefaultViewLevel(
  AItemControl: TdxBarItemControl): TdxBarItemViewLevel;
begin
  Result := ivlDefault;
end;

function TCustomdxBarControl.GetItemControlOffset(AItemLink: TdxBarItemLink): Integer;
begin
  if AItemLink.BeginGroup and (AItemLink.VisibleIndex > 0) then
    Result := BeginGroupSize
  else
    Result := 0;
end;

function TCustomdxBarControl.GetItemRect(Item: TdxBarItemControl): TRect;
begin
  if Item = nil then
    SetRectEmpty(Result)
  else
    Result := Item.ItemBounds;
end;

function TCustomdxBarControl.GetItemRectEx(Item: TdxBarItemControl;
  IsBeginGroup: Boolean): TRect;
begin
  Result := GetItemRect(Item);
end;

function TCustomdxBarControl.GetItemRegion(Item: TdxBarItemControl): HRGN;
begin
  Result := CreateRectRgnIndirect(GetItemRectEx(Item, True));
end;

function TCustomdxBarControl.GetItemScreenRect(Item: TdxBarItemControl): TRect;
begin
  Result := dxMapWindowRect(Handle, 0, GetItemRect(Item));
end;

function TCustomdxBarControl.GetItemsRectOffset: TRect;
begin
  Result := cxNullRect;
end;

function TCustomdxBarControl.GetMarkDrawState: TdxBarMarkState;
begin
  Result := MarkState;
end;

function TCustomdxBarControl.GetMarkSize: Integer;
begin
  if MarkExists then
    Result := MarkSize
  else
    Result := 0;
end;

function TCustomdxBarControl.GetNextBarControl(AForward: Boolean): TdxBarControl;

  function GetNextBarManager(ABarManager: TdxBarManager; AGoForward: Boolean): TdxBarManager;
  begin
    Result := dxBarManagerList.NextActive(ABarManager, AGoForward);
    if Result.Bars.Count = 0 then
      Result := GetNextBarManager(Result, AGoForward);
  end;

var
  APrevBarControl: TCustomdxBarControl;
  AIndex, APrevIndex, APrevBarIndex: Integer;
  ABar: TdxBar;
  ABars: TdxBars;
begin
  Result := nil;
  APrevBarControl := GetParentBarForBar(Self);
  if APrevBarControl is TdxBarControl then
  begin
    ABar := TdxBarControl(APrevBarControl).Bar;
    APrevBarIndex := dxBarManagerList.IndexOf(ABar.Bars.BarManager);
    APrevIndex := ABar.Index;
    repeat
      AIndex := ABar.Index;
      if AForward then
      begin
        Inc(AIndex);
        if AIndex >= ABar.Bars.Count then
        begin
          ABar := GetNextBarManager(ABar.Bars.BarManager, True).Bars[0];
          AIndex := 0;
        end;
      end
      else
      begin
        Dec(AIndex);
        if AIndex < 0 then
        begin
          ABars := GetNextBarManager(ABar.Bars.BarManager, False).Bars;
          ABar := ABars[ABars.Count - 1];
          AIndex := ABar.Bars.Count - 1;
        end;
      end;
      if (APrevBarIndex = dxBarManagerList.IndexOf(ABar.Bars.BarManager)) and (AIndex = APrevIndex) then
        Break;
      ABar := ABar.Bars[AIndex];
      if (ABar.Control <> nil) and ABar.Control.CanBeFocused and (ABar.ItemLinks.First <> nil) then
      begin
        Result := ABar.Control;
        Break;
      end;
    until False;
  end;
end;

function TCustomdxBarControl.GetNormalItemHeight: Integer;
begin
  // TODO: NormalItemHeight for BarControl
  Result := Painter.SubMenuControlNormalItemHeight(ScaleFactor);
end;

function TCustomdxBarControl.GetOwnerControl: TWinControl;
begin
  if not IsRectEmpty(FOwnerBounds) then
    Result := FOwnerControl
  else
    Result := nil;
end;

function TCustomdxBarControl.GetPainter: TdxBarPainter;
begin
  if FPainter <> nil then
    Result := FPainter
  else
    if ParentBar <> nil then
      Result := ParentBar.GetPainter
    else
      if DockControl <> nil then
        Result := DockControl.Painter
      else
        Result := BarManager.DefaultPainter;
end;

function TCustomdxBarControl.GetPaintType: TdxBarPaintType;
begin
  if IsVertical then
    Result := ptVert
  else
    Result := ptHorz;
end;

function TCustomdxBarControl.GetSelectableObject: TPersistent;
begin
  Result := nil;
end;

function TCustomdxBarControl.GetSelectionOperation(AButton: TMouseButton;
  AShift: TShiftState; ASelectableItem: IdxBarSelectableItem): TdxBarSelectionOperation;
begin
  Result := soExclusive;
  if ASelectableItem <> nil then
  begin
    if AButton = mbRight then
    begin
      if ASelectableItem.IsComponentSelected and not BarDesignController.IsSelectionComplex(BarManager) then
        Result := soAdd;
    end
    else
      if ([ssShift, ssCtrl] * AShift = [ssShift]) then
      begin
        if ASelectableItem.IsComponentSelected then
          Result := soExclude
        else
          Result := soAdd;
      end;
  end;
end;

function TCustomdxBarControl.GetToolbarBrush: HBRUSH;
begin
  Result := Painter.BarToolbarBrush(Self);
end;

function TCustomdxBarControl.GetToolbarDownedBrush: HBRUSH;
begin
  Result := Painter.BarToolbarDownedBrush(Self);
end;

function TCustomdxBarControl.GetToolbarDownedSelBrush: HBRUSH;
begin
  Result := Painter.BarToolbarDownedSelBrush(Self);
end;

function TCustomdxBarControl.GetToolbarSelBrush: HBRUSH;
begin
  Result := Painter.BarToolbarSelBrush(Self);
end;

procedure TCustomdxBarControl.RepaintBarEx(ARecreateControls: Boolean);
var
  APrevSelectedItemLink: TdxBarItemLink;
begin
  if IsDestroying or not HandleAllocated or
    ([bsCreatingControls, bsDestroyingControls, bsRepaintBar] * FState <> []) or
    CheckLockUpdate then
    Exit;

  Include(FState, bsRepaintBar);
  try
    APrevSelectedItemLink := nil;
    if IsCustomizing then
    begin
      if (BarManager.SelectedItem <> nil) and (BarManager.SelectedItem.Parent = Self) then
      begin
        APrevSelectedItemLink := BarManager.SelectedItem.ItemLink;
        BarManager.InternalSetSelectedItem(nil);
      end;
      SelectedLink := nil;
    end;

    DoRepaintBar(ARecreateControls);

    if APrevSelectedItemLink <> nil then
      SetKeySelectedItem(APrevSelectedItemLink.Control);
  finally
    Exclude(FState, bsRepaintBar);
  end;
end;

procedure TCustomdxBarControl.SetControlVisible(AControl: TdxBarItemControl);
begin
  // do nothing
end;

procedure TCustomdxBarControl.SetItemLinks(Value: TdxBarItemLinks);
begin
  FItemLinks := Value;
end;

function TCustomdxBarControl.GetNCDrawingDC(AUpdatedRgn: HRGN): HDC;
begin
  Result := GetWindowDC(Handle);
end;

procedure TCustomdxBarControl.ReleaseNCDrawingDC(ADC: HDC);
begin
  ReleaseDC(Handle, ADC);
end;

function TCustomdxBarControl.GetBorderSize: Integer;
begin
  Result := Painter.GetBorderSize;
end;

function TCustomdxBarControl.GetIconAreaSize: Integer;
begin
  Result := Painter.GetIconAreaSize(Self);
end;

function TCustomdxBarControl.GetTextSize: Integer;
begin
  Result := Painter.GetDefaultTextSize(Canvas, ScaleFactor);
end;

function TCustomdxBarControl.GetWindowRect: TRect;
begin
  Result := cxGetWindowRect(Self);
end;

function TCustomdxBarControl.GetWindowPoint(const AClientPoint: TPoint): TPoint;
begin
  Result := AClientPoint;
  Result.X := Result.X + NCOffset.X;
  Result.Y := Result.Y + NCOffset.Y;
end;

function TCustomdxBarControl.AllowSelectionFrame: Boolean;
begin
  Result := False;
end;

function TCustomdxBarControl.AllowFade: Boolean;
begin
  Result := True;
end;

function TCustomdxBarControl.HasShadow: Boolean;
begin
  Result := dxCanUseShadows and Painter.BarHasShadow(Self);
end;

function TCustomdxBarControl.NeedHideOnClick: Boolean;
begin
  Result := False;
end;

function TCustomdxBarControl.NeedHideOnKeyPress: Boolean;
begin
  Result := False;
end;

function TCustomdxBarControl.NeedsKey(AKey: Word; AShift: TShiftState): Boolean;
begin
  Result := True;
end;

function TCustomdxBarControl.PreProcessKey(AKey: Word; AShift: TShiftState): Boolean;
begin
  Result := (SelectedControl <> nil) and SelectedControl.Focused or not NeedsKey(AKey, AShift);
end;

function TCustomdxBarControl.IsChildBar(Value: TCustomdxBarControl): Boolean;
begin
  Result := False;
  while Value.ParentBar <> nil do
  begin
    Value := Value.ParentBar;
    if Self = Value then
    begin
      Result := True;
      Exit;
    end;
  end;
end;

function TCustomdxBarControl.IsChildWindow(AWnd: HWND): Boolean;
begin
  Result := IsChildEx(Handle, AWnd) or
    (ChildBar <> nil) and (ChildBar.IsChildWindow(AWnd)) or
    (SelectedControl <> nil) and SelectedControl.IsChildWindow(AWnd);
end;

function TCustomdxBarControl.IsControlExists(ABarItemControl: TdxBarItemControl): Boolean;
begin
  Result := ItemLinks.IsControlExists(ABarItemControl);
end;

function TCustomdxBarControl.IsLinkedToOwner: Boolean;
var
  R1, R2: TRect;
begin
  R1 := FOwnerBounds;
  R2 := BoundsRect;
  Result :=
    ((R1.Bottom = R2.Top) or (R1.Top = R2.Bottom)) and
    (R1.Left < R2.Right) and (R1.Right > R2.Left) or
    ((R1.Right = R2.Left) or (R1.Left = R2.Right)) and
    (R1.Top < R2.Bottom) and (R1.Bottom > R2.Top);
end;

function TCustomdxBarControl.IsMeaningParent(AWnd: HWND): Boolean;
begin
  Result := False;
end;

function TCustomdxBarControl.IsPopup: Boolean;
begin
  Result := False;
end;

function TCustomdxBarControl.IsVerticalDirection: Boolean;
begin
  Result := IsRealVertical;
end;

function TCustomdxBarControl.IsWindowEnabled: Boolean;
begin
  Result := HandleAllocated and IsWindowEnabledEx(Handle);
//TODO    Windows.IsWindowEnabled(Handle) and Windows.IsWindowEnabled(BarManager.Owner.Handle);//#DG
end;

procedure TCustomdxBarControl.MakeItemControlFullyVisible(
  AItemControl: TdxBarItemControl);
begin
end;

function TCustomdxBarControl.MarkExists: Boolean;
begin
  Result := False;
end;

function TCustomdxBarControl.MarkRect: TRect;
begin
  Result := cxNullRect;
end;

function TCustomdxBarControl.MouseOnMark(const AMousePos: TPoint): Boolean;
begin
  Result := PtInRect(MarkRect, AMousePos);
end;

function TCustomdxBarControl.MouseOnMark: Boolean;
begin
  Result := MouseOnMark(ScreenToClient(GetMouseCursorPos));
end;

procedure TCustomdxBarControl.SetMarkState(Value: TdxBarMarkState);
begin
end;

procedure TCustomdxBarControl.ActivateHint;
begin
  ActivateHint(True, '', Self);
end;

procedure TCustomdxBarControl.ActivateHint(AShow: Boolean; const ACustomHint: string; AHintObject: TObject = nil);
begin
  BarManager.ActivateHint(AShow, ACustomHint, AHintObject);
end;

function TCustomdxBarControl.CreateHintViewInfo(const AHintText, AShortCut: string; AScreenTip: TdxScreenTip): TdxBarCustomHintViewInfo;
begin
  Result := Painter.CreateHintViewInfo(BarManager, AHintText, AShortCut, AScreenTip);
end;

function TCustomdxBarControl.GetHintPosition(const AItemBounds: TRect; const ACursorPos: TPoint; AHeight: Integer): TPoint;
begin
  Result := Painter.GetBarItemControlHintPosition(Self, AItemBounds, ACursorPos, AHeight);
end;

function TCustomdxBarControl.NeedShowGlyphAndCheckForItem: Boolean;
begin
  Result := False;
end;

function TCustomdxBarControl.NotHandleMouseMove(ACheckLastMousePos: Boolean = True): Boolean;
begin
  Result := IsCustomizing or not IsWindowVisible(Handle) or
    ACheckLastMousePos and cxPointIsEqual(FLastMousePos, GetMouseCursorPos) or
    not PtInRect(WindowRect, GetMouseCursorPos);
end;

procedure TCustomdxBarControl.PaintItem(ACanvas: TcxCanvas; AControl: TdxBarItemControl);
begin
  Include(FState, bsPaintItem);
  try
    FBkBrush := ToolbarBrush;
    DoPaintItem(AControl, ACanvas, AControl.ItemBounds);
  finally
    Exclude(FState, bsPaintItem);
  end;
end;

procedure TCustomdxBarControl.ResizeShadow;
var
  R: TRect;
begin
  if IsLinkedToOwner and Painter.BarLinkedOwnerHasShadow(Self) then
    R := FOwnerBounds
  else
    SetRectEmpty(R);
  FShadow.SetOwnerBounds(R, BoundsRect);
end;

procedure TCustomdxBarControl.SetCursorForMoving(AMoving: Boolean);
const
  Cursors: array[Boolean] of TCursor = (crDefault, crSizeAll);
begin
  Cursor := Cursors[AMoving];
end;

procedure TCustomdxBarControl.SetDockingStyle(Value: TdxBarDockingStyle);
begin
  if FDockingStyle <> Value then
  begin
    FDockingStyle := Value;
    ResetBackground;
    Perform(CM_FONTCHANGED, 0, 0);
    SetLayeredAttributes;
  end;
end;

procedure TCustomdxBarControl.SetLayeredAttributes;
begin
end;

function TCustomdxBarControl.SelectedItemWantsKey(Key: Word): Boolean;
begin
  Result := (SelectedControl <> nil) and SelectedControl.Enabled and
    SelectedControl.WantsKey(Key);
  if Result then SelectedControl.KeyDown(Key, []);
end;

procedure TCustomdxBarControl.SelectItemControl(AItemControl: TdxBarItemControl; AButton: TMouseButton; AShift: TShiftState);
var
  ASelectableItem: IdxBarSelectableItem;
begin
  if AButton = mbRight then
    AShift := [];
  if (AItemControl = nil) then
    ASelectableItem := GetSelectableItem(GetSelectableObject)
  else
  begin
    BarGetFocus(AItemControl);

    ASelectableItem := GetSelectableItem(AItemControl.GetSelectableObject);

    case AButton of
      mbLeft:
        begin
          if ViewInfo.ItemControlCount = 0 then
            Exit;

          if AItemControl.CanCustomize then {1}
          begin
            if AItemControl = SelectedControl then
            begin
              if AItemControl.IsActive then
                AItemControl.ControlInactivate(True)
              else
                AItemControl.ControlActivate(True, True);
              BarManager.SelectedItem := AItemControl;
            end;
            SetMouseSelectedItem(AItemControl);
          end;
        end;
      mbRight:
        begin
          if SelectedControl <> nil then
            SelectedControl.ControlInactivate(True);
          if AItemControl = SelectedControl then
          begin
            BarManager.SelectedItem := AItemControl;
          end;
          SetKeySelectedItem(AItemControl);
        end;
    end;
  end;
  BarDesignController.SelectItem(ASelectableItem,
    GetSelectionOperation(AButton, AShift, ASelectableItem));
end;

procedure TCustomdxBarControl.SetAccelSelectedItem(AItemLink: TdxBarItemLink; ADuplicate: Boolean);
begin
  SetKeySelectedItem(AItemLink.Control);
  if not ADuplicate then
    SendMessage(Handle, WM_KEYDOWN, VK_RETURN, 0);
end;

procedure TCustomdxBarControl.SetKeySelectedItem(Value: TdxBarItemControl);
var
  ALockedBarManager: TdxBarManager;
begin
  if not HandleAllocated or (csDestroying in ComponentState) then Exit;
  if SelectedControl <> Value then
  begin
    if (SelectedControl <> nil) and (Value <> nil) then
      ALockedBarManager := BarManager
    else
      ALockedBarManager := nil;
    if ALockedBarManager <> nil then
      Inc(ALockedBarManager.FChangingFocusedItemControlLockCount);
    try
      if (SelectedControl <> nil) and SelectedControl.IsActive then
        SelectedControl.ControlInactivate(True);
      if not BarControlExists(Self) then
        Exit;
      if Value is TdxBarSubItemControl then
        TdxBarSubItemControl(Value).FShowAnimation := False;
      if Value <> nil then Value.FSelectedByMouse := False;
      SelectedControl := Value;
    finally
      if ALockedBarManager <> nil then
        Dec(ALockedBarManager.FChangingFocusedItemControlLockCount);
    end;
    if Value <> nil then
      MakeItemControlFullyVisible(Value);
  end;
end;

procedure TCustomdxBarControl.SetMouseSelectedItem(Value: TdxBarItemControl);

  function CanSelectedItemControlActivate: Boolean;
  var
    ALinksOwner: IdxBarLinksOwner;
    AErrorText: string;
  begin
    Result := BarControlExists(Self) and (SelectedControl <> nil) and
     (not BarManager.Dragging or not SelectedControl.IsDropDown or
      not Supports(GetItemByLink(SelectedLink), IdxBarLinksOwner, ALinksOwner) or
      ALinksOwner.CanContainItem(BarManager.DraggingItem, AErrorText));
  end;

var
  ALockedBarManager: TdxBarManager;
begin
  if not HandleAllocated or (csDestroying in ComponentState) or
    (BarNavigationController.IsNavigationBarControl(Self)) and
    (bboMouseCantUnselectNavigationItem in BehaviorOptions) then
    Exit;

  if (SelectedControl <> Value) and not ((SelectedControl <> nil) and SelectedControl.HasWindow and SelectedControl.Focused) then
  begin
    if (SelectedControl <> nil) and (Value <> nil) then
      ALockedBarManager := BarManager
    else
      ALockedBarManager := nil;
    if ALockedBarManager <> nil then
      Inc(ALockedBarManager.FChangingFocusedItemControlLockCount);
    try
      if (SelectedControl <> nil) and SelectedControl.IsActive then
        SelectedControl.ControlInactivate(False);
      if Value <> nil then Value.FSelectedByMouse := True;
      SelectedControl := Value;
    finally
      if ALockedBarManager <> nil then
        Dec(ALockedBarManager.FChangingFocusedItemControlLockCount);
    end;

    if CanSelectedItemControlActivate then
    begin
      if SelectedControl is TdxBarButtonLikeControl then
        TdxBarButtonLikeControl(SelectedControl).FShowAnimation := True;
      SelectedControl.ControlActivate(False, True);
    end;
  end;
end;

procedure TCustomdxBarControl.SetSelectedControl(Value: TdxBarItemControl);
var
  APrevSelectedLink: TdxBarItemLink;
  AParentBar: TCustomdxBarControl;
  AQuickControl: TdxBarPopupControl;
begin
  if SelectedControl <> Value then
  begin
    if (BarDesignController.QuickControl <> nil) and not BarDesignController.QuickControl.LockHotTrackWhenPopup then
    begin
      AQuickControl := BarDesignController.QuickControl;
      if not AQuickControl.IsActive and (AQuickControl <> Self) and (Value <> nil) then
        AQuickControl.StartHidingTimer;
    end;
    APrevSelectedLink := SelectedLink;
    SelectedLink := GetLinkByControl(Value);
    if bboMouseCantUnselectNavigationItem in BehaviorOptions then
      IsDowned := False;
    if IsCustomizing then
    begin
      BarManager.SelectedItem := Value;
      if not BarControlExists(Self) then Exit;
    end
    else
      if not BarManager.IsCustomizing then
        BarManager.InternalSetSelectedItem(Value);

    UpdateItem(GetControlByLink(APrevSelectedLink));
    UpdateItem(SelectedControl);

    if SelectedControl = nil then
      Cursor := crDefault;
    if (SelectedControl <> nil) or
      (Self is TdxBarSubMenuControl) or (TdxBarControl(Self).MarkState = msNone) then
      ActivateHint(True, '', SelectedControl);
    // for Application.Hint:
    if (SelectedControl <> nil) and
      (SelectedControl.Enabled or BarManager.ShowHintForDisabledItems) then
      Hint := GetLongHint(SelectedControl.Hint)
    else
      Hint := '';
    AParentBar := GetParentBarOrSubMenuForBar(Self);
    if (AParentBar is TdxBarSubMenuControl) and
      (AParentBar.ItemLinks.Owner is TdxBarCustomPopupMenu) and
      TdxBarCustomPopupMenu(AParentBar.ItemLinks.Owner).FUseOwnMessageLoop then
      Application.Hint := Hint;
  end;
end;

procedure TCustomdxBarControl.Show;
begin
  ShowWindow(Handle, SW_SHOWNOACTIVATE);
  if SelectedControl <> nil then
    SelectedControl.ParentVisibleChange(True);
end;

procedure TCustomdxBarControl.UpdateCanvasFont;
var
  ALogFont: TLogFont;
begin
  if bsUpdatingCanvasFont in FState then
    Exit;
  Include(FState, bsUpdatingCanvasFont);
  try
    if IsVertical then
    begin
      dxGetFontData(Font.Handle, ALogFont);
      ALogFont.lfEscapement := -900;
      ALogFont.lfOrientation := ALogFont.lfEscapement;
      ALogFont.lfOutPrecision := OUT_TT_ONLY_PRECIS;
      Canvas.Font.Handle := CreateFontIndirect(ALogFont);
    end
    else
      Canvas.Font := Font;
  finally
    Exclude(FState, bsUpdatingCanvasFont);
  end;
end;

procedure TCustomdxBarControl.UpdateControlStyle;
begin
  if (BarManager.GetPaintStyle = bmsStandard) and not IsCustomizing then // ???
    ControlStyle := ControlStyle - [csDoubleClicks]
  else
    ControlStyle := ControlStyle + [csDoubleClicks];
end;

procedure TCustomdxBarControl.UpdateParentItemControl;
begin
end;

procedure TCustomdxBarControl.ViewStateChanged(APrevValue: TdxBarViewState);
begin
end;

function TCustomdxBarControl.WantMouse: Boolean;
begin
  Result := cxWindowFromPoint(GetMouseCursorPos) = Handle;
end;

procedure TCustomdxBarControl.DoShowPopup(ASelectedControl: TdxBarItemControl);
begin
  if (ASelectedControl <> nil) or BarManager.Designing then
    BarDesignController.ShowCustomizePopup(Self, GetLinkByControl(ASelectedControl));
end;

procedure TCustomdxBarControl.InitCustomizationPopup(AItemLinks: TdxBarItemLinks);
begin
// do nothing
end;

procedure TCustomdxBarControl.ShowPopup(AItem: TdxBarItemControl);
begin
  DoShowPopup(SelectedControlAtDesign);
end;

function TCustomdxBarControl.AllowNCPaint: Boolean;
begin
  Result := True;
end;

function TCustomdxBarControl.AllowSeparators: Boolean;
begin
  Result := True;
end;

procedure TCustomdxBarControl.CMBiDiModeChanged(var Message: TMessage);
var
  APrevWParam: Integer;
begin
  APrevWParam := Message.WParam;
  try
    Message.wParam := 1;
    inherited;
  finally
    Message.wParam := APrevWParam;
  end;
end;

procedure TCustomdxBarControl.FillBackgroundRgn(DC: HDC; ARgn: HRGN; ABrush: HBRUSH;
  AIsClientArea: Boolean);
var
  AClipRgn: HRGN;
  AClipRgnExists: Boolean;
begin
  SaveClipRgn(DC, AClipRgn, AClipRgnExists);
  ExtSelectClipRgn(DC, ARgn, RGN_AND);
  FillBackground(DC, NCRect, ABrush, clNone, AIsClientArea);
  RestoreClipRgn(DC, AClipRgn, AClipRgnExists);
end;

procedure TCustomdxBarControl.FullInvalidate;
begin
  if HandleAllocated then
    SendMessage(Handle, WM_NCPAINT, 0, 0);
  Invalidate;
end;

procedure TCustomdxBarControl.FullRepaint;
begin
  if HandleAllocated then
    SendMessage(Handle, WM_NCPAINT, 0, 0);
  Repaint;
end;

procedure TCustomdxBarControl.InvalidateNCRect(ARect: TRect);
var
  ARegion: HRGN;
begin
  ARect := cxRectOffset(ARect, WindowRect.TopLeft);
  ARegion := CreateRectRgnIndirect(ARect);
  SendMessage(Handle, WM_NCPAINT, ARegion, 0);
  DeleteObject(ARegion);
end;

function TCustomdxBarControl.IsInternal: Boolean;
begin
  Result := False;
end;

function TCustomdxBarControl.IsBackgroundBitmap: Boolean;
begin
  Result := (DockControl <> nil) and DockControl.IsBackgroundBitmap;
end;

function TCustomdxBarControl.NeedBufferedOnGlass(AControl: TdxBarItemControl): Boolean;
begin
  Result := IsOnGlass and not AControl.IsTransparentOnGlass;
end;

function TCustomdxBarControl.IsTransparent: Boolean;
begin
  Result := (DockControl <> nil) and DockControl.IsTransparent;
end;

function TCustomdxBarControl.NCOffset: TPoint;
begin
  Result.X := 0;
  Result.Y := 0;
end;

procedure TCustomdxBarControl.NCPaint(ADC: HDC);
begin
// do nothing
end;

function TCustomdxBarControl.GetScaleFactor: TdxScaleFactor;
begin
  Result := BarManager.ScaleFactor;
end;

function TCustomdxBarControl.PointBarToDock(const APoint: TPoint): TPoint;
var
  ABounds: TRect;
begin
  ABounds := BoundsRect;
  Result.X := APoint.X + ABounds.Left;
  Result.Y := APoint.Y + ABounds.Top;
end;

procedure TCustomdxBarControl.ResetBackground;
begin
  FBackgroundTempBitmap.Assign(nil);
end;

procedure TCustomdxBarControl.UpdateDoubleBuffered;
begin
  DoubleBuffered := IsDoubleBufferedNeeded;
end;

procedure TCustomdxBarControl.Initialize;
begin
  FCanvas := TcxCanvas.Create(inherited Canvas);
  FViewInfo := GetViewInfoClass.Create(Self);
  FBackgroundTempBitmap := TcxBitmap.CreateSize(0, 0, cxDoubleBufferedBitmapPixelFormat);
  FShadow := TdxBarShadow.Create(Self);
end;

procedure TCustomdxBarControl.Finalize;
begin
  FreeAndNil(FShadow);
  FreeAndNil(FBackgroundTempBitmap);
  FreeAndNil(FViewInfo);
  FreeAndNil(FCanvas);
  FreeAndNil(FActiveCanvas);
end;

procedure TCustomdxBarControl.HideByEscape;
begin
  FCloseUpReason := bcrEscape;
  Hide;
end;

procedure TCustomdxBarControl.HideAll(AReason: TdxBarCloseUpReason);
var
  ALinkSelf: TcxObjectLink;
begin
  if (bsHideAll in FState) then
    Exit;

  FCloseUpReason := AReason;
  ALinkSelf := cxAddObjectLink(Self);
  Include(FState, bsHideAll);
  try
    DoHideAll(AReason);
  finally
    if ALinkSelf.Ref <> nil then
      Exclude(FState, bsHideAll);
    cxRemoveObjectLink(ALinkSelf);
  end;
end;

procedure TCustomdxBarControl.HideAllByEscape;
begin
  HideAll(bcrEscape);
end;

procedure TCustomdxBarControl.PostponedHideAll(AReason: TdxBarCloseUpReason);
begin
  PostMessage(Handle, DXM_BAR_HIDEALL, 0, LPARAM(AReason));
end;

function TCustomdxBarControl.IsOnGlass: Boolean;
begin
  Result := False;
end;

function TCustomdxBarControl.IsRealVertical: Boolean;
begin
  Result := False;
end;

function TCustomdxBarControl.IsVertical: Boolean;
begin
  Result := False;
end;

function TCustomdxBarControl.ItemAtPos(const APos: TPoint): TdxBarItemControl;
var
  I: Integer;
begin
  Result := nil;
  if not IsCustomizing or CanCustomizing then
    for I := 0 to ViewInfo.ItemControlCount - 1 do
      if PtInRect(ViewInfo.ItemControlViewInfos[I].Bounds, APos) then
      begin
        Result := ViewInfo.ItemControlViewInfos[I].Control;
        if IsCustomizing and Result.IsHiddenForCustomization then
          Result := nil;
        Break;
      end;
end;

procedure TCustomdxBarControl.RepaintBar;
begin
  RepaintBarEx(True);
end;

function TCustomdxBarControl.DoHint(var ANeedDeactivate: Boolean; out AHintText: string;
  out AShortCut: string): Boolean;
begin
  AHintText := GetHintItemText;
  AShortCut := '';
  Result := True;
end;

function TCustomdxBarControl.CreateHintViewInfo(const AHintText, AShortCut: string): TdxBarCustomHintViewInfo;
begin
  Result := CreateHintViewInfo(AHintText, AShortCut, nil);
end;

function TCustomdxBarControl.GetHintKeeperEnabled: Boolean;
begin
  Result := True;
end;

function TCustomdxBarControl.GetHintPosition(const ACursorPos: TPoint; AHeight: Integer): TPoint;
begin
  Result := GetHintPosition(MarkRect, ACursorPos, AHeight);
end;

function TCustomdxBarControl.GetHintedControl: TControl;
begin
  Result := Self;
end;

function TCustomdxBarControl.IsCustomHintSupported: Boolean;
begin
  Result := Painter.IsCustomHintSupported;
end;

function TCustomdxBarControl.IsDoubleBufferedNeeded: Boolean;
begin
  Result := IsTransparent or BarManager.IsUncustomizable or
    (Painter <> nil) and Painter.NeedDoubleBuffer;
end;

function TCustomdxBarControl.GetManager: IdxManager;
begin
  Result := BarManager;
end;

{ TdxDockCol }

constructor TdxDockCol.Create(ADockRow: TdxDockRow; ABarControl: TdxBarControl);
begin
  inherited Create;
  FDockRow := ADockRow;
  FBarControl := ABarControl;
end;

procedure TdxDockCol.AssignPosition;
var
  ALeft: Integer;
begin
  ALeft := FDockRow.DockControl.GetBarControlPos(FBarControl.Left, FBarControl.Width);
  FPos := Point(ALeft, FBarControl.Top);
end;

{ TdxBarItem }

constructor TdxBarItem.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FBarManager := GetBarManagerByComponent(AOwner);
  if (FBarManager = nil) and (dxBarManagerList.Count > 0) then
    FBarManager := TdxBarManager(dxBarManagerList[0]);

  FLinks := TList.Create;
  FStylesData := TdxBarItemStylesData.Create(GetStyleCount);
  FStylesData.OnChange := InternalStyleChanged;

  FGlyph := dxBarCreateSmartGlyph(OnGlyphChanged);
  FLargeGlyph := dxBarCreateSmartGlyph(OnLargeGlyphChanged);
  FImageIndex := -1;
  FLargeImageIndex := -1;

  FCanSelect := True;
  FCategory := -1;
  FMergeKind := mkAdd;
end;

destructor TdxBarItem.Destroy;
begin
  FreeAndNil(FStylesData);
  FreeAndNil(FLinks);
  FreeAndNil(FActionLink);
  FreeAndNil(FLargeGlyph);
  FreeAndNil(FGlyph);
  cxClearObjectLinks(Self);
  inherited Destroy;
end;

procedure TdxBarItem.AfterConstruction;
begin
  inherited AfterConstruction;
  if BarManager <> nil then
    BarManager.FItems.Add(Self);
end;

procedure TdxBarItem.Assign(Source: TPersistent);
var
  AItem: TdxBarItem;
begin
  if Source is TdxBarItem then
  begin
    AItem := TdxBarItem(Source);
    Action := AItem.Action;
    Align := AItem.Align;
    Caption := AItem.Caption;
    Category := AItem.Category;
    Description := AItem.Description;
    Enabled := AItem.Enabled;
    HelpContext := AItem.HelpContext;
    Hint := AItem.Hint;
    KeyTip := AItem.KeyTip;
    MergeKind := AItem.MergeKind;
    MergeOrder := AItem.MergeOrder;
    Style := AItem.Style;
    ScreenTip := AItem.ScreenTip;
    Visible := AItem.Visible;

    Data := AItem.Data;
    Glyph := AItem.Glyph;
    ImageIndex := AItem.ImageIndex;
    LargeGlyph := AItem.LargeGlyph;
    LargeImageIndex := AItem.LargeImageIndex;
    ShortCut := AItem.ShortCut;
    OnClick := AItem.OnClick;
  end
  else
    inherited;
end;

procedure TdxBarItem.BeforeDestruction;
begin
  inherited;
  CallNotify(FOnDestroy, Self);
  DestroyLinks;
end;

function TdxBarItem.GetAction: TBasicAction;
begin
  if FActionLink = nil then
    Result := nil
  else
    Result := FActionLink.Action;
end;

function TdxBarItem.GetActiveLink: TdxBarItemLink;

  function InternalGetActiveLink: TdxBarItemLink;
  var
    I: Integer;
  begin
    Result := nil;
    for I := 0 to LinkCount - 1 do
      if (Links[I].Control <> nil) then
      begin
        Result := Links[I];
        Break;
      end;
  end;

begin
  if GetItemByLink(BarManager.LastSelectedLinkAtDesign) = Self then
    Result := BarManager.LastSelectedLinkAtDesign
  else
    Result := InternalGetActiveLink
end;

function TdxBarItem.GetActuallyVisible: Boolean;
begin
  Result :=
    (Visible = ivAlways) and (InternalActuallyVisible or BarManager.IsCustomizing) or
    (Visible = ivInCustomizing) and BarManager.IsCustomizing or
    (Visible = ivNotInCustomizing) and not BarManager.IsCustomizing;
end;

function TdxBarItem.GetCurItemLink: TdxBarItemLink;
var
  I: Integer;
begin
  Result := nil;
  for I := 0 to LinkCount - 1 do
    if (Links[I].Control <> nil) and Links[I].Control.IsActive then
    begin
      Result := Links[I];
      Break;
    end;
end;

function TdxBarItem.GetFlat: Boolean;
begin
  // TODO: obsolete
  Result := BarManager.Flat;
end;

function TdxBarItem.GetIndex: Integer;
begin
  Result := BarManager.FItems.IndexOf(Self);
end;

function TdxBarItem.GetIsDesigning: Boolean;
begin
  Result := csDesigning in ComponentState;
end;

function TdxBarItem.GetIsDestroying: Boolean;
begin
  Result := csDestroying in ComponentState;
end;

function TdxBarItem.GetIsLoading: Boolean;
begin
  Result := csLoading in ComponentState;
end;

function TdxBarItem.GetLinkCount: Integer;
begin
  Result := FLinks.Count;
end;

function TdxBarItem.GetLinks(Index: Integer): TdxBarItemLink;
begin
  Result := nil;
  if (Index > -1) and (Index < LinkCount) then
    Result := TdxBarItemLink(FLinks[Index]);
end;

function TdxBarItem.GetPainterClass: TdxBarPainterClass;
begin
  Result := BarManager.PainterClass;
end;

function TdxBarItem.GetVisibleForCustomization: Boolean;
begin
  Result := Visible in [ivAlways, ivInCustomizing];
end;

function TdxBarItem.GetVisibleForUser: Boolean;
var
  I: Integer;
begin
  Result := True;
  for I := 0 to LinkCount - 1 do
    if Links[I].CanVisibleIndex <> -1 then Exit;
  Result := False;
end;

procedure TdxBarItem.SetAction(Value: TBasicAction);
begin
  if Action <> Value then
    if Value = nil then
      FreeAndNil(FActionLink)
    else
    begin
      if csLoading in Value.ComponentState then
        BarManager.LockDesignerModified(True);
      try
        if FActionLink = nil then
          FActionLink := GetActionLinkClass.Create(Self);
        FActionLink.Action := Value;
        FActionLink.OnChange := DoActionChange;
        ActionChange(Value, csLoading in Value.ComponentState);
        Value.FreeNotification(Self);
      finally
        if csLoading in Value.ComponentState then
          BarManager.LockDesignerModified(False, False);
      end;
    end;
end;

procedure TdxBarItem.SetAlign(Value: TdxBarItemAlign);
begin
  if FAlign <> Value then
  begin
    FAlign := Value;
    UpdateEx;
  end;
end;

procedure TdxBarItem.SetCategory(Value: Integer);

  function CanSetCategory(AValue: Integer): Boolean;
  begin
    Result := (BarManager <> nil) and (Index >= 0) and
      TdxBarManagerCategories(BarManager.Categories).IsIndexValid(Value);
  end;

  procedure Rank;
  var
    AList: TList;
    ANewIndex: Integer;
  begin
    AList := TList.Create;
    try
      BarManager.GetAllItemsByCategory(Value, AList);
      if AList.Count > 0 then
      begin
        if Index <= TdxBarItem(AList.Last).Index then
          ANewIndex := TdxBarItem(AList.Last).Index
        else
          ANewIndex := TdxBarItem(AList.Last).Index + 1;
        BarManager.MoveItem(Index, ANewIndex);
      end;
    finally
      AList.Free;
    end;
  end;

begin
  if IsLoading then
    FCategory := Value
  else
    if (FCategory <> Value) and CanSetCategory(Value) then
    begin
      Rank;
      FCategory := Value;
      Changed(True);
    end;
end;

procedure TdxBarItem.SetDescription(Value: string);
begin
  if FDescription <> Value then
  begin
    FDescription := Value;
    Changed;
  end;
end;

procedure TdxBarItem.SetGlyph(Value: TdxSmartGlyph);
begin
  FGlyph.Assign(Value);
end;

procedure TdxBarItem.SetHint(Value: string);
begin
  FHint := Value;
end;

procedure TdxBarItem.SetIndex(Value: Integer);
begin
  if Index <> Value then
    BarManager.ItemList.Move(Index, Value);
end;

procedure TdxBarItem.SetLargeGlyph(Value: TdxSmartGlyph);
begin
  FLargeGlyph.Assign(Value);
end;

procedure TdxBarItem.SetMergeOrder(Value: Integer);
begin
  FMergeOrder := Max(Value, 0);
end;

procedure TdxBarItem.SetPaintStyle(Value: TdxBarPaintStyle);
begin
  if FPaintStyle <> Value then
  begin
    FPaintStyle := Value;
    if not IsLoading then PaintStyleChanged;
  end;
end;

procedure TdxBarItem.SetShowCaption(Value: Boolean);
begin
  if FShowCaption <> Value then
  begin
    FShowCaption := Value;
    if not IsLoading then UpdateEx;
  end;
end;

procedure TdxBarItem.SetShortCut(Value: TShortCut);
begin
  if FShortCut <> Value then
  begin
    FShortCut := Value;
    if not IsLoading then ShortCutChanged;
  end;
end;

procedure TdxBarItem.DestroyLinks;

  function HasItemLinkOnUnlockedBar: Boolean;
  var
    ABarControl: TCustomdxBarControl;
    I: Integer;
  begin
    Result := False;
    for I := 0 to LinkCount - 1 do
    begin
      ABarControl := Links[I].BarControl;
      if (ABarControl is TdxBarControl) and not TdxBarControl(ABarControl).BarManager.IsUpdateLocked then
      begin
        Result := True;
        Break;
      end;
    end;
  end;

var
  ALink: TdxBarItemLink;
  ALock: Boolean;
begin
  ALock := not BarManager.IsDestroying and HasItemLinkOnUnlockedBar;
  if ALock then
    BarManager.BeginUpdate;
  try
    while LinkCount > 0 do
    begin
      ALink := TdxBarItemLink(FLinks.Last);
      FLinks.Remove(ALink);
      ALink.Free;
    end;
  finally
    if ALock then
      BarManager.EndUpdate;
  end;
end;

procedure TdxBarItem.DoActionChange(Sender: TObject);
begin
  if Sender = Action then ActionChange(Sender, False);
end;

function TdxBarItem.IsEnabledStored: Boolean;
begin
  Result := (FActionLink = nil) or not FActionLink.IsEnabledLinked;
end;

function TdxBarItem.IsHelpContextStored: Boolean;
begin
  Result := (ActionLink = nil) or not FActionLink.IsHelpContextLinked;
end;

function TdxBarItem.IsImageIndexStored: Boolean;
begin
  Result := (FActionLink = nil) or not FActionLink.IsImageIndexLinked;
end;

function TdxBarItem.IsShortCutStored: Boolean;
begin
  Result := (FActionLink = nil) or not FActionLink.IsShortCutLinked;
end;

function TdxBarItem.IsVisibleStored: Boolean;
begin
  Result := (FActionLink = nil) or not FActionLink.IsVisibleLinked;
end;

function TdxBarItem.IsOnClickStored: Boolean;
begin
  Result := (FActionLink = nil) or not FActionLink.IsOnExecuteLinked;
end;

function TdxBarItem.GetHintFromCaption: string;
var
  P: Integer;
begin
  Result := Caption;
  P := Pos('&', Result);
  if P > 0 then Delete(Result, P, 1);
  P := Pos('...', Result);
  if P > 0 then Delete(Result, P, 3);
end;

procedure TdxBarItem.OnGlyphChanged(Sender: TObject);
begin
  GlyphChanged;
end;

procedure TdxBarItem.OnLargeGlyphChanged(Sender: TObject);
begin
  LargeGlyphChanged;
end;

procedure TdxBarItem.AssignTo(Dest: TPersistent);
begin
  if Dest is TCustomAction then
    with TCustomAction(Dest) do
    begin
      Caption := Self.Caption;
      if Self is TdxBarCustomButton then
        Checked := TdxBarCustomButton(Self).Down;
      Enabled := Self.Enabled;
      HelpContext := Self.HelpContext;
      Hint := Self.Hint;
      ImageIndex := Self.ImageIndex;
      ShortCut := Self.ShortCut;
      case Self.Visible of
        ivNever: Visible := False;
        ivAlways: Visible := True;
      end;
      OnExecute := Self.OnClick;
    end
  else
    inherited AssignTo(Dest);
end;

procedure TdxBarItem.ChangeScale(M, D: Integer);
begin
  Width := MulDiv(Width, M, D);
end;

function TdxBarItem.GetEnabled: Boolean;
begin
  if BarManager.IsCustomizing and not BarManager.Designing and (Category > -1) then
    Result := True
  else
    Result := FEnabled;
end;

procedure TdxBarItem.Loaded;
begin
  inherited Loaded;
  FIsPredefined := True;
  if Action <> nil then
    ActionChange(Action, True);
  CallNotify(FOnCreate, Self);
end;

procedure TdxBarItem.Notification(AComponent: TComponent; Operation: TOperation);
begin
  inherited Notification(AComponent, Operation);
  if not (csDestroying in ComponentState) and (Operation = opRemove) then
  begin
    if AComponent = Action then
      Action := nil;
    if AComponent = FScreenTip then
      FScreenTip := nil;
  end;
end;

procedure TdxBarItem.ReadState(Reader: TReader);
begin
  inherited ReadState(Reader);
  if Reader.Parent is TdxBarManager then
    FBarManager := TdxBarManager(Reader.Parent);
end;

procedure TdxBarItem.SelectionChanged;
var
  I: Integer;
begin
  BarDesignController.SynchronizeLastSelectedItem;
  for I := 0 to LinkCount - 1 do
    RepaintItemControl(Links[I].Control);
end;

procedure TdxBarItem.SetName(const NewName: TComponentName);
begin
  inherited;
  if not ((csDesigning in ComponentState) and (NewName = '')) then
    Changed;
end;

procedure TdxBarItem.SetEnabled(Value: Boolean);
begin
  if FEnabled <> Value then
  begin
    inherited;
    if not IsLoading then
      EnabledChanged;
  end;
end;

procedure TdxBarItem.SetVisible(Value: TdxBarItemVisible);
begin
  if FVisible <> Value then
  begin
    inherited;
    VisibleChanged;
  end;
end;

procedure TdxBarItem.SetWidth(Value: Integer);
begin
  if (FWidth <> Value) and (Value >= 0) then
  begin
    FWidth := Value;
    if not IsLoading then
      WidthChanged;
  end;
end;

procedure TdxBarItem.Invalidate;
begin
  Update;
end;

function TdxBarItem.IsComplex: Boolean;
begin
  Result := LinkCount > 1;
end;

function TdxBarItem.CanDelete(ADestruction: Boolean = False): Boolean;
begin
  Result := (LinkCount > 0) and not ADestruction or BarManager.CanDeleteComponent(Self);
end;

procedure TdxBarItem.ExecuteCustomizationAction(ABasicAction: TdxBarCustomizationAction);
begin
  if (LinkCount = 1) and (GetSelectableItem(Links[0]) <> BarDesignController.LastSelectedItem) then
    Links[0].ExecuteCustomizationAction(ABasicAction);
end;

procedure TdxBarItem.GetMasterObjects(AList: TdxObjectList);
begin
  AList.Add(BarManager.Owner);
end;

function TdxBarItem.GetNextSelectableItem: IdxBarSelectableItem;

  function GetNextLink(AItemLink: TdxBarItemLink): TdxBarItemLink;
  begin
    if AItemLink <> nil then
      Result := AItemLink.GetNext
    else
      Result := nil;
  end;

  function GetNextItem(AItemLink: TdxBarItemLink): TdxBarItem;
  var
    ANext: TdxBarItemLink;
  begin
    Result := nil;
    ANext := AItemLink;
    repeat
      ANext := GetNextLink(ANext);
      if GetItemByLink(ANext) <> Self then
      begin
        Result := GetItemByLink(ANext);
        Break;
      end;
    until (ANext = nil) or (ANext = AItemLink);
  end;

begin
  Result := GetNextItem(GetActiveLink);
end;

function TdxBarItem.GetSelectableParent: TPersistent;
begin
  if GetActiveLink <> nil then
    Result := GetActiveLink.GetSelectableParent
  else
    Result := nil;
end;

function TdxBarItem.GetSupportedActions: TdxBarCustomizationActions;
begin
  if BarManager.Designing then
  begin
    if BarDesignController.IsItemLinkCustomized then
      Result := [caReset, caDelete, caDeleteItem, caDeleteLink, caSelectLink,
        caChangeCaption, caChangePosition, caChangeViewLevels,
        caChangeBeginGroup, caChangeVisible, caChangeRecentList, caChangeDistributed]
    else
      Result := [caDelete];
  end
  else
    Result := [caReset, caDeleteLink, caChangeCaption, caChangeBeginGroup];
end;

procedure TdxBarItem.DeleteSelection(var AReference: IdxBarSelectableItem; ADestruction: Boolean);
begin
  if ADestruction or (LinkCount = 0) then
    inherited
  else
    DestroyLinks;
end;

function TdxBarItem.SelectParentComponent: Boolean;
begin
  if GetActiveLink <> nil then
    Result := GetActiveLink.SelectParentComponent
  else
    Result := False;
end;

procedure TdxBarItem.ActionChange(Sender: TObject; CheckDefaults: Boolean);
begin
  if Action is TCustomAction then
    with TCustomAction(Sender) do
    begin
      FCheckDefaults := CheckDefaults;
      try
        if not CheckDefaults or (Self.Caption = '') then
          Self.Caption := Caption;
      finally
        FCheckDefaults := False;
      end;
      if (Self is TdxBarCustomButton) and
        (not CheckDefaults or not TdxBarCustomButton(Self).Down) then
        TdxBarCustomButton(Self).Down := Checked;
      if not CheckDefaults or (Self.Enabled) then
        Self.Enabled := Enabled;
      if not CheckDefaults or (Self.HelpContext = 0) then
        Self.HelpContext := HelpContext;
      if not CheckDefaults or (Self.Hint = '') then
        Self.Hint := Hint;
      if not CheckDefaults or (Self.ActionImageIndex = -1) then
        Self.ActionImageIndex := ImageIndex;
      if not CheckDefaults or (Self.ShortCut = scNone) then
        Self.ShortCut := ShortCut;
      if not CheckDefaults or (Self.Visible = ivAlways) then
        Self.Visible := VisibleTodxBarVisible(Visible);
      if not CheckDefaults or not Assigned(Self.OnClick) then
        Self.OnClick := OnExecute;
    end;
end;

function TdxBarItem.CanBePlacedOn(AParentKind: TdxBarItemControlParentKind;
  AToolbar: TdxBar; out AErrorText: string): Boolean;
begin
  Result := True;
end;

function TdxBarItem.CanChangePaintStyle: Boolean;
begin
  Result := False;
end;

function TdxBarItem.CanClicked: Boolean;
begin
  Result := True;
end;

function TdxBarItem.CanMergeWith(AItem: TdxBarItem): Boolean;
begin
  Result := InternalCanMergeWith(AItem) and AItem.InternalCanMergeWith(Self);
end;

function TdxBarItem.CurImageIndexLinked: Boolean;
begin
  Result := IsImageAssigned(GetCurrentImages, ImageIndex)
end;

procedure TdxBarItem.DrawCustomizingImage(ACanvas: TCanvas; const ARect: TRect; AState: TOwnerDrawState);
begin
  dxBarCustomizingForm.PainterClass.DrawButtonOrSubItem(ACanvas, ARect, Self, GetTextOf(Caption), odSelected in AState);
end;

procedure TdxBarItem.DrawCustomizingImageContent(ACanvas: TCanvas;
  const ARect: TRect; ASelected: Boolean);
begin
  ACanvas.Brush.Color := clWindow;
  ACanvas.FillRect(ARect);
end;

function TdxBarItem.GetActionLinkClass: TdxBarItemActionLinkClass;
begin
  Result := TdxBarItemActionLink;
end;

function TdxBarItem.GetActionImageIndex: Integer;
begin
  Result := ImageIndex;
end;

procedure TdxBarItem.SetActionImageIndex(Value: Integer);
begin
  ImageIndex := Value;
end;

function TdxBarItem.GetControlClass(AIsVertical: Boolean): TdxBarItemControlClass;
var
  I: Integer;
begin
  Result := nil;
  for I := 0 to RegdxItemList.Count - 1 do
    if ClassInfo = RegdxItemList.Items[I].FItemClass.ClassInfo then
    begin
      Result := RegdxItemList.Items[I].FItemControlClass;
      Break;
    end;
end;

function TdxBarItem.GetHidden: Boolean;
begin
  Result := False;
end;

function TdxBarItem.GetItemLinks: TdxBarItemLinks;
begin
  Result := nil;
end;

class function TdxBarItem.GetStyleCount: Integer;
begin
  Result := 1;
end;

function TdxBarItem.GetStyleValue(AIndex: Integer): TcxStyle;
begin
  Result := StylesData.Styles[AIndex];
end;

function TdxBarItem.HasAccel(AItemLink: TdxBarItemLink): Boolean;
begin
  Result := Enabled;//True
end;

function TdxBarItem.HasControls: Boolean;
var
  I: Integer;
begin
  Result := True;
  for I := 0 to LinkCount - 1 do
    if Links[I].Control <> nil then Exit;
  Result := False;
end;

procedure TdxBarItem.HideControl(AControl: TdxBarItemControl);
begin
end;

function TdxBarItem.InternalActuallyVisible: Boolean;
begin
  Result := True;
end;

function TdxBarItem.InternalCanMergeWith(AItem: TdxBarItem): Boolean;
begin
  Result := False;
end;

function TdxBarItem.IsHintFromCaption: Boolean;
begin
  Result := GetShortHint(Hint) = GetHintFromCaption;
end;

function TdxBarItem.IsShortCut(AShortCut: TShortCut): Boolean;
begin
  Result := False;
  if Enabled then
  begin
    if CanClicked then
      Result := ShortCut = AShortCut;
    if Result then
      Click
    else
      if GetItemLinks <> nil then
        Result := GetItemLinks.IsShortCut(AShortCut);
  end;
end;

function TdxBarItem.IsStyleColorSupported: Boolean;
begin
  Result := False;
end;

function TdxBarItem.NeedToBeHidden: Boolean;
begin
  Result := False;
end;

procedure TdxBarItem.ObjectNotification(AOperation: TOperation; AObject: TObject);
begin
end;

procedure TdxBarItem.Recalculate;
var
  I: Integer;
begin
  for I := 0 to LinkCount - 1 do
    if Links[I].Control <> nil then
      with Links[I].Control do
        PartsChanged;
end;

function TdxBarItem.GetScreenTip: TdxScreenTip;
begin
  Result := FScreenTip;
end;

procedure TdxBarItem.SetScreenTip(Value: TdxScreenTip);
begin
  if FScreenTip <> Value then
  begin
    cxRemoveFreeNotification(Self, FScreenTip);
    FScreenTip := Value;
    cxAddFreeNotification(Self, FScreenTip);
  end;
end;

procedure TdxBarItem.SetImageIndex(Value: Integer);
begin
  if FImageIndex <> Value then
  begin
    FImageIndex := Value;
    GlyphChanged;
  end;
end;

procedure TdxBarItem.SetLargeImageIndex(Value: Integer);
begin
  if FLargeImageIndex <> Value then
  begin
    FLargeImageIndex := Value;
    LargeGlyphChanged;
  end;
end;

procedure TdxBarItem.SetStyleValue(AIndex: Integer; Value: TcxStyle);
begin
  StylesData.Styles[AIndex] := Value;
end;

procedure TdxBarItem.ShowDefaultEventHandler;
begin
  BarManager.ShowDefaultEventHandler(Self);
end;

procedure TdxBarItem.Update;
var
  I: Integer;
begin
  for I := 0 to LinkCount - 1 do
    if Links[I].Control <> nil then
      with Links[I].Control do
        if not IsSelected or not Parent.IsActive then
          Repaint;
end;

procedure TdxBarItem.UpdateActionLink;
begin
  if ActionLink <> nil then
    ActionLink.Update;
end;

procedure TdxBarItem.UpdateEx(AParentKinds: TdxBarKinds = dxBarKindAny);
var
  I: Integer;
begin
  for I := 0 to LinkCount - 1 do
    if Links[I].Control <> nil then
      with Links[I].Control do
        if (Parent.Kind in AParentKinds) and (not IsSelected or not Parent.IsActive) then
          Parent.RepaintBar;
end;

function TdxBarItem.UseHotImages: Boolean;
begin
  Result := False;
end;

function TdxBarItem.UseLargeImages: Boolean;
begin
  Result := (ImageIndex > -1) or (LargeImageIndex > -1);
end;

procedure TdxBarItem.CaptionChanged;
var
  I: Integer;
begin
  for I := 0 to LinkCount - 1 do
    if not (udCaption in Links[I].UserDefine) and (Links[I].Control <> nil) then
      Links[I].Control.CaptionChanged;
  Changed;
end;

procedure TdxBarItem.EnabledChanged;
var
  I: Integer;
begin
  for I := 0 to LinkCount - 1 do
    if Links[I].Control <> nil then
    begin
      Links[I].Control.ResetCachedValues(False);
      Links[I].Control.EnabledChanged;
    end;
  Changed;
end;

procedure TdxBarItem.GlyphChanged;
var
  ALink: TdxBarItemLink;
  I: Integer;
begin
  for I := 0 to LinkCount - 1 do
  begin
    ALink := Links[I];
    if not (udGlyph in ALink.UserDefine) and (ALink.Control <> nil) then
      ALink.Control.ResetCachedValues(True);
  end;
  for I := 0 to LinkCount - 1 do
  begin
    ALink := Links[I];
    if not (udGlyph in ALink.UserDefine) and (ALink.Control <> nil) then
      ALink.Control.GlyphChanged;
  end;
  Changed;
end;

procedure TdxBarItem.HotGlyphChanged;
var
  ALink: TdxBarItemLink;
  I: Integer;
begin
  for I := 0 to LinkCount - 1 do
  begin
    ALink := Links[I];
    if ALink.Control <> nil then
    begin
      ALink.Control.ResetCachedValues(False);
      ALink.Control.HotGlyphChanged;
    end;
  end;
end;

procedure TdxBarItem.InternalStyleChanged(AChangeKind: TdxBarItemStyleChangeKind);

  procedure DoItemLinkChange(ALink: TdxBarItemLink);
  begin
    if AChangeKind = sckDrawing then
      ALink.Control.CalcDrawingConsts
    else
      ALink.RecreateControl;
  end;

  procedure DoItemChange;
  begin
    if AChangeKind = sckDrawing then
      Update
    else
      UpdateEx;
  end;

var
  I: Integer;
begin
  if not (csDestroying in ComponentState) then
  begin
    for I := 0 to LinkCount - 1 do
      if Links[I].Control <> nil then
         DoItemLinkChange(Links[I]);
    DoItemChange;
  end;
end;

procedure TdxBarItem.LargeGlyphChanged;
var
  I: Integer;
begin
  for I := 0 to LinkCount - 1 do
    if Links[I].Control <> nil then
      Links[I].Control.ResetCachedValues(True);

  for I := 0 to LinkCount - 1 do
    if Links[I].Control <> nil then
      Links[I].Control.LargeGlyphChanged;
  Changed;
end;

procedure TdxBarItem.PaintStyleChanged;
begin
// do nothing
end;

procedure TdxBarItem.ShortCutChanged;
begin
  UpdateEx([bkSubMenu]);
  Changed;
end;

procedure TdxBarItem.VisibleChanged;
var
  I: Integer;
begin
  if IsDesigning or IsDestroying or IsLoading and not (bisAfterLoading in BarManager.FInternalState) then
    Exit;

  BarManager.BeginUpdate;
  try
    for I := 0 to LinkCount - 1 do
      Links[I].VisibleChanged;
  finally
    BarManager.EndUpdate;
    Changed;
  end;
end;

procedure TdxBarItem.WidthChanged;
var
  AItem: TdxBarItemLink;
  I: Integer;
begin
  for I := 0 to LinkCount - 1 do
  begin
    AItem := Links[I];
    if not (udWidth in AItem.UserDefine) and (AItem.Control <> nil) then
      AItem.Control.WidthChanged;
  end;
end;

function TdxBarItem.GetGlyph: TdxSmartGlyph;
begin
  Result := FGlyph;
end;

function TdxBarItem.GetImageIndex: Integer;
begin
  Result := FImageIndex;
end;

function TdxBarItem.DoIsChildWindow(AWindowHandle: THandle): Boolean;
begin
  Result := Assigned(FOnIsChildWindow) and FOnIsChildWindow(Self, AWindowHandle);
end;

function TdxBarItem.DoGetScreenTip: TdxScreenTip;
begin
  Result := FScreenTip;
  if Assigned(FOnGetScreenTip) then
    FOnGetScreenTip(Self, Result);
end;

function TdxBarItem.GetCaption: string;
begin
  Result := FCaption;
end;

function TdxBarItem.IsCaptionStored: Boolean;
begin
  Result := (FActionLink = nil) or not FActionLink.IsCaptionLinked;
end;

procedure TdxBarItem.SetCaption(const Value: string);
var
  AMakeHint: Boolean;
  S: string;
begin
  if FCaption <> Value then
  begin
    AMakeHint := not FCheckDefaults and not (Self is TCustomdxBarSubItem) and
      ((Hint = '') or IsHintFromCaption);
    FCaption := Value;
    if not IsLoading then
    begin
      if AMakeHint then
      begin
        S := GetHintFromCaption;
        if Pos('|', Hint) = 0 then
          Hint := S
        else
          Hint := S + '|' + GetLongHint(Hint);
      end;
      CaptionChanged;
    end;
  end;
end;

function TdxBarItem.GetHint: string;
begin
  Result := FHint;
end;

function TdxBarItem.IsHintStored: Boolean;
begin
  Result := (FActionLink = nil) or not FActionLink.IsHintLinked;
end;

procedure TdxBarItem.CheckLinks(ASource: TCustomIniFile; const ABaseSection: string);
begin
// do nothing
end;

function TdxBarItem.GetIniSection(const ABaseSection: string): string;
begin
  Result := '';
end;

procedure TdxBarItem.LoadFromIni(ASource: TCustomIniFile; const ABaseSection: string; AStoringKind: TdxBarStoringKind);
begin
// do nothing
end;

procedure TdxBarItem.LoadUsageData(ASource: TCustomIniFile; const ABaseSection: string);
begin
// do nothing
end;

procedure TdxBarItem.SaveToIni(ADestination: TCustomIniFile; const ABaseSection: string; AStoringKind: TdxBarStoringKind);
begin
// do nothing
end;

procedure TdxBarItem.GetTextViewParams(out AViewParams: TcxViewParams);
begin
  GetViewParams(Style, AViewParams);
end;

procedure TdxBarItem.GetViewParams(AStyle: TcxStyle; out AViewParams: TcxViewParams);
begin
  AViewParams := DefaultViewParams;
  if AStyle <> nil then
  begin
    if svBitmap in AStyle.AssignedValues then
      AViewParams.Bitmap := AStyle.Bitmap;
    if svColor in AStyle.AssignedValues then
      AViewParams.Color := AStyle.Color;
    if svFont in AStyle.AssignedValues then
      AViewParams.Font := AStyle.Font;
    if svTextColor in AStyle.AssignedValues then
      AViewParams.TextColor := AStyle.TextColor;
  end;
end;

class function TdxBarItem.GetNewCaption: string;
begin
  Result := dxSBAR_NEWITEMCAPTION;
end;

procedure TdxBarItem.Click;
begin
  if CanClicked then
    DirectClick;
end;

procedure TdxBarItem.DirectClick;
begin
  if Enabled then
  begin
    try
      BarManager.DoClickItem(Self);
      DoClick;
    except
      Application.HandleException(Self);
    end;
  end;
end;

procedure TdxBarItem.DoClick;
begin
  if Assigned(FOnClick) and ((Action = nil) or (@FOnClick <> @Action.OnExecute)) then
    FOnClick(Self)
  else
    if not IsDesigning and (FActionLink <> nil) then
      FActionLink.Execute(Self);
end;

function TdxBarItem.GetAddMessageName: string;
begin
  Result := '';
end;

function TdxBarItem.GetCurrentImages: TCustomImageList;
begin
  Result := BarManager.Images;
end;

function TdxBarItem.GetParentComponent: TComponent;
begin
  if HasParent then Result := FBarManager
  else Result := nil;
end;

function TdxBarItem.HasParent: Boolean;
begin
  Result := FCategory > -1;
end;

procedure TdxBarItem.SetParentComponent(AParent: TComponent);
begin
  if not IsLoading then
    FBarManager := AParent as TdxBarManager;
end;

{ TdxBarLabel }

constructor TdxBarLabel.Create(AOwner: TComponent);
begin
  inherited;
  FShowCaption := True;
end;

{ TdxBarSeparator }

function TdxBarSeparator.CanBePlacedOn(AParentKind: TdxBarItemControlParentKind;
  AToolbar: TdxBar; out AErrorText: string): Boolean;
begin
  Result := AParentKind = pkSubItemOrPopupMenu;
  if not Result then
    AErrorText := dxSBAR_CANTPLACESEPARATOR;
end;

class function TdxBarSeparator.GetNewCaption: string;
begin
  Result := dxSBAR_NEWSEPARATORCAPTION;
end;

function TdxBarSeparator.GetSupportedActions: TdxBarCustomizationActions;
begin
  Result := inherited GetSupportedActions - [caChangeRecentList];
end;

{ TdxBarWindowItem }

function TdxBarWindowItem.GetCurText: string;
begin
  if CurItemLink = nil then Result := Text
  else
    if CurItemLink.Control is TdxBarWinControl then
      Result := TdxBarWinControl(CurItemLink.Control).Text;
end;

function TdxBarWindowItem.GetFocusedItemLink: TdxBarItemLink;
begin
  if (CurItemLink <> nil) and (CurItemLink.Control <> nil) and CurItemLink.Control.Focused then
    Result := CurItemLink
  else
    Result := nil;
end;

procedure TdxBarWindowItem.SetCurText(Value: string);
begin
  if CurItemLink = nil then Text := Value
  else
    if CurItemLink.Control is TdxBarWinControl then
      TdxBarWinControl(CurItemLink.Control).Text := Value;
end;

function TdxBarWindowItem.CanClicked: Boolean;
begin
  Result := False;
end;

procedure TdxBarWindowItem.Change;
begin
  if not IsLoading and Assigned(FOnChange) then FOnChange(Self);
end;

procedure TdxBarWindowItem.CurChange;
begin
  CallNotify(FOnCurChange, Self);
end;

procedure TdxBarWindowItem.DoEnter;
begin
  CallNotify(FOnEnter, Self);
end;

procedure TdxBarWindowItem.DoExit;
begin
  CallNotify(FOnExit, Self);
end;

function TdxBarWindowItem.GetControlClass(AIsVertical: Boolean): TdxBarItemControlClass;
begin
  if AIsVertical then
    Result := TdxBarButtonControl
  else
    Result := inherited GetControlClass(AIsVertical);
end;

function TdxBarWindowItem.GetText: string;
begin
  Result := FText;
end;

procedure TdxBarWindowItem.KeyDown(var Key: Word; Shift: TShiftState);
begin
  if Assigned(FOnKeyDown) then FOnKeyDown(Self, Key, Shift);
end;

procedure TdxBarWindowItem.KeyPress(var Key: Char);
begin
  if Assigned(FOnKeyPress) then FOnKeyPress(Self, Key);
end;

procedure TdxBarWindowItem.KeyUp(var Key: Word; Shift: TShiftState);
begin
  if Assigned(FOnKeyUp) then FOnKeyUp(Self, Key, Shift);
end;

procedure TdxBarWindowItem.SetText(Value: string);
begin
  if FText <> Value then
  begin
    FText := Value;
{    if (CurItemLink <> nil) and (CurItemLink.Control is TdxBarWinControl) then
      TdxBarWinControl(CurItemLink.Control).Text := FText;}
    Update;
    Change;
    Update;
  end;
end;

procedure TdxBarWindowItem.SetFocus(ACheckBarControlVisibility: Boolean = False);
var
  I: Integer;
begin
  for I := 0 to LinkCount - 1 do
    with Links[I] do
      if Control is TdxBarWinControl and
        (not ACheckBarControlVisibility or IsControlVisible(BarControl)) then
      begin
        (BarControl as TdxBarControl).BarGetFocus(Control);
        Control.Click(False);
        Break;
      end;
end;


{ TdxBarButtonLikeItem }

procedure TdxBarButtonLikeItem.CheckLinks(ASource: TCustomIniFile; const ABaseSection: string);
begin
  if GetItemLinks <> nil then
  begin
    LoadFromIni(ASource, ABaseSection, skIni);
    LoadUsageData(ASource, ABaseSection);
    GetItemLinks.CheckLinks(ASource, ABaseSection);
  end;
end;

procedure TdxBarButtonLikeItem.LoadFromIni(ASource: TCustomIniFile; const ABaseSection: string; AStoringKind: TdxBarStoringKind);
begin
  if (Name <> '') and (ASource.ReadInteger(GetIniSection(ABaseSection), 'ItemLinkCount', -1) > -1) and (GetItemLinks <> nil) then
    GetItemLinks.LoadFromIni(ASource, GetIniSection(ABaseSection), AStoringKind);
end;

procedure TdxBarButtonLikeItem.LoadUsageData(ASource: TCustomIniFile; const ABaseSection: string);
begin
  if GetItemLinks <> nil then
    GetItemLinks.LoadUsageData(ASource, GetIniSection(ABaseSection));
end;

procedure TdxBarButtonLikeItem.SaveToIni(ADestination: TCustomIniFile; const ABaseSection: string; AStoringKind: TdxBarStoringKind);
begin
  if (Name <> '') and (GetItemLinks <> nil) then
    GetItemLinks.SaveToIni(ADestination, GetIniSection(ABaseSection), AStoringKind);
end;

procedure TdxBarButtonLikeItem.SetGlyphLayout(Value: TdxBarGlyphLayout);
begin
  if FGlyphLayout <> Value then
  begin
    FGlyphLayout := Value;
    UpdateEx;
  end;
end;

{ TdxBarCustomButton }

var
  ABarActivationDropDownControl: TdxBarButtonLikeControl;
  ABarActivationDropDownControlTimerID: UINT;

  ABarDeActivationDropDownControl: TdxBarButtonLikeControl;
  ABarDeActivationDropDownControlTimerID: UINT;

constructor TdxBarCustomButton.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FCloseSubMenuOnClick := True;
  FDropDownEnabled := True;
  FUnclickAfterDoing := True;
end;

function TdxBarCustomButton.GetButtonStyle: TdxBarButtonStyle;
begin
  if FInternalStates = [] then
    Result := bsDefault
  else
    if FInternalStates = [bstChecked] then
      Result := bsChecked
    else
      if FInternalStates = [bstDropDown] then
        Result := bsDropDown
      else
        Result := bsCheckedDropDown;
end;

procedure TdxBarCustomButton.SetAllowAllUp(Value: Boolean);
var
  I: Integer;
begin
  if FAllowAllUp <> Value then
  begin
    FAllowAllUp := Value;
    if GroupIndex <> 0 then
      with BarManager do
        for I := 0 to ItemCount - 1 do
          if (Items[I] is TdxBarCustomButton) and (TdxBarCustomButton(Items[I]).GroupIndex = GroupIndex) then
            TdxBarCustomButton(Items[I]).FAllowAllUp := FAllowAllUp;
  end;
end;

procedure TdxBarCustomButton.SetButtonStyle(Value: TdxBarButtonStyle);
begin
  if ButtonStyle <> Value then
  begin
    case Value of
      bsDefault: FInternalStates := [];
      bsChecked: FInternalStates := [bstChecked];
      bsDropDown: FInternalStates := [bstDropDown];
      bsCheckedDropDown: FInternalStates := [bstChecked, bstDropDown];
    end;
    Down := False;
    if not IsLoading then
      UpdateEx;
    Changed;
  end;
end;

procedure TdxBarCustomButton.SetDown(Value: Boolean);

  function GetDownedButton: TdxBarCustomButton;
  var
    AItem: TdxBarItem;
    I: Integer;
  begin
    with BarManager do
      for I := 0 to ItemCount - 1 do
      begin
        AItem := Items[I];
        if (AItem <> Self) and (AItem is TdxBarCustomButton) then
        begin
          Result := TdxBarCustomButton(Items[I]);
          if (bstChecked in Result.FInternalStates) and
             (Result.GroupIndex = GroupIndex) and Result.Down
          then
            Exit;
        end;
      end;
    Result := nil;
  end;

var
  ADownedButton: TdxBarCustomButton;
begin
  if (FDown <> Value) and ((bstChecked in FInternalStates) or not Value) then
  begin
    ADownedButton := nil;
    if not IsLoading and (bstChecked in FInternalStates) and (GroupIndex <> 0) then
    begin
      if Value then
        ADownedButton := GetDownedButton
      else
        if not AllowAllUp and (GetDownedButton = nil) then
          Exit;
    end;
    FDown := Value;
    if not IsLoading then
    begin
      Update;
      if ADownedButton <> nil then
        ADownedButton.Down := False;
    end;
  end;
end;

procedure TdxBarCustomButton.SetDropDownEnabled(Value: Boolean);
begin
  if FDropDownEnabled <> Value then
  begin
    FDropDownEnabled := Value;
    if not IsLoading then
      Update;
  end;
end;

procedure TdxBarCustomButton.SetDropDownMenu(Value: TdxBarCustomPopupMenu);
begin
  if Value <> FDropDownMenu then
  begin
    if (Value <> nil) and Value.GetItemLinks.IsReferencedBy(Self) then
      raise EdxException.Create(cxGetResourceString(@dxSBAR_RECURSIVEMENUS))
    else
    begin
      FDropDownMenu := Value;
      cxAddFreeNotification(Self, Value);
    end;
  end;
end;

procedure TdxBarCustomButton.SetGroupIndex(Value: Integer);
begin
  if FGroupIndex <> Value then
  begin
    if not (bstChecked in FInternalStates) then
      Value := 0;
    FGroupIndex := Value;
    Down := False;
  end;
end;

procedure TdxBarCustomButton.SetLowered(Value: Boolean);
begin
  if FLowered <> Value then
  begin
    FLowered := Value;
    if not IsLoading then UpdateEx;
  end;
end;

function TdxBarCustomButton.IsDownStored: Boolean;
begin
  Result := (FActionLink = nil) or not FActionLink.IsCheckedLinked;
end;

function TdxBarCustomButton.CanChangePaintStyle: Boolean;
begin
  Result := True;
end;

procedure TdxBarCustomButton.DoDropDown(AControl: TdxBarButtonControl; X, Y: Integer;
  ByMouse: Boolean);
var
  R: TRect;
  AItemBounds: TRect;
  AOwnerWidth, AOwnerHeight: Integer;
begin
  if FDropDownMenu <> nil then
  begin
    if AControl.HasShadow then
      R := AControl.Parent.GetItemScreenRect(AControl)
    else
      R := Rect(0, 0, 0, 0);
    FDropDownMenu.FOwnerItemControl := AControl;
    try
      AItemBounds := AControl.ItemBounds;
      if (AControl.Parent.Kind = bkSubMenu) or AControl.Parent.IsRealVertical then
      begin
        AOwnerWidth := cxRectWidth(AItemBounds);
        AOwnerHeight := 0;
      end
      else
      begin
        AOwnerWidth := 0;
        AOwnerHeight := cxRectHeight(AItemBounds);
      end;
      FDropDownMenu.PopupEx(X, Y, AOwnerWidth, AOwnerHeight, AControl.FShowAnimation, @R, False, AControl.Parent);
    finally
      FDropDownMenu.FOwnerItemControl := nil;
    end;
    with FDropDownMenu.SubMenuControl do
    begin
      FDropDownButton := AControl;
      if not ByMouse and (ItemLinks.First <> nil) then
        SetKeySelectedItem(ItemLinks.First.Control);
    end;
    if AControl.Parent.Kind = bkSubMenu then
      AControl.Parent.ChildBar := FDropDownMenu.SubMenuControl;
  end;
end;

function TdxBarCustomButton.HasAccel(AItemLink: TdxBarItemLink): Boolean;
begin
  Result := inherited HasAccel(AItemLink) and
    (not (AItemLink.Owner.Owner is TdxBar) or
     (AItemLink.PaintStyle in [psCaption, psCaptionGlyph]) or
     (AItemLink.Control <> nil) and
       (TdxBarButtonControl(AItemLink.Control).PaintStyle in [psCaption, psCaptionGlyph]));
end;

procedure TdxBarCustomButton.Notification(AComponent: TComponent; Operation: TOperation);
begin
  inherited;
  if (Operation = opRemove) and (AComponent = DropDownMenu) then
    FDropDownMenu := nil;
end;

procedure TdxBarCustomButton.PaintStyleChanged;
var
  I: Integer;
begin
  for I := 0 to LinkCount - 1 do
    if not (udPaintStyle in Links[I].UserDefine) and (Links[I].Control <> nil) then
      TdxBarButtonControl(Links[I].Control).PaintStyleChanged;
end;

function TdxBarCustomButton.GetIniSection(const ABaseSection: string): string;
begin
  Result := ABaseSection + 'Button_' + Name;
end;

// IdxBarLinksOwner
function TdxBarCustomButton.CanContainItem(AItem: TdxBarItem; out AErrorText: string): Boolean;
begin
  Result := (DropDownMenu <> nil) and DropDownMenu.CanContainItem(AItem, AErrorText);
end;

function TdxBarCustomButton.CreateBarControl: TCustomdxBarControl;
begin
  if DropDownMenu <> nil then
    Result := DropDownMenu.CreateBarControl
  else
    Result := nil;
end;

function TdxBarCustomButton.GetItemLinks: TdxBarItemLinks;
begin
  if DropDownMenu <> nil then
    Result := DropDownMenu.ItemLinks
  else
    Result := inherited GetItemLinks;
end;

function TdxBarCustomButton.GetImages: TCustomImageList;
begin
  Result := nil;
end;

function TdxBarCustomButton.IsLoading: Boolean;
begin
  Result := csLoading in ComponentState;
end;

function TdxBarCustomButton.GetSupportedActions: TdxBarCustomizationActions;
begin
  Result := inherited GetSupportedActions + [caChangeButtonPaintStyle];
  if BarManager.Designing then
    Include(Result, caChangeButtonGroup);
end;

class function TdxBarCustomButton.GetNewCaption: string;
begin
  Result := dxSBAR_NEWBUTTONCAPTION;
end;

procedure TdxBarCustomButton.Click;
begin
  if Enabled and (bstChecked in FInternalStates) then
    Down := not Down;
  inherited Click;
end;

procedure DropDownButtonLikeItem(AItem: TdxBarItem; AByMouse: Boolean = False);

  procedure InternalDropDown(AItemControl: TdxBarButtonLikeControl; AByMouse: Boolean);
  begin
    if AByMouse then
      AItemControl.Parent.SetMouseSelectedItem(AItemControl);
    AItemControl.Parent.BarGetFocus(AItemControl);
    AItemControl.DropDown(AByMouse);
  end;

var
  I: Integer;
begin
  for I := 0 to AItem.LinkCount - 1 do
    with AItem.Links[I] do
      if (Control is TdxBarButtonLikeControl) and IsControlVisible(BarControl) then
      begin
        InternalDropDown(TdxBarButtonLikeControl(Control), AByMouse);
        Break;
      end;
end;

procedure TdxBarCustomButton.DropDown(AByMouse: Boolean = False);
begin
  DropDownButtonLikeItem(Self, AByMouse);
end;

{ TdxBarLargeButton }

constructor TdxBarLargeButton.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FAutoGrayScale := True;
  FGlyphLayout := glTop;
  FHotGlyph := dxBarCreateSmartGlyph(OnHotGlyphChanged);
  FHotImageIndex := -1;
  FShowCaption := True;
  FSyncImageIndex := True;
end;

destructor TdxBarLargeButton.Destroy;
begin
  FreeAndNil(FHotGlyph);
  inherited;
end;

function TdxBarLargeButton.IsImageIndexStored: Boolean;
begin
  Result := not SyncImageIndex;
end;

function TdxBarLargeButton.IsLargeImageIndexStored: Boolean;
begin
  Result := (ActionLink = nil) or not ActionLink.IsImageIndexLinked;
end;

procedure TdxBarLargeButton.SetAutoGrayScale(Value: Boolean);
begin
  if FAutoGrayScale <> Value then
  begin
    FAutoGrayScale := Value;
    Update;
  end;
end;

procedure TdxBarLargeButton.SetHeight(Value: Integer);
begin
  if FHeight <> Value then
  begin
    if Value < 0 then Exit;
    FHeight := Value;
    UpdateEx;
  end;
end;

procedure TdxBarLargeButton.SetHotGlyph(Value: TdxSmartGlyph);
begin
  FHotGlyph.Assign(Value);
end;

procedure TdxBarLargeButton.SetHotImageIndex(Value: Integer);
begin
  if FHotImageIndex <> Value then
  begin
    FHotImageIndex := Value;
    HotGlyphChanged;
  end;
end;

procedure TdxBarLargeButton.SetSyncImageIndex(Value: Boolean);
begin
  if IsLoading and not FInSyncImageIndex then
    FSetSyncImageIndex := True;
  if FSyncImageIndex <> Value then
  begin
    FSyncImageIndex := Value;
    if FSyncImageIndex then
      LargeGlyphChanged;
  end;
end;

procedure TdxBarLargeButton.OnHotGlyphChanged(Sender: TObject);
begin
  HotGlyphChanged;
end;

procedure TdxBarLargeButton.DefineProperties(Filer: TFiler);
begin
  inherited;
  Filer.DefineProperty('ImageIndex', ReadImageIndex, WriteImageIndex, IsImageIndexStored);
end;

procedure TdxBarLargeButton.Loaded;
begin
  inherited Loaded;
  FSetImageIndex := False;
  FSetLargeImageIndex := False;
  FSetSyncImageIndex := False;
end;

procedure TdxBarLargeButton.ReadImageIndex(Reader: TReader);
begin
  ImageIndex := Reader.ReadInteger;
end;

procedure TdxBarLargeButton.WriteImageIndex(Writer: TWriter);
begin
  Writer.WriteInteger(ImageIndex);
end;

function TdxBarLargeButton.GetActionImageIndex: Integer;
begin
  Result := LargeImageIndex;
end;

procedure TdxBarLargeButton.SetActionImageIndex(Value: Integer);
begin
  LargeImageIndex := Value;
end;

function TdxBarLargeButton.HasAccel(AItemLink: TdxBarItemLink): Boolean;
begin
  Result := inherited HasAccel(AItemLink) and
    (not (AItemLink.Owner.Owner is TdxBar) or FShowCaption);
end;

procedure TdxBarLargeButton.HotGlyphChanged;
var
  I: Integer;
{var
  AItemLink: TdxBarItemLink;}
begin
{  AItemLink := CurItemLink;
  if (AItemLink <> nil) and (AItemLink.Control <> nil) then
    TdxBarLargeButtonControl(AItemLink.Control).HotGlyphChanged;}
  for I := 0 to LinkCount - 1 do
    if Links[I].Control <> nil then
      TdxBarLargeButtonControl(Links[I].Control).HotGlyphChanged;
end;

function TdxBarLargeButton.IsHotImageLinked: Boolean;
begin
  Result := IsImageAssigned(BarManager.HotImages, FHotImageIndex);
end;

function TdxBarLargeButton.IsLargeImageLinked: Boolean;
begin
  Result := IsImageAssigned(BarManager.LargeImages, LargeImageIndex);
end;

procedure TdxBarLargeButton.LargeGlyphChanged;
begin
  if not FInSyncImageIndex and SyncImageIndex then
  begin
    if IsLoading and FSetImageIndex then
      SyncImageIndex := LargeImageIndex = ImageIndex
    else
    begin
      FInSyncImageIndex := True;
      try
        ImageIndex := LargeImageIndex;
      finally
        FInSyncImageIndex := False;
      end;
    end;
  end;
  inherited;
end;

procedure TdxBarLargeButton.SetImageIndex(Value: Integer);
begin
  if IsLoading and not FInSyncImageIndex then
    FSetImageIndex := True;
  inherited SetImageIndex(Value);
  if not FInSyncImageIndex then
  begin
    if IsLoading and (LargeImageIndex = -1) and (SyncImageIndex or not FSetSyncImageIndex) then
    begin
      FInSyncImageIndex := True;
      try
        LargeImageIndex := ImageIndex;
      finally
        FInSyncImageIndex := False;
      end;
    end
    else
//      if not FInSyncImageIndex then
      if not FSetSyncImageIndex then
        SyncImageIndex := False;
  end;
end;

procedure TdxBarLargeButton.SetLargeImageIndex(Value: Integer);
begin
  if IsLoading and not FInSyncImageIndex then
    FSetLargeImageIndex := True;
  inherited;
end;

function TdxBarLargeButton.UseHotImages: Boolean;
begin
  Result := HotImageIndex > -1;
end;

function TdxBarLargeButton.UseLargeImages: Boolean;
begin
  Result := LargeImageIndex > -1;
end;

procedure TdxBarLargeButton.WidthChanged;
begin
  UpdateEx;
end;

function TdxBarLargeButton.GetSupportedActions: TdxBarCustomizationActions;
begin
  Result := inherited GetSupportedActions - [caChangeButtonPaintStyle];
end;

{ TcxCustomBarEdit }

constructor TdxCustomBarEdit.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FWidth := 100;
end;

procedure TdxCustomBarEdit.ReadState(Reader: TReader);
begin
  if not FGlyphLoaded then // the same as in cxButtonEdit
  begin
    Glyph := nil;
    FGlyphLoaded := True;
  end;
  inherited;
end;

procedure TdxCustomBarEdit.DrawCustomizingImage(ACanvas: TCanvas;
  const ARect: TRect; AState: TOwnerDrawState);
begin
  dxBarCustomizingForm.PainterClass.DrawEdit(ACanvas, ARect, Self,
    odSelected in AState, False);
end;

procedure TdxCustomBarEdit.GetEditViewParams(out AViewParams: TcxViewParams);
begin
  GetViewParams(StyleEdit, AViewParams);
end;

class function TdxCustomBarEdit.GetStyleCount: Integer;
begin
  Result := 2;
end;

function TdxCustomBarEdit.HasAccel(AItemLink: TdxBarItemLink): Boolean;
begin
  Result := inherited HasAccel(AItemLink) and (FShowCaption or not (AItemLink.Owner.Owner is TdxBar));
end;

{ TdxBarEdit }

procedure TdxBarEdit.SetMaxLength(Value: Integer);
var
  I: Integer;
begin
  if Value <= 0 then
    Value := 0;
  if FMaxLength <> Value then
  begin
    FMaxLength := Value;
    for I := 0 to LinkCount - 1 do
      if Links[I].Control <> nil then
        (Links[I].Control as TdxBarEditControl).SetLimitText;
  end;
end;

procedure TdxBarEdit.DrawInterior(ABarEditControl: TdxBarEditControl; ACanvas: TCanvas;
  R: TRect; ItemLink: TdxBarItemLink);
begin
  ABarEditControl.Painter.EditDrawInterior(ABarEditControl, Self, ACanvas, R, ItemLink);
end;

{ TCustomdxBarCombo }

function TCustomdxBarCombo.GetDroppedDown: Boolean;
begin
  if CurItemLink = nil then
    Result := False
  else
    if CurItemLink.Control is TCustomdxBarComboControl then
      Result := TCustomdxBarComboControl(CurItemLink.Control).DroppedDown
    else
      Result := False;
end;

function TCustomdxBarCombo.GetShowEditor: Boolean;
begin
  Result := not EmptyWindow;
end;

procedure TCustomdxBarCombo.SetDroppedDown(Value: Boolean);
begin
  if (CurItemLink <> nil) and (CurItemLink.Control is TCustomdxBarComboControl) then
    TCustomdxBarComboControl(CurItemLink.Control).DroppedDown := Value;
end;

procedure TCustomdxBarCombo.SetShowEditor(Value: Boolean);
begin
  EmptyWindow := not Value;
end;

procedure TCustomdxBarCombo.AfterDropDown;
begin
end;

procedure TCustomdxBarCombo.CheckDropDownPoint(var X, Y: Integer);
var
  R: TRect;
  AControlWidth, AControlHeight, ADropDownWindowWidth, ADropDownWindowHeight: Integer;
begin
  if DropDownWindow > 0 then
  begin
    AControlWidth := cxRectWidth(CurItemLink.ItemRect);
    AControlHeight := cxRectHeight(CurItemLink.ItemRect);
    R := cxGetWindowRect(DropDownWindow);
    ADropDownWindowWidth := cxRectWidth(R);
    ADropDownWindowHeight := cxRectHeight(R);

    if CurItemLink.BarControl.UseRightToLeftAlignment then
      X := X - ADropDownWindowWidth;

    if CurItemLink.BarControl.UseRightToLeftAlignment then
      R := GetWorkArea(Point(X + ADropDownWindowWidth, Y))
    else
      R := GetWorkArea(Point(X, Y));
    if (CurItemLink.BarControl is TdxBarSubMenuControl) or CurItemLink.BarControl.IsRealVertical then
    begin
      if ((X + ADropDownWindowWidth) > R.Right) and ((X - AControlWidth - R.Left) > (R.Right - X)) then
        Dec(X, AControlWidth + ADropDownWindowWidth)
      else
        if (X < R.Left) and ((R.Right - (X + AControlWidth + ADropDownWindowWidth)) > (R.Left - X)) then
          Inc(X, AControlWidth + ADropDownWindowWidth);
      Y := Min(Y, R.Bottom - ADropDownWindowHeight);
    end
    else
    begin
      X := Min(X, R.Right - ADropDownWindowWidth);
      if ((Y + ADropDownWindowHeight) > R.Bottom) and ((Y - AControlHeight - R.Top) > (R.Bottom - Y)) then
        Dec(Y, AControlHeight + ADropDownWindowHeight);
    end;
    X := Max(X, R.Left);
    Y := Max(Y, R.Top);
  end;
end;

function TCustomdxBarCombo.CheckKeyForDropDownWindow(Key: Word;
  Shift: TShiftState): Boolean;
begin
  Result := (Key <> VK_ESCAPE) and (Key <> VK_RETURN) and (Key <> VK_TAB);
  if Assigned(FOnCheckKeyForDropDownWindow) then
    FOnCheckKeyForDropDownWindow(Self, Key, Shift, Result);
end;

procedure TCustomdxBarCombo.CloseUp;
begin
  if DropDownWindow <> 0 then
    ShowWindow(DropDownWindow, SW_HIDE);
  CallNotify(FOnCloseUp, Self);
end;

procedure TCustomdxBarCombo.DrawCustomizingImage(ACanvas: TCanvas;
  const ARect: TRect; AState: TOwnerDrawState);
begin
  dxBarCustomizingForm.PainterClass.DrawEdit(ACanvas, ARect, Self,
    odSelected in AState, True);
end;

procedure TCustomdxBarCombo.DropDown(X, Y: Integer);
begin
  CallNotify(FOnDropDown, Self);
  if DropDownWindow <> 0 then
  begin
    InitDropDownWindow;
    CheckDropDownPoint(X, Y);
    SetWindowPos(DropDownWindow, 0, X, Y, 0, 0, SWP_NOZORDER or SWP_NOSIZE or SWP_NOACTIVATE);
    dxSetZOrder(DropDownWindow, HWND_TOP, False, SWP_FRAMECHANGED or SWP_SHOWWINDOW);
    AfterDropDown;
  end;
end;

function TCustomdxBarCombo.GetDropDownWindow: HWND;
begin
  Result := 0;
  if Assigned(FOnGetDropDownWindow) then
    FOnGetDropDownWindow(Self, Result);
end;

procedure TCustomdxBarCombo.InitDropDownWindow;
begin
end;

procedure TCustomdxBarCombo.InternalInitDropDownWindow(ADropDownWindow: TWinControl);
var
  AEditControl: TdxBarCustomEditControl;
  AEditControlPainter: TdxBarPainter;
begin
  AEditControl := TdxBarCustomEditControl(CurItemLink.Control);
  AEditControlPainter := AEditControl.Painter;
  TControlAccess(ADropDownWindow).Font := AEditControl.EditFont;
  TControlAccess(ADropDownWindow).Color := AEditControlPainter.EditGetBkColor(AEditControl.DrawParams);
  TControlAccess(ADropDownWindow).Font.Color := AEditControlPainter.EditGetTextColor(AEditControl);
end;

{ TdxBarCustomCombo }

constructor TdxBarCustomCombo.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FDropDownCount := 8;
  FItemIndex := -1;
  FItems := TStringList.Create;
  TStringList(FItems).OnChange := ItemsChanged;
  FListBox := TdxBarDropDownListBox.Create(Self);
  with TdxBarDropDownListBox(FListBox) do
  begin
    FCombo := Self;
    OnDrawItem := ListBoxDrawItem;
    OnMeasureItem := ListBoxMeasureItem;
  end;
end;

destructor TdxBarCustomCombo.Destroy;
begin
  FreeAndNil(FListBox);
  FreeAndNil(FItems);
  inherited Destroy;
end;

function TdxBarCustomCombo.GetCurItemIndex: Integer;
begin
  if FocusedItemLink = nil then
    Result := ItemIndex
  else
    Result := TdxBarComboControl(FocusedItemLink.Control).LocalItemIndex;
end;

function TdxBarCustomCombo.GetItemsHeight(Index: Integer): Integer;
begin
  MeasureItem(Index, Result);
end;

procedure TdxBarCustomCombo.SetCurItemIndex(Value: Integer);
begin
  if FocusedItemLink = nil then
    ItemIndex := Value
  else
    TdxBarComboControl(FocusedItemLink.Control).LocalItemIndex := Value;
end;

procedure TdxBarCustomCombo.SetItemIndex(Value: Integer);
var
  AText: string;
begin
  if FItemIndex <> Value then
  begin
    FItemIndex := Value;
    if (FItemIndex < 0) or (FItemIndex > Items.Count - 1) then
      FItemIndex := -1;
    if FItemIndex = -1 then
      AText := ''
    else
      AText := Items[FItemIndex];
    if Text = AText then
    begin
      Update;
      Change;
      Update;
    end
    else
      Text := AText;
  end;
end;

procedure TdxBarCustomCombo.SetItems(Value: TStrings);
begin
  FItems.Assign(Value);
end;

procedure TdxBarCustomCombo.SetSorted(Value: Boolean);
begin
  if FSorted <> Value then
  begin
    FSorted := Value;
    TStringList(FItems).Sorted := FSorted;
    FItemIndex := FItems.IndexOf(Text);
  end;
end;

procedure TdxBarCustomCombo.CheckLocalPos;
var
  AText: string;
  AItemIndex: Integer;
begin
  if (CurItemLink = nil) or not (CurItemLink.Control is TdxBarComboControl) then
    Exit;
  AText := TdxBarComboControl(CurItemLink.Control).Text;
  AItemIndex := TdxBarComboControl(CurItemLink.Control).LocalItemIndex;
  if not ((0 <= AItemIndex) and (AItemIndex < Items.Count) and (Items[AItemIndex] = AText)) then
    AItemIndex := GetNearestItemIndex(AText);
  TdxBarComboControl(CurItemLink.Control).FLocalItemIndex := AItemIndex;
  if DroppedDown then
    if (AItemIndex > -1) and (AnsiCompareText(AText, Items[AItemIndex]) = 0) then
      ListBox.ItemIndex := AItemIndex
    else
    begin
      ListBox.ItemIndex := -1;
      ListBox.TopIndex := AItemIndex;
    end;
end;

procedure TdxBarCustomCombo.ItemsChanged(Sender: TObject);
begin
  if (ItemIndex > -1) and ((ItemIndex >= Items.Count) or (Items[ItemIndex] <> Text)) then
    ItemIndex := FindItemIndex(Text);
end;

procedure TdxBarCustomCombo.ListBoxDrawItem(Control: TWinControl; Index: Integer;
  Rect: TRect; State: TOwnerDrawState);
begin
  DrawItem(CurItemLink.Control.Painter, Index, Rect, State);
end;

procedure TdxBarCustomCombo.ListBoxMeasureItem(Control: TWinControl; Index: Integer;
  var Height: Integer);
begin
  MeasureItem(Index, Height);
end;

procedure TdxBarCustomCombo.AfterDropDown;
begin
  with TdxBarDropDownListBox(ListBox) do
    if LeftButtonPressed then
    begin
      SetCapture(Handle);
      FWaitForCapture := True;
    end
    else
      FWaitForCapture := False;
end;

function TdxBarCustomCombo.CheckKeyForDropDownWindow(Key: Word;
  Shift: TShiftState): Boolean;
begin
  Result := (Shift = []) and
    ((Key = VK_UP) or (Key = VK_DOWN) or (Key = VK_PRIOR) or (Key = VK_NEXT));
end;

procedure TdxBarCustomCombo.CloseUp;
begin
  inherited;
  FListBox.Parent := nil;
end;

procedure TdxBarCustomCombo.CurChange;
begin
  inherited;
  CheckLocalPos;
end;

procedure TdxBarCustomCombo.DrawInterior(ABarEditControl: TdxBarEditControl; ACanvas: TCanvas;
  R: TRect; ItemLink: TdxBarItemLink);
var
  AIndex: Integer;
begin
  FCanvas := ACanvas;
  try
    if FocusedItemLink = ItemLink then
      AIndex := TdxBarComboControl(CurItemLink.Control).LocalItemIndex
    else
      AIndex := ItemIndex;
    FInteriorIsDrawing := True;
    try
      DrawItem(ABarEditControl.Painter, AIndex, R, []);
    finally
      FInteriorIsDrawing := False;
    end;
  finally
    FCanvas := nil;
  end;
end;

procedure TdxBarCustomCombo.DrawItem(APainter: TdxBarPainter;
  AIndex: Integer; ARect: TRect; AState: TOwnerDrawState);
begin
  if Assigned(FOnDrawItem) then
    FOnDrawItem(Self, AIndex, ARect, AState)
  else
    APainter.CustomComboDrawItem(Self, Canvas, AIndex, ARect, AState, FInteriorIsDrawing);
  if odFocused in AState then DrawFocusRect(Canvas.Handle, ARect); // for hiding focus rect
end;

procedure TdxBarCustomCombo.DropDown(X, Y: Integer);
begin
  FListBox.Parent := CurItemLink.Control.Parent;  //BarManager.MainForm;
  inherited;
  CheckLocalPos;
end;

function TdxBarCustomCombo.GetCanvas: TCanvas;
begin
  if FCanvas <> nil then
    Result := FCanvas
  else
    Result := FListBox.Canvas;
end;

function TdxBarCustomCombo.GetDropDownWidth: Integer;
var
  AItemWidth: Integer;
  AScaleFactor: TdxScaleFactor;
  I: Integer;
begin
  if CurItemLink <> nil then
    AScaleFactor := CurItemLink.BarControl.ScaleFactor
  else
    AScaleFactor := BarManager.ScaleFactor;

  Result := DropDownWidth;
  if Result <= 0 then
  begin
    if CurItemLink <> nil then
      Result := cxRectWidth(TdxBarComboControl(CurItemLink.Control).GetEditRect) - 2 * AScaleFactor.Apply(2);
    if DropDownCount < Items.Count then
      Dec(Result, dxGetSystemMetrics(SM_CXVSCROLL, AScaleFactor));
    for I := 0 to Items.Count - 1 do
    begin
      MeasureItemWidth(I, AItemWidth);
      Result := Max(Result, AItemWidth);
    end;
  end;
  Inc(Result, 2 + AScaleFactor.Apply(2));
  if DropDownCount < Items.Count then
    Inc(Result, dxGetSystemMetrics(SM_CXVSCROLL, AScaleFactor));
end;

function TdxBarCustomCombo.GetDropDownWindow: HWND;
begin
  Result := inherited GetDropDownWindow;
  if Result = 0 then
    Result := FListBox.Handle;
end;

function TdxBarCustomCombo.GetNearestItemIndex(AText: string): Integer;
var
  AItem: string;
  FoundChars, I, J: Integer;
begin
  AText := AnsiUpperCase(AText);
  FoundChars := 0;
  Result := -1;
  for I := 0 to Items.Count - 1 do
  begin
    AItem := AnsiUpperCase(Items[I]);
    if Copy(AItem, 1, FoundChars) = Copy(AText, 1, FoundChars) then
      for J := FoundChars + 1 to Length(AText) do
        if (J <= Length(AItem)) and (AItem[J] = AText[J]) then
        begin
          FoundChars := J;
          Result := I;
          if J = Length(AText) then Exit;
        end
        else Break;
  end;
end;

function TdxBarCustomCombo.FindItemIndex(const AText: string): Integer;
var
  I: Integer;
begin
  for I := 0 to Items.Count - 1 do
  begin
    if Items[I] = AText then
      Exit(I);
  end;
  Result := -1;
end;

procedure TdxBarCustomCombo.InitDropDownWindow;
var
  AWidth, AHeight, I: Integer;
begin
  InternalInitDropDownWindow(FListBox);
  FListBox.Canvas.Font := TdxBarDropDownListBox(FListBox).Font;
  FListBox.Items.Assign(Items);

  AWidth := GetDropDownWidth;
  AHeight := 2 * TdxBarDropDownListBox(FListBox).Painter.DropDownListBoxBorderSize;
  for I := 0 to Min(Items.Count, DropDownCount) - 1 do
    Inc(AHeight, ItemsHeight[I]);
  SetWindowPos(FListBox.Handle, 0, 0, 0, AWidth, AHeight, SWP_NOZORDER or SWP_NOMOVE or SWP_NOACTIVATE);
end;

procedure TdxBarCustomCombo.MeasureItem(AIndex: Integer; var AHeight: Integer);
begin
  if ItemHeight <= 0 then
    AHeight := cxTextHeight(Canvas.Handle)
  else
    AHeight := ItemHeight;
  if Assigned(FOnMeasureItem) then
    FOnMeasureItem(Self, AIndex, AHeight);
end;

procedure TdxBarCustomCombo.MeasureItemWidth(AIndex: Integer; var AWidth: Integer);
begin
  AWidth := 1 + Canvas.TextWidth(Items[AIndex]) + 1;
end;

procedure TdxBarCustomCombo.SetText(Value: string);
begin
  if (FItemIndex = -1) or (Items[FItemIndex] <> Value) then
    FItemIndex := Items.IndexOf(Value);
  inherited;
end;

{ TCustomdxBarSubItem }

constructor TCustomdxBarSubItem.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FItemLinks := GetItemLinksClass.Create(BarManager, Self);
  FShowCaption := True;
end;

destructor TCustomdxBarSubItem.Destroy;
begin
  DetachingBar := -1;
  FreeAndNil(FItemLinks);
  inherited Destroy;
end;

function TCustomdxBarSubItem.GetDetachingBarIndex: Integer;
begin
  if FDetachingBar = nil then
    Result := -1
  else
    Result := FDetachingBar.Index;
end;

function TCustomdxBarSubItem.GetItemOptions: TdxBarItemOptions;
begin
  Result := FItemLinks.ItemOptions;
end;

procedure TCustomdxBarSubItem.SetBarSize(Value: Integer);
begin
  if Value < 0 then Value := 0;
  FBarSize := Value;
end;

procedure TCustomdxBarSubItem.SetDetachingBar(Value: Integer);
begin
  if (BarManager.Bars = nil) or
    (Value < -1) or (Value > BarManager.Bars.Count - 1) then Value := -1;
  if DetachingBar <> Value then
  begin
    cxRemoveFreeNotification(Self, FDetachingBar);
    if Value = -1 then
      FDetachingBar := nil
    else
      FDetachingBar := BarManager.Bars[Value];
    cxAddFreeNotification(Self, FDetachingBar);
  end;
end;

procedure TCustomdxBarSubItem.SetImages(AImages: TCustomImageList);
begin
  ItemLinks.Images := AImages;
end;

procedure TCustomdxBarSubItem.SetIsInternal(Value: Boolean);
begin
  if FIsInternal <> Value then
  begin
    FIsInternal := Value;
    FItemLinks.Internal := Value;
  end;
end;

procedure TCustomdxBarSubItem.SetItemLinks(Value: TdxBarItemLinks);
begin
  FItemLinks.Assign(Value);
end;

procedure TCustomdxBarSubItem.SetItemOptions(Value: TdxBarItemOptions);
begin
  FItemLinks.ItemOptions := Value;
end;

function TCustomdxBarSubItem.CanClicked: Boolean;
begin
  Result := False;
end;

procedure TCustomdxBarSubItem.ChangeScale(M, D: Integer);
begin
  inherited ChangeScale(M, D);
  FItemLinks.ChangeScale(M, D);
end;

procedure TCustomdxBarSubItem.DoCloseUp;
begin
  CallNotify(FOnCloseUp, Self);
end;

procedure TCustomdxBarSubItem.DoDetaching;
begin
  CallNotify(FOnDetaching, Self);
end;

function TCustomdxBarSubItem.GetItemLinksClass: TdxBarItemLinksClass;
begin
  Result := TdxBarSubMenuControlItemLinks;
end;

procedure TCustomdxBarSubItem.Loaded;
begin
  inherited Loaded;
  if ItemLinks <> nil then
    ItemLinks.LoadItemNames;
end;

procedure TCustomdxBarSubItem.DoPopup;
begin
  CallNotify(FOnPopup, Self);
end;

procedure TCustomdxBarSubItem.ObjectNotification(AOperation: TOperation; AObject: TObject);
begin
  inherited;
  if (AOperation = opRemove) and (AObject = FDetachingBar) then
    DetachingBar := -1;
end;

function TCustomdxBarSubItem.GetIniSection(const ABaseSection: string): string;
begin
  Result := ABaseSection + 'SubItem_' + Name;
end;

procedure TCustomdxBarSubItem.LoadFromIni(ASource: TCustomIniFile; const ABaseSection: string; AStoringKind: TdxBarStoringKind);
var
  ASection: string;
begin
  inherited LoadFromIni(ASource, ABaseSection, AStoringKind);
  if not IsPredefined then
  begin
    ASection := GetIniSection(ABaseSection);
    Caption := ASource.ReadString(ASection, 'Caption', Caption);
    Category := ASource.ReadInteger(ASection, 'Category', Category);
    Description := ASource.ReadString(ASection, 'Description', Description);
    Enabled := ASource.ReadBool(ASection, 'Enabled', Enabled);
    ImageIndex := ASource.ReadInteger(ASection, 'ImageIndex', ImageIndex);
    LargeImageIndex := ASource.ReadInteger(ASection, 'LargeImageIndex', LargeImageIndex);
    MergeKind := TdxBarItemMergeKind(ASource.ReadInteger(ASection, 'MergeKind', Integer(MergeKind)));
    MergeOrder := ASource.ReadInteger(ASection, 'MergeOrder', MergeOrder);
    ShowCaption := ASource.ReadBool(ASection, 'ShowCaption', ShowCaption);
    Visible := TdxBarItemVisible(ASource.ReadInteger(ASection, 'Visible', Integer(Visible)));
  end;
end;

procedure TCustomdxBarSubItem.SaveToIni(ADestination: TCustomIniFile; const ABaseSection: string; AStoringKind: TdxBarStoringKind);
var
  ASection: string;
begin
  inherited SaveToIni(ADestination, ABaseSection, AStoringKind);
  if not IsPredefined then
  begin
    ASection := GetIniSection(ABaseSection);
    ADestination.WriteString(ASection, 'ClassName', ClassName);
    ADestination.WriteString(ASection, 'Name', Name);
    ADestination.WriteString(ASection, 'Caption', Caption);
    ADestination.WriteInteger(ASection, 'Category', Category);
    ADestination.WriteString(ASection, 'Description', Description);
    ADestination.WriteBool(ASection, 'Enabled', Enabled);
    ADestination.WriteInteger(ASection, 'ImageIndex', ImageIndex);
    ADestination.WriteInteger(ASection, 'LargeImageIndex', LargeImageIndex);
    ADestination.WriteInteger(ASection, 'MergeKind', Integer(MergeKind));
    ADestination.WriteInteger(ASection, 'MergeOrder', MergeOrder);
    ADestination.WriteBool(ASection, 'ShowCaption', ShowCaption);
    ADestination.WriteInteger(ASection, 'Visible', Integer(Visible));
  end;
end;

// IdxBarLinksOwner
function TCustomdxBarSubItem.CanContainItem(AItem: TdxBarItem; out AErrorText: string): Boolean;
begin
  Result := AItem.CanBePlacedOn(pkSubItemOrPopupMenu, nil, AErrorText);
  if Result then
  begin
    Result := (GetOwnedLinks(AItem) = nil) or not GetOwnedLinks(AItem).IsReferencedBy(Self);
    if not Result then
      AErrorText := cxGetResourceString(@dxSBAR_RECURSIVEMENUS);
  end;
end;

function TCustomdxBarSubItem.CreateBarControl: TCustomdxBarControl;
begin
  if CurItemLink <> nil then
  begin
    Result := TdxBarSubMenuControl.Create(CurItemLink.BarManager);
    TdxBarSubMenuControl(Result).FParentWnd := CurItemLink.BarControl.Handle;
  end
  else
    Result := TdxBarSubMenuControl.Create(BarManager);
end;

function TCustomdxBarSubItem.GetItemLinks: TdxBarItemLinks;
begin
  Result := FItemLinks;
end;

function TCustomdxBarSubItem.GetImages: TCustomImageList;
begin
  Result := ItemLinks.Images;
end;

function TCustomdxBarSubItem.IsLoading: Boolean;
begin
  Result := BarManager.IsLoading;
end;

// IdxBarSelectableItem
function TCustomdxBarSubItem.GetSupportedActions: TdxBarCustomizationActions;
begin
  Result := inherited GetSupportedActions;
  if BarManager.Designing then
    Include(Result, caChangeButtonGroup);
end;

// IdxBarSubMenuOwner
function TCustomdxBarSubItem.GetBarSize: Integer;
begin
  Result := FBarSize;
end;

procedure TCustomdxBarSubItem.DoPaintBar(Canvas: TCanvas; const R: TRect);
begin
  if Assigned(FOnPaintBar) then FOnPaintBar(Self, Canvas, R);
end;

function TCustomdxBarSubItem.GetDetachingBar: TdxBar;
begin
  Result := FDetachingBar;
end;

procedure TCustomdxBarSubItem.DropDown(AByMouse: Boolean = False);
begin
  DropDownButtonLikeItem(Self, AByMouse);
end;

{ TdxBarSubItem }

constructor TdxBarSubItem.Create(AOwner: TComponent);
begin
  inherited;
  FAllowCustomizing := True;
end;

class function TdxBarSubItem.GetNewCaption: string;
begin
  Result := dxSBAR_NEWSUBITEMCAPTION;
end;

function TdxBarSubItem.InternalCanMergeWith(AItem: TdxBarItem): Boolean;
begin
  Result := AItem is TdxBarSubItem;
end;

{ TCustomdxBarContainerItem }

function TCustomdxBarContainerItem.AddListedItemLink(
  AItemLinks: TdxBarItemLinks; ALinkData: TObject; AIndex: Integer;
  AItem: TdxBarItem): TdxBarItemLink;
begin
  Result := AItemLinks.Add;
  Result.FOriginalItemLink := TdxBarContainerLinkData(ALinkData).FItemLink;
  Result.Index := AIndex;
  Result.Synchronize(TdxBarContainerLinkData(ALinkData).FItemLink);
  Result.Item := AItem;

  TdxBarContainerLinkData(ALinkData).FExpandedItems.Add(Result);
end;

procedure TCustomdxBarContainerItem.AddListedItemLinks(
  AItemLinks: TdxBarItemLinks; ALinkData: TObject; AIndex: Integer);
begin
  FIsListPopulation := True;
  try
    PrepareListedItemLinks;
    PopulateListedItemLinks(AItemLinks, ALinkData, AIndex);
  finally
    FIsListPopulation := False;
  end;
end;

procedure TCustomdxBarContainerItem.DeleteListedItemLinks(ALinkData: TObject);
begin
  Dec(FItemsPopulationCount);
  TdxBarContainerLinkData(ALinkData).FExpandedItems.Clear;
end;

procedure TCustomdxBarContainerItem.ClearItemList;
begin
  FNeedClearItemList := False;
end;

function TCustomdxBarContainerItem.HideWhenRun: Boolean;
begin
  Result := True;
end;

function TCustomdxBarContainerItem.InternalActuallyVisible: Boolean;
begin
  Result := Assigned(FOnGetData);
end;

function TCustomdxBarContainerItem.AllowProcessItemsChanged(AItemLinks: TObject): Boolean;
begin
  Result := not FIsListPopulation and not ResettingToolbar and not IsDesigning;
end;

procedure TCustomdxBarContainerItem.ItemsChanged(AItemLinks: TObject);
begin
  if AllowProcessItemsChanged(AItemLinks) then
    VisibleChanged;
end;

procedure TCustomdxBarContainerItem.NeedClearItemList;
begin
  FNeedClearItemList := True;
end;

procedure TCustomdxBarContainerItem.PopulateListedItemLinks(
  AItemLinks: TdxBarItemLinks; ALinkData: TObject; AIndex: Integer);
begin
end;

procedure TCustomdxBarContainerItem.PrepareListedItemLinks;
begin
  if FNeedClearItemList then
    ClearItemList;
  if (FItemsPopulationCount = 0) and Assigned(FOnGetData) then
    FOnGetData(Self);
  Inc(FItemsPopulationCount);
end;

{ TdxBarListItem }

constructor TdxBarListItem.Create(AOwner: TComponent);
begin
  inherited;
  FItems := TStringList.Create;
  TStringList(FItems).OnChange := ItemsChanged;
  FItemIndex := -1;
  FItemList := TComponentList.Create;
  FShowNumbers := True;
end;

destructor TdxBarListItem.Destroy;
begin
  FreeAndNil(FItemList);
  FreeAndNil(FItems);
  inherited;
end;

procedure TdxBarListItem.Assign(Source: TPersistent);
begin
  if Source is TdxBarListItem then
  begin
    Items := TdxBarListItem(Source).Items;
    ShowCheck := TdxBarListItem(Source).ShowCheck;
    ShowNumbers := TdxBarListItem(Source).ShowNumbers;
  end;
  inherited;
end;

procedure TdxBarListItem.PopulateListedItemLinks(
  AItemLinks: TdxBarItemLinks; ALinkData: TObject; AIndex: Integer);
var
  ABeginGroup: Boolean;
  ACreateItems: Boolean;
  ACurIndex, I: Integer;
begin
  inherited PopulateListedItemLinks(AItemLinks, ALinkData, AIndex);
  ABeginGroup := True;
  ACreateItems := FItemList.Count = 0;
  ACurIndex := 0;
  for I := 0 to Items.Count - 1 do
  begin
    if Items[I] <> ListItemSeparator then
    begin
      if ACreateItems then
        CreateItem(I, ACurIndex);
      AddListedItemLink(AItemLinks, ALinkData, AIndex + ACurIndex,
        TdxBarItem(FItemList[ACurIndex])).BeginGroup := ABeginGroup;
      ABeginGroup := False;
      Inc(ACurIndex);
    end
    else
      ABeginGroup := True;
  end;
end;

function TdxBarListItem.GetDataIndex: Integer;
var
  I: Integer;
begin
  Result := -1;
  if (0 <= FItemIndex) and (FItemIndex < Items.Count) then
    for I := 0 to FItemIndex do
      if Items[I] <> ListItemSeparator then Inc(Result);
end;

function TdxBarListItem.GetItemList: TList;
begin
  Result := FItemList;
end;

procedure TdxBarListItem.SetDataIndex(Value: Integer);
var
  J, I: Integer;
begin
  if Items.Count = 0 then
    I := -1
  else
  begin
    J := -1;
    for I := 0 to Items.Count - 1 do
    begin
      if Items[I] <> ListItemSeparator then
        Inc(J);
      if J = Value then Break;
    end;
  end;
  ItemIndex := I;
end;

procedure TdxBarListItem.SetItems(Value: TStrings);
begin
  FItems.Assign(Value);
end;

procedure TdxBarListItem.ClickItem(Sender: TObject);
begin
  FItemIndex := TComponent(Sender).Tag;
  DirectClick;
end;

procedure TdxBarListItem.ClearItemList;

  function IsAnotherInstanceOpen: Boolean;
  begin
    Result := (FItemList.Count > 0) and (TdxBarItem(FItemList.First).LinkCount > 0);
  end;

begin
  if not IsAnotherInstanceOpen then
    FItemList.Clear;
  inherited ClearItemList;
end;

function TdxBarListItem.CreateItem(AIndex, ACurIndex: Integer): TdxBarButton;
begin
  Result := GetItemClass.Create(BarManager.Owner);
  BarDesignController.AddInternalItem(Result, FItemList);
  Result.Action := Action;
  if ShowCheck and (AIndex{ACurIndex} = FItemIndex) then
  begin
    Result.ButtonStyle := bsChecked;
    Result.Down := True;
  end;
  Result.FCaption := GetDisplayNumber(ACurIndex) + GetDisplayText(AIndex);
  Result.Hint := GetDisplayHint(Items[AIndex]);
  Result.Tag := AIndex;  //ACurIndex;
  Result.OnClick := ClickItem;
  Result.Enabled := Enabled;
end;

function TdxBarListItem.GetItemClass: TdxBarButtonClass;
begin
  Result := TdxBarButton;
end;

function TdxBarListItem.GetDisplayHint(const AText: string): string;
begin
  Result := '';
end;

function TdxBarListItem.GetDisplayNumber(AIndex: Integer): string;
begin
  if ShowNumbers then
  begin
    if AIndex < 9 then
      Result := IntToStr(AIndex + 1)
    else
      Result := Chr(Ord('A') + AIndex - 9);
    Result := '&' + Result + ' ';
  end
  else
    Result := '';
end;

function TdxBarListItem.GetDisplayText(const AText: string): string;
begin
  Result := AText;
end;

function TdxBarListItem.GetDisplayText(AItemIndex: Integer): string;
begin
  Result := GetDisplayText(Items[AItemIndex]);
end;

function TdxBarListItem.InternalActuallyVisible: Boolean;
begin
  Result := inherited InternalActuallyVisible or (Items.Count > 0);
end;

procedure TdxBarListItem.DirectClick;
begin
  if CurItemLink = nil then
    inherited;
end;

{ TdxBarContainerItem }

constructor TdxBarContainerItem.Create(AOwner: TComponent);
begin
  inherited;
  FItemLinks.OnChange := ItemsChanged;
end;

procedure TdxBarContainerItem.PopulateListedItemLinks(
  AItemLinks: TdxBarItemLinks; ALinkData: TObject; AIndex: Integer);
var
  I: Integer;
  AIsBeginGroup: Boolean;
  ALink: TdxBarItemLink;
begin
  inherited;
  if AItemLinks = ItemLinks then Exit;
  AItemLinks.BeginUpdate;
  try
    for I := 0 to FItemLinks.CanVisibleItemCount - 1 do
    begin
      AIsBeginGroup := (I = 0) and HideWhenRun;
      ALink := AddListedItemLink(AItemLinks, ALinkData, AIndex + I, FItemLinks.CanVisibleItems[I].Item);
      ALink.Assign(FItemLinks.CanVisibleItems[I]);
      ALink.BeginGroup := AIsBeginGroup;
    end;
  finally
    AItemLinks.EndUpdate;
  end;
end;

function TdxBarContainerItem.InternalActuallyVisible: Boolean;
begin
  Result := inherited InternalActuallyVisible or IsItemsExist;
end;

function TdxBarContainerItem.InternalCanMergeWith(AItem: TdxBarItem): Boolean;
begin
  Result := AItem is TdxBarContainerItem;
end;

function TdxBarContainerItem.AllowProcessItemsChanged(AItemLinks: TObject): Boolean;
begin
  Result := inherited AllowProcessItemsChanged(AItemLinks) and
    (((AItemLinks as TdxBarItemLinks).BarControl = nil) or ([bsCreatingControls, bsDestroyingControls] * TdxBarItemLinks(AItemLinks).BarControl.FState = []));
end;

function TdxBarContainerItem.IsItemsExist: Boolean;
var
  I: Integer;
  AItemExists: Boolean;
begin
  Result := ItemLinks.Count > 0;
  if Result then // check empty items
  begin
    AItemExists := False;
    for I := 0 to ItemLinks.Count - 1 do
      if ItemLinks[I].Item <> nil then
      begin
        AItemExists := True;
        Break;
      end;
    if AItemExists then
    begin
      Result := False;
      for I := 0 to ItemLinks.Count - 1 do
        if (ItemLinks[I].Item <> nil) and
          ItemLinks[I].Item.ActuallyVisible then
        begin
          Result := True;
          Break;
        end;
    end;
  end;
end;

{ TdxBarSubMenuBackButton }

constructor TdxBarSubMenuBackButton.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  CloseSubMenuOnClick := False;
  KeyTip := #27;
end;

{ TdxBarItemControlDrawParams }

constructor TdxBarItemControlDrawParams.Create(ABarItemControl: TdxBarItemControl);
begin
  inherited Create;
  FBarItemControl := ABarItemControl;
end;

function TdxBarItemControlDrawParams.HasIcon: Boolean;
begin
  Result := (cpIcon in ViewStructure) and BarItemControl.IconAssigned(ViewSize);
end;

procedure TdxBarItemControlDrawParams.ResetCachedValues;
begin
  FCaptionRect := cxNullRect;
end;

function TdxBarItemControlDrawParams.GetScaleFactor: TdxScaleFactor;
begin
  if FBarItemControl <> nil then
    Result := FBarItemControl.ScaleFactor
  else
    Result := dxSystemScaleFactor;
end;

function TdxBarItemControlDrawParams.GetUseRightToLeftAlignment: Boolean;
begin
  if BarItemControl <> nil then
    Result := BarItemControl.UseRightToLeftAlignment
  else
    if Canvas <> nil then
      Result := Canvas.UseRightToLeftAlignment
    else
      Result := False;
end;

procedure TdxBarItemControlDrawParams.SetViewSize(Value: TdxBarItemControlViewSize);
begin
  if FViewSize <> Value then
  begin
    FViewSize := Value;
    if FBarItemControl <> nil then
      FBarItemControl.ResetCachedValues(False);
  end;
end;

{ TdxBarEditLikeControlDrawParams }

function TdxBarEditLikeControlDrawParams.GetBarEditControl: TdxBarEditControl;
begin
  Result := TdxBarEditControl(BarItemControl);
end;

{ TdxBarStaticLikeControlDrawParams }

function TdxBarStaticLikeControlDrawParams.GetBarStaticControl: TdxBarCustomStaticControl;
begin
  Result := TdxBarCustomStaticControl(BarItemControl);
end;

{ TdxBarItemControlViewInfo }

constructor TdxBarItemControlViewInfo.Create(AControl: TdxBarItemControl);
begin
  inherited Create(nil);
  FControl := AControl;
  FAllowedViewLevels := Control.ViewLevels;
  FMinPossibleViewLevel := GetMinViewLevel(Control.PossibleViewLevels);
  FViewLevelForButtonGroup := GetMinViewLevel(FAllowedViewLevels);
  if FViewLevelForButtonGroup = ivlLargeIconWithText then
    FViewLevelForButtonGroup := FMinPossibleViewLevel;
  ResetCachedValues;
end;

destructor TdxBarItemControlViewInfo.Destroy;
begin
  if not Control.Parent.IsDestroying then
    Control.Parent.ViewInfo.RemoveItemControlViewInfo(Self);
  inherited Destroy;
end;

procedure TdxBarItemControlViewInfo.ResetCachedValues;
var
  AViewLevel: TdxBarItemRealViewLevel;
begin
  for AViewLevel := Low(TdxBarItemRealViewLevel) to High(TdxBarItemRealViewLevel) do
    FViewLevelInfos[AViewLevel].Calculated := False;
end;

// IdxBarItemControlViewInfo
procedure TdxBarItemControlViewInfo.CalculateFinalize;
begin
  BoundsCalculated;
end;

function TdxBarItemControlViewInfo.GetAlign: TdxBarItemAlign;
begin
  Result := Control.Item.Align;
end;

function TdxBarItemControlViewInfo.GetAllowedViewLevels: TdxBarItemViewLevels;
begin
  Result := FAllowedViewLevels;
end;

function TdxBarItemControlViewInfo.GetBounds: TRect;
begin
  Result := FBounds;
end;

function TdxBarItemControlViewInfo.GetColumnRowCount: Integer;
begin
  Result := FColumnRowCount;
end;

function TdxBarItemControlViewInfo.GetDistributed: Boolean;
begin
  Result := Control.ItemLink.Distributed;
end;

function TdxBarItemControlViewInfo.GetPosition: TdxBarItemPosition;
begin
  Result := Control.ItemLink.Position;
end;

function TdxBarItemControlViewInfo.GetPositionInButtonGroup: TdxBarButtonGroupPosition;
begin
  if Control.CanBePartOfButtonGroup then
    Result := Control.ItemLink.ButtonGroup
  else
    Result := bgpNone;
end;

function TdxBarItemControlViewInfo.GetRealPositionInButtonGroup: TdxBarButtonGroupRealPosition;
begin
  Result := FRealPositionInButtonGroup;
end;

function TdxBarItemControlViewInfo.GetRow: Integer;
begin
  Result := FRow;
end;

function TdxBarItemControlViewInfo.GetViewLevel: TdxBarItemViewLevel;
begin
  Result := FViewLevel;
end;

function TdxBarItemControlViewInfo.GetViewLevelForButtonGroup: TdxBarItemRealViewLevel;
begin
  Result := FViewLevelForButtonGroup;
end;

function TdxBarItemControlViewInfo.GetWidth(
  AViewLevel: TdxBarItemRealViewLevel): Integer;
var
  AMultiColumnItemControlViewInfo: IdxBarMultiColumnItemControlViewInfo;
begin
  if IsMultiColumnItemControl(True, AMultiColumnItemControlViewInfo) then
  begin
    Result := AMultiColumnItemControlViewInfo.GetWidthForColumnCount(AMultiColumnItemControlViewInfo.GetColumnCount);
    Exit;
  end;
  if not (AViewLevel in GetAllowedViewLevels) then
    raise EdxException.Create('The level is not allowed');
  if not FViewLevelInfos[AViewLevel].Calculated then
  begin
    FViewLevelInfos[AViewLevel].Width := Control.GetWidthByViewLevel(AViewLevel);
    FViewLevelInfos[AViewLevel].Calculated := True;
  end;
  Result := FViewLevelInfos[AViewLevel].Width;
end;

function TdxBarItemControlViewInfo.HasSeparator: Boolean;
begin
  Result := Control.ItemLink.BeginGroup; // TODO check
end;

function TdxBarItemControlViewInfo.IsPrimaryForDistribution: Boolean;
begin
  Result := Control.ItemLink.IsPrimaryForDistribution;
end;

function TdxBarItemControlViewInfo.IsMultiColumnItemControl(ACheckCollapsed: Boolean;
  out AIMultiColumnItemControlViewInfo: IdxBarMultiColumnItemControlViewInfo): Boolean;
begin
  Result := Supports(TObject(Self), IdxBarMultiColumnItemControlViewInfo,
    AIMultiColumnItemControlViewInfo) and (not ACheckCollapsed or not AIMultiColumnItemControlViewInfo.GetCollapsed);
end;

procedure TdxBarItemControlViewInfo.SetBounds(const Value: TRect);
begin
  FBounds := Value;
end;

procedure TdxBarItemControlViewInfo.SetColumnRowCount(Value: Integer);
begin
  FColumnRowCount := Value;
end;

procedure TdxBarItemControlViewInfo.SetDistributed(Value: Boolean);
begin
  Control.ItemLink.SetDistributedByPrimaryLink(Value);
end;

procedure TdxBarItemControlViewInfo.SetRealPositionInButtonGroup(Value: TdxBarButtonGroupRealPosition);
begin
  FRealPositionInButtonGroup := Value;
end;

procedure TdxBarItemControlViewInfo.SetRow(Value: Integer);
begin
  FRow := Value;
end;

procedure TdxBarItemControlViewInfo.SetViewLevel(Value: TdxBarItemViewLevel);
begin
  if not (Value in GetAllowedViewLevels) then
    raise EdxException.Create('The level is not allowed');
  if FViewLevel <> Value then
  begin
    FViewLevel := Value;
    CallNotify(Control.ItemLink.OnViewLevelChanged, Control.ItemLink);
  end;
end;

procedure TdxBarItemControlViewInfo.BoundsCalculated;
begin
end;

{ TdxBarCachedImage }

constructor TdxBarCachedImage.Create;
begin
  inherited;
  FCachedImage := TdxGpImage.Create;
end;

destructor TdxBarCachedImage.Destroy;
begin
  FreeAndNil(FCachedImage);
  inherited;
end;

procedure TdxBarCachedImage.Draw(DC: HDC; const ARect: TRect);
begin
  FCachedImage.StretchDraw(DC, ARect);
end;

procedure TdxBarCachedImage.Reset;
begin
  FCachedImageID.Reset;
end;

procedure TdxBarCachedImage.Update(const ARect: TRect; AGlyph: TGraphic;
  AImages: TCustomImageList; AImageIndex: Integer; ADrawMode: TcxImageDrawMode; ATransparentColor: TColor;
  ASmoothImage, AUseLeftBottomPixelAsTransparent: Boolean; AColorPalette: IdxColorPalette = nil);
var
  AImageID: TdxDrawImageCacheID;
begin
  AImageID := TdxDrawImageCacheID.Create(AGlyph, AImages, AImageIndex, ADrawMode,
    AUseLeftBottomPixelAsTransparent, ASmoothImage, ATransparentColor, AColorPalette);
  if not (cxSizeIsEqual(FCachedImage.ClientRect, ARect) and FCachedImageID.IsEqual(AImageID)) then
  begin
    TdxImageListPaintCache.PrepareImage(FCachedImage, cxSize(ARect), AImageID, AColorPalette);
    FCachedImageID := AImageID;
  end;
end;

{ TdxBarItemControl }

constructor TdxBarItemControl.Create(AItemLink: TdxBarItemLink);
begin
  inherited Create;

  FItemLink := AItemLink;
  FParent := AItemLink.BarControl;
  FScaleFactor := FParent.ScaleFactor;
  FDrawParams := GetDrawParamsClass.Create(Self);
  FGlyphCache := TdxBarCachedImage.Create;
  FIconAssigned := bDefault;

  FViewInfo := GetViewInfoClass.Create(Self);
  CalcDrawingConsts;

  FHotPartIndex := icpNone;
  CalcDrawParams;
  ViewInfo.FViewLevel := Parent.GetItemControlDefaultViewLevel(Self);
end;

destructor TdxBarItemControl.Destroy;

  procedure ClearReferences;
  begin
    if (BarManager <> nil) and (BarManager.FSelectedItem = Self) then
      BarManager.InternalSetSelectedItem(nil);
    if FItemLink <> nil then FItemLink.FControl := nil;
    if (FParent <> nil) and not BarManager.IsDestroying and
      (FParent.SelectedControl = Self) and not BarManager.IsCustomizing then
      if (FItemLink <> nil) and (FItemLink.VisibleIndex <> -1) then
        FParent.SetMouseSelectedItem(nil)
      else
        FParent.SelectedLink := nil;
    if BarManager.FHintObject = Self then
      BarManager.FHintObject := nil;
  end;

begin
  BarAccessibilityHelperOwnerObjectDestroyed(FIAccessibilityHelper);
  if Fader <> nil then
    Fader.Remove(Self);


  ClearReferences;
  DeleteGDIObject(FBkBrush);
  cxClearObjectLinks(Self);
  FreeAndNil(FViewInfo);
  FreeAndNil(FGlyphCache);
  FreeAndNil(FDrawParams);
  FParent := nil;
  inherited Destroy;
end;

procedure TdxBarItemControl.BeforeDestruction;
begin
  FIsDestroying := True;
  inherited;
end;

function TdxBarItemControl.FadingDrawSelected: Boolean;
begin
  Result := DrawParams.DrawSelected;
end;

function TdxBarItemControl.FindPartAtPos(APoint: TPoint): Integer;
var
  I: Integer;
begin
  if not PtInRect(ItemBounds, APoint) then
    Result := icpNone
  else
  begin
    Result := icpNonClient;
    for I := Low(FParts) to High(FParts) do
      if PtInRect(FParts[I], APoint) then
      begin
        Result := I;
        Break;
      end;
  end;
end;

function TdxBarItemControl.GetAlign: TdxBarItemAlign;
begin
  Result := Item.Align;
  if (Result <> iaLeft) and not Parent.CanAlignControl(Self) then
    Result := iaLeft;
end;

function TdxBarItemControl.GetBarManager: TdxBarManager;
begin
  if FItemLink <> nil then
    Result := FItemLink.BarManager
  else
    Result := nil;
end;

function TdxBarItemControl.GetBkBrush: HBRUSH;
begin
  Result := FBkBrush;
  if Result = 0 then
    Result := Parent.BkBrush;
end;

function TdxBarItemControl.GetCanvas: TcxCanvas;
begin
  if FActiveCanvas <> nil then
    Result := FActiveCanvas
  else
    Result := Parent.Canvas;
end;

function TdxBarItemControl.GetFlat: Boolean;
begin
  // TODO: obsolete
  Result := Parent.Flat;
end;

function TdxBarItemControl.GetIAccessibilityHelper: IdxBarAccessibilityHelper;
begin
  if FIAccessibilityHelper = nil then
    FIAccessibilityHelper := GetAccessibilityHelperClass.Create(Self);
  Result := FIAccessibilityHelper;
end;

function TdxBarItemControl.GetIsFadingAvailable: Boolean;
begin
  Result := ((Parent = nil) or Parent.IsFadingAvailable) and
    (Fader <> nil) and Painter.IsFadingAvailable;
end;

function TdxBarItemControl.GetIsSelected: Boolean;
begin
  Result := (FParent <> nil) and (FParent.SelectedControl = Self) and
    (Enabled or not FSelectedByMouse or (PainterClass = TdxBarXPPainter));
end;

function TdxBarItemControl.GetItem: TdxBarItem;
begin
  Result := GetItemByLink(FItemLink);
end;

function TdxBarItemControl.GetItemBarManager: TdxBarManager;
begin
  Result := Item.BarManager;
end;

function TdxBarItemControl.GetItemBounds: TRect;
begin
  Result := ItemLink.ItemRect;
end;

function TdxBarItemControl.GetPainterClass: TdxBarPainterClass;
begin
  Result := TdxBarPainterClass(Painter.ClassType);
end;

function TdxBarItemControl.GetRealSize: TSize;
begin
  GetRealSize(@Result.cx, @Result.cy);
end;

procedure TdxBarItemControl.GetRealSize(AWidth, AHeight: PInteger);
var
  ASavedFont: TdxBarSavedFont;
begin
  PrepareCanvasFont(0, Item.Style, ASavedFont);
  try
    CalcDrawParams(False);

    if AWidth <> nil then
    begin
      if (Align = iaClient) and not Parent.IsRealVertical and (bboExtendItemWhenAlignedToClient in Parent.BehaviorOptions) then
        AWidth^ := MinWidth
      else
        AWidth^ := GetDefaultWidth;
    end;

    if AHeight <> nil then
    begin
      if (Align = iaClient) and Parent.IsRealVertical then
      begin
        if Parent.IsVertical then
          AHeight^ := MinWidth
        else
          AHeight^ := MinHeight;
      end
      else
        AHeight^ := GetDefaultHeight;
    end;
  finally
    RestoreCanvasFont(ASavedFont);
  end;
end;

function TdxBarItemControl.GetRealHeight: Integer;
begin
  GetRealSize(nil, @Result);
end;

function TdxBarItemControl.GetRealWidth: Integer;
begin
  GetRealSize(@Result, nil);
end;

function TdxBarItemControl.GetShowDescription: Boolean;
begin
  Result := (ItemLink.Owner.ItemSize = misLarge) and ItemLink.Owner.ItemShowDescriptions;
end;

function TdxBarItemControl.GetSubMenuParent: TdxBarSubMenuControl;
begin
  Result := Parent as TdxBarSubMenuControl;
end;

function TdxBarItemControl.GetUnclickAfterDoing: Boolean;
begin
  if Item is TdxBarCustomButton then
    Result := Item.UnclickAfterDoing
  else
    Result := True;
end;

function TdxBarItemControl.InternalGetPossibleViewLevels: TdxBarItemViewLevels;
begin
  Result := GetPossibleViewLevels;
  if Result = [] then
    raise EdxException.Create(ClassName + '.GetPossibleViewLevels = []');
end;

procedure TdxBarItemControl.SetHotPartIndex(AValue: Integer);
begin
  if not Enabled then
    AValue := icpNone;
  if HotPartIndex <> AValue then
  begin
    FHotPartIndex := AValue;
    HotPartChanged;
  end;
end;

procedure TdxBarItemControl.SetPressed(Value: Boolean);
begin
  if FPressed <> Value then
  begin
    FPressed := Value;
    PressedChanged;
  end;
end;

//IdxFadingObject
function TdxBarItemControl.CanFade: Boolean;
begin
  Result := False;
end;

procedure TdxBarItemControl.DrawFadeImage;
begin
  Repaint;
end;

function TdxBarItemControl.GetFadingOptions: TdxFadingOptions;
begin
  Result := Painter.GetBarItemControlFadingOptions;
end;

function TdxBarItemControl.GetScaleFactor: TdxScaleFactor;
begin
  Result := FScaleFactor;
end;

procedure TdxBarItemControl.GetFadingImages(out AFadeOutImage, AFadeInImage: TcxBitmap);
begin

end;

function TdxBarItemControl.GetFader: TdxFader;
begin
  Result := Parent.GetFader;
end;

// IdxBarHintKeeper
function TdxBarItemControl.DoHint(var ANeedDeactivate: Boolean; out AHintText: string; out AShortCut: string): Boolean;
var
  Action: TBasicAction;
begin
  Result := False;
  ANeedDeactivate := False;
  AShortCut := '';
  AHintText := '';

  if (Parent <> nil) and Parent.CanShowHint and (Parent.ItemAtMousePos = Self) then
  begin
    GetHintParams(AHintText, AShortCut);
    Action := Item.Action;
    if Action is TCustomAction then
      if not TCustomAction(Action).DoHint(AHintText) then
      begin
        ANeedDeactivate := True;
        Exit;
      end;
    Result := True;
  end;
end;

function TdxBarItemControl.CreateHintViewInfo(const AHintText, AShortCut: string): TdxBarCustomHintViewInfo;
begin
  Result := Parent.CreateHintViewInfo(AHintText, AShortCut, GetScreenTip);
end;

function TdxBarItemControl.GetEnabled: Boolean;
begin
  Result := Item.Enabled and Parent.Enabled;
end;

function TdxBarItemControl.GetHintPosition(const ACursorPos: TPoint; AHeight: Integer): TPoint;
begin
  Result := Parent.GetHintPosition(ViewInfo.Bounds, ACursorPos, AHeight);
end;

function TdxBarItemControl.GetHintedControl: TControl;
begin
  Result := Parent;
end;

function TdxBarItemControl.IsCustomHintSupported: Boolean;
begin
  Result := Parent.IsCustomHintSupported;
end;

function TdxBarItemControl.GetAction: TBasicAction;
begin
  Result := Item.Action;
end;

function TdxBarItemControl.GetScreenTip: TdxScreenTip;
begin
  Result := Item.DoGetScreenTip;
end;

function TdxBarItemControl.GetShortCutAsString: string;
var
  AHintText: string;
begin
  GetHintParams(AHintText, Result);
end;

procedure TdxBarItemControl.BeginGroupChanged;
begin
  FParent.RepaintBar;
end;

procedure TdxBarItemControl.CaptionChanged;
begin
  if (Align = iaClient) and (bboExtendItemWhenAlignedToClient in Parent.BehaviorOptions) then
    Repaint
  else
    FParent.RepaintBar;
end;

procedure TdxBarItemControl.EnabledChanged;
begin
  BarManager.UpdateControlByMouse(Parent);
  if not Enabled and (Parent.SelectedControl = Self) then
    Parent.SelectedLink := nil;
  Repaint;
end;

procedure TdxBarItemControl.GlyphChanged;

  function GlyphAreaWidthChanged: Boolean;
  begin
    Result := (ViewInfo.GetAllowedViewLevels <> ViewLevels) or
      ((cpIcon in FDrawParams.ViewStructure) <> (cpIcon in GetViewStructure));
  end;

begin
  if GlyphAreaWidthChanged then
    Parent.RepaintBar
  else
    Repaint;
end;

procedure TdxBarItemControl.HotGlyphChanged;
begin
// do nothing
end;

procedure TdxBarItemControl.LargeGlyphChanged;
begin
  if FDrawParams.ViewSize <> cvsSmall then
    if FDrawParams.PaintType <> ptMenu then
      Parent.RepaintBar
    else
      Repaint;
end;

procedure TdxBarItemControl.PartsChanged;
begin
  DoCalculateParts;
  Repaint;
end;

procedure TdxBarItemControl.PaintStyleChanged;
begin
// do nothing
end;

procedure TdxBarItemControl.ParentVisibleChange(AIsShowing: Boolean);
begin
// do nothing
end;

procedure TdxBarItemControl.PressedChanged;
begin
  if not FPressed then Repaint;
end;

procedure TdxBarItemControl.RealVisibleChanging(AVisible: Boolean);
begin
end;

procedure TdxBarItemControl.VisibleChanged;
begin
  FParent.RepaintBar;
end;

procedure TdxBarItemControl.WidthChanged;
begin
  if Parent is TdxBarControl then
    Parent.RepaintBar;
end;

procedure TdxBarItemControl.ResetCachedValues(AFull: Boolean);
begin
  if AFull then
    ViewInfo.ResetCachedValues;
  FIconAssigned := bDefault;
  FGlyphCache.Reset;
end;

function TdxBarItemControl.UseLargeIcons: Boolean;
begin
  Result := BarManager.ImageOptions.LargeIcons and Painter.AllowLargeIcons;
end;

function TdxBarItemControl.UseLargeImageSource(AViewSize: TdxBarItemControlViewSize): Boolean;
begin
  Result := (AViewSize = cvsLarge) or (GetPaintType <> ptMenu) and UseLargeIcons and BarManager.UseLargeImagesForLargeIcons;
end;

procedure TdxBarItemControl.BeforeDestroyParentHandle;
begin
end;

function TdxBarItemControl.CanBePartOfButtonGroup: Boolean;
begin
  Result := False;
end;

function TdxBarItemControl.CanClicked: Boolean;
begin
  Result := True;
end;

function TdxBarItemControl.CanCustomize: Boolean;
begin
  Result := (BarManager = GetItemBarManager) or
    (csAncestor in BarManager.ComponentState);
end;

function TdxBarItemControl.CanDeselect(ABarManager: TdxBarManager): Boolean;
begin
  Result := CanHide;
end;

function TdxBarItemControl.CanHide: Boolean;
begin
  Result := True;
end;

function TdxBarItemControl.CanMouseSelect: Boolean;
begin
  Result := CanSelect;
end;

function TdxBarItemControl.CanSelect: Boolean;
begin
  Result := not IsSelectionForbidden;
end;

function TdxBarItemControl.CanShowShortCut: Boolean;
begin
  Result := ItemLink.Owner.ItemShowShortCuts;
end;

function TdxBarItemControl.CanVisuallyPressed: Boolean;
begin
  Result := not Parent.NeedHideOnClick;
end;

procedure TdxBarItemControl.CheckDrawParams;
var
  APrevDrawSelected: Boolean;
begin
  APrevDrawSelected := FadingDrawSelected;
  CalcDrawParams;
  if IsFadingAvailable and not (DrawParams.IsPressed or DrawParams.SelectedByKey) and (APrevDrawSelected <> FadingDrawSelected) then
  begin
    if FadingDrawSelected then
      Fader.FadeIn(Self)
    else
      Fader.FadeOut(Self);
  end;
end;

procedure TdxBarItemControl.CheckHotTrack(APoint: TPoint);
begin
  if Enabled then
    HotPartIndex := FindPartAtPos(APoint)
  else
    HotPartIndex := icpNone;
end;

procedure TdxBarItemControl.AcceleratorClick;
begin
  Click(False);
end;

procedure TdxBarItemControl.Click(AByMouse: Boolean; AKey: Char = #0);
var
  AParent: TCustomdxBarControl;
begin
  if Enabled then
  begin
    AParent := Parent;
    ControlClick(AByMouse, AKey);
    if BarControlExists(AParent) and AParent.IsControlExists(Self) then
      ControlUnclick(AByMouse);
  end;
end;

procedure TdxBarItemControl.ControlActivate(AImmediately, AByMouse: Boolean);
begin
  FIsActive := True;
end;

procedure TdxBarItemControl.ControlInactivate(Immediately: Boolean);
begin
  FIsActive := False;
end;

procedure TdxBarItemControl.ControlClick(AByMouse: Boolean; AKey: Char = #0);
begin
end;

procedure TdxBarItemControl.ControlUnclick(AByMouse: Boolean);
var
  AItem: TdxBarItem;
  AItemLink: TdxBarItemLink;
  AAllowClick, ACanDestroyOnClick, AAllowPressed: Boolean;
  ALinkSelf, ALinkItem: TcxObjectLink;
begin
  if (Self is TdxBarButtonControl) and (Parent.Kind = bkSubMenu) then
    PlaySound(psMenuCommand);
  AItemLink := FItemLink.RealItemLink;
  if AItemLink = nil then
    AItemLink := FItemLink;
  AItem := FItemLink.Item;
  AAllowClick := CanClicked;
  ACanDestroyOnClick := CanDestroyOnClick;
  if ACanDestroyOnClick then
  begin
    AItemLink.BringToTopInRecentList(True);
    // for TCustomdxBarContainerItem:
    if AItemLink <> FItemLink then
      FItemLink.BringToTopInRecentList(True);
  end;

  ALinkSelf := cxAddObjectLink(Self);
  AAllowPressed := UnclickAfterDoing and (not ACanDestroyOnClick or CanVisuallyPressed);
  if AAllowPressed then
    Pressed := True;
  try
    if ACanDestroyOnClick then
      Parent.HideAll(bcrEnter);
    if AAllowClick then
    begin
      ALinkItem := cxAddObjectLink(AItem);
      AItem.FClickItemLink := AItemLink;
      try
        AItem.DirectClick;
      finally
        if ALinkItem.Ref <> nil then
          AItem.FClickItemLink := nil;
        cxRemoveObjectLink(ALinkItem);
      end;
    end;
  finally
    if (ALinkSelf.Ref <> nil) and AAllowPressed {and BarControlExists(AParent)} then
      Pressed := False;
    cxRemoveObjectLink(ALinkSelf);
  end;
end;

procedure TdxBarItemControl.ControlGetFocus(AIsSelected: Boolean; var AProcessed: Boolean);
begin
  Parent.IsDowned := False;
  Parent.SetKeySelectedItem(Self);
end;

procedure TdxBarItemControl.DblClick;
begin
end;

function TdxBarItemControl.DrawSelected: Boolean;
begin
  Result := IsSelected;
end;

function TdxBarItemControl.GetSelectableObject: TPersistent;
begin
  Result := ItemLink;
end;

function TdxBarItemControl.WantsDblClick: Boolean;
begin
  Result := BarManager.Designing or IsExpandable;
end;

function TdxBarItemControl.GetCurrentCursor(const AMousePos: TPoint): TCursor;
begin
  Result := crDefault;
end;

procedure TdxBarItemControl.KeyDown(var Key: Word; Shift: TShiftState);
begin
end;

procedure TdxBarItemControl.KeyUp(var Key: Word; Shift: TShiftState);
begin
end;

procedure TdxBarItemControl.KeyPress(var Key: Char);
begin
end;

procedure TdxBarItemControl.MouseDown(Button: TMouseButton; Shift: TShiftState;
  X, Y: Integer);
begin
// do nothing;
end;

procedure TdxBarItemControl.MouseEnter(Shift: TShiftState; X, Y: Integer);
begin
  CheckHotTrack(Point(X, Y));
  Parent.ActivateHint(True, '', Self);
end;

procedure TdxBarItemControl.MouseLeave;
begin
  CheckHotTrack(cxInvalidPoint);
end;

procedure TdxBarItemControl.MouseMove(Shift: TShiftState; X, Y: Integer);
begin
  CheckHotTrack(Point(X, Y));
end;

procedure TdxBarItemControl.MouseUp(Button: TMouseButton; Shift: TShiftState;
  X, Y: Integer);
begin
// do nothing;
end;

function TdxBarItemControl.WantsKey(Key: Word): Boolean;
begin
  Result := False;
end;

function TdxBarItemControl.GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass;
begin
  Result := TdxBarItemControlAccessibilityHelper;
end;

function TdxBarItemControl.GetPossibleViewLevels: TdxBarItemViewLevels;
begin
  Result := [ivlSmallIconWithText];
  if IconAssigned(cvsSmall) then
    Include(Result, ivlSmallIcon);
end;

function TdxBarItemControl.GetViewLevels: TdxBarItemViewLevels;
begin
  Result := PossibleViewLevels;
  if Result * ItemLink.GetAllowedViewLevels <> [] then
    Result := Result * ItemLink.GetAllowedViewLevels;
end;

function TdxBarItemControl.GetViewStructure: TdxBarItemControlViewStructure;
begin
  case ViewInfo.ViewLevel of
    ivlLargeIconWithText, ivlSmallIconWithText:
      begin
        Result := [cpText];
        if IconAssigned then
          Include(Result, cpIcon);
      end;

    ivlSmallIcon:
      if IconAssigned then
        Result := [cpIcon]
      else
        Result := [];
    ivlLargeControlOnly, ivlControlOnly: Result := [];
    ivlDefault: Result := GetDefaultViewStructure;
  end;
end;

function TdxBarItemControl.GetDefaultViewStructure: TdxBarItemControlViewStructure;
begin
  Result := [];
end;

function TdxBarItemControl.GetViewSize: TdxBarItemControlViewSize;
begin
  case ViewInfo.ViewLevel of
    ivlLargeIconWithText:
      Result := cvsLarge;
    ivlSmallIconWithText, ivlSmallIcon:
      Result := cvsSmall;
    else
      Result := GetDefaultViewSize;
  end;
end;

function TdxBarItemControl.GetDefaultViewSize: TdxBarItemControlViewSize;
begin
  if MenuItemSize = misLarge then
    Result := cvsLarge
  else
    if UseLargeIcons then
      Result := cvsMedium
    else
      Result := cvsSmall;
end;

function TdxBarItemControl.GetPaintType: TdxBarPaintType;
begin
  Result := Parent.GetPaintType;
end;

function TdxBarItemControl.GetPartCount: Integer;
begin
  Result := 1;
end;

function TdxBarItemControl.GetViewInfoClass: TdxBarItemControlViewInfoClass;
begin
  Result := TdxBarItemControlViewInfo;
end;

function TdxBarItemControl.GrayScale: Boolean;
begin
  Result := False;
end;

function TdxBarItemControl.IconAssigned: Boolean;
begin
  Result := IconAssigned(GetViewSize);
end;

function TdxBarItemControl.IconAssigned(AViewSize: TdxBarItemControlViewSize): Boolean;
var
  ACurrentGlyph: TdxSmartGlyph;
  ACurrentImageEnabled: TdxDefaultBoolean;
  ACurrentImageIndex: Integer;
  ACurrentImages: TCustomImageList;
begin
  if (FIconAssigned = bDefault) or (AViewSize <> FIconAssignedViewSize) then
  begin
    FIconAssignedViewSize := AViewSize;
    FIconAssigned := dxBooleanToDefaultBoolean(GetCurrentImage(AViewSize,
      False, ACurrentGlyph, ACurrentImages, ACurrentImageIndex, ACurrentImageEnabled));
  end;
  Result := FIconAssigned = bTrue;
end;

procedure TdxBarItemControl.FrameAndFillRect(DC: HDC; var R: TRect; Enabled, Selected, Pressed: Boolean);
begin
  Painter.FrameAndFillRect(Self, DC, R, Enabled, Selected, Pressed);
end;

function TdxBarItemControl.GetCaption: string;
begin
  if FItemLink <> nil then
    Result := FItemLink.Caption
  else
    Result := '';
end;

function TdxBarItemControl.GetControl: TControl;
begin
  Result := nil;
end;

procedure TdxBarItemControl.GetDefaultTextColors(
  AEnabled, ASelected, AFlat: Boolean; var AColor1, AColor2: TColor);
begin
  Painter.GetDefaultTextColors(Self, AEnabled, ASelected, AFlat, AColor1, AColor2);
end;

function TdxBarItemControl.GetDrawParamsClass: TdxBarItemControlDrawParamsClass;
begin
  Result := TdxBarItemControlDrawParams;
end;

function TdxBarItemControl.GetFocused: Boolean;
begin
  Result := False;
end;

function TdxBarItemControl.GetGlyph: TdxSmartGlyph;
begin
  if FItemLink <> nil then
    Result := FItemLink.Glyph
  else
    Result := nil;
end;

function TdxBarItemControl.GetImageIndex: Integer;
begin
  if ItemLink.ImageIndex <> -1 then
    Result := ItemLink.ImageIndex
  else
    Result := Item.ImageIndex;
end;

function TdxBarItemControl.GetImages(AEnabled: Boolean; var ADrawImageEnabled: TdxDefaultBoolean): TCustomImageList;
begin
  Result := GetItemBarManager.ImageOptions.GetImages(AEnabled, ADrawImageEnabled);
end;

function TdxBarItemControl.GetHint;
begin
  if Item <> nil then
    Result := Item.Hint
  else
    Result := '';
end;

procedure TdxBarItemControl.GetHintParams(out AHintText: string; out AShortCut: string);
begin
  AHintText := GetShortHint(Hint);
  AShortCut := GetShortCutToHint(ShortCut, UseRightToLeftReading);
end;

function TdxBarItemControl.GetHotImages: TCustomImageList;
begin
  Result := GetItemBarManager.HotImages;
end;

function TdxBarItemControl.GetLargeGlyph: TdxSmartGlyph;
begin
  Result := Item.LargeGlyph;
end;

function TdxBarItemControl.GetLargeImageIndex: Integer;
begin
  Result := Item.LargeImageIndex;
end;

function TdxBarItemControl.GetLargeImages(AEnabled: Boolean; var ADrawImageEnabled: TdxDefaultBoolean): TCustomImageList;
begin
  Result := GetItemBarManager.ImageOptions.GetLargeImages(AEnabled, ADrawImageEnabled);
end;

function TdxBarItemControl.GetMenuItemSize: TdxBarMenuItemSize;
begin
  Result := ItemLink.Owner.ItemSize;
end;

function TdxBarItemControl.GetPainter: TdxBarPainter;
begin
  Result := Parent.Painter;
end;

function TdxBarItemControl.GetShortCut;
begin
  if Item <> nil then
    Result := Item.ShortCut
  else
    Result := 0;
end;

function TdxBarItemControl.GetTextAreaOffset: Integer;
begin
  Result := Painter.TextAreaOffset(Self);
end;

procedure TdxBarItemControl.GetTextColors(
  AEnabled, ASelected, AFlat: Boolean; var AColor1, AColor2: TColor);
var
  ATextViewParams: TcxViewParams;
begin
  if AEnabled then
  begin
    Item.GetTextViewParams(ATextViewParams);
    if ATextViewParams.TextColor = clDefault then
      GetDefaultTextColors(AEnabled, ASelected, AFlat, AColor1, AColor2)
    else
    begin
      AColor1 := ATextViewParams.TextColor;
      AColor2 := AColor1;
    end;
  end
  else
    GetDefaultTextColors(AEnabled, ASelected, AFlat, AColor1, AColor2);
end;

procedure TdxBarItemControl.SetFocused(AValue: Boolean);
begin
// do nothing
end;

procedure TdxBarItemControl.CalcDrawParams(AFull: Boolean = True);
begin
  FDrawParams.ResetCachedValues;
  if AFull then
  begin
    FDrawParams.Caption := Caption;
    FDrawParams.Description := Item.Description;
    FDrawParams.ShortCut := '';
    FDrawParams.PaintType := GetPaintType;
    FDrawParams.Enabled := Enabled;
    FDrawParams.CanSelect := CanSelect;
    FDrawParams.DrawSelected := DrawSelected;
    FDrawParams.IsDropDown := IsDropDown;
    FDrawParams.HotPartIndex := HotPartIndex;
    FDrawParams.IsCustomizing := FParent.IsCustomizing;
    FDrawParams.SelectedByKey := DrawSelected and not FSelectedByMouse;
  end;
  FDrawParams.Canvas := Canvas;
  FDrawParams.ViewSize := GetViewSize;
  FDrawParams.ViewStructure := GetViewStructure;
  FDrawParams.DefaultButtonSize := Painter.GetButtonSize(BarManager.GetGlyphSize(ScaleFactor), GetTextSize, ScaleFactor);
end;

procedure TdxBarItemControl.CalcParts;
var
  I: Integer;
begin
  SetLength(FParts, GetPartCount);
  for I := Low(FParts) to High(FParts) do
    FParts[I] := ItemBounds;
end;

procedure TdxBarItemControl.CalcDrawingConsts;
var
  ASavedFont: TdxBarSavedFont;
begin
  PrepareCanvasFont(0, Item.Style, ASavedFont);
  try
    DoCalcDrawingConsts;
  finally
    RestoreCanvasFont(ASavedFont);
  end;
end;

procedure TdxBarItemControl.DoCalcDrawingConsts;
var
  ATextViewParams: TcxViewParams;
begin
  DeleteGDIObject(FBkBrush);
  if Item.IsStyleColorSupported then
  begin
    Item.GetTextViewParams(ATextViewParams);
    if ATextViewParams.Color <> clDefault then
      FBkBrush := CreateSolidBrush(ColorToRGB(ATextViewParams.Color));
  end;
  FTextSize := Parent.GetTextSize;
end;

procedure TdxBarItemControl.DoPaint(ARect: TRect; PaintType: TdxBarPaintType);
begin
// do nothing
end;

function TdxBarItemControl.IsTransparentOnGlass: Boolean;
begin
  Result := True;
end;

procedure TdxBarItemControl.Paint(ACanvas: TcxCanvas; ARect: TRect;
  PaintType: TdxBarPaintType);
var
  ASavedFont: TdxBarSavedFont;
begin
  if not IsRectEmpty(ARect) then
  begin
    ACanvas.SaveState;
    try
      if ACanvas <> Canvas then
        ACanvas.Font := Canvas.Font;
      FActiveCanvas := ACanvas;
      try
        PrepareCanvasFont(0, Item.Style, ASavedFont);
        try
          CheckDrawParams;
          DoPaint(ARect, PaintType)
        finally
          RestoreCanvasFont(ASavedFont);
        end;
      finally
        FActiveCanvas := nil;
        CalcDrawParams(False);
      end;
    finally
      ACanvas.RestoreState;
    end;
  end;
end;

procedure TdxBarItemControl.PrepareCanvasFont(ABaseFont: HFONT;
  AStyle: TcxStyle; out ASavedFont: TdxBarSavedFont);
var
  ABaseLogFont, ALogFont: TLogFont;
begin
  ASavedFont.Saved := (AStyle <> nil) and (svFont in AStyle.AssignedValues) or
    (ABaseFont <> 0);
  if ASavedFont.Saved then
  begin
    ASavedFont.LogFont := dxGetFontData(Canvas.Font.Handle);
    if ABaseFont <> 0 then
      dxGetFontData(ABaseFont, ABaseLogFont)
    else
      ABaseLogFont := ASavedFont.LogFont;
    if (AStyle <> nil) and (svFont in AStyle.AssignedValues) then
    begin
      dxGetFontData(AStyle.Font.Handle, ALogFont);
      ALogFont.lfEscapement := ABaseLogFont.lfEscapement;
      ALogFont.lfOrientation := ALogFont.lfEscapement;
      ALogFont.lfOutPrecision := ABaseLogFont.lfOutPrecision;
      ALogFont.lfHeight := ScaleFactor.Apply(ALogFont.lfHeight, dxSystemScaleFactor);
      Canvas.Font.Handle := CreateFontIndirect(ALogFont);
    end
    else
      Canvas.Font.Handle := CreateFontIndirect(ABaseLogFont);
  end;
end;

procedure TdxBarItemControl.RestoreCanvasFont(const ASavedFont: TdxBarSavedFont);
begin
  if ASavedFont.Saved then
  begin
    Canvas.Font.Handle := CreateFontIndirect(ASavedFont.LogFont);
    Canvas.Handle; // RequiredState(csAllValid)
  end;
end;

function TdxBarItemControl.GetOwnedBarControl: TCustomdxBarControl;
begin
  Result := nil;
end;

function TdxBarItemControl.GetNonBufferedRect: TRect;
begin
  Result := cxEmptyRect;
end;

function TdxBarItemControl.GetCaptionWidth: Integer;
var
  ASavedFont: TdxBarSavedFont;
begin
  PrepareCanvasFont(0, Item.Style, ASavedFont);
  try
    Result := cxRectWidth(Painter.GetControlCaptionRect(FDrawParams));
  finally
    RestoreCanvasFont(ASavedFont);
  end;
end;

function TdxBarItemControl.GetCurrentImage(AViewSize: TdxBarItemControlViewSize; ASelected: Boolean;
  out AGlyph: TdxSmartGlyph; out AImages: TCustomImageList; out AImageIndex: Integer; out ADrawImageEnabled: TdxDefaultBoolean): Boolean;

  function GetCurrentImageIndex(AUseLargeImages: Boolean; AImages: TCustomImageList): Integer;
  begin
    Result := -1;
    if AUseLargeImages and (AImages <> nil) then
      Result := LargeImageIndex;
    if Result < 0 then
      Result := ImageIndex;
  end;

var
  ADrawImageFromImageListEnabled: TdxDefaultBoolean;
  AEnabled: Boolean;
  AUseLargeImageList: Boolean;
  AUseLargeImages: Boolean;
begin
  AImages := nil;
  AImageIndex := -1;

  AEnabled := Enabled;
  ADrawImageEnabled := dxBooleanToDefaultBoolean(AEnabled);
  ADrawImageFromImageListEnabled := ADrawImageEnabled;

  AUseLargeImages := UseLargeImageSource(AViewSize);
  AImages := GetCurrentImages(AEnabled, AUseLargeImages, ADrawImageFromImageListEnabled);
  AImageIndex := GetCurrentImageIndex(AUseLargeImages, AImages);
  AUseLargeImageList := AUseLargeImages and IsImageAssigned(AImages, AImageIndex);
  if AUseLargeImages and not AUseLargeImageList then
    AImages := GetCurrentImages(AEnabled, False, ADrawImageFromImageListEnabled);

  if AUseLargeImages and IsGlyphAssigned(LargeGlyph) then
    AGlyph := LargeGlyph
  else
    if not AUseLargeImageList and IsGlyphAssigned(Glyph) then
      AGlyph := Glyph
    else
    begin
      ADrawImageEnabled := ADrawImageFromImageListEnabled;
      AGlyph := nil;
    end;

  Result := IsImageAssigned(AGlyph, AImages, AImageIndex);
  if not Result then
  begin
    AGlyph := Parent.GetDefaultItemGlyph;
    Result := IsGlyphAssigned(AGlyph);
  end;
end;

function TdxBarItemControl.GetCurrentImages(AEnabled, AUseLargeImages: Boolean; var ADrawImageEnabled: TdxDefaultBoolean): TCustomImageList;
begin
  Result := nil;
  if AUseLargeImages then
    Result := GetLargeImages(AEnabled, ADrawImageEnabled);
  if Result = nil then
    Result := Parent.GetCurrentImages;
  if Result = nil then
    Result := GetImages(AEnabled, ADrawImageEnabled);
end;

function TdxBarItemControl.GetDefaultGlyphSize(AViewSize: TdxBarItemControlViewSize): TSize;
begin
  if AViewSize = cvsLarge then
    Result := ScaleFactor.Apply(cxSize(20, 20))
  else
    Result := cxSize(BarManager.GetGlyphSize(ScaleFactor));
end;

function TdxBarItemControl.GetGlyphSize(AViewSize: TdxBarItemControlViewSize; ASelected: Boolean = False): TSize;
var
  AGlyph: TdxSmartGlyph;
  ADrawImageEnabled: TdxDefaultBoolean;
  AImageIndex: Integer;
  AImages: TCustomImageList;
begin
  if GetCurrentImage(AViewSize, ASelected, AGlyph, AImages, AImageIndex, ADrawImageEnabled) then
    Result := GetGlyphSize(AViewSize, AGlyph, AImages, AImageIndex)
  else
    Result := GetDefaultGlyphSize(AViewSize);
end;

function TdxBarItemControl.GetGlyphSize(AViewSize: TdxBarItemControlViewSize;
  AGlyph: TdxSmartGlyph; AImages: TCustomImageList; AImageIndex: Integer): TSize;
begin
  if IsImageAssigned(AGlyph, AImages, AImageIndex) then
    Result := dxGetImageSize(AGlyph, AImages, AImageIndex, ScaleFactor)
  else
    Result := GetDefaultGlyphSize(AViewSize);
end;

function TdxBarItemControl.GetIndents(ADrawAreaType: TdxBarItemControlPart): TRect;
begin
  Result := Painter.ItemControlGetIndents(FDrawParams, ADrawAreaType);
end;

function TdxBarItemControl.GetRotationDependentHeight(ASourceSize: TSize): Integer;
begin
  if IsRotated then
    Result := ASourceSize.cx
  else
    Result := ASourceSize.cy;
end;

function TdxBarItemControl.GetRotationDependentWidth(ASourceSize: TSize): Integer;
begin
  if IsRotated then
    Result := ASourceSize.cy
  else
    Result := ASourceSize.cx;
end;

function TdxBarItemControl.GetTextExtent(const AText: string): TSize;
var
  ASavedFont: TdxBarSavedFont;
begin
  PrepareCanvasFont(0, Item.Style, ASavedFont);
  try
    Result := Canvas.TextExtent(AText);
  finally
    RestoreCanvasFont(ASavedFont);
  end;
end;

function TdxBarItemControl.GetTextHeight: Integer;
begin
  Result := GetTextExtent(dxMeasurePattern).cy;
end;

function TdxBarItemControl.GetTextSize: Integer;
begin
  if (Item.Style <> nil) and (svFont in Item.Style.AssignedValues) then
    Result := FTextSize
  else
    Result := Parent.TextSize;
end;

function TdxBarItemControl.GetTextWidth(const AText: string): Integer;
begin
  Result := GetTextExtent(AText).cx;
end;

function TdxBarItemControl.GetCaptionAreaWidth: Integer;

  function GetTailAreaSize: Integer;
  begin
    Result := Painter.GetTailAreaSize(FDrawParams);
  end;

  function GetShortCutAreaSize: Integer;
  begin
    if CanShowShortCut and (ShortCut <> 0) then
      Result := Parent.TextSize - 6 + GetTextWidth(FDrawParams.ShortCut)
    else
      Result := 0;
  end;

var
  ADescriptionWidth: Integer;
begin
  if cpText in FDrawParams.ViewStructure then
  begin
    if FDrawParams.PaintType = ptMenu then
    begin
      Result := GetCaptionWidth + GetShortCutAreaSize;
      if (MenuItemSize = misLarge) and ShowDescription and (FDrawParams.Description <> '') then
      begin
        ADescriptionWidth := cxRectWidth(cxGetTextRect(Canvas.Handle, FDrawParams.Description, 2));
        Result := Max(Result, ADescriptionWidth);
      end;
      Inc(Result, GetIndents(cpText).Left + GetIndents(cpText).Right);
      Inc(Result, GetTailAreaSize);
    end
    else
    begin
      Result := GetCaptionWidth;
      if cpIcon in FDrawParams.ViewStructure then
        Inc(Result, Painter.GetControlTextIndents.Left)
      else
        Inc(Result, GetControlCaptionOffset * 2);
    end
  end
  else
    Result := 0;
end;

function TdxBarItemControl.GetControlAreaWidth: Integer;
begin
  Result := 0;
end;

function TdxBarItemControl.GetGlyphAreaWidth: Integer;
begin
  if FDrawParams.PaintType = ptMenu then
    Result := Parent.IconAreaSize
  else
    if cpIcon in FDrawParams.ViewStructure then
      Result := GetRotationDependentWidth(FDrawParams.DefaultButtonSize)
    else
      Result := 0;
end;

function TdxBarItemControl.GetControlCaptionOffset: Integer;
begin
  Result := -MulDiv(Parent.Font.Height, 72, 200);
end;

function TdxBarItemControl.GetDefaultHeight: Integer;
begin
  if Parent.Kind = bkSubMenu then
    Result := GetDefaultHeightInSubMenu
  else
    if IsRotated then
      Result := InternalGetDefaultWidth
    else
      Result := InternalGetDefaultHeight;

  dxAdjustToTouchableSize(Result, ScaleFactor);
end;

function TdxBarItemControl.GetDefaultWidth: Integer;
begin
  if FDrawParams.PaintType = ptMenu then
    Result := GetDefaultWidthInSubMenu
  else
    if IsRotated then
      Result := InternalGetDefaultHeight
    else
      Result := InternalGetDefaultWidth;
end;

function TdxBarItemControl.GetDefaultSmallWidth: Integer;
begin
  Result := GetGlyphAreaWidth + GetCaptionAreaWidth + GetControlAreaWidth;
end;

function TdxBarItemControl.GetDefaultLargeWidth: Integer;
begin
  Result := Max(GetGlyphAreaWidth, GetCaptionAreaWidth) + GetControlAreaWidth;
end;

function TdxBarItemControl.GetDefaultHeightInSubMenu: Integer;
begin
  Result := Parent.GetDefaultItemHeight(Self);
  Painter.CorrectButtonControlDefaultHeight(Result);
end;

function TdxBarItemControl.GetDefaultWidthInSubMenu: Integer;
begin
  Result := GetDefaultSmallWidth;
  Painter.CorrectButtonControlDefaultWidth(Result);
end;

function TdxBarItemControl.GetMinHeight: Integer;
begin
  Result := 1;
end;

function TdxBarItemControl.GetMinWidth: Integer;
begin
  Result := 1;
end;

function TdxBarItemControl.GetWidthByViewLevel(AViewLevel: TdxBarItemRealViewLevel): Integer;
var
  APrevViewLevel: TdxBarItemViewLevel;
begin
  APrevViewLevel := ViewInfo.ViewLevel;
  try
    ViewInfo.FViewLevel := AViewLevel;
    Result := Width;
  finally
    ViewInfo.FViewLevel := APrevViewLevel;
  end;
end;

function TdxBarItemControl.InternalGetDefaultHeight: Integer;
begin
  if FDrawParams.ViewSize = cvsLarge then
    Result := GetLargeHeight
  else
    Result := GetSmallHeight;
end;

function TdxBarItemControl.GetLargeHeight: Integer;
begin
  Result := 0;
end;

function TdxBarItemControl.GetSmallHeight: Integer;
begin
  Result := 0;
  if cpText in FDrawParams.ViewStructure then
    Result := Max(Result, GetTextSize);
  if cpIcon in FDrawParams.ViewStructure then
    Result := Max(Result, GetRotationDependentHeight(FDrawParams.DefaultButtonSize));
end;

function TdxBarItemControl.InternalGetDefaultWidth: Integer;
begin
  if FDrawParams.ViewSize = cvsLarge then
    Result := GetDefaultLargeWidth
  else
    Result := GetDefaultSmallWidth;
end;

function TdxBarItemControl.AllowSelectWithoutFocusing: Boolean;
begin
  Result := bboAllowSelectWindowItemsWithoutFocusing in Parent.BehaviorOptions;
end;

function TdxBarItemControl.HasHint: Boolean;
begin
  Result := (Hint <> '') and (Parent is TdxBarControl);
end;

function TdxBarItemControl.HasShadow: Boolean;
begin
  Result := FParent.ChildrenHaveShadows;
end;

procedure TdxBarItemControl.HotPartChanged;
begin
  Repaint;
end;

function TdxBarItemControl.HotPartWantMouse: Boolean;
begin
  Result := WantMouse;
end;

function TdxBarItemControl.IsBkColorAssigned: Boolean;
begin
  Result := FBkBrush <> 0;
end;

function TdxBarItemControl.IsChildWindow(AWnd: HWND): Boolean;
begin
  Result := Item.DoIsChildWindow(AWnd) or IsChildEx(Parent.Handle, AWnd);
end;

function TdxBarItemControl.CanDestroyOnClick: Boolean;
begin
  Result := True;
end;

function TdxBarItemControl.IsDropDown: Boolean;
begin
  Result := False;
end;

function TdxBarItemControl.IsEditTransparent: Boolean;
begin
  Result := False;
end;

function TdxBarItemControl.IsExpandable: Boolean;
begin
  Result := False;
end;

function TdxBarItemControl.IsHiddenForCustomization: Boolean;
begin
  Result := False;
end;

function TdxBarItemControl.IsInvertTextColor: Boolean;
begin
  Result := False;
end;

function TdxBarItemControl.IsMenuItem: Boolean;
begin
  Result := False;
end;

function TdxBarItemControl.IsRotated: Boolean;
begin
  Result := Parent.IsVertical;
end;

function TdxBarItemControl.IsSelectionForbidden: Boolean;
begin
  Result := (Parent.IsCustomizing and (BarManager <> GetItemBarManager) and
      not (csAncestor in BarManager.ComponentState));
end;

function TdxBarItemControl.MousePressed: Boolean;
var
  R: TRect;
  P: TPoint;
begin
  R := Parent.GetItemRect(Self);
  P := Parent.ScreenToClient(GetMouseCursorPos);
  Result := Enabled and PtInRect(R, P);
  if Result then
    if InMouseHook then
      Result := LeftButtonPressed
    else
      Result := GetKeyState(VK_LBUTTON) < 0;
end;

function TdxBarItemControl.NeedBufferedRepaint: Boolean;
begin
  Result := False;
end;

function TdxBarItemControl.NeedCaptureMouse: Boolean;
begin
  Result := False;
end;

function TdxBarItemControl.NeedUpdateWhenResize: Boolean;
begin
  Result := False;
end;

function TdxBarItemControl.WantMouse: Boolean;
begin
  Result := CanSelect or CanClicked;
end;

procedure TdxBarItemControl.CheckNonRecent;
begin
  if Parent.Kind = bkSubMenu then
    SubMenuParent.FNonRecent := FNonRecent;
end;

procedure TdxBarItemControl.UncheckNonRecent;
begin
  if Parent.Kind = bkSubMenu then
    SubMenuParent.FNonRecent := False;
end;

procedure TdxBarItemControl.BeginResize(APoint: TPoint);
begin
// do nothing
end;

function TdxBarItemControl.CanResize(APoint: TPoint): Boolean;
begin
  Result := False;
end;

procedure TdxBarItemControl.EndResize(AAllowResize: Boolean);
begin
// do nothing
end;

procedure TdxBarItemControl.Resizing(APoint: TPoint);
begin
// do nothing
end;

procedure TdxBarItemControl.DoCalculateParts;
begin
  CalcDrawParams(False);
  InternalCalculateParts;
end;

procedure TdxBarItemControl.DoRightToLeftConversion(const ABounds: TRect);
var
  I: Integer;
begin
  for I := Low(FParts) to High(FParts) do
    FParts[I] := TdxRightToLeftLayoutConverter.ConvertRect(FParts[I], ABounds);
end;

procedure TdxBarItemControl.InternalCalculateParts;
begin
  FIsRightToLeftConverted := False;
  CalcParts;
  if UseRightToLeftAlignment then
  begin
    DoRightToLeftConversion(ItemBounds);
    FIsRightToLeftConverted := True;
  end;
end;

function TdxBarItemControl.HasWindow: Boolean;
begin
  Result := False;
end;

function TdxBarItemControl.IsDroppedDown: Boolean;
begin
  Result := False;
end;

procedure TdxBarItemControl.Repaint;
begin
  if Parent.HandleAllocated then
    Parent.UpdateItem(Self);
end;

procedure TdxBarItemControl.Update;
begin
  Update(ItemBounds);
end;

procedure TdxBarItemControl.Update(const R: TRect);
begin
  if Parent.HandleAllocated then
    cxInvalidateRect(Parent.Handle, R, False);
end;

function TdxBarItemControl.UseRightToLeftAlignment: Boolean;
begin
  Result := Parent.UseRightToLeftAlignment;
end;

function TdxBarItemControl.UseRightToLeftReading: Boolean;
begin
  Result := Parent.UseRightToLeftReading;
end;

function TdxBarItemControl.UseRightToLeftScrollbar: Boolean;
begin
  Result := Parent.UseRightToLeftScrollBar;
end;

{ TdxBarCustomStaticControl}

function TdxBarCustomStaticControl.CanClicked: Boolean;
begin
  Result := False;
end;

function TdxBarCustomStaticControl.CanSelect: Boolean;
begin
  Result := inherited CanSelect and BarManager.IsCustomizing;
end;

procedure TdxBarCustomStaticControl.DoPaint(ARect: TRect; PaintType: TdxBarPaintType);
begin
  Painter.DrawStaticGlyphAndCaption(DrawParams, ARect);
end;

function TdxBarCustomStaticControl.GetDefaultViewStructure: TdxBarItemControlViewStructure;
begin
  Result := [];
  if Item.ShowCaption then
    Result := [cpText];
  if IconAssigned then
    Include(Result, cpIcon);
end;

function TdxBarCustomStaticControl.GetDrawParamsClass: TdxBarItemControlDrawParamsClass;
begin
  Result := TdxBarStaticLikeControlDrawParams;
end;

function TdxBarCustomStaticControl.GetDrawParams: TdxBarStaticLikeControlDrawParams;
begin
  Result := TdxBarStaticLikeControlDrawParams(FDrawParams);
end;

{ TdxBarSeparatorControl }

procedure TdxBarSeparatorControl.CalcDrawParams(AFull: Boolean = True);
begin
  inherited;
  DrawParams.IsTop := ItemLink.VisibleIndex = 0;
end;

procedure TdxBarSeparatorControl.DoPaint(ARect: TRect; PaintType: TdxBarPaintType);
begin
  Painter.DrawSeparatorControl(DrawParams, ARect);
end;

procedure TdxBarSeparatorControl.GetDefaultTextColors(
  AEnabled, ASelected, AFlat: Boolean; var AColor1, AColor2: TColor);
begin
  Painter.SeparatorControlGetTextColors(Self, AEnabled, ASelected, AFlat, AColor1, AColor2);
end;

function TdxBarSeparatorControl.GetIndents(ADrawAreaType: TdxBarItemControlPart): TRect;
begin
  Result := Painter.SeparatorControlGetIndents(DrawParams, ADrawAreaType);
end;

function TdxBarSeparatorControl.GetMenuItemSize: TdxBarMenuItemSize;
begin
  Result := misNormal;
end;

function TdxBarSeparatorControl.GetGlyphAreaWidth: Integer;
begin
  Result := 0;
end;

function TdxBarSeparatorControl.GetDefaultHeightInSubMenu: Integer;
const
  ASeparatorsCount: array [Boolean] of Integer = (2, 1);
begin
  if cpText in DrawParams.ViewStructure then
    Result := inherited GetDefaultHeightInSubMenu +
      Painter.SeparatorControlSeparatorSize * ASeparatorsCount[DrawParams.IsTop]
  else
    Result := Parent.BeginGroupSize
end;

function TdxBarSeparatorControl.GetDefaultWidthInSubMenu: Integer;
begin
  Result := inherited GetDefaultWidthInSubMenu;
end;

function TdxBarSeparatorControl.GetMinWidth: Integer;
begin
  Result := Parent.IconAreaSize + Painter.GetTailAreaSize(FDrawParams);
end;

function TdxBarSeparatorControl.InternalGetDefaultHeight: Integer;
begin
  Result := GetTextSize;
end;

function TdxBarSeparatorControl.InternalGetDefaultWidth: Integer;
begin
  Result := Parent.BeginGroupSize;
end;

procedure TdxBarSeparatorControl.PrepareCanvasFont(ABaseFont: HFONT; AStyle: TcxStyle;
  out ASavedFont: TdxBarSavedFont);
begin
  if AStyle <> nil then
    inherited
  else
    Canvas.Font.Style := [fsBold];
end;

procedure TdxBarSeparatorControl.RestoreCanvasFont(const ASavedFont: TdxBarSavedFont);
begin
  Canvas.Font.Style := [];
end;

function TdxBarSeparatorControl.GetDefaultViewStructure: TdxBarItemControlViewStructure;
begin
  if (DrawParams.PaintType = ptMenu) and Item.ShowCaption then
    Result := [cpText]
  else
    Result := [];
end;

function TdxBarSeparatorControl.GetDrawParamsClass: TdxBarItemControlDrawParamsClass;
begin
  Result := TdxBarSeparatorControlDrawParams;
end;

function TdxBarSeparatorControl.GetDrawParams: TdxBarSeparatorControlDrawParams;
begin
  Result := TdxBarSeparatorControlDrawParams(FDrawParams);
end;

{ TdxBarWinControl }

procedure TdxBarWinControl.DefaultHandler(var Message);
begin
  inherited;
  if (Handle <> 0) and (FWindowProcObject <> nil) then
    FWindowProcObject.DefaultProc(TMessage(Message));
end;

function TdxBarWinControl.HasWindow: Boolean;
begin
  Result := True;
end;

function TdxBarWinControl.HandleAllocated: Boolean;
begin
  Result := Handle <> 0;
end;

function TdxBarWinControl.DoCallKeyboardHook(AWParam: WParam; ALParam: LParam): Boolean;
var
  AHookResult: LRESULT;
begin
  AHookResult := 0;
  dxBarKeyboardHook(0, AWParam, ALParam, AHookResult);
  Result := False;
end;

function TdxBarWinControl.GetItem: TdxBarWindowItem;
begin
  Result := TdxBarWindowItem(ItemLink.Item);
end;

function TdxBarWinControl.GetWindowRect: TRect;
begin
  if Enabled and not Item.EmptyWindow then
    Result := FWindowRect
  else
    Result := cxEmptyRect;
end;

procedure TdxBarWinControl.SetWindowRect(const Value: TRect);
var
  R: TRect;
begin
  FWindowRect := Value;
  if IsWindowVisible(Handle) then
  begin
    R := dxMapWindowRect(0, Parent.Handle, cxGetWindowRect(Handle));
    if not EqualRect(R, FWindowRect) then
    begin
      with WindowRect do
        SetWindowPos(Handle, 0, Left, Top,
          Right - Left, Bottom - Top, SWP_NOZORDER or SWP_NOACTIVATE {SWP_SHOWWINDOW});
      PrepareEditWnd;
    end;
  end;
end;

function TdxBarWinControl.CanClicked: Boolean;
begin
  Result := FParent.IsVertical;
end;

function TdxBarWinControl.CanDeselect(ABarManager: TdxBarManager): Boolean;
begin
  Result := inherited CanDeselect(ABarManager) and
    ((BarManager = ABarManager) or
      IsMDIForm(ABarManager.MasterForm) and IsMDIChild(BarManager.MasterForm) and not FFocusing);
end;

function TdxBarWinControl.CanSelect: Boolean;
begin
  Result := inherited CanSelect and Item.CanSelect;
end;

procedure TdxBarWinControl.ControlInactivate(Immediately: Boolean);
begin
  inherited;
  Focused := False;
end;

procedure TdxBarWinControl.ControlClick(AByMouse: Boolean; AKey: Char = #0);
begin
  Focused := True;
  inherited;
  ActivateEdit(AByMouse, AKey);
end;

procedure TdxBarWinControl.ControlGetFocus(AIsSelected: Boolean; var AProcessed: Boolean);
begin
  if AIsSelected and Focused then
  begin
    AProcessed := True;
    if not PtInRect(WindowRect, GetMouseCursorPos) then
      TransferMessage(Parent.Handle, Parent.FCurrentMessage);
  end
  else
    inherited
end;

procedure TdxBarWinControl.EnabledChanged;
begin
  Focused := False;
  inherited;
end;

function TdxBarWinControl.GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass;
begin
  Result := TdxBarWinControlAccessibilityHelper;
end;

function TdxBarWinControl.GetFocused: Boolean;
begin
  Result := FFocused;
end;

function TdxBarWinControl.IsChildWindow(AWnd: HWND): Boolean;
begin
  Result := inherited IsChildWindow(AWnd) or IsChildEx(Handle, AWnd);
end;

function TdxBarWinControl.CanDestroyOnClick: Boolean;
begin
  Result := False;
end;

function TdxBarWinControl.IsWindowEnabled: Boolean;
begin
  Result := Parent.IsWindowEnabled and
    (not HandleAllocated or Windows.IsWindowEnabled(Handle));
end;

procedure TdxBarWinControl.KeyDown(var Key: Word; Shift: TShiftState);

  function IsWindowDestroyed: Boolean;
  begin
    Result := Handle = 0;
  end;

var
  ALinkSelf: TcxObjectLink;
begin
  if IsSysKeyDown(Key, Shift) then
    SysKeyDown(Key, Shift)
  else
  begin
    ALinkSelf := cxAddObjectLink(Self);
    try
      Item.KeyDown(Key, Shift);
      if (ALinkSelf.Ref = nil) or IsWindowDestroyed then
        Key := 0;
      case Key of
        VK_ESCAPE:
          begin
            DoEscape;
            Key := 0;
          end;
        VK_RETURN:
          begin
            DoEnter;
            Key := 0;
         end;
        VK_TAB:
          begin
            DoNavigation(Shift);
            Key := 0;
          end;
      end;
    finally
      cxRemoveObjectLink(ALinkSelf);
    end;
  end;
end;

procedure TdxBarWinControl.KeyPress(var Key: Char);
begin
  Item.KeyPress(Key);
end;

procedure TdxBarWinControl.KeyUp(var Key: Word; Shift: TShiftState);
begin
  if IsSysKeyUp(Key, Shift) then
    SysKeyUp(Key, Shift)
  else
  begin
    if ssAlt in Shift then
      FKeyPressedInside := 0;
    Item.KeyUp(Key, Shift);
  end;
end;

function TdxBarWinControl.ClientToParent(const APoint: TPoint): TPoint;
begin
  Result := dxMapWindowPoint(Handle, Parent.Handle, APoint);
end;

function TdxBarWinControl.ParentToClient(const APoint: TPoint): TPoint;
begin
  Result := dxMapWindowPoint(Parent.Handle, Handle, APoint);
end;

procedure TdxBarWinControl.CreateInnerEdit;
begin
  if Handle <> 0 then
    FWindowProcObject := cxWindowProcController.Add(Handle, MainWndProc);
end;

procedure TdxBarWinControl.DestroyInnerEdit(AFullDestroy: Boolean = True);
begin
  if Handle <> 0 then
    Focused := False;
  cxWindowProcController.Remove(FWindowProcObject);
end;

procedure TdxBarWinControl.DoEnter;
var
  AHandle: HWND;
  AParent: TCustomdxBarControl;
begin
  AHandle := Handle;
  AParent := Parent;
  if (ItemLink.RealItemLink <> nil) then
    ItemLink.RealItemLink.BringToTopInRecentList(True);
  StoreDisplayValue;
  if IsWindowVisible(AHandle) then
  begin
    AParent.SetKeySelectedItem(nil);
    KillBeep(AHandle);
    AParent.HideAll(bcrEnter);
  end;
end;

procedure TdxBarWinControl.DoEscape;
begin
  Parent.SetKeySelectedItem(nil);
  KillBeep(Handle);
  Parent.AfterControlEscape(Self);
end;

procedure TdxBarWinControl.DoNavigation(AShift: TShiftState);
begin
  StoreDisplayValue;
  if IsWindowVisible(Handle) then
  begin
    KillBeep(Handle);
    BarNavigationController.HandleKey(VK_TAB, AShift)
  end;
end;

function TdxBarWinControl.DoKeyDown(var Message: TWMKey): Boolean;
begin
  KeyDown(Message.CharCode, KeyDataToShiftState(Message.KeyData));
  Result := (Message.CharCode = 0);
end;

function TdxBarWinControl.DoKeyPress(var Message: TWMKey): Boolean;
var
  Ch: Char;
begin
  Ch := Char(Message.CharCode);
  KeyPress(Ch);
  Message.CharCode := Word(Ch);
  Result := (Ch = #0);
end;

function TdxBarWinControl.DoKeyUp(var Message: TWMKey): Boolean;
begin
  KeyUp(Message.CharCode, KeyDataToShiftState(Message.KeyData));
  Result := (Message.CharCode = 0);
end;

procedure TdxBarWinControl.DoKillFocus(var Message: TMessage);
begin
  KillFocus(Message.WParam);
end;

procedure TdxBarWinControl.DoMouseDown(var Message: TWMMouse;
  AButton: TMouseButton; AShift: TShiftState);
var
  APoint: TPoint;
begin
  MouseDown(AButton, KeysToShiftState(Message.Keys), Message.XPos, Message.YPos);

  if mbRight = AButton then
  begin
    APoint := ClientToParent(Point(Message.XPos, Message.YPos));
    SendMessage(Parent.Handle, WM_RBUTTONDOWN, Message.Keys, MakeLParam(APoint.X, APoint.Y));
  end;
end;

procedure TdxBarWinControl.ActivateEdit(AByMouse: Boolean; AKey: Char = #0);
var
  P: TPoint;
begin
  if AByMouse then
  begin
    P := Parent.ScreenToClient(GetMouseCursorPos);
    if not PtInRect(WindowRect, P) then
    begin
      P := ParentToClient(P);
      SendMessage(Handle, WM_LBUTTONDOWN, ShiftStateToKeys(KeyboardStateToShiftState), MakeLParam(P.X, P.Y));
    end;
  end;
end;

function TdxBarWinControl.GetText: string;
var
  S: PChar;
  Len: Integer;
begin
  if Handle <> 0 then
  begin
    S := StrAlloc(256);
    Len := SendMessage(Handle, WM_GETTEXT, 255, LPARAM(S));
    if Len = 0 then Result := ''
    else Result := S;
    StrDispose(S);
  end;
end;

function TdxBarWinControl.IsSysKeyDown(var Key: Word; Shift: TShiftState): Boolean;
begin
  Result := (Key = VK_F10) or (Key = VK_MENU);
end;

function TdxBarWinControl.IsSysKeyUp(var Key: Word; Shift: TShiftState): Boolean;
begin
  Result := (Key = VK_MENU);
end;

procedure TdxBarWinControl.KillFocus(AHandle: THandle);
begin
  // do nothing
end;

procedure TdxBarWinControl.MainWndProc(var Message: TMessage);
begin
  try
    WndProc(Message);
  except
    Application.HandleException(Self);
  end;
end;

function TdxBarWinControl.NeedFocusOnClick: Boolean;
begin
  Result := True;
end;

procedure TdxBarWinControl.PrepareEditWnd;
begin
  // do nothing
end;

procedure TdxBarWinControl.RestoreDisplayValue;
begin
  Text := Item.Text;
end;

procedure TdxBarWinControl.SetFocused(Value: Boolean);
var
  IsDesignForm: Boolean;

  procedure SetTopMosts(AShow: Boolean);
  begin
    if BarDesignController.IsCustomizedByPopup then
      BarDesignController.SetCustomizePopupTopMosts(AShow);
  end;

begin
  if FFocused <> Value then
  begin
    FFocused := Value;
    if FFocused then
    begin
      if BarManager.FChangingFocusedItemControlLockCount = 0 then
        BarManager.FPrevFocusedControl := Windows.GetFocus;
      if not IsActive then
        ControlActivate(True, True);
      Parent.MakeItemControlFullyVisible(Self);
      Show;
    end
    else
    begin
{      if FHandle <> 0 then
        SetWindowPos(Handle, 0, 0, 0, 0, 0,
          SWP_NOZORDER or SWP_NOMOVE or SWP_NOSIZE or SWP_HIDEWINDOW or SWP_NOACTIVATE);}

      Hide(BarManager.AlwaysSaveText and
        ((GetAsyncKeyState(VK_ESCAPE) >= 0) or
         (GetAsyncKeyState(VK_CONTROL) < 0) or (GetAsyncKeyState(VK_MENU) < 0)));

      if (BarManager.FChangingFocusedItemControlLockCount = 0) and
        not (bisToolbarsVisibleChanging in BarManager.FInternalState) and not BarManager.IsDestroying then
      begin
        IsDesignForm := (dxBarCustomizingForm <> nil) and
          (GetParentForm(FindControl(BarManager.FPrevFocusedControl)) = dxBarCustomizingForm);
        if IsDesignForm then
          SetTopMosts(True);
        if (BarManager.FPrevFocusedControl > 0) and IsWindowVisible(BarManager.FPrevFocusedControl) then
          SetFocus(BarManager.FPrevFocusedControl)
        else
          if IsControlVisible(BarManager.Owner) then
            Windows.SetFocus(BarManager.Owner.Handle)
          else
            Windows.SetFocus(GetNextWindow(BarManager.Owner.Handle, GW_HWNDNEXT));
        if IsDesignForm then SetTopMosts(False);
        BarManager.FPrevFocusedControl := 0;
      end;
    end;
  end;
end;

procedure TdxBarWinControl.SetText(Value: string);
begin
  SetWindowText(Handle, PChar(Value));
  if Item.EmptyWindow then Repaint;
end;

procedure TdxBarWinControl.Show;
begin
  FOnGlass := Parent.IsOnGlass;
end;

procedure TdxBarWinControl.StoreDisplayValue;
begin
  Item.Text := Text;
end;

procedure TdxBarWinControl.SysKeyDown(var Key: Word; Shift: TShiftState);
begin
  Inc(FKeyPressedInside);
  case Key of
    VK_MENU: Key := 0;
    VK_F10:
      begin
        FKeyPressedInside := 0;
        Parent.HideAll;
        if (ssShift in Shift) or DoCallKeyboardHook(Key, 1) then
          Key := 0;
      end;
  end;
end;

procedure TdxBarWinControl.SysKeyUp(var Key: Word; Shift: TShiftState);
begin
  if FKeyPressedInside > 0 then
  begin
    FKeyPressedInside := 0;
    if (Key = VK_MENU) and (Shift = []) then
    begin
      Parent.HideAll;
      WaitForMenu := True;
      if DoCallKeyboardHook(Key, LPARAM($C0000001)) then
        Key := 0;
    end;
  end
  else
    Key := 0;
end;

procedure TdxBarWinControl.TransferMessage(AFromWindow: HWND; const Message: TMessage);
var
  APoint: TPoint;
begin
  case Message.Msg of
    WM_MOUSEFIRST..WM_MOUSELAST:
      begin
        APoint := dxMapWindowPoint(AFromWindow, Handle, SmallPointToPoint(TWMMouse(Message).Pos));
        SendMessage(Handle, Message.Msg, Message.WParam, dxPointToLParam(APoint));
      end;
  end;
end;

procedure TdxBarWinControl.WndProc(var Message: TMessage);
var
  AItem: TdxBarWindowItem;
  AFocusedParent: HWND;
  ALinkSelf: TcxObjectLink;
  P: TPoint;
begin
  AItem := Item;
  ALinkSelf := cxAddObjectLink(Self);
  try
    case Message.Msg of
      WM_SETFOCUS:
        AItem.DoEnter;
      WM_KILLFOCUS:
        try
          DoKillFocus(Message);
          if Focused then
          begin
            DefaultHandler(Message);
            //KillBeep(Handle);
            Parent.HideAll;
            Exit;
          end;
          if Parent is TdxBarControl then
          begin
            if GetFocus = Parent.Handle then
              AFocusedParent := Parent.Handle
            else
              AFocusedParent := GetParent(GetFocus);
            if not (FindControl(AFocusedParent) is TdxBarControl) then
              AFocusedParent := GetParent(AFocusedParent);
            if AFocusedParent <> Parent.Handle then
            begin
              DefaultHandler(Message);
              KillBeep(Handle);
              Parent.HideAll;
              Exit;
            end;
          end;
        finally
          AItem.DoExit;
        end;
      WM_MOUSEFIRST..WM_MOUSELAST:
        case Message.Msg of
          WM_RBUTTONDOWN:
            begin
              DoMouseDown(TWMMouse(Message), mbRight, []);
              Exit;
            end;
          WM_MOUSEMOVE: ;
        else
          P := ClientToParent(Point(TWMMouse(Message).XPos, TWMMouse(Message).YPos));
          if (GetCapture <> Handle) and
            not PtInRect(WindowRect, P) and PtInRect(Parent.GetItemRect(Self), P) then
              Exit;
        end;
      WM_CHAR:
        if DoKeyPress(TWMKey(Message)) then
          Exit;
      WM_KEYDOWN, WM_SYSKEYDOWN:
        if DoKeyDown(TWMKey(Message)) then
          Exit;
      WM_KEYUP, WM_SYSKEYUP:
        if DoKeyUp(TWMKey(Message)) then
          Exit;
      WM_COMMAND:
        if (HiWord(Message.WParam) = EN_CHANGE) and not FFocusing then
          Item.CurChange;
      WM_DESTROY:
        InnerControlBufferedPaint := False;
    end;
    if ALinkSelf.Ref <> nil then
      DefaultHandler(Message);
  finally
    cxRemoveObjectLink(ALinkSelf);
  end;
end;

{ TdxBarButtonLikeControl }

procedure FinishSubMenuTracking(var ADropDownControl: TdxBarButtonLikeControl; var ATimerID: DWORD);
begin
  dxKillTimer(0, ATimerID);
  ADropDownControl := nil;
end;

procedure FinishSubMenuActivationTracking;
begin
  FinishSubMenuTracking(ABarActivationDropDownControl, ABarActivationDropDownControlTimerID);
end;

procedure FinishSubMenuDeActivationTracking;
begin
  FinishSubMenuTracking(ABarDeActivationDropDownControl, ABarDeActivationDropDownControlTimerID);
end;

procedure DeActivateSubMenu;
begin
  if ABarDeActivationDropDownControl <> nil then
    ABarDeActivationDropDownControl.ControlInActivate(True);
  FinishSubMenuDeActivationTracking;
end;

procedure ActivateSubMenu;
begin
  if ABarActivationDropDownControl <> nil then
    ABarActivationDropDownControl.ControlActivate(True, True);
  FinishSubMenuActivationTracking;
end;

procedure ActivateSubMenuTimerProc(Wnd: HWnd; Msg, TimerID, SysTime: Longint); stdcall;
begin
  ActivateSubMenu;
end;

procedure DeActivateSubMenuTimerProc(Wnd: HWnd; Msg, TimerID, SysTime: Longint); stdcall;
begin
  DeActivateSubMenu;
end;

procedure StartSubMenuActivationTracking(ADropDownControl: TdxBarButtonLikeControl);
begin
  ABarActivationDropDownControl := ADropDownControl;
  ABarActivationDropDownControlTimerID := SetTimer(0, 0, dxBarWaitForSubMenuTime, @ActivateSubMenuTimerProc);
end;

procedure StartSubMenuDeActivationTracking(ADropDownControl: TdxBarButtonLikeControl);
begin
  ABarDeActivationDropDownControl := ADropDownControl;
  ABarDeActivationDropDownControlTimerID := SetTimer(0, 0, dxBarWaitForSubMenuTime, @DeActivateSubMenuTimerProc);
end;

destructor TdxBarButtonLikeControl.Destroy;
begin
  FinishSubMenuTracking;
  if (SubMenuControl <> nil) {and not ItemLink.Item.IsDestroying} then
    SubMenuControl.Hide;
  inherited;
end;

function TdxBarButtonLikeControl.ArrowWidth: Integer;
begin
  if Parent.Kind = bkSubMenu then
    Result := Parent.MenuArrowWidth
  else
    Result := ScaleFactor.Apply(Painter.RealButtonArrowWidth(BarManager));
end;

procedure TdxBarButtonLikeControl.CalcDrawParams(AFull: Boolean = True);
begin
  inherited CalcDrawParams(AFull);

  if AFull then
  begin
    DrawParams.ButtonGroup := ViewInfo.RealPositionInButtonGroup;
    DrawParams.IsTextSelected := IsTextSelected;
    DrawParams.IsFlatText := IsFlatText;
  end;

  DrawParams.ArrowSize := cxSize(ArrowWidth, Parent.MenuArrowHeight);
end;

function TdxBarButtonLikeControl.CanBePartOfButtonGroup: Boolean;
begin
  Result := True;
end;

function TdxBarButtonLikeControl.CanFade: Boolean;
begin
  Result := IsFadingAvailable and not IsDroppedDown and Parent.AllowFade;
end;

function TdxBarButtonLikeControl.CanActivate: Boolean;
begin
  Result := Enabled or BarManager.Designing;
end;

procedure TdxBarButtonLikeControl.ControlActivate(AImmediately, AByMouse: Boolean);
begin
  if IsDroppedDown then
    FinishSubMenuTracking
  else
  begin
    inherited;
    if IsDropDown and CanActivate then
    begin
      if Parent is TdxBarControl then
        if Parent.IsCustomizing or TdxBarControl(Parent).IsDowned then
          AImmediately := True
        else
          Exit;
      if not AImmediately and not BarManager.IsCustomizing then
        StartSubMenuTracking(True)
      else
      begin
        DeActivateSubMenu;
        DoDropDown(AByMouse);
      end;
    end;
  end;
end;

procedure TdxBarButtonLikeControl.ControlInactivate(Immediately: Boolean);
begin
  if Parent is TdxBarControl then
    Immediately := True;

  if (Parent <> nil) and not (Immediately or Parent.IsDestroying or
    BarManager.IsCustomizing or BarDesignController.IsCustomizedByPopup) then
  begin
    StartSubMenuTracking(False);
    Exit;
  end;

  inherited ControlInactivate(Immediately);

  DoCloseUp(SubMenuControl <> nil);
end;

procedure TdxBarButtonLikeControl.ControlGetFocus(AIsSelected: Boolean; var AProcessed: Boolean);
begin
  if not AIsSelected then
    inherited
  else
    if Parent.IsDowned and IsDroppedDown then
      Parent.BarLostFocus;
end;

procedure TdxBarButtonLikeControl.DoPaint(ARect: TRect; PaintType: TdxBarPaintType);
begin
  Painter.DrawButtonLikeControl(DrawParams, ARect);
end;

procedure TdxBarButtonLikeControl.DropDown(AByMouse: Boolean);
begin
  Parent.IsDowned := True;
end;

function TdxBarButtonLikeControl.GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass;
begin
  Result := TdxBarButtonLikeControlAccessibilityHelper;
end;

function TdxBarButtonLikeControl.GetDefaultLargeWidth: Integer;
var
  W: Integer;
begin
  Result := GetRotationDependentWidth(GetGlyphSize(cvsLarge));

  if cpText in FDrawParams.ViewStructure then
  begin
    W := 2 * ScaleFactor.Apply(3) + GetCaptionWidth;
    if GetGlyphLayout in [glLeft, glRight] then
      Inc(Result, W)
    else
      Result := Max(Result, W);
  end;
  Inc(Result, Painter.GetLargeButtonBorderWidth);
end;

function TdxBarButtonLikeControl.GetDrawParamsClass: TdxBarItemControlDrawParamsClass;
begin
  Result := TdxBarButtonLikeControlDrawParams;
end;

function TdxBarButtonLikeControl.GetLargeHeight: Integer;
var
  H: Integer;
begin
  Result := GetRotationDependentHeight(GetGlyphSize(cvsLarge));

  if cpText in FDrawParams.ViewStructure then
  begin
    H := GetTextHeight;
    if GetGlyphLayout in [glTop, glBottom] then
      Inc(Result, H + ScaleFactor.Apply(1))
    else
      Result := Max(Result, H);
  end;
  Inc(Result, Painter.GetLargeButtonBorderHeight);
end;

function TdxBarButtonLikeControl.GetSubMenuControl: TdxBarSubMenuControl;
begin
  Result := nil;
end;

function TdxBarButtonLikeControl.FadingDrawSelected: Boolean;
var
  AHelper: IdxFadingPainterHelper2;
begin
  if Supports(Painter, IdxFadingPainterHelper2, AHelper) then
    Result := AHelper.GetButtonPartState(DrawParams, bcpButton) in [DXBAR_HOT, DXBAR_ACTIVE, DXBAR_HOTCHECK]
  else
    Result := inherited FadingDrawSelected;
end;

procedure TdxBarButtonLikeControl.GetFadingImages(out AFadeOutImage, AFadeInImage: TcxBitmap);

  procedure PrepareImage(ABitmap: TcxBitmap; AFadingHelper: IdxFadingPainterHelper; ADrawHot: Boolean);
  var
    APrevDrawSelected: Boolean;
    APrevHotPartIndex: Integer;
  begin
    FActiveCanvas := ABitmap.cxCanvas;
    FActiveCanvas.UseRightToLeftAlignment := UseRightToLeftAlignment;
    if Parent.UseRightToLeftReading then
      FActiveCanvas.TextFlags := FActiveCanvas.TextFlags or ETO_RTLREADING;
    CalcDrawParams;
    try
      APrevHotPartIndex := DrawParams.HotPartIndex;
      APrevDrawSelected := DrawParams.DrawSelected;
      try
        ABitmap.cxCanvas.ViewportOrg := cxPointInvert(ItemBounds.TopLeft);
        DrawParams.DrawSelected := ADrawHot;
        if not ADrawHot then
          DrawParams.HotPartIndex := icpNone;
        AFadingHelper.DrawButtonBackground(DrawParams);
        ABitmap.cxCanvas.ViewportOrg := cxNullPoint;
      finally
        DrawParams.DrawSelected := APrevDrawSelected;
        DrawParams.HotPartIndex := APrevHotPartIndex;
      end;
    finally
      FActiveCanvas := nil;
      CalcDrawParams(False);
    end;
  end;

var
  AFadingHelper: IdxFadingPainterHelper;
  R: TRect;
begin
  if (DrawParams.PaintType <> ptMenu) and Supports(Painter, IdxFadingPainterHelper, AFadingHelper) then
  begin
    R := ItemBounds;
    OffsetRect(R, -R.Left, -R.Top);
    AFadeInImage := TcxBitmap32.CreateSize(R, True);
    AFadeOutImage := TcxBitmap32.CreateSize(R, True);
    PrepareImage(AFadeOutImage, AFadingHelper, False);
    PrepareImage(AFadeInImage, AFadingHelper, True);
    if AFadingHelper.BarMarkIsOpaque then
    begin
      TcxBitmap32(AFadeOutImage).MakeOpaque;
      TcxBitmap32(AFadeInImage).MakeOpaque;
    end;
  end;
end;

function TdxBarButtonLikeControl.IsFlatText: Boolean;
begin
  Result := Painter.UseTextColorForItemArrow;
end;

function TdxBarButtonLikeControl.IsTextSelected: Boolean;
begin
  Result := Painter.IsCustomSelectedTextColorExists(Self);
end;

procedure TdxBarButtonLikeControl.KeyDown(var Key: Word; Shift: TShiftState);
begin
  inherited;
  if WantsKey(Key) then
    DropDown(False);
end;

function TdxBarButtonLikeControl.WantsKey(Key: Word): Boolean;
begin
  Result := inherited WantsKey(Key) or
    IsDropDown and
    ((Parent.Kind = bkSubMenu) and (Key = VK_RIGHT) or
     (Parent.Kind <> bkSubMenu) and (Key in [VK_UP, VK_DOWN]));
end;

procedure TdxBarButtonLikeControl.FinishSubMenuTracking;
begin
  if ABarActivationDropDownControl = Self then
    FinishSubMenuActivationTracking;
  if ABarDeActivationDropDownControl = Self then
    FinishSubMenuDeActivationTracking;
end;

procedure TdxBarButtonLikeControl.StartSubMenuTracking(AActivation: Boolean);
begin
  if AActivation then
  begin
    if ABarDeActivationDropDownControl = Self then
      FinishSubMenuDeActivationTracking;
    if ABarActivationDropDownControl <> nil then
      FinishSubMenuActivationTracking;
    StartSubMenuActivationTracking(Self);
  end
  else
  begin
    if ABarActivationDropDownControl = Self then
      FinishSubMenuActivationTracking;
    if IsDroppedDown then
    begin
      if ABarDeActivationDropDownControl <> nil then
        FinishSubMenuDeActivationTracking;
      StartSubMenuDeActivationTracking(Self);
    end;
  end;
end;

procedure TdxBarButtonLikeControl.DoCloseUp(AHadSubMenuControl: Boolean);
begin
  FinishSubMenuTracking;
  if AHadSubMenuControl then
    SubMenuControl.Hide;
  Repaint;
end;

function TdxBarButtonLikeControl.GetDrawParams: TdxBarButtonLikeControlDrawParams;
begin
  Result := TdxBarButtonLikeControlDrawParams(FDrawParams);
end;

function TdxBarButtonLikeControl.GetGlyphLayout: TdxBarGlyphLayout;
begin
  Result := Painter.GetGlyphLayout(DrawParams);
end;

{ TdxBarButtonControl }

destructor TdxBarButtonControl.Destroy;
begin
  if (Parent.FButtonPressTimer <> nil) and (Parent.FButtonPressTimer.Tag = TdxNativeInt(Self)) then
    FreeAndNil(Parent.FButtonPressTimer);
  inherited;
end;

function TdxBarButtonControl.IsDroppedDown: Boolean;
begin
  Result := FDroppedDown and (SubMenuControl <> nil);
end;

function TdxBarButtonControl.GetButtonItem: TdxBarCustomButton;
begin
  if Item is TdxBarCustomButton then
    Result := TdxBarCustomButton(Item)
  else
    Result := nil;
end;

function TdxBarButtonControl.GetDown: Boolean;
begin
  if ButtonItem <> nil then
    Result := ButtonItem.Down
  else
    Result := False;
end;

function TdxBarButtonControl.GetDropDownEnabled: Boolean;
begin
  Result := (ButtonItem <> nil) and ButtonItem.DropDownEnabled;
end;

function TdxBarButtonControl.GetDroppedDownFlat: Boolean;
begin
  Result := Painter.IsFlatItemText and IsDroppedDown;
end;

function TdxBarButtonControl.GetGroupIndex: Integer;
begin
  Result := ButtonItem.GroupIndex;
end;

function TdxBarButtonControl.GetInternalStates: TdxBarButtonStates;
begin
  if ButtonItem <> nil then
    Result := ButtonItem.FInternalStates
  else
    Result := [];
end;

function TdxBarButtonControl.GetKind: TdxBarButtonControlKind;
begin
  if IsDropDown then
  begin
    if cxIsTouchModeEnabled and (GetViewSize = cvsSmall) and (GetPaintType <> ptMenu) then
      Result := bbckDropDown
    else
      Result := bbckDropDownButton
  end
  else
    Result := bbckStandard;
end;

function TdxBarButtonControl.GetLowered: Boolean;
begin
  Result := (ButtonItem <> nil) and ButtonItem.Lowered;
end;

procedure TdxBarButtonControl.DoButtonPressTimer(Sender: TObject);

  function NeedStopTimer: Boolean;
  begin
    Result := not (ssLeft in KeyboardStateToShiftState);
  end;

begin
  if NeedStopTimer then
    FreeAndNil(Parent.FButtonPressTimer)
  else
  begin
    Parent.FButtonPressTimer.Interval := cxButtonsRepeatPause;
    if IsPressed and (HotPartIndex = bcpButton) then
      ButtonItem.DirectClick;
  end;
end;

function TdxBarButtonControl.MouseOverArrow: Boolean;
begin
  Result := IsDropDown and (HotPartIndex = bcpDropButton);
end;

procedure TdxBarButtonControl.CalcDrawParams(AFull: Boolean = True);
begin
  inherited CalcDrawParams(AFull);
  if AFull then
  begin
    DrawParams.ShortCut := ShortCutToText(ShortCut);
    DrawParams.IsPressed := IsPressed;
    DrawParams.Downed := Down;
    DrawParams.DrawDowned := DrawParams.IsPressed;
    DrawParams.DroppedDown := DroppedDown;
    DrawParams.DroppedDownFlat := DroppedDownFlat;
    DrawParams.DropDownEnabled := DropDownEnabled;
    DrawParams.SplitDropDown := Kind <> bbckDropDown;
    DrawParams.GrayScale := GrayScale;
    DrawParams.IsLowered := Lowered;
  end;
end;

procedure TdxBarButtonControl.CalcParts;
begin
  inherited CalcParts;
  Painter.CalculateButtonParts(DrawParams, FParts, ItemBounds);
end;

procedure TdxBarButtonControl.ControlClick(AByMouse: Boolean; AKey: Char = #0);

  function CanDropDown: Boolean;
  begin
    Result := MousePressed and ((Kind = bbckDropDown) or
      (Kind = bbckDropDownButton) and MouseOverArrow);
  end;

begin
  inherited ControlClick(AByMouse, AKey);

  if (Parent is TdxBarControl) and not TdxBarControl(Parent).IsDowned then
    Exit;

  if CanDropDown then
    DropDown(AByMouse)
  else
    if (Parent is TdxBarControl) or IsDropDown then
      Repaint;
end;

procedure TdxBarButtonControl.ControlUnclick(ByMouse: Boolean);
begin
  if (Kind <> bbckDropDown) and (not ByMouse or (HotPartIndex = bcpButton)) then
  begin
    if bstChecked in InternalStates then
      ButtonItem.Down := not ButtonItem.Down;
    ControlInactivate(True);
    inherited ControlUnclick(ByMouse);
  end;
end;

procedure TdxBarButtonControl.ControlGetFocus(AIsSelected: Boolean; var AProcessed: Boolean);
begin
  if AIsSelected and Parent.IsDowned and IsDroppedDown and (HotPartIndex = bcpButton) and (Kind <> bbckDropDown) then
  begin
    if bboSubMenuCaptureMouse in Parent.BehaviorOptions then
      Parent.BarLostFocus;
    Parent.BarGetFocus(Self)
  end
  else
    inherited ControlGetFocus(AIsSelected, AProcessed);
end;

procedure TdxBarButtonControl.DoCloseUp(AHadSubMenuControl: Boolean);
begin
//  if AHadSubMenuControl then
//    SubMenuControl.FDropDownButton := nil;
  FDroppedDown := False;
  inherited;
end;

procedure TdxBarButtonControl.DoDropDown(AByMouse: Boolean);
var
  ARect: TRect;
  P: TPoint;
begin
  if not FDroppedDown and Enabled and DropDownEnabled and
    (ButtonItem.DropDownMenu <> nil) then
  begin
    FDroppedDown := True;
    Parent.MakeItemControlFullyVisible(Self);
    Repaint;
    ARect := Parent.GetItemRect(Self);
    if (Parent.Kind = bkSubMenu) or Parent.IsRealVertical then
    begin
      if UseRightToLeftAlignment then
        P := Point(ARect.Left, ARect.Top)
      else
        P := Point(ARect.Right, ARect.Top);
      if {not Flat or }(Parent.Kind = bkSubMenu) then // fix
        Dec(P.Y, SubMenuParent.BorderSize);
    end
    else
      if UseRightToLeftAlignment then
        P := Point(ARect.Right, ARect.Bottom)
      else
        P := Point(ARect.Left, ARect.Bottom);
    P := Parent.ClientToScreen(P);
    ButtonItem.DoDropDown(Self, P.X, P.Y, AByMouse);
    if Painter.IsDropDownRepaintNeeded then Repaint;
    if AByMouse then
      Parent.ActivateHint(True, '', Self);
  end;
end;

function TdxBarButtonControl.DrawSelected: Boolean;
begin
  Result := inherited DrawSelected and not FParent.IsCustomizing or Pressed;
end;

procedure TdxBarButtonControl.DropDown(AByMouse: Boolean);
begin
  inherited;
  ControlActivate(True, AByMouse);
end;

function TdxBarButtonControl.FadingDrawSelected: Boolean;
begin
  Result := inherited FadingDrawSelected or Pressed;
end;

function TdxBarButtonControl.GetSubMenuControl: TdxBarSubMenuControl;
begin
  if (ButtonItem <> nil) and (ButtonItem.DropDownMenu <> nil) then
    Result := TdxBarSubMenuControl(ButtonItem.DropDownMenu.ItemLinks.BarControl)
  else
    Result := nil;
end;

function TdxBarButtonControl.IsFlatText: Boolean;
begin
  Result := not IsTextSelected or inherited IsFlatText;
end;

function TdxBarButtonControl.IsTextSelected: Boolean;
begin
  Result := Painter.IsFlatItemText and
    (((IsPressed or Down and DrawSelected) and Painter.IsItemTextSelectedInverted) or
    ((IsPressed or Down or DrawSelected) and (IsHighContrastWhite and not DroppedDown or inherited IsTextSelected)));
end;

procedure TdxBarButtonControl.MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  inherited;

  if (ButtonItem <> nil) and ButtonItem.RepeatClick and (Button = mbLeft) then
  begin
    if Parent.FButtonPressTimer <> nil then
      Parent.FButtonPressTimer.Reset
    else
      Parent.FButtonPressTimer := cxCreateTimer(DoButtonPressTimer, cxButtonsRepeatInitPause, True);
    Parent.FButtonPressTimer.Tag := TdxNativeInt(Self);
  end;
end;

function TdxBarButtonControl.GetDefaultHeight: Integer;
begin
  Result := inherited GetDefaultHeight;
  if Lowered then
    Inc(Result, 2 * Painter.LoweredBorderSize(Self));
  Inc(Result, cxMarginsHeight(DrawParams.ContentOffset));
end;

function TdxBarButtonControl.GetDefaultWidth: Integer;
begin
  Result := inherited GetDefaultWidth;
  Painter.InflateSizeForArrow(DrawParams, Result);
  if Lowered then
    Inc(Result, 2 * Painter.LoweredBorderSize(Self));
  Inc(Result, cxMarginsWidth(DrawParams.ContentOffset));
end;

function TdxBarButtonControl.GetSmallHeight: Integer;
begin
  Result := inherited GetSmallHeight;
  if cpText in DrawParams.ViewStructure then
    Result := Max(Result, GetRotationDependentHeight(DrawParams.DefaultButtonSize));
end;

function TdxBarButtonControl.GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass;
begin
  Result := TdxBarButtonControlAccessibilityHelper;
end;

function TdxBarButtonControl.GetDefaultViewStructure: TdxBarItemControlViewStructure;
begin
  case PaintStyle of
    psStandard:
      if GetPaintType = ptMenu then
        Result := [cpIcon, cpText]
      else
        if IconAssigned then
          Result := [cpIcon]
        else
          Result := [cpText];

    psCaption:
      Result := [cpText];

    psCaptionInMenu:
      if GetPaintType = ptMenu then
        Result := [cpText]
      else
        Result := [cpIcon];

    psCaptionGlyph:
      Result := [cpIcon, cpText];
  end;
end;

function TdxBarButtonControl.GetOwnedBarControl: TCustomdxBarControl;
begin
  Result := SubMenuControl;
end;

function TdxBarButtonControl.GetPaintStyle: TdxBarPaintStyle;
begin
  if FItemLink <> nil then
    Result := FItemLink.PaintStyle
  else
    Result := psStandard;
//  if (Parent is TdxBarControl) and (Result = psStandard) and not ImageExists then
//    Result := psCaption;
  if (Parent is TdxBarControl) and (Result = psStandard) then
    PreparePaintStyleOnBar(Result);
end;

function TdxBarButtonControl.GetPartCount: Integer;
begin
  if FDrawParams.IsDropDown then
    Result := 2
  else
    Result := 1;
end;

function TdxBarButtonControl.GetViewStructure: TdxBarItemControlViewStructure;
begin
  if ViewInfo.ViewLevel = ivlSmallIcon then
    Result := [cpIcon]
  else
    Result := inherited GetViewStructure;
end;

function TdxBarButtonControl.CanDestroyOnClick: Boolean;
begin
  Result := (Parent is TdxBarControl) or ButtonItem.CloseSubMenuOnClick;
end;

function TdxBarButtonControl.IsDropDown: Boolean;
begin
  Result := bstDropDown in InternalStates;
end;

function TdxBarButtonControl.IsPressed: Boolean;
begin
  Result := DrawSelected and Parent.IsActive and MousePressed and (HotPartIndex = bcpButton) or
    Pressed and not (bstChecked in InternalStates) or (Kind = bbckDropDown) and IsDroppedDown;
end;

function TdxBarButtonControl.NeedCaptureMouse: Boolean;
begin
  Result := not DroppedDown and (Parent.Kind = bkBarQuickControl);
end;

procedure TdxBarButtonControl.PaintStyleChanged;
begin
  Parent.RepaintBar;
end;

procedure TdxBarButtonControl.PreparePaintStyleOnBar(var APaintStyle: TdxBarPaintStyle);
begin
  if not IconAssigned then
    APaintStyle := psCaption;
end;

{ TdxBarLargeButtonControl }

function TdxBarLargeButtonControl.GetHotGlyph: TdxSmartGlyph;
begin
  Result := Item.HotGlyph;
end;

function TdxBarLargeButtonControl.GetItem: TdxBarLargeButton;
begin
  Result := TdxBarLargeButton(ItemLink.Item);
end;

function TdxBarLargeButtonControl.IsInheritedBehaviour: Boolean;
begin
  Result := GetPaintType = ptMenu;
end;

function TdxBarLargeButtonControl.IsSizeAssigned: Boolean;
begin
  with Item do
    Result := (Width <> 0) and (Height <> 0);
end;

function TdxBarLargeButtonControl.ArrowWidth: Integer;
begin
  if Parent is TdxBarControl then
    Result := ScaleFactor.Apply(Painter.RealLargeButtonArrowWidth(BarManager))
  else
    Result := inherited ArrowWidth;
end;

procedure TdxBarLargeButtonControl.HotGlyphChanged;
begin
  LargeGlyphChanged;
end;

procedure TdxBarLargeButtonControl.LargeGlyphChanged;
begin
  if DrawParams.ViewSize = cvsLarge then
    if IsSizeAssigned or (DrawParams.PaintType = ptMenu) then
      Repaint
    else
      Parent.RepaintBar;
end;

function TdxBarLargeButtonControl.GetCurrentImage(AViewSize: TdxBarItemControlViewSize; ASelected: Boolean;
  out AGlyph: TdxSmartGlyph; out AImages: TCustomImageList; out AImageIndex: Integer; out ADrawImageEnabled: TdxDefaultBoolean): Boolean;

  function CheckHotGlyph: Boolean;
  begin
    Result := True;
    if not HotGlyph.Empty then
      AGlyph := HotGlyph
    else
      if Item.IsHotImageLinked then
      begin
        AImages := HotImages;
        AImageIndex := Item.HotImageIndex;
      end
      else
        Result := False;
  end;

  function CheckLargeGlyph: Boolean;
  begin
    Result := True;
    if not LargeGlyph.Empty then
      AGlyph := LargeGlyph
    else
      if Item.IsLargeImageLinked then
      begin
        AImages := GetLargeImages(Enabled, ADrawImageEnabled);
        AImageIndex := LargeImageIndex;
      end
      else
        Result := False;
  end;

begin
  if DrawParams.ViewSize = cvsLarge then
  begin
    AGlyph := nil;
    AImages := nil;
    AImageIndex := -1;
    ADrawImageEnabled := bDefault;
    if ASelected then
      Result := CheckHotGlyph or CheckLargeGlyph
    else
      Result := CheckLargeGlyph or CheckHotGlyph;
  end
  else
    Result := inherited;
end;

function TdxBarLargeButtonControl.GetDefaultViewStructure: TdxBarItemControlViewStructure;
begin
  if IsInheritedBehaviour then
    Result := inherited GetDefaultViewStructure
  else
  begin
    Result := [cpIcon];
    if Item.ShowCaption then
      Include(Result, cpText);
  end;
end;

function TdxBarLargeButtonControl.GetDefaultViewSize: TdxBarItemControlViewSize;
begin
  if IsInheritedBehaviour then
    Result := inherited GetDefaultViewSize
  else
    Result := cvsLarge;
end;

function TdxBarLargeButtonControl.GetPossibleViewLevels: TdxBarItemViewLevels;
begin
  Result := inherited GetPossibleViewLevels;
  Include(Result, ivlLargeIconWithText);
end;

function TdxBarLargeButtonControl.GrayScale: Boolean;
begin
  Result := not DrawSelected and Enabled and Item.AutoGrayScale;
end;

function TdxBarLargeButtonControl.InternalGetDefaultHeight: Integer;
begin
  if Item.Height = 0 then
    Result := inherited InternalGetDefaultHeight
  else
    Result := Item.Height;
end;

function TdxBarLargeButtonControl.InternalGetDefaultWidth: Integer;
begin
  if Item.Width = 0 then
    Result := inherited InternalGetDefaultWidth
  else
    Result := Item.Width;
end;

function TdxBarLargeButtonControl.IsRotated: Boolean;
begin
  Result := inherited IsRotated and Item.ShowCaption;
end;

procedure TdxBarLargeButtonControl.PreparePaintStyleOnBar(var APaintStyle: TdxBarPaintStyle);
begin
  APaintStyle := psCaption;
end;

{ TdxBarApplicationMenuButtonControl }

procedure TdxBarApplicationMenuButtonControl.CalcDrawParams(AFull: Boolean = False);
begin
  inherited CalcDrawParams(AFull);
  if AFull then
    DrawParams.ContentWidth := inherited InternalGetDefaultWidth;
end;

procedure TdxBarApplicationMenuButtonControl.DoPaint(ARect: TRect; PaintType: TdxBarPaintType);
begin
  Painter.ApplicationMenuDrawButton(DrawParams, ARect);
end;

procedure TdxBarApplicationMenuButtonControl.GetDefaultTextColors(
  AEnabled, ASelected, AFlat: Boolean; var AColor1, AColor2: TColor);
begin
  AColor1 := Painter.ApplicationMenuButtonTextColor(AEnabled, ASelected);
  AColor2 := AColor1;
end;

function TdxBarApplicationMenuButtonControl.GetDefaultViewStructure: TdxBarItemControlViewStructure;
begin
  Result := [cpText];
  if IconAssigned then
    Include(Result, cpIcon);
end;

function TdxBarApplicationMenuButtonControl.GetDrawParamsClass: TdxBarItemControlDrawParamsClass;
begin
  Result := TdxBarApplicationMenuButtonControlDrawParams;
end;

function TdxBarApplicationMenuButtonControl.GetPaintType: TdxBarPaintType;
begin
  Result := ptHorz;
end;

function TdxBarApplicationMenuButtonControl.InternalGetDefaultWidth: Integer;
begin
  if Item.Width <> 0 then
    Result := Item.Width
  else
    Result := inherited InternalGetDefaultWidth;
end;

procedure TdxBarApplicationMenuButtonControl.CaptionChanged;
begin
  Parent.Repaint;
end;

procedure TdxBarApplicationMenuButtonControl.GlyphChanged;
begin
  Parent.Repaint;
end;

procedure TdxBarApplicationMenuButtonControl.VisibleChanged;
begin
  Parent.Repaint;
end;

procedure TdxBarApplicationMenuButtonControl.WidthChanged;
begin
  Parent.Repaint;
end;

function TdxBarApplicationMenuButtonControl.GetDrawParams: TdxBarApplicationMenuButtonControlDrawParams;
begin
  Result := TdxBarApplicationMenuButtonControlDrawParams(FDrawParams);
end;

{ TdxBarCustomEditControl }

destructor TdxBarCustomEditControl.Destroy;
begin
  FreeAndNil(FBkBrush);
  inherited Destroy;
end;

procedure TdxBarCustomEditControl.CorrectFrameRect(var ARect: TRect);
begin
// do nothing
end;

procedure TdxBarCustomEditControl.DoCalcDrawingConsts;
var
  ASavedFont: TdxBarSavedFont;
begin
  inherited DoCalcDrawingConsts;
  PrepareCanvasFont(Parent.EditFontHandle, Item.StyleEdit, ASavedFont);
  try
    FEditTextSize := Parent.GetTextSize;
  finally
    RestoreCanvasFont(ASavedFont);
  end;
end;

procedure TdxBarCustomEditControl.DoPaint(ARect: TRect; PaintType: TdxBarPaintType);
begin
  Painter.DrawEditLikeControl(DrawParams, ARect);
end;

procedure TdxBarCustomEditControl.DoRightToLeftConversion(const ABounds: TRect);
var
  I: Integer;
begin
  inherited DoRightToLeftConversion(ABounds);
  for I := Low(FAreaParts) to High(FAreaParts) do
    FAreaParts[I] := TdxRightToLeftLayoutConverter.ConvertRect(FAreaParts[I], ABounds);
end;

procedure TdxBarCustomEditControl.DrawFrame;

  function IsEditorFrameOnly: Boolean;
  begin
    Result := not IsEditTransparent or (GetPaintType = ptMenu);
  end;

var
  AFrameRect, AContentRect: TRect;
begin
  if IsEditorFrameOnly then
    AFrameRect := GetEditRect
  else
    AFrameRect := ItemBounds;

  CorrectFrameRect(AFrameRect);
  AContentRect := AFrameRect;
  Painter.EditControlDrawBorder(DrawParams, AContentRect);
  ExcludeFrameRegion(Canvas, AFrameRect, AContentRect);
end;

procedure TdxBarCustomEditControl.CalcDrawParams(AFull: Boolean = True);
begin
  inherited;
  if AFull then
  begin
    DrawParams.IsTransparent := IsEditTransparent;
    DrawParams.Focused := Focused;
    DrawParams.ViewLayout := GetViewLayout;
  end;
end;

procedure TdxBarCustomEditControl.CalcParts;
begin
  inherited CalcParts;
  CalculateAreaParts;
  Painter.CalculateEditParts(DrawParams, FParts, FAreaParts);
end;

procedure TdxBarCustomEditControl.DrawEditSizingFrame(AWidth: Integer);
var
  AItemRect: TRect;
  ADC: HDC;
begin
  AItemRect := ItemBounds;
  if FRightBorderSizing then
    AItemRect.Right := AItemRect.Left + AWidth
  else
    AItemRect.Left := AItemRect.Right - AWidth;
  ADC := GetDC(0);
  AItemRect := dxMapWindowRect(Parent.Handle, 0, AItemRect);
  with AItemRect do
  begin
    PatBlt(ADC, Left, Top, Right - Left, 2, DSTINVERT);
    PatBlt(ADC, Left, Bottom - 2, Right - Left, 2, DSTINVERT);
    PatBlt(ADC, Left, Top + 2, 2, Bottom - Top - 4, DSTINVERT);
    PatBlt(ADC, Right - 2, Top + 2, 2, Bottom - Top - 4, DSTINVERT);
  end;
  ReleaseDC(0, ADC);
end;

function TdxBarCustomEditControl.DrawSelected: Boolean;
begin
  Result := inherited DrawSelected and not FParent.IsCustomizing and AllowSelectWithoutFocusing;
end;

function TdxBarCustomEditControl.GetDefaultViewStructure: TdxBarItemControlViewStructure;
begin
  Result := [];
  if ShowCaption then
    Result := [cpText];
  if IconAssigned and Painter.EditControlShowIconDefault(DrawParams) then
    Include(Result, cpIcon);
end;

function TdxBarCustomEditControl.GetDrawParamsClass: TdxBarItemControlDrawParamsClass;
begin
  Result := TdxBarEditLikeControlDrawParams;
end;

function TdxBarCustomEditControl.GetPartCount: Integer;
begin
  Result := inherited GetPartCount + 2;
end;

function TdxBarCustomEditControl.GetPossibleViewLevels: TdxBarItemViewLevels;
begin
  Result := inherited GetPossibleViewLevels;
  Include(Result, ivlControlOnly);
end;

function TdxBarCustomEditControl.GetCaptionAreaWidth: Integer;
begin
  Result := 0;
  if cpText in DrawParams.ViewStructure then
  begin
    Result := GetCaptionWidth;
    if Result <> 0 then
      Inc(Result, GetIndents(cpText).Right);
    Inc(Result, GetIndents(cpText).Left);
  end;
end;

function TdxBarCustomEditControl.GetControlAreaWidth: Integer;
begin
  Result := Max(GetMinEditorWidth, ItemLink.Width);
end;

function TdxBarCustomEditControl.GetGlyphAreaWidth: Integer;
begin
  if cpIcon in DrawParams.ViewStructure then
    Result := GetGlyphSize(DrawParams.ViewSize).cx + cxMarginsWidth(GetIndents(cpIcon))
  else
    Result := 0;
end;

procedure TdxBarCustomEditControl.CalculateAreaParts;
var
  AEditRect: TRect;
  ASavedFont: TdxBarSavedFont;
  ATextRect: TRect;
  ATransparentIndent, ACaptionAreaWidth, AGlyphAreaWidth: Integer;
begin
  PrepareCanvasFont(0, Item.Style, ASavedFont);
  try
    SetLength(FAreaParts, 0);
    SetLength(FAreaParts, 3);

    AEditRect := ItemBounds;

    if not IsRectEmpty(AEditRect) then
    begin
      FAreaParts[ecpIcon] := AEditRect;
      FAreaParts[ecpText] := AEditRect;
      FAreaParts[ecpEdit] := AEditRect;

      if DrawParams.ViewSize = cvsLarge then
      begin
        FAreaParts[ecpEdit].Left := FAreaParts[ecpEdit].Right - GetControlAreaWidth;
        FAreaParts[ecpIcon].Right := FAreaParts[ecpEdit].Left;
        FAreaParts[ecpText].Right := FAreaParts[ecpEdit].Left;
        ATextRect := cxGetTextRect(Canvas.Handle, Caption, 2{GetMaxLineCount}, True);
        FAreaParts[ecpText].Top := FAreaParts[ecpText].Bottom - cxRectHeight(ATextRect) - 1;
      end
      else
      begin
        if DrawParams.IsTransparent and (DrawParams.PaintType <> ptMenu) then
          ATransparentIndent := Painter.EditControlBorderOffsets(DrawParams.PaintType).Left
        else
          ATransparentIndent := 0;
        AGlyphAreaWidth := GetGlyphAreaWidth;
        ACaptionAreaWidth := GetCaptionAreaWidth;
        case GetViewLayout of
          ivlGlyphCaptionControl:
            begin
              FAreaParts[ecpIcon].Right := FAreaParts[ecpIcon].Left + AGlyphAreaWidth + ATransparentIndent;

              FAreaParts[ecpText].Left := FAreaParts[ecpIcon].Right;
              FAreaParts[ecpText].Right := FAreaParts[ecpText].Left + ACaptionAreaWidth;

              FAreaParts[ecpEdit].Left := FAreaParts[ecpEdit].Left + ACaptionAreaWidth + AGlyphAreaWidth;
            end;

        ivlGlyphControlCaption:
          begin
            FAreaParts[ecpIcon].Right := FAreaParts[ecpIcon].Left + AGlyphAreaWidth;
            FAreaParts[ecpText].Left := FAreaParts[ecpText].Right - ACaptionAreaWidth;

            FAreaParts[ecpEdit].Left := FAreaParts[ecpIcon].Right;
            FAreaParts[ecpEdit].Right := FAreaParts[ecpText].Left;
          end;
        end;
      end;
    end;
  finally
    RestoreCanvasFont(ASavedFont);
  end;
end;

function TdxBarCustomEditControl.GetDefaultHeight: Integer;
begin
  Result := GetEditTextSize;
  if ShowCaption then
    Result := Max(Result, Parent.GetDefaultItemHeight(Self));
end;

function TdxBarCustomEditControl.GetDefaultWidth: Integer;
begin
  if FDrawParams.ViewSize = cvsLarge then
    Result := GetDefaultLargeWidth
  else
    Result := GetDefaultSmallWidth;
end;

function TdxBarCustomEditControl.GetEditOffset: Integer;
begin
  if UseRightToLeftAlignment then
    Result := ItemBounds.Right - GetEditRect.Right
  else
    Result := GetEditRect.Left - ItemBounds.Left;
end;

function TdxBarCustomEditControl.GetEditRect: TRect;
begin
  if Length(FAreaParts) > 0 then
  begin
    Result := FAreaParts[ecpEdit];
    if (DrawParams.ViewSize <> cvsLarge) and (Align = iaClient) and not (bboExtendItemWhenAlignedToClient in Parent.BehaviorOptions) then
      if FIsRightToLeftConverted then
        Result.Right := Result.Left + GetControlAreaWidth
      else
        Result.Left := Result.Right - GetControlAreaWidth;
  end
  else
    Result := cxEmptyRect;
end;

function TdxBarCustomEditControl.GetEditTextSize: Integer;
begin
  if (Item.StyleEdit <> nil) and (svFont in Item.StyleEdit.AssignedValues) then
    Result := FEditTextSize
  else
    Result := Parent.EditTextSize;
end;

function TdxBarCustomEditControl.GetIndents(ADrawAreaType: TdxBarItemControlPart): TRect;
begin
  Result := Painter.EditControlIndents(DrawParams, ADrawAreaType);
end;

function TdxBarCustomEditControl.GetMinWidth: Integer;
begin
  if DrawParams.ViewSize = cvsLarge then
    Result := Max(GetGlyphAreaWidth, GetCaptionAreaWidth) + GetMinEditorWidth
  else
    Result := GetGlyphAreaWidth + GetCaptionAreaWidth + GetMinEditorWidth;
end;

function TdxBarCustomEditControl.GetShowCaption: Boolean;
begin
  Result := (Parent.Kind = bkSubMenu) or Item.ShowCaption;
end;

function TdxBarCustomEditControl.GetViewLayout: TdxBarItemViewLayout;
begin
  if Parent.Kind = bkSubMenu then
    Result := ivlGlyphCaptionControl
  else
    Result := ItemLink.ViewLayout;
end;

procedure TdxBarCustomEditControl.Show;
begin
  inherited Show;
  InitEdit;
end;

procedure TdxBarCustomEditControl.BeginResize(APoint: TPoint);
begin
  FRightBorderSizing := PtInRect(RightSizingRect, APoint);
  FSizingEditWidth := cxRectWidth(ItemBounds);
  Paint(Canvas, ItemBounds, ptHorz);
  DrawEditSizingFrame(FSizingEditWidth);
end;

function TdxBarCustomEditControl.CanResize(APoint: TPoint): Boolean;
begin
  Result := BarManager.IsCustomizing and (PtInRect(RightSizingRect, APoint) or PtInRect(LeftSizingRect, APoint));
end;

procedure TdxBarCustomEditControl.EndResize(AAllowResize: Boolean);
begin
  DrawEditSizingFrame(FSizingEditWidth);
  if AAllowResize and (GetControlAreaWidth <> FSizingEditWidth - GetEditOffset) then
    ItemLink.UserWidth := FSizingEditWidth - GetEditOffset
  else
    Repaint;
end;

procedure TdxBarCustomEditControl.Resizing(APoint: TPoint);
var
  AItemRect: TRect;
  APrevSizingEditWidth: Integer;
begin
  AItemRect := ItemBounds;
  APrevSizingEditWidth := FSizingEditWidth;
  if FRightBorderSizing then
    FSizingEditWidth := APoint.X - AItemRect.Left
  else
    FSizingEditWidth := AItemRect.Right - APoint.X;

  CheckEditWidth(FSizingEditWidth, MinWidth);

  if FSizingEditWidth <> APrevSizingEditWidth then
  begin
    DrawEditSizingFrame(APrevSizingEditWidth);
    DrawEditSizingFrame(FSizingEditWidth);
  end;
end;

function TdxBarCustomEditControl.HotPartWantMouse: Boolean;
begin
  Result := inherited HotPartWantMouse;
  if not BarManager.IsCustomizing and (GetPaintType <> ptMenu) then
   // Result := Result and not (FHotPartIndex in ecpHeaderParts);
    Result := Result and not (HotPartIndex in [ecpIcon, ecpText]) // TODO must be checked
end;

procedure TdxBarCustomEditControl.RefreshBkBrush(var AHandle: HBRUSH);
begin
  if FBkBrush = nil then
    FBkBrush := TBrush.Create;
  FBkBrush.Color := Painter.EditGetBkColor(DrawParams);
  AHandle := FBkBrush.Handle;
end;

function TdxBarCustomEditControl.GetCaptionBkBrush: HBRUSH;
begin
  if DrawSelected and (GetPaintType = ptMenu) then
    Result := Parent.ToolbarSelBrush
  else
    Result := Parent.BkBrush;
end;

function TdxBarCustomEditControl.GetDrawParams: TdxBarEditLikeControlDrawParams;
begin
  Result := TdxBarEditLikeControlDrawParams(FDrawParams);
end;

function TdxBarCustomEditControl.GetEditBkBrush: HBRUSH;
begin
  RefreshBkBrush(Result);
end;

function TdxBarCustomEditControl.GetEditFont: TFont;
var
  AStyleEdit: TcxStyle;
begin
  AStyleEdit := Item.StyleEdit;
  if (AStyleEdit <> nil) and (svFont in AStyleEdit.AssignedValues) then
    Result := AStyleEdit.Font
  else
    Result := Parent.EditFont;
end;

function TdxBarCustomEditControl.GetItem: TdxCustomBarEdit;
begin
  Result := TdxCustomBarEdit(inherited GetItem);
end;

function TdxBarCustomEditControl.LeftSizingRect: TRect;
begin
  Result := ItemBounds;
  Result.Right := Result.Left + EditSizingZoneSize;
end;

function TdxBarCustomEditControl.RightSizingRect: TRect;
begin
  Result := ItemBounds;
  Result.Left := Result.Right - EditSizingZoneSize;
end;

{ TdxBarEditControl }

constructor TdxBarEditControl.Create(AItemLink: TdxBarItemLink);
begin
  inherited Create(AItemLink);
  if not ((Parent is TdxBarControl) and TdxBarControl(Parent).Moving) then
    CreateInnerEdit;
end;

destructor TdxBarEditControl.Destroy;
begin
  if not ((Parent is TdxBarControl) and TdxBarControl(Parent).Moving) then
    DestroyInnerEdit;
  inherited Destroy;
end;

procedure TdxBarEditControl.CreateWindowHandle;
var
  AExStyle: Cardinal;
begin
  AExStyle := 0;
  Parent.AddBiDiModeExStyle(AExStyle);
  FHandle := CreateWindowEx(AExStyle, 'EDIT', '', getWindowStyle, 0, 0, 100, 100, Parent.Handle, 0, HInstance, nil);

  RestoreDisplayValue;
  SetLimitText;
end;

procedure TdxBarEditControl.DestroyWindowHandle(ADestroyWindow: Boolean = True);
begin
  dxBar.DestroyWindowHandle(FHandle, ADestroyWindow);
end;

function TdxBarEditControl.GetItem: TdxBarEdit;
begin
  Result := TdxBarEdit(ItemLink.Item);
end;

function TdxBarEditControl.GetMaxLength: Integer;
begin
  Result := Item.MaxLength;
end;

function TdxBarEditControl.GetReadOnly: Boolean;
begin
  Result := Item.ReadOnly;
end;

procedure TdxBarEditControl.SetLimitText;
begin
  SendMessage(FHandle, EM_SETLIMITTEXT, MaxLength, 0);
end;

function TdxBarEditControl.CanDrawEditor: Boolean;
begin
  Result := not Focused or not Enabled;
end;

function TdxBarEditControl.getWindowStyle: DWORD;
begin
  Result := WS_CHILD or ES_AUTOHSCROLL or ES_MULTILINE;
end;

procedure TdxBarEditControl.ControlClick(AByMouse: Boolean; AKey: Char = #0);
var
  ALinkSelf: TcxObjectLink;
begin
  ALinkSelf := cxAddObjectLink(Self);
  try
    inherited;
    if (ALinkSelf.Ref <> nil) and Focused then
      SendMessage(FHandle, EM_SETSEL, 0, -1);
  finally
    cxRemoveObjectLink(ALinkSelf);
  end;
end;

procedure TdxBarEditControl.CreateInnerEdit;
begin
  CreateWindowHandle;
  inherited CreateInnerEdit;
end;

procedure TdxBarEditControl.DestroyInnerEdit(AFullDestroy: Boolean = True);
begin
  inherited DestroyInnerEdit(AFullDestroy);
  DestroyWindowHandle(AFullDestroy);
end;

procedure TdxBarEditControl.DrawTextField;
var
  ASavedFont: TdxBarSavedFont;
begin
  if Enabled then
    WindowRect := FParts[ecpEdit];
  if CanDrawEditor then
  begin
    PrepareCanvasFont(Parent.EditFontHandle, Item.StyleEdit, ASavedFont);
    try
      Painter.EditControlDrawTextField(Self, Canvas, FParts[ecpEdit]);
    finally
      RestoreCanvasFont(ASavedFont);
    end;
  end;
end;

function TdxBarEditControl.GetHandle: HWND;
begin
  Result := FHandle;
end;

function TdxBarEditControl.GetMinEditorWidth: Integer;
begin
  Result := MinEditWidth;
end;

function TdxBarEditControl.GetNonBufferedRect: TRect;
begin
  if CanDrawEditor then
    Result := inherited GetNonBufferedRect
  else
    Result := FParts[ecpEdit];
end;

procedure TdxBarEditControl.Hide(AStoreDisplayValue: Boolean);
begin
  if Handle <> 0 then
    ShowWindow(Handle, SW_HIDE);
  if AStoreDisplayValue then
    StoreDisplayValue;
end;

procedure TdxBarEditControl.InitEdit;
begin
  CalcDrawParams;
end;

function TdxBarEditControl.IsTransparentOnGlass: Boolean;
begin
  Result := False;
end;

procedure TdxBarEditControl.PrepareEditWnd;
var
  R: TRect;
begin
  R := WindowRect;
  OffsetRect(R, -R.Left, -R.Top);
  Painter.EditOffsetInteriorRect(Self, R);
  SendMessage(Handle, EM_SETRECTNP, 0, LPARAM(@R));
end;

procedure TdxBarEditControl.SetFocused(Value: Boolean);
begin
  if Value <> FFocused then
  begin
    if Value{Focused} then
      SendMessage(Handle, EM_SETREADONLY, WPARAM(ReadOnly or Item.EmptyWindow), 0);
    inherited;
    Repaint;
  end;
end;

procedure TdxBarEditControl.SetText(Value: string);
var
  ANotEqual: Boolean;
begin
  ANotEqual := Text <> Value;
  inherited;
  Painter.EditControlUpdateWndText(Self, Handle, ANotEqual);
end;

procedure TdxBarEditControl.Show;
begin
  inherited Show;
  SendMessage(Handle, WM_SETFONT, EditFont.Handle, 0);
  with WindowRect do
    SetWindowPos(Handle, 0, Left, Top, Right - Left, Bottom - Top, SWP_SHOWWINDOW);
  PrepareEditWnd;

  FFocusing := True;
  try
    RestoreDisplayValue;
  finally
    FFocusing := False;
  end;

  SetFocus(Handle);
end;

procedure TdxBarEditControl.WndProc(var Message: TMessage);
begin
  case Message.Msg of
    WM_DESTROY:
      begin
        Focused := False;
        DefaultHandler(Message);
        DestroyInnerEdit(False);
      end;
    WM_PAINT:
      if OnGlass then
      begin
        dxPaintWindowOnGlass(Handle);
        Message.Result := 1;
      end
      else
        DefaultHandler(Message);
    DXM_BUFFEREDPAINTONGLASS:
      if OnGlass and InnerControlBufferedPaint then
      try
        dxDrawWindowOnGlass(Handle);
      finally
        InnerControlBufferedPaint := False;
      end;
  else
    inherited WndProc(Message);
  end;
end;

{ TCustomdxBarComboControl }

destructor TCustomdxBarComboControl.Destroy;
begin
  DroppedDown := False;
  inherited;
end;

function TCustomdxBarComboControl.IsDroppedDown: Boolean;
begin
  Result := DroppedDown;
end;

function TCustomdxBarComboControl.GetDropDownWindow: HWND;
begin
  Result := Item.DropDownWindow;
end;

function TCustomdxBarComboControl.GetItem: TCustomdxBarCombo;
begin
  Result := TCustomdxBarCombo(ItemLink.Item);
end;

function TCustomdxBarComboControl.IsSpecialKey(var Key: Word; Shift: TShiftState): Boolean;
begin
  Result := Key in [VK_UP, VK_DOWN];
end;

procedure TCustomdxBarComboControl.CalcDrawParams(AFull: Boolean = True);
begin
  inherited;
  if AFull then
    DrawParams.DroppedDown := FDroppedDown;
end;

procedure TCustomdxBarComboControl.CalcParts;
begin
  inherited CalcParts;
  Painter.CalculateComboParts(DrawParams, FParts, FAreaParts);
end;

function TCustomdxBarComboControl.CanDrawEditor: Boolean;
begin
  Result := not Enabled or not Focused or Item.EmptyWindow;
end;

procedure TCustomdxBarComboControl.ControlInactivate(Immediately: Boolean);
begin
  DroppedDown := False;
  inherited;
end;

procedure TCustomdxBarComboControl.CorrectFrameRect(var ARect: TRect);
begin
  if UseRightToLeftAlignment then
    ARect.Left := FParts[ccpDropButton].Left - Painter.ComboControlButtonOffsets(DrawParams.PaintType).Right
  else
    ARect.Right := FParts[ccpDropButton].Right + Painter.ComboControlButtonOffsets(DrawParams.PaintType).Right;
end;

procedure TCustomdxBarComboControl.DrawTextField;
begin
  Painter.ComboControlDrawArrowButton(DrawParams, FParts[ccpDropButton], True);
  inherited DrawTextField;
end;

procedure TCustomdxBarComboControl.EnabledChanged;
begin
  DroppedDown := False;
  inherited;
end;

function TCustomdxBarComboControl.GetPartCount: Integer;
begin
  Result := inherited GetPartCount + 1;
end;

function TCustomdxBarComboControl.IsChildWindow(AWnd: HWND): Boolean;
begin
  Result := inherited IsChildWindow(AWnd) or
    (DroppedDown and IsWindowVisible(DropDownWindow) and IsChildEx(DropDownWindow, AWnd));
end;

procedure TCustomdxBarComboControl.CalcDropDownPos(out APoint: TPoint);
begin
  with Parent.GetItemRect(Self) do
    if (Parent.Kind = bkSubMenu) or Parent.IsRealVertical then
    begin
      if UseRightToLeftAlignment then
        APoint.X := Left
      else
        APoint.X := Right;
      APoint.Y := Top;
    end
    else
    begin
      if UseRightToLeftAlignment then
        APoint.X := Right - GetEditOffset
      else
        APoint.X := Left + GetEditOffset;
      APoint.Y := Bottom;
    end;
  ClientToScreen(Parent.Handle, APoint);
end;

procedure TCustomdxBarComboControl.SetDroppedDown(Value: Boolean);
var
  P: TPoint;
begin
  if (FDroppedDown <> Value) and not Item.ReadOnly then
  begin
    FDroppedDown := Value;
    Repaint;
    if FDroppedDown then
    begin
      CalcDropDownPos(P);
      Item.DropDown(P.X, P.Y);
    end
    else
      Item.CloseUp;
  end;
end;

function TCustomdxBarComboControl.IsSysKeyDown(var Key: Word; Shift: TShiftState): Boolean;
begin
  Result := inherited IsSysKeyDown(Key, Shift) or
    (ssAlt in Shift) and IsSpecialKey(Key, Shift);
end;

function TCustomdxBarComboControl.IsSysKeyUp(var Key: Word; Shift: TShiftState): Boolean;
begin
  Result := inherited IsSysKeyUp(Key, Shift) or
    (ssAlt in Shift) and IsSpecialKey(Key, Shift);
end;

procedure TCustomdxBarComboControl.SysKeyDown(var Key: Word; Shift: TShiftState);
begin
  if IsSpecialKey(Key, Shift) then
  begin
    DroppedDown := not DroppedDown;
    Key := 0;
  end;
  inherited SysKeyDown(Key, Shift);
end;

procedure TCustomdxBarComboControl.SysKeyUp(var Key: Word; Shift: TShiftState);
begin
  if IsSpecialKey(Key, Shift) then
    Key := 0;
  inherited SysKeyUp(Key, Shift);
end;

procedure TCustomdxBarComboControl.WndProc(var Message: TMessage);

  function IsMouseCursorInDroppedDownArea: Boolean;
  begin
    if Item.ShowEditor then
      Result := HotPartIndex in [ccpDropButton]
    else
      Result := HotPartIndex in [ecpEdit, ccpDropButton];
  end;

  function LButtonDowned: Boolean;
  begin
    with Message do
      LButtonDowned := (Msg = WM_LBUTTONDOWN) or (Msg = WM_LBUTTONDBLCLK);
  end;

var
  Shift: TShiftState;
  AHandle: HWND;
begin
  with Message do
    case Msg of
      WM_KEYDOWN, WM_KEYUP, WM_CHAR:
        begin
          Shift := KeyDataToShiftState(lParam);
          if (Msg = WM_KEYDOWN) and (wParam = VK_F4) then
          begin
            DroppedDown := not DroppedDown;
            Exit;
          end
          else
            if DroppedDown and (DropDownWindow <> 0) and
              Item.CheckKeyForDropDownWindow(wParam, Shift) then
            begin
              Result := SendMessage(DropDownWindow, Msg, wParam, lParam);
              Exit;
            end;
        end;
    end;
  AHandle := Handle;
  inherited;
  if not IsWindowVisible(AHandle) then Exit;
  if LButtonDowned then FOnPressDroppedDown := DroppedDown;
  if IsMouseCursorInDroppedDownArea and (not FOnPressDroppedDown and LButtonDowned or
    FOnPressDroppedDown and (Message.Msg = WM_LBUTTONUP)) then
      DroppedDown := not DroppedDown;
end;

{ TdxBarComboControl }

function TdxBarComboControl.GetItem: TdxBarCustomCombo;
begin
  Result := TdxBarCustomCombo(ItemLink.Item);
end;

function TdxBarComboControl.GetItemIndex: Integer;
begin
  Result := Item.ItemIndex;
end;

function TdxBarComboControl.GetItems: TStrings;
begin
  Result := Item.Items;
end;

function TdxBarComboControl.GetSorted: Boolean;
begin
  Result := Item.Sorted;
end;

procedure TdxBarComboControl.SetLocalItemIndex(Value: Integer);
begin
  FLocalItemIndex := Value;
  RestoreDisplayValue;
  if Item.EmptyWindow then Repaint;
end;

procedure TdxBarComboControl.RestoreDisplayValue;
begin
  if (0 <= FLocalItemIndex) and (FLocalItemIndex <= Items.Count - 1) then
    Text := Items[FLocalItemIndex]
  else
    inherited RestoreDisplayValue;
end;

procedure TdxBarComboControl.SetFocused(Value: Boolean);
begin
  FFocusing := True;
  try
    if Value then LocalItemIndex := ItemIndex;
  finally
    FFocusing := False;
  end;
  inherited;
end;

procedure TdxBarComboControl.WndProc(var Message: TMessage);
var
  Shift: TShiftState;
begin
  if not ReadOnly then
  begin
    with Message do
      case Msg of
        WM_MOUSEWHEEL:
          begin
            if SmallInt(HIWORD(TWMMouse(Message).Keys)) > 0 then
            begin
              if not DroppedDown then
              begin
                if LocalItemIndex > 0 then
                  LocalItemIndex := LocalItemIndex - 1;
              end
              else
                SendMessage(DropDownWindow, WM_VScroll, SB_LINEUP, 0);
            end
            else
            begin
              if not DroppedDown then
              begin
                if LocalItemIndex < (Items.Count - 1) then
                  LocalItemIndex := LocalItemIndex + 1;
              end
              else
                SendMessage(DropDownWindow, WM_VScroll, SB_LINEDOWN, 0);
            end;
          end;
        WM_KEYDOWN:
          begin
            if (wParam = VK_RETURN) or (wParam = VK_TAB) then
            begin
              if (LocalItemIndex <> -1) and (Item.Items[LocalItemIndex] = Text) then
              begin
                Item.ItemIndex := LocalItemIndex;
                if not IsWindowVisible(Handle) then Exit;
              end;
            end
            else
            begin
              Shift := KeyDataToShiftState(lParam);
              if not DroppedDown and ((wParam = VK_UP) or (wParam = VK_DOWN)) and (Shift = []) then
              begin
                if (wParam = VK_UP) and (LocalItemIndex > 0) then
                  LocalItemIndex := LocalItemIndex - 1
                else
                  if (wParam = VK_DOWN) and (LocalItemIndex < Items.Count - 1) then
                    LocalItemIndex := LocalItemIndex + 1;
                Exit;
              end;
            end;
          end;
      end;
  end;
  inherited WndProc(Message);
end;

{ TdxBarSubItemControl }

destructor TdxBarSubItemControl.Destroy;
begin
  FIsActive := False;
  inherited Destroy;
end;

function TdxBarSubItemControl.IsDroppedDown: Boolean;
begin
  Result := (SubMenuControl <> nil) and IsActive and (SubMenuControl.ParentItemControl = Self);
end;

function TdxBarSubItemControl.GetCaptionOffset: Integer;
begin
  Result := Painter.GetControlCaptionOffset(Self);
end;

function TdxBarSubItemControl.GetItem: TCustomdxBarSubItem;
begin
  Result := TCustomdxBarSubItem(ItemLink.Item);
end;

function TdxBarSubItemControl.GetSubMenuControl: TdxBarSubMenuControl;
begin
  if Item.ItemLinks = nil then
    Result := nil
  else
    Result := TdxBarSubMenuControl(Item.ItemLinks.BarControl);
end;

procedure TdxBarSubItemControl.CalcDrawParams(AFull: Boolean = True);
begin
  inherited;
  if AFull then
  begin
    DrawParams.IsPressed := IsPressed;
    DrawParams.DrawDowned := IsDroppedDown;
    DrawParams.DroppedDown := IsDroppedDown;
    DrawParams.IsMenuItem := IsMenuItem;
  end;
end;

function TdxBarSubItemControl.CanActivate: Boolean;
begin
  Result := inherited CanActivate and (Enabled or not Item.IsInternal);
end;

function TdxBarSubItemControl.CanClicked: Boolean;
begin
  Result := False;
end;

procedure TdxBarSubItemControl.ControlActivate(AImmediately, AByMouse: Boolean);
begin
  if not HasSubMenu then Exit;

{ #DG TODO: Check it
  if IsDroppedDown then
    if (ItemLink.Item.CurItemLink = nil) or (Self = ItemLink.Item.CurItemLink.Control) then
    begin
      FinishSubMenuTracking;
      Exit;
    end
    else
      ItemLink.Item.CurItemLink.Control.ControlInActivate(True);
}

  inherited;
end;

procedure TdxBarSubItemControl.ControlInactivate(Immediately: Boolean);
begin
  if HasSubMenu then
    inherited;
end;

procedure TdxBarSubItemControl.ControlClick(AByMouse: Boolean; AKey: Char = #0);
begin
  if IsDroppedDown then
  begin
    if Parent.IsCustomizing or (BarManager.GetPaintStyle = bmsStandard) then // ???
      ControlInactivate(True)
  end
  else
  begin
    ControlActivate(True, AByMouse);
    if not AByMouse and (SubMenuControl <> nil) then
      with SubMenuControl do
        if NeedsSelectFirstItemOnDropDownByKey and (ItemLinks.First <> nil) then
          SetKeySelectedItem(ItemLinks.First.Control);
  end;
end;

procedure TdxBarSubItemControl.CreateSubMenuControl;
begin
  Item.ItemLinks.CreateBarControl;
end;

procedure TdxBarSubItemControl.DoCreateSubMenuControl;
begin
  CreateSubMenuControl;
  if SubMenuControl <> nil then
    SubMenuControl.FSubItem := Self;
  if HasShadow and IsDroppedDown then
  begin
    SubMenuControl.OwnerBounds := Parent.GetItemScreenRect(Self);
    SubMenuControl.FOwnerControl := Parent;
  end;
end;

procedure TdxBarSubItemControl.DoCloseUp(AHadSubMenuControl: Boolean);
begin
//  if AHadSubMenuControl then
//    SubMenuControl.FSubItem := nil;
  inherited DoCloseUp(AHadSubMenuControl);
  if AHadSubMenuControl then
    Item.DoCloseUp;
end;

procedure TdxBarSubItemControl.DoDropDown(AByMouse: Boolean);
begin
  Item.DoPopup;
  Item.DirectClick;
  DoCreateSubMenuControl;
  if SubMenuControl <> nil then
  begin
    ShowSubMenuControl;
    if AByMouse then
      Parent.ActivateHint(True, '', Self);
  end;
end;

procedure TdxBarSubItemControl.DropDown(AByMouse: Boolean);
begin
  inherited;
  Click(AByMouse);
end;

function TdxBarSubItemControl.GetCollapsed: Boolean;
begin
  Result := True;
end;

procedure TdxBarSubItemControl.GetSubMenuControlPositionParams(out P: TPoint;
  out AOwnerWidth, AOwnerHeight: Integer);
var
  R: TRect;
begin
  AOwnerWidth := 0;
  AOwnerHeight := 0;
  R := Parent.GetItemRect(Self);
  if Parent.Kind = bkSubMenu then
  begin
    if UseRightToLeftAlignment then
      P := Point(R.Left, R.Top - SubMenuParent.BorderSize)
    else
      P := Point(R.Right, R.Top - SubMenuParent.BorderSize);
    AOwnerWidth := cxRectWidth(R);
  end
  else
    if Parent.IsRealVertical then
    begin
      if UseRightToLeftAlignment then
        P := Point(R.Left, R.Top)
      else
        P := Point(R.Right, R.Top);
      AOwnerWidth := cxRectWidth(R);
    end
    else
    begin
      if UseRightToLeftAlignment then
        P := Point(R.Right, R.Bottom)
      else
        P := Point(R.Left, R.Bottom);
      AOwnerHeight := cxRectHeight(R);
    end;
  P := Parent.ClientToScreen(P);
end;

procedure TdxBarSubItemControl.GetSubMenuControlSingleMenuPositionParams(out P: TPoint;
  out AOwnerWidth, AOwnerHeight: Integer);
begin
  P.X := SubMenuParent.Left;
  P.Y := SubMenuParent.Top;
  AOwnerWidth := SubMenuParent.OwnerWidth;
  AOwnerHeight := SubMenuParent.OwnerHeight;
  SubMenuParent.StoreAndReduceSize;
end;

function TdxBarSubItemControl.IsFlatText: Boolean;
begin
  Result := Painter.IsFlatItemText and (not IsHighContrastWhite or inherited IsFlatText);
end;

function TdxBarSubItemControl.IsTextSelected: Boolean;

  function IsFlatText: Boolean;
  begin
    Result := Painter.IsFlatItemText and IsHighContrastWhite;
  end;

begin
  Result := DrawSelected and
    (not IsFlatText and Painter.IsMenuItem(Self) or IsFlatText and not IsDroppedDown or inherited IsTextSelected);
end;

procedure TdxBarSubItemControl.ShowSubMenuControl;
var
  AOwnerHeight, AOwnerWidth: Integer;
  AUseSingleMenuWindowMode: Boolean;
  P: TPoint;
begin
  AUseSingleMenuWindowMode := BarNavigationController.UseSingleMenuWindowMode(Self);
  if AUseSingleMenuWindowMode then
    BarNavigationController.PrepareNewSingleMenuLevel(Item.ItemLinks, Parent.Kind);
  if AUseSingleMenuWindowMode and (Parent.Kind = bkSubMenu) then
    GetSubMenuControlSingleMenuPositionParams(P, AOwnerWidth, AOwnerHeight)
  else
    GetSubMenuControlPositionParams(P, AOwnerWidth, AOwnerHeight);
  SubMenuControl.OwnerWidth := AOwnerWidth;
  SubMenuControl.OwnerHeight := AOwnerHeight;
  SubMenuControl.Left := P.X;
  SubMenuControl.Top := P.Y;
  Parent.ChildBar := SubMenuControl;
  SubMenuControl.UpdateDoubleBuffered;
  if Parent.Kind <> bkSubMenu then
    Repaint;
  SubMenuControl.FShowAnimation := FShowAnimation;
  FShowAnimation := False;
  SubMenuControl.Show;
  if Painter.IsDropDownRepaintNeeded then
    Repaint;
end;

function TdxBarSubItemControl.GetCaptionAreaWidth: Integer;
begin
  Result := inherited GetCaptionAreaWidth;
  Painter.InflateSizeForArrow(DrawParams, Result);
end;

function TdxBarSubItemControl.GetControlCaptionOffset: Integer;
begin
  Result := Painter.GetControlCaptionOffset(Self);
end;

function TdxBarSubItemControl.GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass;
begin
  Result := TdxBarSubItemControlAccessibilityHelper;
end;

function TdxBarSubItemControl.GetOwnedBarControl: TCustomdxBarControl;
begin
  Result := SubMenuControl;
end;

function TdxBarSubItemControl.HasSubMenu: Boolean;
begin
  Result := True;
end;

function TdxBarSubItemControl.CanDestroyOnClick: Boolean;
begin
  Result := False;
end;

function TdxBarSubItemControl.IsDropDown: Boolean;
begin
  Result := True;
end;

function TdxBarSubItemControl.IsExpandable: Boolean;
begin
  Result := True;
end;

function TdxBarSubItemControl.IsMenuItem: Boolean;
begin
  Result := Parent.IsMainMenu;
end;

function TdxBarSubItemControl.IsPressed: Boolean;
begin
  Result := IsDroppedDown and (HotPartIndex <> icpNone) and MousePressed;
end;

function TdxBarSubItemControl.WantsDblClick: Boolean;
begin
  Result := inherited WantsDblClick and not BarManager.Designing;
end;

function TdxBarSubItemControl.WantsKey(Key: Word): Boolean;
begin
  Result := inherited WantsKey(Key) or (Key = VK_RETURN);
end;

function TdxBarSubItemControl.GetPossibleViewLevels: TdxBarItemViewLevels;
begin
  Result := inherited GetPossibleViewLevels;
  Include(Result, ivlLargeIconWithText);
end;

function TdxBarSubItemControl.GetDefaultViewStructure: TdxBarItemControlViewStructure;
begin
  Result := [];
  if Item.ShowCaption or (GetPaintType = ptMenu) then
    Include(Result, cpText);
  if IconAssigned or not (cpText in Result) then
    Include(Result, cpIcon);
end;


constructor TdxBarContainerItemSubMenuControl.Create(AOwner: TComponent);
begin
  inherited;
  FContainerLinkData := TdxBarContainerLinkData.Create;
end;

destructor TdxBarContainerItemSubMenuControl.Destroy;
var
  AContainerItem: TCustomdxBarContainerItem;
begin
  DestroyHandle;
  FreeAndNil(FContainerLinkData);
  AContainerItem := FContainerItem;
  inherited;
  AContainerItem.NeedClearItemList;
end;

procedure TdxBarContainerItemSubMenuControl.DoCloseUp;
begin
  with FContainerItem do
    DeleteListedItemLinks(FContainerLinkData);
  inherited DoCloseUp;
end;

function TdxBarContainerItemSubMenuControl.GetIsCustomizing: Boolean;
begin
  Result := False;
end;

{ TdxBarContainerItemControl }

function TdxBarContainerItemControl.GetItem: TCustomdxBarContainerItem;
begin
  Result := TCustomdxBarContainerItem(ItemLink.Item);
end;

procedure TdxBarContainerItemControl.CreateSubMenuControl;
var
  ABarControl: TdxBarContainerItemSubMenuControl;
begin
  if BarManager.IsCustomizing then Exit;
  ABarControl := GetSubMenuControlClass.Create(BarManager);
  Item.ItemLinks.FBarControl := ABarControl;
  SubMenuControl.FItemLinks := Item.ItemLinks;
  ABarControl.FContainerItem := Item;
  ABarControl.FContainerLinkData.FItemLink := ItemLink;
  Item.AddListedItemLinks(Item.ItemLinks, ABarControl.FContainerLinkData, 0);
end;

procedure TdxBarContainerItemControl.DoPaint(ARect: TRect; PaintType: TdxBarPaintType);
begin
  if PaintType = ptMenu then
    Painter.DrawGlyphAndTextInSubMenu(DrawParams, ARect)
  else
    inherited;
end;

function TdxBarContainerItemControl.DrawSelected: Boolean;
begin
  Result := inherited DrawSelected and not Parent.IsCustomizing;
end;

function TdxBarContainerItemControl.GetCaption: string;
begin
  Result := inherited GetCaption;
  if not ShowRealCaption then
    Result := '(' + Result + ')';
end;

function TdxBarContainerItemControl.GetSubMenuControlClass: TdxBarContainerItemSubMenuControlClass;
begin
  Result := TdxBarContainerItemSubMenuControl;
end;

function TdxBarContainerItemControl.IsExpandable: Boolean;
begin
  Result := not BarManager.IsCustomizing;
end;

function TdxBarContainerItemControl.ShowRealCaption: Boolean;
begin
  Result := (Parent is TdxBarControl) or not Item.HideWhenRun;
end;

{ TdxBarSubMenuBackButtonControl }

procedure TdxBarSubMenuBackButtonControl.ControlUnclick(ByMouse: Boolean);
begin
  inherited ControlUnclick(ByMouse);
  if not ByMouse or (HotPartIndex = bcpButton) then
    SubMenuParent.ParentItemControl.ControlInactivate(True);
end;

procedure TdxBarSubMenuBackButtonControl.DoPaint(ARect: TRect; PaintType: TdxBarPaintType);
begin
  Painter.DrawBackButtonControl(DrawParams, ARect);
end;

procedure TdxBarSubMenuBackButtonControl.GetDefaultTextColors(AEnabled, ASelected, AFlat: Boolean;
  var AColor1, AColor2: TColor);
begin
  if ASelected then
    inherited GetDefaultTextColors(AEnabled, ASelected, AFlat, AColor1, AColor2)
  else
    Painter.SeparatorControlGetTextColors(Self, AEnabled, ASelected, AFlat, AColor1, AColor2);
end;

procedure TdxBarSubMenuBackButtonControl.PrepareCanvasFont(ABaseFont: HFONT; AStyle: TcxStyle;
  out ASavedFont: TdxBarSavedFont);
begin
  if AStyle <> nil then
    inherited PrepareCanvasFont(ABaseFont, AStyle, ASavedFont)
  else
    Canvas.Font.Style := [fsBold];
end;

procedure TdxBarSubMenuBackButtonControl.RestoreCanvasFont(const ASavedFont: TdxBarSavedFont);
begin
  Canvas.Font.Style := [];
end;

{ TdxBar }

constructor TdxBar.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FAlphaBlendValue := 255;
  FBackgroundBitmap := dxBarCreateBitmap(BitmapChanged);
  FAllowClose := True;
  FAllowCustomizing := True;
  FAllowQuickCustomizing := True;
  FAllowReset := True;
  FBorderStyle := bbsSingle;
  FColor := clDefault;
  FDockedDockingStyle := dsTop;
  FEditFont := TFont.Create;
  FFont := TFont.Create;
  FFont.OnChange := FontChanged;
  FFreeNotificationItems := TList.Create;
  FListeners := TInterfaceList.Create;
  FGlyph := dxBarCreateSmartGlyph(GlyphChanged);
  FMergeData := TdxBarMergeData.Create;
  FRotateWhenVertical := True;
  FShowMark := True;
  FSizeGrip := True;

  FCaptionButtons := TdxBarCaptionButtons.Create(Self);
  FCaptionButtons.OnChange := CaptionButtonsNotification;
  FScaleFactor := TdxScaleFactor.Create;
end;

destructor TdxBar.Destroy;
begin
  DoDestroy;
  if not BarManager.IsDestroying and Assigned(BarManager.FOnBarDelete) then
    BarManager.OnBarDelete(BarManager, Self);
  if FMergeData.MergedWith <> nil then
    FMergeData.MergedWith.Unmerge(Self);
  Unmerge;
  FreeAndNil(FMergeData);


  Visible := False;
  RemoveFromDockRow(True);
  MakeFreeNotification;
  FreeAndNil(FCaptionButtons);
  FreeAndNil(FFreeNotificationItems);
  if BarManager.MainMenuBar = Self then
    BarManager.FMainMenuBar := nil;
  FreeAndNil(FItemLinks);
  FreeAndNil(FGlyph);
  FreeAndNil(FFont);
  FreeAndNil(FEditFont);
  FreeAndNil(FBackgroundBitmap);
  FreeAndNil(FListeners);
  FreeAndNil(FScaleFactor);
  cxClearObjectLinks(Self);
  inherited Destroy;
end;

procedure TdxBar.Assign(Source: TPersistent);
var
  Bar: TdxBar;
begin
  if Source is TdxBar then
  begin
    Bar := TdxBar(Source);

    AllowClose := Bar.AllowClose;
    AllowCustomizing := Bar.AllowCustomizing;
    AllowQuickCustomizing := Bar.AllowQuickCustomizing;
    AllowReset := Bar.AllowReset;
    BorderStyle := Bar.BorderStyle;
    Caption := Bar.Caption;
    CaptionButtons := Bar.CaptionButtons;
    DockedDockControl := Bar.DockedDockControl;
    DockedDockingStyle := Bar.DockedDockingStyle;
    DockedLeft := Bar.DockedLeft;
    DockedTop := Bar.DockedTop;
    FloatLeft := Bar.FloatLeft;
    FloatTop := Bar.FloatTop;
    FloatClientWidth := Bar.FloatClientWidth;
    FloatClientHeight := Bar.FloatClientHeight;
    Hidden := Bar.Hidden;
    IsMainMenu := Bar.IsMainMenu;
    ItemLinks := Bar.ItemLinks;
    NotDocking := Bar.NotDocking;
    OldName := Bar.OldName;
    OneOnRow := Bar.OneOnRow;
    RotateWhenVertical := Bar.RotateWhenVertical;
    Row := Bar.Row;
    ShowMark := Bar.ShowMark;
    SizeGrip := Bar.SizeGrip;
    WholeRow := Bar.WholeRow;
    ChangeDockingStyle(Bar.DockingStyle, Bar.DockControl);
    UseRecentItems := Bar.UseRecentItems;
    UseRestSpace := Bar.UseRestSpace;
    Color := Bar.Color;
    Font := Bar.Font;
    UseOwnFont := Bar.UseOwnFont;
    Visible := Bar.Visible;
  end
  else inherited Assign(Source);
end;

procedure TdxBar.BitmapChanged(Sender: TObject);
begin
  if Control <> nil then
    Control.RebuildBar;
end;

procedure TdxBar.DoDestroy;
begin
  CallNotify(FOnDestroy, Self);
end;

function TdxBar.GetBars: TdxBars;
begin
  if GetBarManager = nil then
    Result := nil
  else
    Result := GetBarManager.Bars;
end;

function TdxBar.GetControl: TdxBarControl;
begin
  if ItemLinks <> nil then
    Result := ItemLinks.FBarControl as TdxBarControl
  else
    Result := nil;
end;

function TdxBar.GetDockControl: TdxBarDockControl;
begin
  if IsAncestorComponentDifferencesDetection(Self) then
    Result := FLoadedDockControl
  else
    Result := FDockControl;
end;

function TdxBar.GetDockedDockingStyle: TdxBarDockingStyle;
begin
  if FDockedDockControl = nil then
    Result := FDockedDockingStyle
  else
    Result := FDockedDockControl.DockingStyle;
end;

function TdxBar.GetDockingStyle: TdxBarDockingStyle;
begin
  if IsAncestorComponentDifferencesDetection(Self) then
    Result := FLoadedDockingStyle
  else
    if FDockControl = nil then
      Result := FDockingStyle
    else
      Result := FDockControl.DockingStyle;
end;

function TdxBar.GetNext: TdxBar;
begin
  if Index + 1 < Bars.Count then
    Result := Bars[Index + 1]
  else
    if Index <> 0 then
      Result := Bars[0]
    else
      Result := nil;
end;

function TdxBar.GetNotDocking: TdxBarDockingStyles;
begin
  Result := FNotDocking;
end;

function TdxBar.GetPainter: TdxBarPainter;
begin
  if RealDockControl <> nil then
    Result := RealDockControl.Painter
  else
    Result := BarManager.DefaultPainter;
end;

function TdxBar.GetRealDockControl: TdxDockControl;
begin
  Result := FDockControl;
  if (Result = nil) and (FDockingStyle <> dsNone) then
    Result := Bars.DockControls[FDockingStyle];
end;

function TdxBar.GetRow: Integer;
begin
  if DockRow <> nil then
    Result := DockRow.DockControl.RowList.IndexOf(DockRow)
  else
    Result := FRow;
end;

function TdxBar.GetUseRecentItems: Boolean;
begin
  Result := FItemLinks.FUseRecentItems;
end;

function TdxBar.GetVisible: Boolean;
begin
  if IsAncestorComponentDifferencesDetection(Self) then
    Result := FLoadedVisible
  else
    Result := FVisible;
end;

procedure TdxBar.GlyphChanged(Sender: TObject);
begin
  if Control <> nil then
    Control.GlyphChanged;
end;

procedure TdxBar.SetAllowClose(Value: Boolean);
begin
  if FAllowClose <> Value then
  begin
    FAllowClose := Value;
    if (DockingStyle = dsNone) and (Control <> nil) then
      Control.CaptionChanged;
    Changed(False);
  end;
end;

procedure TdxBar.SetAllowQuickCustomizing(Value: Boolean);
begin
  if FAllowQuickCustomizing <> Value then
  begin
    FAllowQuickCustomizing := Value;
    if Control <> nil then
      if DockingStyle = dsNone then
        Control.CaptionChanged
      else
        if BarManager.CanShowRecentItems then
          Control.RepaintBar;
  end;
end;

procedure TdxBar.SetAlphaBlendValue(Value: Byte);
begin
  if FAlphaBlendValue <> Value then
  begin
    FAlphaBlendValue := Value;
    if (Control <> nil) and (Control.DockingStyle = dsNone) then
      Control.SetLayeredAttributes;
  end;
end;

procedure TdxBar.SetBackgroundBitmap(Value: TBitmap);
begin
  FBackgroundBitmap.Assign(Value);
end;

procedure TdxBar.SetBorderStyle(Value: TdxBarBorderStyle);
begin
  if FBorderStyle <> Value then
  begin
    FBorderStyle := Value;
    if Control <> nil then Control.RebuildBar;
  end;
end;

procedure TdxBar.SetCaption(Value: string);
begin
  if FCaption <> Value then
  begin
    if BarManager.BarByCaption(Value) <> nil then
      Exit;
    FCaption := Value;
    if Control <> nil then
      Control.CaptionChanged;
//    if (Name = '') and not BarManager.IsLoading then
//      CheckBarName(Value);
    Changed(False);
  end;
end;

procedure TdxBar.SetCaptionButtons(Value: TdxBarCaptionButtons);
begin
  FCaptionButtons.Assign(Value);
end;

procedure TdxBar.SetColor(Value: TColor);
begin
  if FColor <> Value then
  begin
    FColor := Value;
    if Control <> nil then
      Control.RebuildBar;
  end;
end;

procedure TdxBar.SetDockControl(Value: TdxBarDockControl);
var
  PrevDockingStyle: TdxBarDockingStyle;
  NeedHiding: Boolean;
begin
  if (Value <> nil) and (Value.BarManager <> BarManager) then Exit;
  if IsLoading then
  begin
    FLoadedDockControl := Value;
    Exit;
  end;
  if FDockControl <> Value then
  begin
    PrevDockingStyle := DockingStyle;
    NeedHiding := not FChangingDockingStyle and (Control <> nil);
    if NeedHiding then
      if Value = nil then
//        NeedHiding := (DockingStyle <> dsNone) and (Control.DockControl <> Value)
        NeedHiding :=
          (DockingStyle <> dsNone) and
          not ((Control.DockControl <> nil) and Control.DockControl.Main)
      else
        NeedHiding := Control.DockControl <> Value;
    if NeedHiding then Visible := False;
    FDockControl := Value;
    ItemLinks.RecentItemCount := -1;
    if not FChangingDockingStyle then
    begin
      FChangingDockingStyle := True;
      try
        if Value = nil then
          DockingStyle := PrevDockingStyle//dsNone
        else
          DockingStyle := Value.DockingStyle;
      finally
        FChangingDockingStyle := False;
      end;
    end;
    if NeedHiding then Visible := True;
    if Control <> nil then
      Control.DockControl := RealDockControl;
    if (BarManager <> nil) and (FDockControl <> nil) and FDockControl.HandleAllocated then
      BarManager.ShowBarsFromRestoringList(FDockControl);
    if not FChangingDockingStyle then
      BarManager.DoBarDockingStyleChanged(Self);
  end;
end;

procedure TdxBar.SetDockedDockControl(Value: TdxBarDockControl);
begin
  if (Value <> nil) and (Value.BarManager <> BarManager) then Exit;
  if FDockedDockControl <> Value then
  begin
    FDockedDockControl := Value;
    Changed(False);
  end;
end;

procedure TdxBar.SetDockedValue(Index: Integer; Value: Integer);
var
  PrevValue: Integer;
begin
  Value := Max(Value, 0);
  case Index of
    1: PrevValue := FDockedLeft;
    2: PrevValue := FDockedTop;
  else
    PrevValue := 0;
  end;

  if PrevValue <> Value then
  begin
    case Index of
      1: FDockedLeft := Value;
      2: FDockedTop := Value;
    end;
    if csUpdating in ComponentState then
      FNeedUpdateControlPosition := True
    else
      UpdateControlPosition;
    Changed(False);
  end;
end;

procedure TdxBar.SetDockingStyle(Value: TdxBarDockingStyle);
var
  ANeedHideControl: Boolean;
begin
  if IsLoading then
  begin
    FLoadedDockingStyle := Value;
    Exit;
  end;
  if FDockingStyle <> Value then
  begin
    ANeedHideControl :=
      not FChangingDockingStyle and
      (Control <> nil) and (Control.DockingStyle <> Value);
    if ANeedHideControl then
      Visible := False;
    FDockingStyle := Value;
    if not FChangingDockingStyle then
    begin
      FChangingDockingStyle := True;
      try
        DockControl := nil;
      finally
        FChangingDockingStyle := False;
      end;
    end;
    ItemLinks.RecentItemCount := -1;
    if ANeedHideControl then
    begin
      Visible := True;
      Control.DockingStyle := Value;
    end;
    if not FChangingDockingStyle then
      BarManager.DoBarDockingStyleChanged(Self);
  end;
end;

procedure TdxBar.SetDockRow(Value: TdxDockRow);
begin
  if (FDockRow = Value) or BarManager.IsDestroying then
    Exit;
  if FDockRow <> nil then FDockRow.DeleteBar(Self, True);
  FDockRow := Value;
  if Value <> nil then FDockRow.AddBar(Self);
end;

procedure TdxBar.SetFloatValue(Index: Integer; Value: Integer);
var
  PrevValue: Integer;
begin
  PrevValue := 0;
  case Index of
    1: PrevValue := FFloatLeft;
    2: PrevValue := FFloatTop;
    3: PrevValue := FFloatClientWidth;
    4: PrevValue := FFloatClientHeight;
  end;
  if PrevValue <> Value then
  begin
    case Index of
      1: FFloatLeft := Value;
      2: FFloatTop := Value;
      3: FFloatClientWidth := Value;
      4: FFloatClientHeight := Value;
    end;
    if csUpdating in ComponentState then
      FNeedUpdateControlPosition := True
    else
      UpdateControlPosition;
    Changed(False);
  end;
end;

procedure TdxBar.SetFont(Value: TFont);
begin
  Font.Assign(Value);
end;

procedure TdxBar.SetGlyph(Value: TdxSmartGlyph);
begin
  Glyph.Assign(Value);
end;

procedure TdxBar.SetHidden(Value: Boolean);
begin
  if FHidden <> Value then
  begin
    FHidden := Value;
    Changed(False);
  end;
end;

procedure TdxBar.SetIsMainMenu(Value: Boolean);
begin
  if FIsMainMenu <> Value then
  begin
    BarManager.BeginUpdate;
    try
      if Value and (BarManager.MainMenuBar <> nil) then
        BarManager.MainMenuBar.IsMainMenu := False;
      FIsMainMenu := Value;
      if Value then
      begin
        BarManager.FMainMenuBar := Self;
        WholeRow := True;
        MultiLine := True;
      end
      else
      begin
        BarManager.FMainMenuBar := nil;
        MultiLine := False;
        WholeRow := False;
      end;
      if IsLoading then Exit;
      if Control <> nil then
        if FDockingStyle = dsNone then
          Control.CaptionChanged
        else
          Control.RepaintBar;
      Changed(False);
    finally
      BarManager.EndUpdate;
    end;
  end;
end;

procedure TdxBar.SetItemLinks(Value: TdxBarItemLinks);
begin
  FItemLinks.Assign(Value);
end;

procedure TdxBar.SetLockUpdate(Value: Boolean);
begin
  if Value <> FLockUpdate then
  begin
    FLockUpdate := Value;
    if FLockUpdate then
      BarManager.BeginUpdate
    else
      BarManager.EndUpdate;
  end;
end;

procedure TdxBar.SetMultiLine(Value: Boolean);
begin
  if (FMultiLine <> Value) and (Value or not IsMainMenu) then
  begin
    FMultiLine := Value;
    if (Control <> nil) and (DockingStyle <> dsNone) then
      Control.RepaintBar;
  end;
end;

procedure TdxBar.SetCollection(AValue: TcxComponentCollection);
begin
  inherited SetCollection(AValue);
  if (csLoading in ComponentState) and (BarManager <> nil) then
    ScaleFactor.Assign(BarManager.ScaleFactor);
end;

procedure TdxBar.SetName(const NewName: TComponentName);
begin
  if not BarManager.ReadingOldBars or (Name = '') then
    inherited SetName(NewName)
  else
    FOldName := NewName;
end;

procedure TdxBar.Updated;
begin
  inherited Updated;
  if FNeedUpdateControlPosition then
    UpdateControlPosition;
end;

procedure TdxBar.Updating;
begin
  inherited Updating;
  FNeedUpdateControlPosition := False;
end;

procedure TdxBar.SetNotDocking(Value: TdxBarDockingStyles);
begin
  if FNotDocking <> Value then
  begin
    FNotDocking := Value;
    if Control <> nil then
      Control.RepaintBar;
  end;
end;

procedure TdxBar.SetOneOnRow(Value: Boolean);
begin
  if (RealDockControl = nil) or not RealDockControl.IsBarHandleDestroying then
    FOneOnRow := Value;
end;

function TdxBar.CreateControl: TdxBarControl;
begin
  Result := GetControlClass.Create(BarManager);
  Result.InitializeForDock(Self);
  Result.UpdateFont;
end;

function TdxBar.GetControlClass: TdxBarControlClass;
begin
  if RealDockControl <> nil then
    Result := RealDockControl.GetDockedBarControlClass
  else
    Result := TdxBarControl;
end;

procedure TdxBar.ShowControl;

  function CanShowBar: Boolean;
  begin
    Result := (DockingStyle <> dsNone) or BarManager.IsOwnerVisible and
      (not BarManager.HideFloatingBarsWhenInactive or BarManager.FIsCustomizing or
       IsFormActive(BarManager.ParentForm));
  end;

var
  P: TPoint;
begin
  if DockingStyle <> dsNone then
  begin
    Control.BeginInternal;
    try
      Control.ChangeStyleWinTo(DockingStyle, RealDockControl);
      P := Point(RealDockControl.GetBarControlPos(DockedLeft, Control.Width), DockedTop);
      Windows.ClientToScreen(RealDockControl.Handle, P);
      if DockRow <> nil then
        DockRow.DeleteCol(Control);
      Bars.RegInDock(DockingStyle, RealDockControl, Control, P);
    finally
      Control.EndInternal;
    end;
  end
  else
  begin
    Control.BeginInternal;
    try
      Control.ChangeStyleWinTo(DockingStyle, nil);
    finally
      Control.EndInternal;
    end;
    UpdateFloatingControlPosition;
  end;
  if CanShowBar then
    ShowWindow(Control.Handle, SW_SHOWNA);
  BarManager.RemoveBarFromRestoringList(Self);
end;

class function TdxBar.GetIniSection(const ABaseSection: string; ABarIndex: Integer): string;
begin
  Result := ABaseSection + 'Bar' + IntToStr(ABarIndex);
end;

procedure TdxBar.LoadFromIni(ASource: TCustomIniFile; const ABaseSection: string;
  ABarIndex: Integer; AStoringKind: TdxBarStoringKind; AFullLoad: Boolean = True);

  procedure ReadDockControl(const ASection: string);
  var
    ADockControl: TdxBarDockControl;
  begin
    ADockControl := BarManager.FindDockControl(ASource.ReadString(ASection, 'DockControl', ''));
    if (ADockControl <> nil) or (DockControl <> nil) and DockControl.AllowUndockWhenLoadFromIni then
      DockControl := ADockControl;
  end;

  function ReadScaledValue(const ASection, AIdent: string; ADefaultValue: Integer): Integer;
  begin
    if ASource.ValueExists(ASection, AIdent) then
      Result := ScaleFactor.Apply(ASource.ReadInteger(ASection, AIdent, ScaleFactor.Revert(ADefaultValue)))
    else
      Result := ADefaultValue;
  end;

var
  ASection: string;
begin
  ASection := GetIniSection(ABaseSection, ABarIndex);
  ItemLinks.LoadFromIni(ASource, ASection, AStoringKind);

  if AFullLoad then
  try
    Visible := False;
    DockRow := nil;

    Caption := ASource.ReadString(ASection, 'Caption', Caption);
    DockedDockControl := BarManager.FindDockControl(ASource.ReadString(ASection, 'DockedDockControl', ''));
    DockedDockingStyle := TdxBarDockingStyle(ASource.ReadInteger(ASection, 'DockedDockingStyle', Integer(DockedDockingStyle)));
    DockedLeft := ReadScaledValue(ASection, 'DockedLeft', DockedLeft);
    DockedTop := ReadScaledValue(ASection, 'DockedTop', DockedTop);
    OneOnRow := ASource.ReadBool(ASection, 'OneOnRow', OneOnRow);

    FloatTop := ASource.ReadInteger(ASection, 'FloatTop', FloatTop);
    FloatLeft := ASource.ReadInteger(ASection, 'FloatLeft', FloatLeft);
    FloatClientWidth := ReadScaledValue(ASection, 'FloatClientWidth', FloatClientWidth);
    FloatClientHeight := ReadScaledValue(ASection, 'FloatClientHeight', FloatClientHeight);

    ReadDockControl(ASection);
    DockingStyle := TdxBarDockingStyle(ASource.ReadInteger(ASection, 'DockingStyle', Integer(DockingStyle)));
    Row := ASource.ReadInteger(ASection, 'Row', Row);
    Visible := ASource.ReadBool(ASection, 'Visible', False);
    MergeData.MergedWith := nil;
  except
    Visible := True;
  end;
end;

procedure TdxBar.LoadUsageData(ASource: TCustomIniFile; const ABaseSection: string; ABarIndex: Integer);
begin
  ItemLinks.LoadUsageData(ASource, GetIniSection(ABaseSection, ABarIndex));
end;

procedure TdxBar.SaveToIni(ADestination: TCustomIniFile; const ABaseSection: string; ABarIndex: Integer; AStoringKind: TdxBarStoringKind);
var
  APath: string;
  ASection: string;
begin
  ASection := GetIniSection(ABaseSection, ABarIndex);

  ADestination.WriteString(ASection, 'Name', Name);
  ADestination.WriteString(ASection, 'Caption', Caption);
  if DockControl <> nil then
  begin
    APath := GetComponentPath(BarManager.Owner, DockControl);
    if APath <> '' then
      ADestination.WriteString(ASection, 'DockControl', APath);
  end;
  if DockedDockControl <> nil then
  begin
    APath := GetComponentPath(BarManager.Owner, DockedDockControl);
    if APath <> '' then
      ADestination.WriteString(ASection, 'DockedDockControl', APath);
  end;

  ADestination.WriteInteger(ASection, 'FloatClientHeight', ScaleFactor.Revert(FloatClientHeight));
  ADestination.WriteInteger(ASection, 'FloatClientWidth', ScaleFactor.Revert(FloatClientWidth));
  ADestination.WriteInteger(ASection, 'FloatLeft', FloatLeft);
  ADestination.WriteInteger(ASection, 'FloatTop', FloatTop);

  ADestination.WriteInteger(ASection, 'DockedDockingStyle', Ord(DockedDockingStyle));
  ADestination.WriteInteger(ASection, 'DockedLeft', ScaleFactor.Revert(DockedLeft));
  ADestination.WriteInteger(ASection, 'DockedTop', ScaleFactor.Revert(DockedTop));
  ADestination.WriteInteger(ASection, 'DockingStyle', Ord(DockingStyle));
  ADestination.WriteInteger(ASection, 'Row', Row);
  ADestination.WriteBool(ASection, 'OneOnRow', OneOnRow);

  if MergeData.MergedWith <> nil then
    ADestination.WriteBool(ASection, 'Visible', MergeData.VisibleBeforeMerging)
  else
    ADestination.WriteBool(ASection, 'Visible', Visible or (BarManager.GetBarIndexInRestoringList(Self) <> -1));

  ItemLinks.SaveToIni(ADestination, ASection, AStoringKind);
end;

procedure TdxBar.InternalUpdateFont;
begin
  FInternalFontChange := True;
  try
    if UseOwnFont then
      FontChanged(nil)
    else
      Font := BarManager.Font;
  finally
    FInternalFontChange := False;
  end;
end;

procedure TdxBar.InternalMerge(ABar: TdxBar; ASaveMergingBarVisibility: Boolean);
var
  AIsBarMerged: Boolean;
begin
  if MergeData.MergedWith <> nil then
    raise EdxException.Create(cxGetResourceString(@dxSBAR_CANTMERGEWITHMERGEDTOOLBAR));
  if (ABar = Self) or (ABar = nil) then
    raise EdxException.Create(cxGetResourceString(@dxSBAR_CANTMERGETOOLBAR));
  if ABar.MergeData.MergedWith = Self then
    raise EdxException.Create(Format(cxGetResourceString(@dxSBAR_TOOLBARSALREADYMERGED), [ABar.Caption, Caption]));
  if ABar.MergeData.MergedBarList.Count > 0 then
    raise EdxException.Create(Format(cxGetResourceString(@dxSBAR_TOOLBARHASMERGEDTOOLBARS), [ABar.Caption]));
  AIsBarMerged := ABar.MergeData.MergedWith <> nil;
  if AIsBarMerged then
    ABar.MergeData.MergedWith.InternalUnmergeFromBar(ABar, False);
  FMergingWith := ABar;
  try
    ABar.MergeData.MergedWith := Self;
    MergeData.MergedBarList.Add(ABar);
    BarManager.BeginUpdate;
    try
      ItemLinks.Merge(ABar.ItemLinks);
      CaptionButtons.Merge(ABar.CaptionButtons);
    finally
      BarManager.EndUpdate;
    end;
    if not AIsBarMerged and ASaveMergingBarVisibility then
      ABar.MergeData.VisibleBeforeMerging := ABar.Visible;
    ABar.SetVisibility(False);
  finally
    FMergingWith := nil;
  end;
end;

procedure TdxBar.InternalUnmergeFromBar(ABar: TdxBar; ARestoreMergedBarsVisibility: Boolean);

  function GetBarCaptionButtons(ABar: TdxBar): TdxBarCaptionButtons;
  begin
    if ABar <> nil then
      Result := ABar.CaptionButtons
    else
      Result := nil;
  end;

  procedure RestoreMergedBar(ABar: TdxBar);
  begin
    ABar.MergeData.MergedWith := nil;
    MergeData.MergedBarList.Remove(ABar);
    if ARestoreMergedBarsVisibility then
      ABar.SetVisibility(ABar.MergeData.VisibleBeforeMerging);
  end;

  procedure RestoreMergedBars;
  var
    I: Integer;
  begin
    if ABar <> nil then
      RestoreMergedBar(ABar)
    else
      for I := MergeData.MergedBarList.Count - 1 downto 0 do
        RestoreMergedBar(TdxBar(MergeData.MergedBarList[I]));
  end;

begin
  if ABar = Self then
    raise EdxException.Create(cxGetResourceString(@dxSBAR_CANTUNMERGETOOLBAR));
  if (ABar <> nil) and (ABar.MergeData.MergedWith = nil) then
    Exit;
  if (ABar <> nil) and (ABar.MergeData.MergedWith <> Self) then
    raise EdxException.Create(Format(cxGetResourceString(@dxSBAR_TOOLBARSARENOTMERGED), [ABar.Caption, Caption]));
  if MergeData.MergedBarList.Count = 0 then
    Exit;

  BarManager.BeginUpdate;
  try
    ItemLinks.Unmerge(ABar);
    CaptionButtons.Unmerge(GetBarCaptionButtons(ABar));
  finally
    BarManager.EndUpdate;
  end;
  RestoreMergedBars;

  if not IsMerged and MergeData.CreatedByMerging then
  begin
    if ShouldNotBeDestroyedIfEmptyAfterUnmerge then
    begin
      MergeData.CreatedByMergingBarVisibleBeforeCustomization := Visible;
      SetVisibility(False);
      Hidden := True;
    end
    else
      if not (csDestroying in ComponentState) then
        Free;
  end;
end;

procedure TdxBar.InternalUnmergeFromBarManager(ABarManager: TdxBarManager;
  ARestoreMergedBarsVisibility: Boolean);
var
  ABar: TdxBar;
  I: Integer;
begin
  for I := MergeData.MergedBarList.Count - 1 downto 0 do
  begin
    ABar := MergeData.MergedBarList[I];
    if (ABarManager = nil) or (ABar.BarManager = ABarManager) then
      InternalUnmergeFromBar(ABar, ARestoreMergedBarsVisibility);
  end;
end;

procedure TdxBar.RestoreMergeState;
var
  ABar: TdxBar;
  I: Integer;
begin
  for I := 0 to MergeData.SavedMergedBarCount - 1 do
  begin
    ABar := TdxBar(MergeData.SavedMergedBars[I]);
    InternalMerge(ABar, ABar.BarManager = BarManager);
  end;
  MergeData.ClearSavedMergedBarList;
end;

procedure TdxBar.SaveMergeState;
begin
  MergeData.SaveMergedBarList;
end;

procedure TdxBar.SetVisibility(Value: Boolean);

  procedure SetMDIChildRightWindowRect(out APrevBoundsRect: TRect);
  var
    AHandle: HWND;
    AParentForm: TCustomForm;
    R: TRect;
  begin
    AParentForm := TCustomForm(BarManager.Owner);
    if AParentForm.HandleAllocated then
    begin
      AHandle := AParentForm.Handle;
      APrevBoundsRect := AParentForm.BoundsRect;
      R := dxMapWindowRect(0, GetParent(AHandle), cxGetWindowRect(AHandle));
      TCustomFormAccess(AParentForm).WindowHandle := 0;
      AParentForm.BoundsRect := R;
      TCustomFormAccess(AParentForm).WindowHandle := AHandle;
    end;
  end;

  procedure RestoreMDIChildWindowRect(const APrevBoundsRect: TRect);
  var
    AHandle: HWND;
    AParentForm: TCustomForm;
  begin
    AParentForm := TCustomForm(BarManager.Owner);
    if AParentForm.HandleAllocated then
    begin
      AHandle := AParentForm.Handle;
      TCustomFormAccess(AParentForm).WindowHandle := 0;
      AParentForm.BoundsRect := APrevBoundsRect;
      TCustomFormAccess(AParentForm).WindowHandle := AHandle;
    end;
  end;

var
  APrevBoundsRect: TRect;
begin
  if Value <> Visible then
  begin
    if BarManager.IsOwnerMDIChild(False) then
      SetMDIChildRightWindowRect(APrevBoundsRect);
    Visible := Value;
    if BarManager.IsOwnerMDIChild(False) then
      RestoreMDIChildWindowRect(APrevBoundsRect);
  end;
end;

procedure TdxBar.CaptionButtonsNotification(Sender: TObject; AItem: TCollectionItem);
begin
  if Control <> nil then
    Control.UpdateCaptionButton(TdxBarCaptionButton(AItem));
end;

procedure TdxBar.DoChanged;
begin
  FChanged := True;
end;

procedure TdxBar.DoVisibleChanged;
begin
  Changed(False);
  NotifyListenersBarVisibilityChanged;
end;

procedure TdxBar.SetRotateWhenVertical(Value: Boolean);
begin
  if FRotateWhenVertical <> Value then
  begin
    FRotateWhenVertical := Value;
    if Control <> nil then
      Control.Perform(CM_FONTCHANGED, 0, 0);
  end;
end;

procedure TdxBar.SetRow(Value: Integer);
var
  ADockRow: TdxDockRow;
begin
  if Value < 0 then
    Value := 0;
  if (Row = Value) and (DockRow <> nil) then
    Exit;
  FRow := Value;
  if RealDockControl <> nil then
  begin
    if FRow > RealDockControl.RowCount - 1 then
    begin
      repeat
        ADockRow := TdxDockRow.Create(RealDockControl);
        RealDockControl.RowList.Add(ADockRow);
      until not (BarManager.IsUpdateLocked or BarManager.BarsLoading) or (RealDockControl.RowCount > FRow);
      SetDockRow(ADockRow);
    end
    else
      SetDockRow(RealDockControl.RowList[FRow]);
  end;
  Changed(False);
  if RealDockControl <> nil then
    RealDockControl.UpdateDock;
end;

procedure TdxBar.SetShowMark(Value: Boolean);
begin
  if FShowMark <> Value then
  begin
    FShowMark := Value;
    if Control <> nil then Control.RepaintBar;
  end;
end;

procedure TdxBar.SetSizeGrip(Value: Boolean);
begin
  if FSizeGrip <> Value then
  begin
    FSizeGrip := Value;
    if IsStatusBar and (Control <> nil) then
      Control.RebuildBar;
  end;
end;

procedure TdxBar.SetUseOwnFont(Value: Boolean);
begin
  if FUseOwnFont <> Value then
  begin
    FUseOwnFont := Value;
    InternalUpdateFont;
  end;
end;

procedure TdxBar.SetUseRecentItems(Value: Boolean);
begin
  if UseRecentItems <> Value then
  begin
    FItemLinks.FUseRecentItems := Value;
    if Control <> nil then
      Control.RepaintBar;
  end;
end;

procedure TdxBar.SetUseRestSpace(Value: Boolean);
begin
  if FUseRestSpace <> Value then
  begin
    FUseRestSpace := Value;
    if Control <> nil then Control.RepaintBar;
  end;
end;

procedure TdxBar.SetVisible(Value: Boolean);
begin
  if (BarManager = nil) or Value and BarManager.IsDestroying then Exit;
  if not FVisible and not Value then
    BarManager.RemoveBarFromRestoringList(Self);

  if IsLoading then
  begin
    if FVisible <> Value then
      FInternallyHidden := False;
    FLoadedVisible := Value;
    Exit;
  end;
  if FVisible <> Value then
  begin
    FInternallyHidden := False;
    if not Value and (Control <> nil) then
      Control.SavePos;
    FVisible := Value;
    if FVisible then
    begin
      FItemLinks.CreateBarControl;
      ShowControl;
    end
    else  // Visible = False
      ItemLinks.DestroyBarControl;

    DoVisibleChanged;
  end;
end;

procedure TdxBar.SetWholeRow(Value: Boolean);
begin
  if FWholeRow <> Value then
  begin
    FWholeRow := Value;
    if (Control <> nil) and (DockingStyle <> dsNone) then
    begin
      Visible := False;
      Visible := True;
    end;
  end;
end;

procedure TdxBar.FontChanged(Sender: TObject);
begin
  if not FInternalFontChange then
    FUseOwnFont := True;
  if FUseOwnFont then
    CreateEditFontHandle(Font, FEditFont, False, ScaleFactor);
  if Control <> nil then
    Control.UpdateFont;
end;

procedure TdxBar.Move(X, Y: Integer);
begin
  DockingStyle := dsNone;
  FloatLeft := X;
  FloatTop := Y;
end;

procedure TdxBar.Move(ADockControl: TdxDockControl; ARow, APosition: Integer);
var
  ADockRow: TdxDockRow;
  APrevOneOnRow, APrevVisible: Boolean;
begin
  if (RealDockControl = nil) and (ADockControl = nil) or
    (ADockControl <> nil) and (ADockControl.BarManager <> BarManager) then
      Exit;

  if ADockControl = nil then
    ADockControl := RealDockControl;
  if (ADockControl = RealDockControl) and (ARow = Row) and (APosition = GetDockedPosition) then
    Exit;

  APrevOneOnRow := OneOnRow;
  APrevVisible := Visible;
  Visible := False;

  if BarManager.IsInternalDockControl(ADockControl) then
    DockingStyle := ADockControl.DockingStyle
  else
    FDockControl := TdxBarDockControl(ADockControl);

  if ARow >= ADockControl.RowCount then
  begin
    ADockRow := TdxDockRow.Create(ADockControl);
    ADockControl.RowList.Add(ADockRow);
  end;

  if ADockControl.Vertical then
    DockedTop := APosition
  else
    DockedLeft := APosition;

  Row := ARow;
  OneOnRow := APrevOneOnRow;
  Visible := APrevVisible;
  if RealDockControl <> nil then
    RealDockControl.AssignPositions;
end;

procedure TdxBar.Move(ADockingStyle: TdxBarDockedDockingStyle; ARow, APosition: Integer);
begin
  Move(BarManager.InternalDockControls[ADockingStyle], ARow, APosition);
end;

procedure TdxBar.Move(ABar: TdxBar; AInsertAfter: Boolean = True);
var
  APosition: Integer;
begin
  if (ABar.RealDockControl = nil) or (ABar.BarManager <> BarManager) or AInsertAfter and (ABar.Control = nil) then
    Exit;
  APosition := ABar.GetDockedPosition;
  if AInsertAfter then
    if ABar.IsVertical then
      Inc(APosition, ABar.Control.Height)
    else
      Inc(APosition, ABar.Control.Width);
  OneOnRow := False;
  Move(ABar.RealDockControl, ABar.Row, APosition);
end;

procedure TdxBar.NotifyListenersBarVisibilityChanged;
var
  I: Integer;
begin
  for I := 0 to FListeners.Count - 1 do
    (FListeners[I] as IdxBarListener).BarVisibleChanged(Self);
end;

procedure TdxBar.ReadPixelsPerInch(Reader: TReader);
begin
  ScaleFactor.Assign(Reader.ReadInteger, dxDefaultDPI);
end;

procedure TdxBar.WritePixelsPerInch(Writer: TWriter);
begin
  Writer.WriteInteger(ScaleFactor.Apply(dxDefaultDPI));
end;

procedure TdxBar.UpdateControlPosition;
begin
  if (Control <> nil) and not Bars.IsMoving and not Control.FPosSaving then
  begin
    if DockingStyle = dsNone then
      UpdateFloatingControlPosition
    else
      ShowControl;
  end;
end;

procedure TdxBar.UpdateFloatingControlPosition;
var
  ASize: TSize;
begin
  ASize := Control.GetTrackSize(dsNone);
  Control.SetBounds(FloatLeft, FloatTop, ASize.cx, ASize.cy);
end;

function TdxBar.IsDockedDockingStyleStored: Boolean;
begin
  Result := FDockedDockControl = nil;
end;

function TdxBar.IsDockingStyleStored: Boolean;
begin
  Result := FDockControl = nil;
end;

procedure TdxBar.AddFreeNotification(AItem: TdxBarItem);
begin
  FFreeNotificationItems.Add(AItem);
end;

procedure TdxBar.RemoveFreeNotification(AItem: TdxBarItem);
begin
  FFreeNotificationItems.Remove(AItem);
end;

procedure TdxBar.MakeFreeNotification;
var
  I: Integer;
begin
  for I := FFreeNotificationItems.Count - 1 downto 0 do
    TdxBarItem(FFreeNotificationItems[I]).ObjectNotification(opRemove, Self);
end;

procedure TdxBar.RemoveFromDockRow(ADestroyEmptyDockRow: Boolean);
begin
  if FDockRow <> nil then
    FDockRow.DeleteBar(Self, ADestroyEmptyDockRow);
  FDockRow := nil;
end;

function TdxBar.BarNCSizeX(AStyle: TdxBarDockingStyle): Integer;
begin
  Result := cxMarginsWidth(Painter.GetToolbarContentOffsets(Self, AStyle, ScaleFactor, HasSizeGrip));
end;

function TdxBar.BarNCSizeY(AStyle: TdxBarDockingStyle): Integer;
begin
  Result := cxMarginsHeight(Painter.GetToolbarContentOffsets(Self, AStyle, ScaleFactor, HasSizeGrip));
end;

function TdxBar.CanClose: Boolean;
begin
  Result := FAllowClose and not FIsMainMenu and ((Control = nil) or Control.HasCaption);
end;

function TdxBar.CanMoving: Boolean;
const
  AllDockingStyles = [Low(TdxBarDockingStyle)..High(TdxBarDockingStyle)];
begin
  Result := (NotDocking <> AllDockingStyles) and
    (BarManager.NotDocking <> AllDockingStyles);
end;

function TdxBar.CanReset: Boolean;
begin
  Result := FIsPredefined and FAllowReset;
end;

function TdxBar.GetDockedPosition: Integer;
begin
  if IsVertical then
    Result := DockedTop
  else
    Result := DockedLeft;
end;

function TdxBar.HasSizeGrip: Boolean;
var
  Parent: HWND;
  R, CR: TRect;

  function FindForm(AHandle: HWND): TCustomForm;
  var
    AControl: TWinControl;
  begin
    AControl := FindControl(AHandle);
    if AControl is TCustomForm then
      Result := TCustomForm(AControl)
    else
      Result := nil;
  end;

  function IsBottom(AHandle: HWND): Boolean;
  begin
    Parent := GetParent(AHandle);
    Result := (Parent = 0) or IsMDIChild(FindForm(AHandle));
    if not Result then
    begin
      R := dxMapWindowRect(0, Parent, cxGetWindowRect(AHandle));
      GetClientRect(Parent, CR);
      Result := (R.Bottom = CR.Bottom) and IsBottom(Parent);
    end;
  end;

begin
  Result := IsStatusBar and SizeGrip and not IsZoomed(BarManager.Owner.Handle) and
    ((Control = nil) or IsBottom(Control.Handle));
end;

function TdxBar.IsFloat: Boolean;
begin
  Result := (Control <> nil) and (DockingStyle = dsNone);
end;

function TdxBar.IsMerged: Boolean;
begin
  Result := (MergeData.MergedWith <> nil) or (MergeData.MergedBarList.Count > 0);
end;

function TdxBar.IsShortCut(AShortCut: TShortCut): Boolean;
begin
  Result := FItemLinks.IsShortCut(AShortCut);
end;

function TdxBar.IsStatusBar: Boolean;
begin
  Result := (FBorderStyle = bbsNone) and (DockingStyle = dsBottom) and WholeRow; // !!!
end;

//IdxBarSelectableItem
function TdxBar.CanDelete(ADestruction: Boolean = False): Boolean;
begin
  Result := (BarManager.Designing or not IsPredefined and CanClose) and BarManager.CanDeleteComponent(Self);
end;

procedure TdxBar.DeleteSelection(var AReference: IdxBarSelectableItem; ADestruction: Boolean);
begin
  if CanDelete(ADestruction) then
  begin
    AReference := nil;
    Free;
  end;
end;

procedure TdxBar.ExecuteCustomizationAction(ABasicAction: TdxBarCustomizationAction);
begin
// do nothing
end;

function TdxBar.GetBarManager: TdxBarManager;
begin
  Result := GetParentComponent as TdxBarManager;
end;

procedure TdxBar.GetMasterObjects(AList: TdxObjectList);
begin
  AList.Add(BarManager.Owner);
end;

function TdxBar.GetNextSelectableItem: IdxBarSelectableItem;
begin
  Result := GetNext;
end;

function TdxBar.GetSelectableParent: TPersistent;

  function FindSelectableParent(AControl: TWinControl): TWinControl;
  begin
    Result := nil;
    while (AControl <> nil) and (Result = nil) do
      if GetClass(AControl.ClassName) <> nil then
        Result := AControl
      else
        AControl := AControl.Parent;
  end;

begin
  Result := FindSelectableParent(DockControl);
  if Result = nil then
    Result := BarManager.Owner;
end;

function TdxBar.GetSelectionStatus: TdxBarSelectionStatus;
begin
  Result := BarManager.GetSelectionStatus(Self);
end;

function TdxBar.GetSupportedActions: TdxBarCustomizationActions;
begin
  Result := [caDelete];
end;

procedure TdxBar.Invalidate;
begin
  if Control <> nil then
    Control.Invalidate;
end;

function TdxBar.IsComplex: Boolean;
begin
  Result := False;
end;

function TdxBar.IsComponentSelected: Boolean;
begin
  Result := BarManager.IsComponentSelected(Self);
end;

procedure TdxBar.SelectComponent(ASelectionOperation: TdxBarSelectionOperation = soExclusive);
begin
  BarManager.SelectComponent(Self, ASelectionOperation);
end;

function TdxBar.SelectParentComponent: Boolean;
begin
  BarManager.SelectComponent(GetSelectableParent);
  Result := True;
end;

procedure TdxBar.SelectionChanged;
begin
  BarDesignController.SynchronizeLastSelectedItem;
  Invalidate;
end;

function TdxBar.GetScaleFactor: TdxScaleFactor;
begin
  Result := FScaleFactor;
end;

// IdxBarLinksOwner
function TdxBar.CanContainItem(AItem: TdxBarItem; out AErrorText: string): Boolean;
begin
  Result := AItem.CanBePlacedOn(pkBar, Self, AErrorText);
end;

function TdxBar.CreateBarControl: TCustomdxBarControl;
begin
  Result := CreateControl;
end;

function TdxBar.GetItemLinks: TdxBarItemLinks;
begin
  Result := FItemLinks;
end;

function TdxBar.GetImages: TCustomImageList;
begin
  Result := ItemLinks.Images;
end;

function TdxBar.IsLoading: Boolean;
begin
  Result := BarManager.IsLoading;
end;

procedure TdxBar.SetImages(AImages: TCustomImageList);
begin
  ItemLinks.Images := AImages;
end;

procedure TdxBar.ChangeScale(M, D: Integer);
begin
  ScaleFactor.Change(M, D);
  ItemLinks.ChangeScale(M, D);
  DockedTop := MulDiv(DockedTop, M, D);
  DockedLeft := MulDiv(DockedLeft, M, D);
  if UseOwnFont or not ScaleFactor.Equals(BarManager.ScaleFactor) then
    Font.Height := MulDiv(Font.Height, M, D);
end;

procedure TdxBar.GetAdornerTargetElements(AList: TStrings);

  procedure PopulateList(ABar: TdxBar);
  var
    I: Integer;
  begin
    for I := 0 to ABar.ItemLinks.Count - 1 do
      if ABar.ItemLinks[I].FItem <> nil then
        AList.AddObject(ABar.ItemLinks[I].Item.Name, ABar.ItemLinks[I]);
  end;

begin
  inherited GetAdornerTargetElements(AList);
  if (Control <> nil) and (Control.QuickPopup <> nil) then
    PopulateList(Control.QuickPopup.Bar);

  PopulateList(Self);
end;

function TdxBar.GetComponentInstance: TComponent;
begin
  Result := Self;
end;

function TdxBar.GetPersistentInstance: TPersistent;
begin
  Result := Self;
end;

procedure TdxBar.ChangeDockingStyle(AStyle: TdxBarDockingStyle; ADockControl: TdxDockControl);
begin
  if (ADockControl <> nil) and ADockControl.Main then
    ADockControl := nil;
  if DockingStyle = AStyle then
    DockControl := ADockControl as TdxBarDockControl
  else
    if DockControl = ADockControl then
      DockingStyle := AStyle
    else
      if ADockControl = nil then
        DockingStyle := AStyle
      else
        DockControl := ADockControl as TdxBarDockControl;
end;

function TdxBar.GetCollectionFromParent(AParent: TComponent): TcxComponentCollection;
begin
  Result := (AParent as TdxBarManager).Bars;
end;

function TdxBar.IsVertical: Boolean;
begin
  Result := (DockingStyle in [dsLeft, dsRight]) and RotateWhenVertical;
end;

procedure TdxBar.DefineProperties(Filer: TFiler);
begin
  inherited DefineProperties(Filer);
  Filer.DefineProperty('PixelsPerInch', ReadPixelsPerInch, WritePixelsPerInch, IsFloat and UseOwnFont and ScaleFactor.Assigned);
end;

procedure TdxBar.DoReset;

  procedure InternalReset(ASource: TCustomIniFile; const ABaseSection: string; ABarIndex: Integer);
  begin
    ResettingToolbar := True;
    try
      LoadFromIni(ASource, ABaseSection, ABarIndex, skIni, BarManager.UseFullReset);
      LoadUsageData(ASource, ABaseSection, ABarIndex);
      ItemLinks.CheckLinks(ASource, ABaseSection);
    finally
      ResettingToolbar := False;
    end;
  end;

var
  ABarIndex: Integer;
  ASavedState: TCustomIniFile;
begin
  ASavedState := BarManager.ReadSavedState;
  try
    ABarIndex := BarManager.GetSavedBarIndex(ASavedState, Caption);
    if ABarIndex <> -1 then
    begin
      BarManager.DoBarBeforeReset(Self);
      BarManager.BeginUpdate;
      try
        InternalReset(ASavedState, BarManager.GetBaseIniSection, ABarIndex);
      finally
        BarManager.EndUpdate;
      end;
      BarManager.DoBarAfterReset(Self);
    end;
  finally
    ASavedState.Free;
  end;
end;

procedure TdxBar.Reset(AShowConfirmation: Boolean);
var
  ACanReset: Boolean;
begin
  if not BarManager.DoResetBar(Self, AShowConfirmation) then
  begin
    if AShowConfirmation then
      ACanReset := dxBarMessageBox(
        Format(cxGetResourceString(@dxSBAR_WANTTORESETTOOLBAR), [Caption]),
        MB_OKCANCEL or MB_ICONEXCLAMATION) = ID_OK
    else
      ACanReset := True;

    if ACanReset then
      DoReset;
  end;
end;

procedure TdxBar.ResetWithConfirmation;
begin
  Reset(True);
end;

procedure TdxBar.SetParentComponent(AParent: TComponent);
begin
  RemoveListener(BarManager);
  inherited SetParentComponent(AParent);
  FItemLinks := TdxBarControlItemLinks.Create(BarManager, Self);
  Font.OnChange := nil;
  Font.Assign(BarManager.Font);
  Font.OnChange := FontChanged;
  AddListener(BarManager);
  if not IsLoading then
  begin
    if Assigned(BarManager.OnBarAdd) then
      BarManager.OnBarAdd(BarManager, Self);
    Changed(False);
  end;
end;

procedure TdxBar.AddListener(AListener: IdxBarListener);
begin
  if FListeners <> nil then
    FListeners.Add(AListener);
end;

procedure TdxBar.RemoveListener(AListener: IdxBarListener);
begin
  if FListeners <> nil then
    FListeners.Remove(AListener);
end;

procedure TdxBar.Merge(ABar: TdxBar);
begin
  InternalMerge(ABar, True);
end;

procedure TdxBar.Unmerge(ABar: TdxBar = nil);
begin
  InternalUnmergeFromBar(ABar, True);
end;

{ TdxBars }

constructor TdxBars.Create(ABarManager: TdxBarManager);
begin
  inherited Create(ABarManager, TdxBar);
  FBarManager := ABarManager;
  FDockingZoneSize := MinToolbarSize;
end;

destructor TdxBars.Destroy;
var
  I: TdxBarDockingStyle;
begin
  for I := dsBottom downto dsLeft do
    FDockControls[I].Free;
  inherited;
end;

function TdxBars.GetDockControl(Index: TdxBarDockingStyle): TdxDockControl;
begin
  if not HasDockControls and not BarManager.IsDestroying then
    CreateDockControls;
  Result := FDockControls[Index];
end;

function TdxBars.GetItem(Index: Integer): TdxBar;
begin
  Result := TdxBar(inherited Items[Index]);
end;

procedure TdxBars.SetItem(Index: Integer; Value: TdxBar);
begin
  Items[Index].Assign(Value);
end;

procedure TdxBars.ChangeScale(M, D: Integer);
var
  ABar: TdxBar;
  I: Integer;
begin
  BeginUpdate;
  FScaling := True;
  try
    for I := 0 to Count - 1 do
    begin
      ABar := Items[I];
      if ABar.IsFloat then
        ABar.UseOwnFont := True
      else
        ABar.ChangeScale(M, D);
    end;
  finally
    FScaling := False;
    EndUpdate;
  end;
end;

procedure TdxBars.CreateDockControls;
var
  ADockingStyle: TdxBarDockingStyle;
begin
  if not HasDockControls then
    for ADockingStyle := dsLeft to dsBottom do
    begin
      FDockControls[ADockingStyle] := TdxDockControl.CreateEx(nil, FBarManager, ADockingStyle);
      FDockControls[ADockingStyle].Parent := FBarManager.Owner;
    end;
end;

function TdxBars.HasDockControls: Boolean;
begin
  Result := FDockControls[dsLeft] <> nil;
end;

procedure TdxBars.RegInDock(AStyle: TdxBarDockingStyle; ADockControl: TdxDockControl; ABarControl: TdxBarControl; APos: TPoint);
begin
  if ADockControl <> nil then
    ADockControl.AddBarControl(ABarControl, APos, True)
  else
    if (AStyle <> dsNone) and (DockControls[AStyle] <> nil) then
      DockControls[AStyle].AddBarControl(ABarControl, APos, True);
end;

procedure TdxBars.UnregFromDock(AStyle: TdxBarDockingStyle;
  ADockControl: TdxDockControl; ABarControl: TdxBarControl);
begin
  if ADockControl <> nil then
    ADockControl.DeleteBarControl(ABarControl, nil, True)
  else
    if (AStyle <> dsNone) and (FDockControls[AStyle] <> nil) then
      FDockControls[AStyle].DeleteBarControl(ABarControl, nil, True);
end;

procedure DockTimerProc(Wnd: HWND; Msg: UINT; idEvent: UINT; Time: DWORD); stdcall;
var
  P: TPoint;
begin
  dxKillTimer(0, FDockTimerID);
  if FDockBarManager <> nil then
    with FDockBarManager.Bars do
    begin
      P := GetMouseCursorPos;
      Inc(P.X, FMovingOffset.X);
      Inc(P.Y, FMovingOffset.Y);
      FDocking := True;
      ChangeBarControlPos(FMovingBarControl, P);
      FDocking := False;
      FDockBarManager := nil;
    end;
end;

procedure TdxBars.ChangeBarControlPos(ABarControl: TdxBarControl; APos: TPoint);
var
  AStyle: TdxBarDockingStyle;
  ADockControl: TdxDockControl;
  ASize: TSize;
begin
  AStyle := GetDockingStyleAtPos(ABarControl.Bar, APos, ADockControl);
  if not FBarManager.DoDocking(ABarControl.Bar, AStyle, ADockControl) then Exit;

  if not FDocking and (ABarControl.DockingStyle = dsNone) and (AStyle <> dsNone) then
  begin
    dxKillTimer(0, FDockTimerID);
    FDockBarManager := BarManager;
    FDockTimerID := SetTimer(0, 0, BarManager.WaitForDockingTime, @DockTimerProc);
    ADockControl := nil;
    AStyle := dsNone;
  end;

  if AStyle = dsNone then
  begin
    Dec(APos.X, FMovingOffset.X);
    Dec(APos.Y, FMovingOffset.Y);
  end;
  if (ABarControl.DockingStyle <> AStyle) or
    (ABarControl.DockControl <> ADockControl) then
  begin
    ABarControl.Hide;
    if ABarControl.DockingStyle <> dsNone then
    begin
      UnregFromDock(ABarControl.DockingStyle, ABarControl.DockControl, ABarControl);
      ABarControl.ItemLinks.RecentItemCount := -1;
    end;
    if AStyle <> dsNone then
    begin
      with ABarControl do
      begin
        BeginInternal; //!!!
        try
          ChangeStyleWinTo(AStyle, ADockControl);
        finally
          EndInternal;
        end;
      end;
      RegInDock(AStyle, ADockControl, ABarControl, APos);
    end
    else
      with ABarControl do
      begin
        BeginInternal;  // for WMSize
        try
          ChangeStyleWinTo(AStyle, nil);
        finally
          EndInternal;
        end;
        ASize := GetTrackSize(AStyle);
        with GetDragPointOffset(AStyle) do
          SetWindowPos(Handle, 0, APos.X - X, APos.Y - Y, ASize.cx, ASize.cy,
            SWP_NOZORDER or SWP_NOACTIVATE);
      end;
    Windows.ShowWindow(ABarControl.Handle, SW_SHOWNA);
  end
  else
    if ABarControl.DockingStyle <> dsNone then
      ADockControl.MoveBarControl(ABarControl, APos)
    else
      with ABarControl, GetDragPointOffset(AStyle) do
        SetWindowPos(Handle, 0, APos.X - X, APos.Y - Y, 0, 0,
          SWP_NOZORDER or SWP_NOSIZE or SWP_NOACTIVATE);
end;

function TdxBars.GetDockingStyleAtPos(Bar: TdxBar; Pos: TPoint;
  var DockControl: TdxDockControl): TdxBarDockingStyle;
var
  ADockControl: TdxDockControl;

  function PtInControlRect(ADockControl: TWinControl; const R: TRect; P: TPoint): Boolean;
  var
    AParent: TWinControl;
  begin
    Result := PtInRect(R, P);
    if Result and ADockControl.HandleAllocated and
      (ADockControl.Parent <> nil) and (ADockControl.Parent.Parent <> nil) then
    begin
      AParent := ADockControl.Parent.Parent;
      P := AParent.ScreenToClient(P);
      Result := ADockControl.Parent.Handle =
        ChildWindowFromPointEx(AParent.Handle, P, CWP_SKIPINVISIBLE);
    end;
  end;

  function CheckDockZone(ADockingStyle: TdxBarDockingStyle): Boolean;
  var
    I: Integer;
  begin
    Result := False;
    for I := 0 to FBarManager.DockControlCount - 1 do
    begin
      ADockControl := FBarManager.DockControls[I];
      with ADockControl do
        if (DockingStyle = ADockingStyle) and (CanFocus or BarManager.Designing) then
        begin
          Result :=
            FBarManager.DoDocking(Bar, ADockingStyle, ADockControl) and
            PtInControlRect(ADockControl, GetDockZoneBounds, Pos);
          if Result then Break;
        end;
    end;
    if Result then
    begin
      DockControl := ADockControl;
      GetDockingStyleAtPos := ADockingStyle;
    end;
  end;

begin
  DockControl := nil;
  Result := dsNone;

  if FMoving and (GetAsyncKeyState(VK_CONTROL) < 0) then Exit;

  if CheckDockZone(dsLeft) then Exit;
  if CheckDockZone(dsRight) then Exit;
  if CheckDockZone(dsTop) then Exit;
  if CheckDockZone(dsBottom) then Exit;

  if FMoving then
  begin
    Dec(Pos.X, FMovingOffset.X);
    Dec(Pos.Y, FMovingOffset.Y);
  end;
  if CheckDockZone(dsLeft) then Exit;
  if CheckDockZone(dsRight) then Exit;
  if CheckDockZone(dsTop) then Exit;
  if CheckDockZone(dsBottom) then Exit;
end;

procedure TdxBars.Moving(AMovingBarControl: TdxBarControl);
var
  ACaptureWnd: HWND;
  AMsg: TMsg;
  APrevP, ACalcP, P: TPoint;
  AMovingBar: TdxBar;
  AMessage: TMessage;
begin
  // ---
  if not AMovingBarControl.CanMoving then Exit;

  AMovingBar := AMovingBarControl.Bar;
  if AMovingBar.DockingStyle <> dsNone then
    AMovingBarControl.GetDockCol.FPos := Point(AMovingBar.DockedLeft, AMovingBar.DockedTop);

  FMoving := True;
  AMovingBarControl.Moving := True;
  APrevP := GetMouseCursorPos;

  FMovingBarOriginalDockingStyle := FMovingBarControl.DockingStyle;
  FMovingOffset := cxNullPoint;
  FMovingStaticOffset := cxNullPoint;
  if AMovingBar.DockingStyle <> dsNone then
  begin
    P := FMovingBarControl.GetDockCol.Pos;
    P.X := FMovingBarControl.DockControl.GetBarControlPos(P.X, FMovingBarControl.Width);
    Windows.ClientToScreen(AMovingBar.RealDockControl.Handle, P);

    AMovingBar.RealDockControl.DeleteBarControl(AMovingBarControl, nil, False);
    ACalcP := APrevP;
    AMovingBar.RealDockControl.GetPosForRow(AMovingBar.Row, AMovingBar.OneOnRow, ACalcP);
    if FMovingBarControl.Vertical then
      FMovingOffset.X := ACalcP.X - APrevP.X
    else
      FMovingOffset.Y := ACalcP.Y - APrevP.Y;
    FMovingBarControl.BeginInternal;
    try
      AMovingBar.RealDockControl.AddBarControl(FMovingBarControl, P, False);
    finally
      FMovingBarControl.EndInternal;
    end;

    FMovingStaticOffset := Point(FMovingBarControl.Left, FMovingBarControl.Top);
    Windows.ClientToScreen(AMovingBar.RealDockControl.Handle, FMovingStaticOffset);
    with FMovingStaticOffset do
    begin
      X := APrevP.X - X;
      Y := APrevP.Y - Y;
    end;
  end;

  ProcessPaintMessages;

  Include(BarDesignController.FDesignStates, dsKeyAlreadyProcessed);
  ACaptureWnd := BarManager.GetWindowForMouseCapturing;
  SetCapture(ACaptureWnd);
  try
    while GetCapture = ACaptureWnd do
    begin
      case Integer(GetMessage(AMsg, 0, 0, 0)) of
        -1: Break;
        0: begin
            PostQuitMessage(AMsg.wParam);
            Break;
          end;
      end;
      with AMsg do
        if ((message = WM_KEYDOWN) or (message = WM_KEYUP)) and
          (wParam = VK_CONTROL) then
        begin
          message := WM_MOUSEMOVE;
          hwnd := 0;
          lParam := dxPointToLParam(GetMouseCursorPos);
          APrevP := cxInvalidPoint;
        end;
      case AMsg.message of
        WM_KEYDOWN, WM_KEYUP:
          if AMsg.wParam = VK_ESCAPE then Break;
        WM_MOUSEMOVE:
          begin
            AMessage.LParam := AMsg.lParam;
            P := SmallPointToPoint(TWMMouseMove(AMessage).Pos);
            ClientToScreen(AMsg.hwnd, P);
            if (P.X <> APrevP.X) or (P.Y <> APrevP.Y) then
            begin
              ACalcP := P;
              Inc(ACalcP.X, FMovingOffset.X);
              Inc(ACalcP.Y, FMovingOffset.Y);
              ChangeBarControlPos(FMovingBarControl, ACalcP);
              //ProcessPaintMessages;
              APrevP := P;
            end;
          end;
        WM_LBUTTONUP:
          Break;
      else
        TranslateMessage(AMsg);
        DispatchMessage(AMsg);
      end;
    end;
  finally
    if dxKillTimer(0, FDockTimerID) then
      FDockBarManager := nil;
    if GetCapture = ACaptureWnd then ReleaseCapture;
    AMovingBarControl := FMovingBarControl;
    FMovingBarControl.Moving := False;
    if AMovingBarControl.DockingStyle <> dsNone then
      AMovingBarControl.DockControl.AssignPositions;
    FMoving := False;
    Exclude(BarDesignController.FDesignStates, dsKeyAlreadyProcessed);
  end;
end;

procedure TdxBars.Repaint;
var
  I: Integer;
begin
  for I := 0 to Count - 1 do
    with Items[I] do
      if Control <> nil then
        Control.RepaintBar;
end;

procedure TdxBars.SetItemName(AItem: TcxComponentCollectionItem; ABaseIndex: Integer = -1);
begin
  AItem.Name := GetUniqueToolBarName(BarManager.Name + 'Bar');
end;

procedure TdxBars.Update(AItem: TcxComponentCollectionItem; AAction: TcxComponentCollectionNotification);
begin
  inherited;
  if AAction = ccnChanged then
    BarManager.DesignerModified;
end;

function TdxBars.Add: TdxBar;
begin
  Result := TdxBar(inherited Add);
end;

function TdxBars.GetUniqueToolbarName(const ABaseName: string): string;
begin
  Result := BarManager.GetUniqueToolbarName(ABaseName);
end;

function TdxBars.Insert(Index: Integer): TdxBar;
begin
  Result := TdxBar(inherited Insert(Index));
end;

{ TdxBarPainter }

constructor TdxBarPainter.Create(AData: TdxNativeUInt);
begin
  inherited Create;
end;

procedure TdxBarPainter.CalculateExtraMenuButtonParts(
  const ADrawParams: TdxBarExtraMenuButtonControlDrawParams;
  var AParts: array of TRect; const AItemRect: TRect);
begin
  AParts[epbcpPinButton].Left := AParts[epbcpPinButton].Right - ExtraMenuPinButtonSize;
  AParts[epbcpButton].Right := AParts[epbcpPinButton].Left;
end;

procedure TdxBarPainter.CalculateButtonParts(
  const ADrawParams: TdxBarButtonLikeControlDrawParams;
  var AParts: array of TRect; const AItemRect: TRect);
begin
  if ADrawParams.IsDropDown then
  begin
    AParts[bcpDropButton].Left := AParts[bcpDropButton].Right - ADrawParams.ArrowSize.cx;
    AParts[bcpButton].Right := AParts[bcpDropButton].Left;
  end;
end;

procedure TdxBarPainter.CalculateColorComboParts(const ADrawParams: TdxBarColorComboControlDrawParams;
  var AParts, AAreaParts: array of TRect);
begin
  AParts[clcpCustomColorButton] := GetCustomColorButtonBounds(ADrawParams, AAreaParts[ecpEdit]);
  AParts[ccpDropButton].Right := AParts[clcpCustomColorButton].Left;
  if IsCustomColorButtonVisible(ADrawParams) then
    Dec(AParts[ccpDropButton].Right, GetCustomColorButtonIndents(ADrawParams.PaintType).Left);
  if not ColorComboHasCompleteFrame or not IsCustomColorButtonVisible(ADrawParams) then
    Dec(AParts[ccpDropButton].Right, ComboControlButtonOffsets(ADrawParams.PaintType).Right);
  InternalCalculateComboParts(ADrawParams, AParts);
end;

procedure TdxBarPainter.CalculateComboParts(const ADrawParams: TdxBarEditLikeControlDrawParams;
  var AParts, AAreaParts: array of TRect);
begin
  AParts[ccpDropButton] := cxRectContent(AAreaParts[ecpEdit], ComboControlButtonOffsets(ADrawParams.PaintType));
  InternalCalculateComboParts(ADrawParams, AParts);
end;

procedure TdxBarPainter.CalculateEditParts(const ADrawParams: TdxBarEditLikeControlDrawParams;
  var AParts, AAreaParts: array of TRect);
begin
  with ADrawParams do
  begin
    AParts[ecpIcon] := AAreaParts[ecpIcon];
    AParts[ecpText] := AAreaParts[ecpText];
    AParts[ecpEdit] := EditControlGetContentRect(PaintType, BarEditControl.GetEditRect);
  end;
end;

procedure TdxBarPainter.CalculateSpinEditParts(const ADrawParams: TdxBarSpinEditDrawParams;
  var AParts, AAreaParts: array of TRect);
begin
  AParts[secButtonUp] := GetSpinEditButtonBounds(ADrawParams, AAreaParts[ecpEdit], sbUp);
  AParts[secButtonDown] := GetSpinEditButtonBounds(ADrawParams, AAreaParts[ecpEdit], sbDown);
  AParts[ecpEdit].Right := AParts[secButtonUp].Left - EditControlBorderOffsets(ADrawParams.PaintType).Right - GetSpinEditButtonIndents(ADrawParams.PaintType).Left;
end;

function TdxBarPainter.GetToolbarContentOffsets(ABar: TdxBar;
  ADockingStyle: TdxBarDockingStyle; AScaleFactor: TdxScaleFactor; AHasSizeGrip: Boolean): TRect;
begin
  if ADockingStyle = dsNone then
  begin
    Result := cxRectBounds(BorderSizeX(AScaleFactor), BorderSizeY(AScaleFactor), 0, 0);
    if (ABar.Control = nil) or ABar.Control.HasCaption then
    begin
      Inc(Result.Left, BarHorSize);
      Inc(Result.Right, BarHorSize);
      Inc(Result.Top, BarCaptionAreaSize(AScaleFactor) + BarTopSize);
      Inc(Result.Bottom, BarBottomSize);
    end;
  end
  else
    if ABar.BorderStyle = bbsSingle then
    begin
      BarBorderSizes(ABar, ADockingStyle, Result);
      if ADockingStyle in [dsTop, dsBottom] then
        Inc(Result.Left, BarFingersSize(ABar))
      else
        Inc(Result.Top, BarFingersSize(ABar));
    end
    else
    begin
      Result := cxEmptyRect;
      if ABar.IsStatusBar then
      begin
        Inc(Result.Top, StatusBarTopBorderSize);
        Result.TopLeft := cxPointOffset(Result.TopLeft, StatusBarBorderOffsets.TopLeft);
        Result.BottomRight := cxPointOffset(Result.BottomRight, StatusBarBorderOffsets.BottomRight);
      end;
      if AHasSizeGrip then
        Inc(Result.Right, StatusBarGripSize(ABar.BarManager, AScaleFactor).cx);
    end;
end;

function TdxBarPainter.GetToolbarsOffsetForAutoAlign: Integer;
begin
  Result := 0;
end;

class procedure TdxBarPainter.CalculateArrowPoints(const ARect: TRect; AArrowSize: Integer; AArrowDirection: TcxArrowDirection; out P: TcxArrowPoints);

  procedure OffsetPoints(var P: TcxArrowPoints; ADisplace: TPoint);
  var
    I: Integer;
  begin
    for I := Low(P) to High(P) do
      P[I] := cxPointOffset(P[I], ADisplace);
  end;

  procedure CorrectArrowPoints(var P: TcxArrowPoints; AArrowDirection: TcxArrowDirection);
  begin
    case AArrowDirection of
      adUp:
        begin
          P[cxArrowLeftBasePointIndex] := cxPointOffset(P[cxArrowLeftBasePointIndex], 0, 1);
          P[cxArrowRightBasePointIndex] := cxPointOffset(P[cxArrowRightBasePointIndex], 1, 1);
        end;
      adDown:
        begin
          P[cxArrowLeftBasePointIndex] := cxPointOffset(P[cxArrowLeftBasePointIndex], 1, 0);
          P[cxArrowTopPointIndex] := cxPointOffset(P[cxArrowTopPointIndex], 0, 1);
          if Odd(AArrowSize + cxRectHeight(ARect)) then
            OffsetPoints(P, Point(0, -1));
        end;
      adLeft:
        begin
          P[cxArrowLeftBasePointIndex] := cxPointOffset(P[cxArrowLeftBasePointIndex], 1, 1);
          P[cxArrowRightBasePointIndex] := cxPointOffset(P[cxArrowRightBasePointIndex], 1, 0);
        end;
      adRight:
        begin
          P[cxArrowRightBasePointIndex] := cxPointOffset(P[cxArrowRightBasePointIndex], 0, 1);
          P[cxArrowTopPointIndex] := cxPointOffset(P[cxArrowRightBasePointIndex], 1, 0);
          if Odd(AArrowSize + cxRectWidth(ARect)) then
            OffsetPoints(P, Point(-1, 0));
        end;
    end;
  end;

begin
  cxLookAndFeelPaintersManager.GetPainter(lfsStandard).CalculateArrowPoints(
    ARect, P, AArrowDirection, False, AArrowSize);
  CorrectArrowPoints(P, AArrowDirection);
end;

class function TdxBarPainter.GetArrowRectByPoints(const P: TcxArrowPoints; AArrowDirection: TcxArrowDirection): TRect;
begin
  case AArrowDirection of
    adUp:
      Result := Rect(P[cxArrowLeftBasePointIndex].X, P[cxArrowTopPointIndex].Y, P[cxArrowRightBasePointIndex].X, P[cxArrowRightBasePointIndex].Y);
    adDown:
      Result := Rect(P[cxArrowRightBasePointIndex].X, P[cxArrowRightBasePointIndex].Y, P[cxArrowLeftBasePointIndex].X, P[cxArrowTopPointIndex].Y);
    adLeft:
      Result := Rect(P[cxArrowTopPointIndex].X, P[cxArrowRightBasePointIndex].Y, P[cxArrowLeftBasePointIndex].X, P[cxArrowLeftBasePointIndex].Y);
    adRight:
      Result := Rect(P[cxArrowLeftBasePointIndex].X, P[cxArrowLeftBasePointIndex].Y, P[cxArrowTopPointIndex].X, P[cxArrowRightBasePointIndex].Y);
  end;
end;

class procedure TdxBarPainter.SetArrowRegion(ACanvas: TcxCanvas; AArrowDirection: TcxArrowDirection;
  P: TcxArrowPoints; AOperation: TcxRegionOperation);

  procedure CalculateClipArea(var P: TcxArrowPoints);
  begin
    case AArrowDirection of
      adUp:
        begin
          Dec(P[cxArrowLeftBasePointIndex].X);
          Inc(P[cxArrowRightBasePointIndex].X);
          Dec(P[cxArrowTopPointIndex].Y);
        end;
      adLeft:
        begin
          Inc(P[cxArrowRightBasePointIndex].X);
          Dec(P[cxArrowRightBasePointIndex].Y, 2);
          Dec(P[cxArrowTopPointIndex].X);
        end;
      adRight:
        begin
          Dec(P[cxArrowLeftBasePointIndex].X);
          Dec(P[cxArrowLeftBasePointIndex].Y, 2);
        end;
    end;
  end;

var
  ARgn: HRGN;
begin
  CalculateClipArea(P);
  ARgn := CreatePolygonRgn(P, 3, WINDING);
  ACanvas.SetClipRegion(TcxRegion.Create(ARgn), AOperation);
end;

class function TdxBarPainter.GetControlCaptionOffset(ABarItemControl: TdxBarItemControl): Integer;
begin
  Result := -ABarItemControl.Parent.Font.Height div 2;
end;

class function TdxBarPainter.GetDefaultTextSize(ACanvas: TcxCanvas; AScaleFactor: TdxScaleFactor): Integer;
begin
  Result := cxTextHeight(ACanvas.Handle) + AScaleFactor.Apply(6);
end;

class function TdxBarPainter.GetPopupWindowBorderWidth: Integer;
begin
  Result := 2;
end;

function TdxBarPainter.GetSmallIconSize(AScaleFactor: TdxScaleFactor): Integer;
begin
  Result := AScaleFactor.Apply(DefaultGlyphSize);
end;

class function TdxBarPainter.SubMenuControlGetItemIconRealRect(const AItemRect: TRect; AIconAreaSize: Integer; AIsRightToLeft: Boolean): TRect;
begin
  Result := SubMenuControlGetItemIconRect(AItemRect, AIconAreaSize);
  if AIsRightToLeft then
    Result := TdxRightToLeftLayoutConverter.ConvertRect(Result, AItemRect);
end;

class function TdxBarPainter.SubMenuControlGetItemTextRealRect(const ADrawParams: TdxBarButtonLikeControlDrawParams; const AItemRect: TRect): TRect;
begin
  Result := SubMenuControlGetItemTextRect(ADrawParams, AItemRect);
  if ADrawParams.UseRightToLeftAlignment then
    Result := TdxRightToLeftLayoutConverter.ConvertRect(Result, AItemRect);
end;

class function TdxBarPainter.SubMenuControlGetItemIconRect(const AItemRect: TRect; AIconAreaSize: Integer): TRect;
begin
  Result := AItemRect;
  Result.Right := Result.Left + AIconAreaSize;
end;

class function TdxBarPainter.SubMenuControlGetItemTextRect(const ADrawParams: TdxBarButtonLikeControlDrawParams; const AItemRect: TRect): TRect;
begin
  Result := AItemRect;
  Inc(Result.Left, SubMenuControlGetItemTextIndent(ADrawParams));
end;

class function TdxBarPainter.SubMenuControlGetItemTextIndent(const ADrawParams: TdxBarItemControlDrawParams): Integer;
begin
  Result := ADrawParams.BarItemControl.SubMenuParent.BandSize + 3;
end;

class procedure TdxBarPainter.DrawBackground(ABarItemControl: TdxBarItemControl;
  DC: HDC; const R: TRect; ABrush: HBRUSH; AOpaque: Boolean);
begin
  if AOpaque then
    FillRect(DC, R, ABrush)
  else
  begin
    ABarItemControl.CheckNonRecent;
    try
      ABarItemControl.Parent.FillBackground(DC, R, ABrush, clNone, True);
    finally
      ABarItemControl.UncheckNonRecent;
    end;
  end;
end;

class procedure TdxBarPainter.DrawBackgroundFrameRect(ABarItemControl: TdxBarItemControl;
  DC: HDC; R: TRect; ABrush: HBRUSH; AOpaque: Boolean);
var
  AClipRgn: HRGN;
  AClipRgnExists: Boolean;
begin
  if AOpaque then
    FrameRect(DC, R, ABrush)
  else
  begin
    SaveClipRgn(DC, AClipRgn, AClipRgnExists);
    InflateRect(R, -1, -1);
    with R do
      ExcludeClipRect(DC, Left, Top, Right, Bottom);
    InflateRect(R, 1, 1);
    DrawBackground(ABarItemControl, DC, R, ABrush, False);
    RestoreClipRgn(DC, AClipRgn, AClipRgnExists);
  end;
end;

class procedure TdxBarPainter.DrawDisabledShadowRect(ABarItemControl: TdxBarItemControl;
  DC: HDC; R: TRect);
begin
  FillRect(DC, R, COLOR_BTNSHADOW + 1);
end;

procedure TdxBarPainter.DrawItemBackground(ABarItemControl: TdxBarItemControl;
  ACanvas: TcxCanvas; const ASourceRect: TRect; ABrush: HBRUSH);
begin
  ABarItemControl.Parent.FillBackground(ACanvas.Handle, ASourceRect, ABrush, clNone, True);
end;

procedure TdxBarPainter.DrawGlyph(ABarItemControl: TdxBarItemControl; ADC: HDC;
  ADrawRect: TRect; const AFullBounds: TRect; APaintType: TdxBarPaintType;
  AGlyphEmpty, ASelected, ADowned, ADrawDowned, ADroppedDown, ACenter, AForceUseBkBrush, AIsSplit: Boolean);
var
  AImageBounds: TRect;
begin
  DrawGlyph(ABarItemControl, ADC, ADrawRect, AFullBounds, AImageBounds, APaintType,
    ABarItemControl.GetViewStructure, ABarItemControl.GetViewSize, AGlyphEmpty, ASelected, ADowned,
    ADrawDowned, ADroppedDown, ACenter, AForceUseBkBrush, False, AIsSplit);
end;

procedure TdxBarPainter.DrawGlyph(ABarItemControl: TdxBarItemControl; ADC: HDC; ADrawRect: TRect;
  const AFullBounds: TRect; out AImageBounds: TRect; APaintType: TdxBarPaintType;
  AViewStructure: TdxBarItemControlViewStructure; AViewSize: TdxBarItemControlViewSize;
  AGlyphEmpty, ASelected, ADowned, ADrawDowned, ADroppedDown, ACenter, AForceUseBkBrush, AGrayScale, AIsSplit: Boolean);
var
  ACurrentGlyph: TdxSmartGlyph;
  ACurrentImageEnabled: Boolean;
  ACurrentImageIndex: Integer;
  ACurrentImages: TCustomImageList;
begin
  GetImageParams(ABarItemControl, ADrawRect, APaintType, AViewStructure, AViewSize, ACenter, ASelected, ADowned,
    ADrawDowned, AGlyphEmpty, ACurrentGlyph, ACurrentImages, ACurrentImageIndex, ACurrentImageEnabled, AImageBounds);

  ABarItemControl.ViewInfo.ImageBounds := AImageBounds;
  if not IsRectEmpty(AFullBounds) then
    ADrawRect := AFullBounds;

  DrawGlyphAndBkgnd(ABarItemControl, ADC, ADrawRect, AImageBounds, APaintType,
    ACurrentGlyph, ACurrentImages, ACurrentImageIndex, AGlyphEmpty, ASelected, ADowned, ADrawDowned,
    ADroppedDown, AForceUseBkBrush, AGrayScale, AIsSplit, ACurrentImageEnabled,
    GetGlyphColorPalette(ABarItemControl, APaintType, ASelected, ADowned, ADrawDowned, ADroppedDown, AIsSplit));
end;

procedure TdxBarPainter.DrawGlyphAndBkgnd(ABarItemControl: TdxBarItemControl; ADC: HDC; const R, AGlyphRect: TRect;
  APaintType: TdxBarPaintType; AGlyph: TdxSmartGlyph; AImages: TCustomImageList; AImageIndex: Integer;
  AGlyphEmpty, ASelected, ADowned, ADrawDowned, ADroppedDown, AForceUseBkBrush, AGrayScale, AIsSplit, AEnabled: Boolean;
  AColorPalette: IdxColorPalette);

  function GetImageGlyphRect(const ARect: TRect; ANeedBorder: Boolean): TRect;
  begin
    if ANeedBorder then
      Result := cxRectInflate(ARect, -1, -1)
    else
      Result := ARect;
  end;

  function DrawFadedBackground(ABarItemControl: TdxBarItemControl; DC: HDC; const R: TRect): Boolean;
  var
    AFadingElement: TdxFadingElement;
    ASaveDC: Integer;
  begin
    Result := dxFader.Find(ABarItemControl, AFadingElement);
    if Result then
    begin
      ASaveDC := SaveDC(DC);
      try
        IntersectClipRect(DC, R.Left, R.Top, R.Right, R.Bottom);
        AFadingElement.DrawImage(DC, ABarItemControl.ItemBounds);
      finally
        RestoreDC(DC, ASaveDC);
      end;
    end;
  end;

  procedure DrawGlyphImageBackground(ABarItemControl: TdxBarItemControl; ADC: HDC;
    const R: TRect; ADown, ADrawDowned, ASelected, AGlyphEmpty: Boolean; ABrush: HBRUSH);
  begin
    if not IsNativeBackground and (AGlyphEmpty or not AGlyphEmpty and IsGlyphImageTransparent(ABarItemControl)) then
      DrawBackground(ABarItemControl, ADC, R, ABrush,
        IsGlyphImageBackgroundOpaque(ABarItemControl, ADown, ADrawDowned, ASelected, AGlyphEmpty));
  end;

var
  ABarManager: TdxBarManager;
  ABrush: HBRUSH;
  AFullGlyphRect: TRect;
  AImageOptions: TdxBarImageOptions;
  ANeedBorder: Boolean;
  AWidth, AHeight, AImageWidth, AImageHeight: Integer;
begin
  AHeight := cxRectHeight(R);
  AWidth := cxRectWidth(R);
  ABrush := GlyphBkgndBrush(ABarItemControl, APaintType, AGlyphEmpty,
    ASelected, ADowned, ADrawDowned, ADroppedDown, AForceUseBkBrush, AGrayScale);

  if AGlyphEmpty then
  begin
    AImageWidth := ABarItemControl.BarManager.GetGlyphSize(ABarItemControl.ScaleFactor);
    ANeedBorder := (AImageWidth + 2 <= AWidth) and (AImageWidth + 2 <= AHeight);
  end
  else
  begin
    AImageHeight := cxRectHeight(AGlyphRect);
    AImageWidth := cxRectWidth(AGlyphRect);
    ANeedBorder := (AImageWidth + 2 <= AWidth) and (AImageHeight + 2 <= AHeight);
  end;

  if IsNativeBackground then
  begin
    if not DrawFadedBackground(ABarItemControl, ADC, R) then
      DrawGlyphBorder(ABarItemControl, ADC, ABrush, ANeedBorder, R, APaintType,
        AGlyphEmpty, ASelected, ADowned, ADrawDowned, ADroppedDown, AIsSplit);
  end;

  AFullGlyphRect := GetImageGlyphRect(R, ANeedBorder);
  DrawGlyphImageBackground(ABarItemControl, ADC, AFullGlyphRect, ADowned, ADrawDowned, ASelected, AGlyphEmpty, ABrush);

  if AGlyphEmpty then
    DrawGlyphEmptyImage(ABarItemControl, ADC, AFullGlyphRect, APaintType, ADowned)
  else
  begin
    if IsGlyphImageTransparent(ABarItemControl) then
      ABrush := 0;

    ABarManager := ABarItemControl.BarManager;
    AImageOptions := ABarManager.ImageOptions;
    TransparentDraw(ABarItemControl, ADC, ABrush, AFullGlyphRect, AGlyphRect, AGlyph, AImages, AImageIndex,
      ABarManager.ImageListBkColor, AEnabled, AGrayScale, IsFlatGlyphImage, ASelected, ADowned, ADrawDowned,
      IsGlyphImageHasShadow, GetFaded(ABarItemControl.Parent), AImageOptions.SmoothGlyphs,
      AImageOptions.UseLeftBottomPixelAsTransparent, AColorPalette);
  end;

  if not IsNativeBackground then
    DrawGlyphBorder(ABarItemControl, ADC, ABrush, ANeedBorder, R,
      APaintType, AGlyphEmpty, ASelected, ADowned, ADrawDowned, ADroppedDown, AIsSplit);
end;

function TdxBarPainter.GetGlyphColorPalette(
  ABarItemControl: TdxBarItemControl; APaintType: TdxBarPaintType;
  ASelected, ADowned, ADrawDowned, ADroppedDown, AIsSplit: Boolean): IdxColorPalette;
begin
  Result := nil;
end;

procedure TdxBarPainter.DrawGlyphAndTextInSubMenu(
  const ADrawParams: TdxBarButtonLikeControlDrawParams; const R: TRect);
begin
  with ADrawParams do
  begin
    DrawItemBackgroundInSubMenu(ADrawParams, R);

    DrawGlyph(BarItemControl, Canvas.Handle,
      SubMenuControlGetItemIconRealRect(R, BarItemControl.Parent.IconAreaSize, UseRightToLeftAlignment),
      cxEmptyRect, ptMenu, not HasIcon, DrawSelected, Downed, False, False, False, False, False);

    DrawItemTextInSubMenu(ADrawParams, SubMenuControlGetItemTextRealRect(ADrawParams, R));
  end;
end;

procedure TdxBarPainter.DrawItemBackgroundInSubMenu(const ADrawParams: TdxBarButtonLikeControlDrawParams; R: TRect);
begin
  // Required
end;

procedure TdxBarPainter.DrawItemMultilineText(const ADrawParams: TdxBarItemControlDrawParams;
  const AText: string; const ATextRect: TRect; AAlignment: UINT; AMaxLineCount: Integer);
var
  ALines: TStrings;
  I, ALettersCount, ALineHeight: Integer;
  ARect: TRect;
begin
  ARect := ATextRect;
  ALines := TStringList.Create;
  try
    cxGetTextLines(AText, ADrawParams.Canvas, ARect, ALines);
    if ALines.Count > AMaxLineCount then
    begin
      for I := ALines.Count - 1 downto AMaxLineCount - 1 do
        ALines.Delete(I);
      if ALines.Count > 0 then
        ALettersCount := Length(ALines[0]) + 1
      else
        ALettersCount := 0;
      ALines.Add(Trim(Copy(AText, ALettersCount, MaxInt)));
    end;
    ALineHeight := cxTextHeight(ADrawParams.Canvas.Handle);
    for I := 0 to ALines.Count - 1 do
    begin
      DrawItemText(ADrawParams.BarItemControl, ADrawParams.Canvas.Handle,
        ALines[I], ARect, AAlignment or DT_TOP, ADrawParams.Enabled,
        ADrawParams.DrawSelected, False, True, IsFlatItemTextForMenu, DT_END_ELLIPSIS);
      OffsetRect(ARect, 0, ALineHeight);
    end;
  finally
    ALines.Free;
  end;
end;

procedure TdxBarPainter.DrawItemText(ABarItemControl: TdxBarItemControl;
  ADC: HDC; S: string; APaintRect: TRect; AAlignment: UINT; AEnabled, ASelected,
  ARotated, AClipped, AFlatText: Boolean; AFormat: UINT);

  procedure UnderlineAccel(ACanvas: TcxCanvas; const APaintRect: TRect; const ATextSize: TSize; AAccelWidth, AAccelOffset: Integer);
  var
    X, Y: Integer;
    ATextMetric: TTextMetric;
  begin
    ACanvas.Pen.Color := ACanvas.Font.Color;
    GetTextMetrics(ACanvas.Handle, ATextMetric);
    X := (APaintRect.Left + APaintRect.Right - ATextSize.cy) div 2 + ATextMetric.tmDescent - 2;
    Y := APaintRect.Top + AAccelOffset;
    ACanvas.Line(X, Y, X, Y + AAccelWidth);
  end;

var
  R: TRect;
  AAccelPos: Integer;
  AFlat: Boolean;
  AColor1, AColor2: TColor;
  ATextSize: TSize;
  ATextOffsetY, AAccelWidth, AAccelOffsetY: Integer;
begin
  cxPaintCanvas.BeginPaint(ADC);
  try
    if ABarItemControl.Parent.UseRightToLeftReading then
      AFormat := AFormat or DT_RTLREADING;
    R := APaintRect;
    if not AClipped then
      AFormat := AFormat or DT_NOCLIP
    else
      if ARotated then
      begin
        AFormat := AFormat or DT_NOCLIP;
        cxPaintCanvas.SetClipRegion(TcxRegion.Create(APaintRect), roIntersect);
      end;

    if ABarItemControl.UseRightToLeftAlignment and not ABarItemControl.Parent.IsRealVertical then
      case AAlignment of
        DT_LEFT:
          AAlignment := DT_RIGHT;
        DT_RIGHT:
          AAlignment := DT_LEFT;
      end;

    AAccelPos := 0;
    AAccelWidth := 0;
    AAccelOffsetY := 0;
    if ARotated then
    begin
      AAccelPos := GetAccelPos(S, True);
      if AAccelPos > 0 then
        AFormat := AFormat or DT_NOPREFIX;
      ATextSize := cxPaintCanvas.TextExtent(S);

      case AAlignment of
        DT_CENTER:
          ATextOffsetY := (cxRectHeight(APaintRect) - ATextSize.cx) div 2;
        DT_RIGHT:
          ATextOffsetY := cxRectHeight(APaintRect) - ATextSize.cx;
      else
        ATextOffsetY := 0;
      end;
      OffsetRect(APaintRect, (cxRectWidth(APaintRect) + ATextSize.cy) div 2, ATextOffsetY);
      if AAccelPos > 0 then
      begin
        AAccelOffsetY := ATextOffsetY + cxPaintCanvas.TextWidth(Copy(S, 1, AAccelPos - 1));
        AAccelWidth := cxPaintCanvas.TextWidth(S[AAccelPos]);
      end;
    end
    else
      AFormat := AFormat or AAlignment or DT_VCENTER;

    AFlat := IsFlatItemText and AFlatText; // TODO and ...
    ABarItemControl.GetTextColors(AEnabled, ASelected, AFlat, AColor1, AColor2);
    cxPaintCanvas.Brush.Style := bsClear;

    if AColor2 <> AColor1 then
    begin
      cxPaintCanvas.Font.Color := AColor1;
      OffsetRect(APaintRect, 1, 1);
      DoDrawText(cxPaintCanvas.Handle, S, APaintRect, AFormat);
      OffsetRect(APaintRect, -1, -1);
      if ARotated and (AAccelPos > 0) then
      begin
        OffsetRect(R, 1, 1);
        UnderlineAccel(cxPaintCanvas, R, ATextSize, AAccelWidth, AAccelOffsetY);
        OffsetRect(R, -1, -1);
      end;
    end;

    cxPaintCanvas.Font.Color := AColor2;
    DoDrawText(cxPaintCanvas.Handle, S, APaintRect, AFormat);
    if ARotated and (AAccelPos > 0) then
      UnderlineAccel(cxPaintCanvas, R, ATextSize, AAccelWidth, AAccelOffsetY);
  finally
    cxPaintCanvas.EndPaint;
  end;
end;

procedure TdxBarPainter.DrawItemTextInSubMenu(const ADrawParams: TdxBarButtonLikeControlDrawParams; R: TRect);

  procedure DrawDescription(var ACaptionRect: TRect);
  var
    ADescriptionRect: TRect;
    ATextHeight, AOffset: Integer;
  begin
    with ADrawParams do
    begin
      if Description <> '' then
      begin
        ATextHeight := cxTextHeight(Canvas.Handle);
        AOffset := (cxRectHeight(R) - ATextHeight * 3) div 4;

        ADescriptionRect.Left := R.Left;
        ADescriptionRect.Top := R.Bottom - (ATextHeight + AOffset) * 2;
        ADescriptionRect.Right := R.Right - BarItemControl.Parent.TextSize;
        ADescriptionRect.Bottom := R.Bottom;

        ACaptionRect.Bottom := ADescriptionRect.Top;

        if Canvas.UseRightToLeftAlignment then
          ADescriptionRect := TdxRightToLeftLayoutConverter.ConvertRect(ADescriptionRect, R);

        DrawItemMultilineText(ADrawParams, Description, ADescriptionRect, DT_LEFT, 2);
      end;
      Canvas.Font.Style := Canvas.Font.Style + [fsBold];
    end;
  end;

var
  ACaptionRect: TRect;
begin
  with ADrawParams do
  begin
    InflateRect(R, 0, SubMenuControlInternalBorderSize);
    ACaptionRect := R;
    if BarItemControl.ShowDescription then
      DrawDescription(ACaptionRect);
    DrawItemText(BarItemControl, Canvas.Handle, Caption, ACaptionRect, DT_LEFT,
      Enabled, DrawSelected, False, False, IsFlatItemTextForMenu);
    if BarItemControl.CanShowShortCut and (ShortCut <> '') then
    begin
      if UseRightToLeftAlignment then
        Inc(ACaptionRect.Left, 5 + BarItemControl.Parent.TextSize)
      else
        Dec(ACaptionRect.Right, 5 + BarItemControl.Parent.TextSize);
      DrawItemText(BarItemControl, Canvas.Handle, ShortCut, ACaptionRect, DT_RIGHT,
        Enabled, DrawSelected, False, False, IsFlatItemTextForMenu);
    end;
  end;
end;

class procedure TdxBarPainter.DrawLowered(DC: HDC; var R: TRect);
begin
  DrawEdge(DC, R, BDR_SUNKENOUTER, BF_RECT);
  InflateRect(R, -1, -1); // LoweredBorderSize(ABarItemControl) = 1
end;

class procedure TdxBarPainter.FrameAndFillRect(ABarItemControl: TdxBarItemControl;
  DC: HDC; var R: TRect; Enabled, Selected, Pressed: Boolean);
begin
  // Required
end;

class function TdxBarPainter.GetCaptionOffsets: TRect;
begin
  Result := Rect(2, 2, 2, 3);
end;

class function TdxBarPainter.GlyphBkgndBrush(ABarItemControl: TdxBarItemControl;
  APaintType: TdxBarPaintType; AGlyphEmpty, ASelected, ADowned, ADrawDowned, ADroppedDown,
  AForceUseBkBrush, AGrayScale: Boolean): HBRUSH;
begin
  Result := ABarItemControl.BkBrush;
end;

class function TdxBarPainter.GlyphDownShift(ABarItemControl: TdxBarItemControl): Integer;
begin
  Result := 0;
end;

class function TdxBarPainter.GlyphDrawDownedShift(ABarItemControl: TdxBarItemControl;
  ADown: Boolean): Integer;
begin
  Result := 0;
end;

class function TdxBarPainter.IsFlatGlyphImage: Boolean;
begin
  Result := False;
end;

class function TdxBarPainter.IsFlatItemText: Boolean;
begin
  Result := False;
end;

class function TdxBarPainter.IsFlatItemTextForMenu: Boolean;
begin
  Result := IsFlatItemText and not IsHighContrastWhite;
end;

function TdxBarPainter.IsCustomSelectedTextColorExists(ABarItemControl: TdxBarItemControl): Boolean;
begin
  Result := False;
end;

class function TdxBarPainter.IsGlyphImageBackgroundOpaque(ABarItemControl: TdxBarItemControl;
  ADown, ADrawDowned, ASelected, AGlyphEmpty: Boolean): Boolean;
begin
  Result := ABarItemControl.FNonRecent;
  if AGlyphEmpty then
    Result := Result or ADown or ADrawDowned or ASelected
  else
    Result := Result or ABarItemControl.IsBkColorAssigned;
end;

class function TdxBarPainter.IsGlyphImageHasShadow: Boolean;
begin
  Result := False;
end;

class function TdxBarPainter.IsGlyphImageTransparent(ABarItemControl: TdxBarItemControl): Boolean;
begin
  Result := IsNativeBackground or not ABarItemControl.FNonRecent and ABarItemControl.Parent.IsTransparent;
end;

class function TdxBarPainter.IsItemTextSelectedInverted: Boolean;
begin
  Result := True;
end;

class function TdxBarPainter.LoweredBorderSize(ABarItemControl: TdxBarItemControl): Integer;
begin
  Result := 0;
end;

class function TdxBarPainter.TextAreaOffset(ABarItemControl: TdxBarItemControl): Integer;
begin
  if ABarItemControl.Parent.Kind = bkSubMenu then
    Result := ABarItemControl.Parent.TextSize + 1
  else
    Result := 0;
end;

function TdxBarPainter.BarFingersSize(ABar: TdxBar): Integer;
begin
  if ABar.Control.CanMoving then
    Result := FingersSize(ABar.Control)
  else
    Result := EmptyFingersSize;
end;

function TdxBarPainter.BeforeFingersSize: Integer;
begin
  // Required
  Result := 0;
end;

class function TdxBarPainter.BorderSizeX(AScaleFactor: TdxScaleFactor): Integer;
begin
  Result := dxGetSystemMetrics(SM_CXFRAME, AScaleFactor);
end;

class function TdxBarPainter.BorderSizeY(AScaleFactor: TdxScaleFactor): Integer;
begin
  Result := dxGetSystemMetrics(SM_CYFRAME, AScaleFactor);
end;

class function TdxBarPainter.EmptyFingersSize: Integer;
begin
  Result := 0;
end;

function TdxBarPainter.GetBarItemControlFadingOptions: TdxFadingOptions;
begin
  Result := nil;
end;

function TdxBarPainter.FingersSize(ABarControl: TdxBarControl): Integer;
begin
  // Required
  Result := 0;
end;

function TdxBarPainter.GripperSize(ABarControl: TdxBarControl): Integer;
begin
  Result := ABarControl.ScaleFactor.Apply(dxBarFingerSize);
end;

class function TdxBarPainter.RealButtonArrowWidth(ABarManager: TdxBarManager): Integer;
begin
  Result := (1 + Byte(ABarManager.LargeIcons)) * ABarManager.FButtonArrowWidth;
  if not Odd(Result) then Inc(Result);
end;

class function TdxBarPainter.RealLargeButtonArrowWidth(ABarManager: TdxBarManager): Integer;
begin
  Result := ABarManager.FLargeButtonArrowWidth;
end;

class function TdxBarPainter.SubMenuBeginGroupIndent: Integer;
begin
  // Required
  Result := 0;
end;

procedure TdxBarPainter.DockControlFillBackground(ADockControl: TdxDockControl;
  DC: HDC; ADestR, ASourceR, AWholeR: TRect; ABrush: HBRUSH; AColor: TColor);
begin
  FillBackgroundRect(DC, ADestR, ASourceR, ABrush, AColor, nil);
end;

class function TdxBarPainter.IsNativeBackground: Boolean;
begin
  Result := False;
end;

class function TdxBarPainter.BarChildrenHaveShadows(ABarControl: TCustomdxBarControl): Boolean;
begin
  Result := False;
end;

procedure TdxBarPainter.BarDrawDockedBackground(ABarControl: TdxBarControl;
  DC: HDC; ADestR, ASourceR: TRect; ABrush: HBRUSH; AColor: TColor);
begin
  BarFillParentBackground(ABarControl, DC, ADestR, ASourceR, ABrush, AColor);
end;

class function TdxBarPainter.BarControlOwnerBrush(ABarManager: TdxBarManager): HBRUSH;
begin
  Result := ABarManager.FlatToolbarsBrush;
end;

class function TdxBarPainter.BarDockedGetRowIndent: Integer;
begin
  Result := 0;
end;

procedure TdxBarPainter.BarDrawFloatingBackground(ABarControl: TCustomdxBarControl;
  DC: HDC; ADestR, ASourceR: TRect; ABrush: HBRUSH; AColor: TColor);
begin
  FillBackgroundRect(DC, ADestR, ASourceR, ABrush, AColor, ABarControl.BarManager.Backgrounds.Bar);
end;

class procedure TdxBarPainter.BarDrawOwnerLink(ABarControl: TCustomdxBarControl; DC: HDC);
begin
  if not IsRectEmpty(ABarControl.OwnerLinkBounds[False]) then
    FillRect(DC, ABarControl.OwnerLinkBounds[False], ABarControl.BarControlOwnerBrush);
end;

procedure TdxBarPainter.BarFillParentBackground(ABarControl: TCustomdxBarControl;
  DC: HDC; const ADestR, ASourceR: TRect; ABrush: HBRUSH; AColor: TColor);
var
  ABounds: TRect;
begin
  if ABarControl.DockControl <> nil then
  begin
    ABounds := ABarControl.BoundsRect;
    ABarControl.DockControl.FillBackground(DC, ADestR,
      cxRectOffset(ASourceR, ABounds.Left, ABounds.Top), ABrush, AColor);
  end;
end;

function TdxBarPainter.BarHasShadow(ABarControl: TCustomdxBarControl): Boolean;
begin
  Result := IsButtonControlArrowFlat and (ABarControl.DockingStyle = dsNone);
end;

function TdxBarPainter.BarLinkedOwnerHasShadow(ABarControl: TCustomdxBarControl): Boolean;
begin
  Result := ABarControl.HasShadow and
    ((ABarControl.ParentBar = nil) or (ABarControl.ParentBar.DockingStyle <> dsNone));
end;

class function TdxBarPainter.BarToolbarBrush(ABarControl: TCustomdxBarControl): HBRUSH;
begin
  Result := GetSysColorBrush(COLOR_BTNFACE);
end;

class function TdxBarPainter.BarToolbarBrushEx(ABarControl: TdxBarControl): HBRUSH;
begin
  Result := BarToolbarBrush(ABarControl);
end;

class function TdxBarPainter.BarToolbarDownedBrush(ABarControl: TCustomdxBarControl): HBRUSH;
begin
  Result := PatternBrush;
end;

class function TdxBarPainter.BarToolbarDownedSelBrush(ABarControl: TCustomdxBarControl): HBRUSH;
begin
  Result := GetSysColorBrush(COLOR_BTNFACE);
end;

class function TdxBarPainter.BarToolbarSelBrush(ABarControl: TCustomdxBarControl): HBRUSH;
begin
  Result := GetSysColorBrush(COLOR_HIGHLIGHT);
end;

function TdxBarPainter.ComboBoxArrowWidth(ABarControl: TCustomdxBarControl; cX: Integer): Integer;
begin
  Result := 2 * cX - 1;
end;

class function TdxBarPainter.EditTextSize(ABarControl: TCustomdxBarControl; cY: Integer): Integer;
var
  ABorderOffsets, ATextOffsets: TRect;
  ATextHeightCorrection: Integer;
begin
  ABorderOffsets := EditControlBorderOffsets(ABarControl.GetPaintType);
  GetEditTextParams(ATextOffsets, ATextHeightCorrection);
  Result := ABorderOffsets.Top + ATextOffsets.Top + cY + ATextOffsets.Bottom +
    ABorderOffsets.Bottom + ATextHeightCorrection;
end;

class procedure TdxBarPainter.GetEditTextParams(out AOffsets: TRect;
  out AHeightCorrection: Integer);
var
  ACaptionOffsets: TRect;
begin
  ACaptionOffsets := GetCaptionOffsets;
  AOffsets := ACaptionOffsets;
  GetEditTextVerticalOffsets(AOffsets.Top, AOffsets.Bottom);
  AHeightCorrection := ACaptionOffsets.Top + ACaptionOffsets.Bottom -
   (AOffsets.Top + AOffsets.Bottom);
end;

class procedure TdxBarPainter.GetEditTextVerticalOffsets(
  out ATop, ABottom: Integer);
begin
  ATop := 2;
  ABottom := 2;
end;

procedure TdxBarPainter.SetWindowRgn(AHandle: THandle; const AWindowRect: TRect; ARedraw: Boolean = False);
begin
// do nothing
end;

class function TdxBarPainter.BarAllowHotTrack: Boolean;
begin
  Result := True;
end;

class function TdxBarPainter.BarAllowQuickCustomizing: Boolean;
begin
  Result := True;
end;

function TdxBarPainter.BarBeginGroupSideSize: Integer;
begin
  Result := (BarBeginGroupSize - (1 + 1){|}) div 2;
end;

function TdxBarPainter.BarBeginGroupSize: Integer;
begin
  Result := 2 + (1 + 1){|} + 2;
end;

procedure TdxBarPainter.BarBorderPaintSizes(ABarControl: TdxBarControl;
  var R: TRect);
begin
  R := Rect(BarBorderSize, BarBorderSize, BarBorderSize, BarBorderSize);
end;

class function TdxBarPainter.BarBorderSize: Integer;
begin
  Result := 1;
end;

procedure TdxBarPainter.BarBorderSizes(ABar: TdxBar; AStyle: TdxBarDockingStyle; var R: TRect);
begin
  R := Rect(2, 2, 2, 2);
end;

class function TdxBarPainter.BarCaptionAreaSize(AScaleFactor: TdxScaleFactor): Integer;
begin
  Result := BarCaptionSize(AScaleFactor) + 1;
end;

procedure TdxBarPainter.BarCaptionFillBackground(ABarControl: TdxBarControl; DC: HDC; R: TRect; AToolbarBrush: HBRUSH);
begin
  FillRect(DC, R, AToolbarBrush);
end;

class function TdxBarPainter.BarCaptionSize(AScaleFactor: TdxScaleFactor): Integer;
begin
  Result := AScaleFactor.Apply(dxSystemInfo.NonClientMetrics.iSmCaptionHeight, dxSystemScaleFactor);
end;

class function TdxBarPainter.BarCaptionTransparent: Boolean;
begin
  Result := False;
end;

class function TdxBarPainter.BarCloseButtonSize(AScaleFactor: TdxScaleFactor): TSize;
begin
  Result.cx := BarCaptionSize(AScaleFactor);
  Result.cy := Result.cx;
end;

procedure TdxBarPainter.BarDrawBackground(ABarControl: TdxBarControl; ADC: HDC;
  const ADestRect, ASourceRect: TRect; ABrush: HBRUSH; AColor: TColor);
begin
  // check background
  if not ABarControl.GetBackgroundBitmap.Empty then
    FillBackgroundRect(ADC, ADestRect, ASourceRect, ABrush, AColor, ABarControl.GetBackgroundBitmap)
  else
  begin
    if ABarControl.Bar.IsStatusBar and ABarControl.BarManager.Backgrounds.Bar.Empty then
      StatusBarFillBackground(ABarControl, ADC, ADestRect, ASourceRect, Rect(0, 0, ABarControl.Width, ABarControl.Height), ABrush, AColor)
    else
    begin
      if ABarControl.Bar.Color = clDefault then
      begin
        if ABarControl.DockControl <> nil then
          BarDrawDockedBackground(ABarControl, ADC, ADestRect, ASourceRect, ABrush, AColor)
        else
          BarDrawFloatingBackground(ABarControl, ADC, ADestRect, ASourceRect, ABrush, AColor)
      end
      else
        FillRectByColor(ADC, ADestRect, ABarControl.Bar.Color); // TODO
    end;
  end;
end;

procedure TdxBarPainter.BarDrawBeginGroup(ABarControl: TCustomdxBarControl;
  DC: HDC; ABeginGroupRect: TRect; AToolbarBrush: HBRUSH; AHorz: Boolean);
begin
  if AHorz then
  begin
    with ABeginGroupRect do
    begin
      ABarControl.FillBackground(DC,
        Rect(Left, Top, Right, Top + BarBeginGroupSideSize),
        AToolbarBrush, clNone, True);
      ABarControl.FillBackground(DC,
        Rect(Left, Bottom - BarBeginGroupSideSize, Right, Bottom),
        AToolbarBrush, clNone, True);
    end;
    InflateRect(ABeginGroupRect, 0, -BarBeginGroupSideSize);
    DrawEdge(DC, ABeginGroupRect, EDGE_ETCHED, BF_TOP)
  end
  else
  begin
    with ABeginGroupRect do
    begin
      ABarControl.FillBackground(DC,
        Rect(Left, Top, Left + BarBeginGroupSideSize, Bottom),
        AToolbarBrush, clNone, True);
      ABarControl.FillBackground(DC,
        Rect(Right - BarBeginGroupSideSize, Top, Right, Bottom),
        AToolbarBrush, clNone, True);
    end;
    InflateRect(ABeginGroupRect, -BarBeginGroupSideSize, 0);
    DrawEdge(DC, ABeginGroupRect, EDGE_ETCHED, BF_LEFT);
  end;
end;

class procedure TdxBarPainter.BarDrawCaptionElement(ABarControl: TdxBarControl;
  DC: HDC; R: TRect; AState: TdxBarMarkState);
var
  ABrush: HBRUSH;
begin
  if AState <> msNone then
  begin
    FrameFlatSelRect(DC, R);
    InflateRect(R, -1, -1);
    if AState = msSelected then
      ABrush := ABarControl.ToolbarSelBrush
    else
      ABrush := ABarControl.ToolbarDownedSelBrush;
    FillRect(DC, R, ABrush);
  end
  else
    FillRectByColor(DC, R, ABarControl.CaptionBkColor);
end;

procedure TdxBarPainter.BarDrawCloseButton(ABarControl: TdxBarControl; DC: HDC; R: TRect);
begin
  // Required
end;

procedure TdxBarPainter.BarDrawDockedBarBorder(ABarControl: TdxBarControl;
  DC: HDC; R: TRect; AToolbarBrush: HBRUSH);
begin
  // Required
end;

procedure TdxBarPainter.BarDrawFloatingBarBorder(ABarControl: TdxBarControl;
  DC: HDC; R, CR: TRect; AToolbarBrush: HBRUSH);
begin
  // Required
end;

procedure TdxBarPainter.BarDrawFloatingBarCaption(ABarControl: TdxBarControl;
  DC: HDC; R, CR: TRect; AToolbarBrush: HBRUSH; AScaleFactor: TdxScaleFactor);
var
  R1: TRect;
  X: Integer;
  ATransparent: Boolean;

  procedure DrawCaption;
  var
    S: string;
    AFont: HFONT;
    Size: TSize;
    APrevBkMode: Integer;
    AFlags: Integer;
  begin
    if cxRectWidth(R) <= 0 then Exit;
    S := ABarControl.GetCaption;
    AFont := SelectObject(DC, CreateToolbarCaptionFontHandle(
      ABarControl.Font, ABarControl.BarManager.UseSystemFont, ABarControl.ScaleFactor));
    SetTextColor(DC, ABarControl.CaptionColor);
    SetBkColor(DC, ABarControl.CaptionBkColor);
    AFlags := ETO_CLIPPED;
    if ABarControl.UseRightToLeftReading then
      AFlags := AFlags or ETO_RTLREADING;
    if ATransparent then
      APrevBkMode := SetBkMode(DC, TRANSPARENT)
    else
    begin
      AFlags := AFlags or ETO_OPAQUE;
      APrevBkMode := 0; // WARN OFF
    end;
    cxGetTextExtentPoint32(DC, S, Size);
    if ABarControl.UseRightToLeftAlignment then
      X := X - Size.cx;
    cxExtTextOut(DC, S, Point(X, (R.Top + R.Bottom - Size.cy) div 2), R, AFlags);
    if ATransparent then
      SetBkMode(DC, APrevBkMode);
    DeleteObject(SelectObject(DC, AFont));
  end;

var
  AIsRightToLeft: Boolean;
begin
  R1 := R;
  R1.Top := R.Bottom;
  R1.Bottom := R1.Top + 1;
  FillRect(DC, R1, AToolbarBrush);

  ATransparent := BarCaptionTransparent;
  AIsRightToLeft := ABarControl.UseRightToLeftAlignment;
  if ATransparent then
    BarCaptionFillBackground(ABarControl, DC, R, AToolbarBrush);
  if ABarControl.HasCloseButton then
  begin
    if AIsRightToLeft then
      Inc(R.Left, BarCaptionSize(AScaleFactor))
    else
      Dec(R.Right, BarCaptionSize(AScaleFactor));
    ABarControl.DrawCloseButton(DC);
  end;

  if AIsRightToLeft then
    X := R.Right
  else
    X := R.Left;

  if ABarControl.MarkExists then
    BarOffsetFloatingBarCaption(ABarControl, X, R)
  else
    if AIsRightToLeft then
      Dec(X, AScaleFactor.Apply(2))
    else
      Inc(X, AScaleFactor.Apply(2));

  DrawCaption;
  if ABarControl.MarkExists then
    ABarControl.DrawMark(DC);
end;

procedure TdxBarPainter.BarDrawMark(ABarControl: TdxBarControl; DC: HDC; MarkR: TRect);
begin
  BarDrawMarkArrow(ABarControl, DC, MarkR);
end;

procedure TdxBarPainter.BarDrawMarks(ABarControl: TdxBarControl;
  ACanvas: TcxCanvas; const AItemRect: TRect; AToolbarBrush: HBRUSH);
begin
  if not ABarControl.MarkFadingHelper.DrawImage(ACanvas.Handle, AItemRect) then
    BarDrawMarkBackground(ABarControl, ACanvas.Handle, AItemRect, AToolbarBrush);
  BarDrawMarkElements(ABarControl, ACanvas.Handle, AItemRect);
end;

procedure TdxBarPainter.BarDrawMDIButton(ABarControl: TdxBarControl;
  AButton: TdxBarMDIButton; AState: Integer; DC: HDC; R: TRect);
begin
  // Required
end;

procedure TdxBarPainter.BarDrawStatusBarGrip(ABarControl: TdxBarControl;
  DC: HDC; const R: TRect; AToolbarBrush: HBRUSH);
var
  AGripRect: TRect;
  AGripBackgroundRect: TRect;
begin
  AGripBackgroundRect := cxRectContent(R, StatusBarBorderOffsets);
  AGripBackgroundRect.Left := AGripBackgroundRect.Right - StatusBarGripSize(ABarControl.BarManager, ABarControl.ScaleFactor).cx;
  if ABarControl.UseRightToLeftAlignment then
    AGripBackgroundRect := TdxRightToLeftLayoutConverter.ConvertRect(AGripBackgroundRect, R);
  AGripRect := AGripBackgroundRect;
  AGripRect.Top := AGripRect.Bottom - StatusBarGripSize(ABarControl.BarManager, ABarControl.ScaleFactor).cy;
  ABarControl.FillBackground(DC, AGripBackgroundRect, AToolbarBrush, clNone, False);
  BarDrawGrip(ABarControl, DC, AGripRect, AToolbarBrush);
end;

procedure TdxBarPainter.BarDrawStatusBarBorder(ABarControl: TdxBarControl; DC: HDC;
  R: TRect; AToolbarBrush: HBRUSH);
begin
  R.Bottom := R.Top + StatusBarTopBorderSize;
  ABarControl.FillBackground(DC, R, AToolbarBrush, clNone, False);
end;

class function TdxBarPainter.BarHorSize: Integer;
begin
  Result := 0;
end;

function TdxBarPainter.BarMarkRect(ABarControl: TdxBarControl): TRect;
begin
  Result := BarMarkItemRect(ABarControl);
end;

function TdxBarPainter.BarMarkItemRect(ABarControl: TdxBarControl): TRect;
var
  ACaptionRect: TRect;
begin
  case ABarControl.DockingStyle of
    dsTop, dsBottom:
      begin
        Result.Left := ABarControl.ClientWidth - ABarControl.MarkSize;
        Result.Top := 0;
        Result.Right := Result.Left + ABarControl.MarkSize;
        Result.Bottom := ABarControl.ClientHeight;
        if ABarControl.UseRightToLeftAlignment then
          Result := TdxRightToLeftLayoutConverter.ConvertRect(Result, ABarControl.ClientRect);
      end;
    dsLeft, dsRight:
      with Result do
      begin
        Left := 0;
        Top := ABarControl.ClientHeight - ABarControl.MarkSize;
        Right := ABarControl.ClientWidth;
        Bottom := Top + ABarControl.MarkSize;
      end;
  else
    ACaptionRect := ABarControl.GetCaptionRect;
    Result := ACaptionRect;
    Result.Left := Result.Right - cxRectHeight(Result);
    if ABarControl.HasCloseButton then
      OffsetRect(Result, -(cxRectWidth(ABarControl.CloseButtonRect) + ABarControl.ScaleFactor.Apply(FloatToolbarMarkIndent)), 0);
    Result.Left := Max(Result.Left, ACaptionRect.Left{ - 3});
    if ABarControl.UseRightToLeftAlignment then
      Result := TdxRightToLeftLayoutConverter.ConvertRect(Result, ACaptionRect);
  end;
end;

procedure TdxBarPainter.BarMarkRectInvalidate(ABarControl: TdxBarControl);
var
  DC: HDC;
begin
  if ABarControl.DockingStyle = dsNone then
  begin
    DC := GetWindowDC(ABarControl.Handle);
    ABarControl.DrawMark(DC);
    ReleaseDC(ABarControl.Handle, DC);
  end
  else
    cxInvalidateRect(ABarControl.Handle, BarMarkItemRect(ABarControl), False);
end;

class function TdxBarPainter.BarTopSize: Integer;
begin
  Result := 0;
end;

class function TdxBarPainter.BarBottomSize: Integer;
begin
  Result := 0;
end;

class function TdxBarPainter.BarUseSystemClose: Boolean;
begin
  Result := False;
end;

class function TdxBarPainter.BarUseSystemNCBorder: Boolean;
begin
  Result := False;
end;

function TdxBarPainter.MarkSizeX(ABarControl: TdxBarControl): Integer;
begin
  Result := ABarControl.ScaleFactor.Apply(11);
end;

procedure TdxBarPainter.StatusBarFillBackground(
  ABarControl: TdxBarControl; DC: HDC; ADestR, ASourceR, AWholeR: TRect; ABrush: HBRUSH; AColor: TColor);
begin
  if IsNativeBackground and ABarControl.BarManager.FThemeAvailable then
    TdxBarXPPainter.StatusBarFillNativeBackground(ABarControl, DC, ADestR, ASourceR, AWholeR, ABrush, AColor)
  else
    FillBackgroundRect(DC, ADestR, ASourceR, ABrush, AColor, nil);
end;

function TdxBarPainter.StatusBarBorderOffsets: TRect;
begin
  Result := cxEmptyRect;
end;

class function TdxBarPainter.StatusBarTopBorderSize: Integer;
begin
  Result := 2;
end;

function TdxBarPainter.StatusBarGripSize(ABarManager: TdxBarManager; AScaleFactor: TdxScaleFactor): TSize;
begin
  if IsNativeBackground and ABarManager.FThemeAvailable then
    Result := AScaleFactor.Apply(TdxBarXPPainter.StatusBarNativeGripSize(ABarManager), dxSystemScaleFactor)
  else
    Result := cxSize(dxGetSystemMetrics(SM_CXHSCROLL, AScaleFactor), dxGetSystemMetrics(SM_CYHSCROLL, AScaleFactor));
end;

class function TdxBarPainter.BarToolbarBrushEx2(ABarControl: TdxBarControl): HBRUSH;
begin
  Result := BarToolbarBrushEx(ABarControl);
end;

class procedure TdxBarPainter.DrawQuickCustItemFrame(
  ABarItemControl: TdxBarItemControl; DC: HDC; var R, ARect: TRect; Selected: Boolean);
begin
  if ABarItemControl.UseRightToLeftAlignment then
  begin
    R.Left := R.Right - cxRectHeight(R);
    ARect.Right := R.Left;
  end
  else
  begin
    R.Right := R.Left + cxRectHeight(R);
    ARect.Left := R.Right;
  end;
end;

class procedure TdxBarPainter.DrawQuickCustItemFrameSelected(
  ABarItemControl: TdxBarItemControl; DC: HDC; WholeR, R: TRect; Selected: Boolean);
begin
end;

class function TdxBarPainter.IsQuickControlPopupOnRight: Boolean;
begin
  Result := False;
end;

class function TdxBarPainter.GetTailAreaSize(const ADrawParams: TdxBarItemControlDrawParams): Integer;
begin
  Result := ADrawParams.BarItemControl.Parent.IconAreaSize;
end;

class function TdxBarPainter.ItemControlGetIndents(const ADrawParams: TdxBarItemControlDrawParams;
  ADrawAreaType: TdxBarItemControlPart): TRect;
begin
  Result := cxRect(3, 0, 3, 0);
end;

function TdxBarPainter.ButtonControlArrowBrush(const ADrawParams: TdxBarItemControlDrawParams): HBRUSH;
begin
  Result := ADrawParams.BarItemControl.BkBrush;
end;

function TdxBarPainter.IsButtonControlArrowBackgroundOpaque(const ADrawParams: TdxBarButtonLikeControlDrawParams): Boolean;
begin
  with ADrawParams do
    Result := BarItemControl.FNonRecent or IsFlatItemText and (DroppedDown or DrawSelected);
end;

function TdxBarPainter.IsButtonControlArrowDrawSelected(const ADrawParams: TdxBarButtonLikeControlDrawParams): Boolean;
begin
  with ADrawParams do
    Result := IsFlatItemText and
      (IsHighContrastWhite and DrawSelected and
      ((PaintType = ptMenu) or not DroppedDown) or ((PaintType = ptMenu) and DroppedDown)) or
      not IsFlatItemText and IsButtonControlArrowFlat and DroppedDown;
end;

function TdxBarPainter.IsButtonControlArrowFlat: Boolean;
begin
  Result := IsFlatItemText;
end;

function TdxBarPainter.IsDropDownRepaintNeeded: Boolean;
begin
  Result := IsFlatItemText;
end;

function TdxBarPainter.GetButtonBorderHeight(AScaleFactor: TdxScaleFactor): Integer;
begin
  Result := AScaleFactor.Apply(dxBarButtonBorderHeight);
end;

function TdxBarPainter.GetButtonBorderWidth(AScaleFactor: TdxScaleFactor): Integer;
begin
  Result := AScaleFactor.Apply(dxBarButtonBorderWidth);
end;

function TdxBarPainter.GetButtonHeight(AIconSize, ATextSize: Integer; AScaleFactor: TdxScaleFactor): Integer;
begin
  Result := AIconSize + GetButtonBorderHeight(AScaleFactor);
end;

function TdxBarPainter.GetButtonWidth(AIconSize, ATextSize: Integer; AScaleFactor: TdxScaleFactor): Integer;
begin
  Result := AIconSize + GetButtonBorderWidth(AScaleFactor);
end;

function TdxBarPainter.GetButtonSize(AIconSize, ATextSize: Integer; AScaleFactor: TdxScaleFactor): TSize;
begin
  Result := Size(GetButtonWidth(AIconSize, ATextSize, AScaleFactor), GetButtonHeight(AIconSize, ATextSize, AScaleFactor));
end;

class procedure TdxBarPainter.CorrectButtonControlDefaultHeight(var DefaultHeight: Integer);
begin
end;

class procedure TdxBarPainter.CorrectButtonControlDefaultWidth(var DefaultWidth: Integer);
begin
end;

procedure TdxBarPainter.OffsetCaptionBounds(ADowned, ADrawDowned: Boolean; var R: TRect);
begin
  if not IsFlatItemText then
  begin
    if ADowned or ADrawDowned then
      OffsetRect(R, 1, 1);
    if not IsButtonControlArrowFlat and ADowned and ADrawDowned then
      OffsetRect(R, 1, 1);
  end;
end;

class procedure TdxBarPainter.OffsetEllipsisBounds(APressed: Boolean; var R: TRect);
begin
  if not IsFlatItemText and APressed then
    OffsetRect(R, 1, 1);
end;

procedure TdxBarPainter.DrawBackButtonControl(const ADrawParams: TdxBarButtonLikeControlDrawParams; ARect: TRect);
begin
  DrawBackButtonControlBackground(ADrawParams, ARect);
  DrawItemTextInSubMenu(ADrawParams, SubMenuControlGetItemTextRealRect(ADrawParams, ARect));
  DrawBackButtonControlArrow(ADrawParams, cxRectSetWidth(ARect, ADrawParams.BarItemControl.Parent.GetIconAreaSize));
end;

procedure TdxBarPainter.DrawBackButtonControlArrow(const ADrawParams: TdxBarButtonLikeControlDrawParams; ARect: TRect);
begin
  DrawBackground(ADrawParams.BarItemControl, ADrawParams.Canvas.Handle, ARect, ButtonControlArrowBrush(ADrawParams),
    IsButtonControlArrowBackgroundOpaque(ADrawParams));
  DrawLargeItemArrow(ADrawParams.Canvas.Handle, ARect, adLeft, ADrawParams.ArrowSize.cy,
    IsButtonControlArrowDrawSelected(ADrawParams), ADrawParams.Enabled and ADrawParams.DropDownEnabled,
    IsButtonControlArrowFlat, GetItemArrowColor(ADrawParams));
end;

procedure TdxBarPainter.DrawBackButtonControlBackground(const ADrawParams: TdxBarButtonLikeControlDrawParams;
  ARect: TRect);
var
  ACaption: string;
begin
  if ADrawParams.DrawSelected then
    DrawItemBackgroundInSubMenu(ADrawParams, ARect)
  else
  begin
    ACaption := ADrawParams.Caption;
    ADrawParams.Caption := '';
    DrawSeparatorControl(TdxBarSeparatorControlDrawParams(ADrawParams), ARect);
    ADrawParams.Caption := ACaption;
  end;
end;

procedure TdxBarPainter.DrawButtonLikeControl(
  const ADrawParams: TdxBarButtonLikeControlDrawParams; ARect: TRect);

  function GetFullBounds(const AFullRect: TRect): TRect;
  begin
    if ADrawParams.DroppedDownFlat then
      Result := ARect
    else
      if ADrawParams.ViewSize = cvsLarge then
        Result := AFullRect
      else
        Result := cxEmptyRect;
  end;

  function DrawFadedBackground(AItemControl: TdxBarItemControl; ACanvas: TcxCanvas; const R: TRect): Boolean;
  var
    AFadingElement: TdxFadingElement;
  begin
    Result := dxFader.Find(AItemControl, AFadingElement);
    if Result then
    begin
      ACanvas.SaveClipRegion;
      try
        ACanvas.IntersectClipRect(AItemControl.FParts[bcpDropButton]);
        AFadingElement.DrawImage(ACanvas.Handle, AItemControl.ItemBounds);
      finally
        ACanvas.RestoreClipRegion;
      end;
    end;
  end;

var
  R, AFullRect, AImageBounds: TRect;
  AOffsets: TRect;
begin
  with ADrawParams do
  begin
    if IsLowered then
      DrawLowered(Canvas.Handle, ARect);

    if PaintType = ptMenu then
      DrawGlyphAndTextInSubMenu(ADrawParams, ARect)
    else
    begin
      if UseRightToLeftAlignment then
        AOffsets := TdxRightToLeftLayoutConverter.ConvertOffsets(ContentOffset)
      else
        AOffsets := ContentOffset;
      R := cxRectContent(ARect, AOffsets);

      if IsDropDown and SplitDropDown then
        if UseRightToLeftAlignment then
          Inc(R.Left, cxRectWidth(BarItemControl.FParts[bcpDropButton]))
        else
          Dec(R.Right, cxRectWidth(BarItemControl.FParts[bcpDropButton]));

      if ViewSize = cvsLarge then
      begin
        AFullRect := R;
        InflateRect(R, -1, -1);
        OffsetCaptionBounds(Downed, DrawDowned, R);
      end
      else
        AFullRect := ARect;

      DrawGlyph(BarItemControl, Canvas.Handle, R, GetFullBounds(AFullRect), AImageBounds, PaintType, ViewStructure,
        ViewSize, not (cpIcon in ViewStructure), DrawSelected, Downed, DrawDowned, DroppedDown, False, False,
        GrayScale, SplitDropDown and IsDropDown);

      DrawButtonLikeControlCaption(ADrawParams, R, AImageBounds);
    end;

    if IsDropDown and not IsMenuItem then
    begin
      if SplitDropDown then
      begin
        if not DrawFadedBackground(BarItemControl, Canvas, ARect) then
          DrawSplitControlArrow(ADrawParams, ARect);
      end
      else
        DrawAssociateControlArrow(ADrawParams, ARect);
    end;
  end;
end;

procedure TdxBarPainter.DrawButtonLikeControlCaption(
  const ADrawParams: TdxBarButtonLikeControlDrawParams; const ARect, AImageBounds: TRect);
var
  AFormat: DWORD;
  ATextAlignment: DWORD;
  ATextBounds: TRect;
begin
  if cpText in ADrawParams.ViewStructure then
  begin
    ATextBounds := ARect;
    ButtonLikeControlCorrectCaptionParams(ADrawParams, ATextBounds, AImageBounds, ATextAlignment, AFormat);
    ButtonLikeControlDrawCaption(ADrawParams, ATextBounds, ATextAlignment, AFormat);
  end;
end;

procedure TdxBarPainter.DrawButtonControlArrow(const ADrawParams: TdxBarButtonLikeControlDrawParams; ARect: TRect);
begin
  with ADrawParams do
  begin
    if not IsButtonControlArrowFlat and DroppedDown and ((cxRectWidth(ARect) > 9) or (PaintType = ptMenu)) then
      if UseRightToLeftAlignment then
        OffsetRect(ARect, -1, 1)
      else
        OffsetRect(ARect, 1, 1);

    if PaintType = ptMenu then
    begin
      cxRightToLeftDependentDraw(Canvas, ARect,
      procedure
      begin
        DrawLargeItemArrow(Canvas.Handle, ARect, adRight, ArrowSize.cy,
          IsButtonControlArrowDrawSelected(ADrawParams), Enabled and DropDownEnabled, IsButtonControlArrowFlat, GetItemArrowColor(ADrawParams));
      end);
    end
    else
      DrawItemArrow(Canvas.Handle, ARect, ScaleFactor, adDown, Enabled and DropDownEnabled,
        IsButtonControlArrowDrawSelected(ADrawParams), IsButtonControlArrowFlat, GetItemArrowColor(ADrawParams));
  end;
end;

procedure TdxBarPainter.DrawButtonControlArrowBackground(const ADrawParams: TdxBarButtonLikeControlDrawParams;
  var R1: TRect; ABrush: HBRUSH);
begin
  with ADrawParams do
  begin
    if IsFlatItemText and (PaintType <> ptMenu) then
      if UseRightToLeftAlignment then
        Inc(R1.Right)
      else
        Dec(R1.Left);
    if not IsFlatItemText or (PaintType = ptMenu) or not DroppedDown then
      DrawBackground(BarItemControl, Canvas.Handle, R1, ABrush, IsButtonControlArrowBackgroundOpaque(ADrawParams));
  end;
end;

procedure TdxBarPainter.DrawSplitControlArrow(
  const ADrawParams: TdxBarButtonLikeControlDrawParams; ARect: TRect);
begin
  if ADrawParams.UseRightToLeftAlignment then
    ARect.Right := ARect.Left + ADrawParams.ArrowSize.cx
  else
    ARect.Left := ARect.Right - ADrawParams.ArrowSize.cx;
  DrawButtonControlArrowBackground(ADrawParams, ARect, ButtonControlArrowBrush(ADrawParams));
  DrawButtonControlArrow(ADrawParams, ARect);
end;

procedure TdxBarPainter.DrawAssociateControlArrow(
  const ADrawParams: TdxBarButtonLikeControlDrawParams; ARect: TRect);

  function IsArrowDrawSelected: Boolean;
  begin
    with ADrawParams do
      Result := (PaintType = ptMenu) and DrawSelected and not IsFlatItemTextForMenu or
        (PaintType <> ptMenu) and IsTextSelected;
  end;

  function GetArrowRect(const ARect: TRect): TRect;
  begin
    Result := ARect;
    with ADrawParams do
    begin
      case PaintType of
        ptVert: Result.Top := Result.Bottom - BarItemControl.Parent.TextSize div 2 + BarItemControl.Parent.Font.Height div 2;
        ptHorz: Result.Left := Result.Right - BarItemControl.Parent.TextSize div 2 + BarItemControl.Parent.Font.Height div 2;
      else{ptMenu}
        Result.Left := Result.Right - BarItemControl.Parent.TextSize + ArrowSize.cy;
      end;
      if UseRightToLeftAlignment and not (PaintType = ptVert) then
        Result := TdxRightToLeftLayoutConverter.ConvertRect(Result, ARect);
    end;
  end;

  function GetArrowSize: Integer;
  begin
    Result := ADrawParams.ArrowSize.cy;
    if ADrawParams.PaintType <> ptMenu then
      Dec(Result);
  end;

const
  Direction: array[TdxBarPaintType] of TcxArrowDirection = (adDown, adRight, adRight);
var
  R1: TRect;
  AArrowRect: TRect;
  AArrowSize: Integer;
  AIsSelected: Boolean;
begin
  with ADrawParams do
  begin
    if PaintType <> ptMenu then
    begin
      R1 := ARect;
      OffsetCaptionBounds(False, DroppedDown, ARect);
      if UseRightToLeftAlignment then
        ARect := TdxRightToLeftLayoutConverter.ConvertRect(ARect, R1);
    end;
      AArrowRect := GetArrowRect(ARect);
      AArrowSize := GetArrowSize;
      AIsSelected := IsArrowDrawSelected;
      cxRightToLeftDependentDraw(Canvas, AArrowRect,
        procedure
        begin
          DrawLargeItemArrow(Canvas.Handle, AArrowRect, Direction[PaintType], AArrowSize,
            AIsSelected, Enabled, IsFlatItemText, GetItemArrowColor(ADrawParams));
        end);
  end;
end;

function TdxBarPainter.ComboControlArrowColor(ADrawParams: TdxBarItemControlDrawParams): TColor;
begin
  Result := clBtnText;
end;

function TdxBarPainter.ComboControlButtonBrush(const ADrawParams: TdxBarItemControlDrawParams): HBRUSH;
begin
  Result := ButtonControlArrowBrush(ADrawParams);
end;

class function TdxBarPainter.ComboControlArrowOffset: Integer;
begin
  Result := 1;
end;

class function TdxBarPainter.ComboControlButtonOffsets(APaintType: TdxBarPaintType): TRect;
begin
  Result := EditControlBorderOffsets(APaintType);
end;

procedure TdxBarPainter.ComboControlDrawArrowButton(
  const ADrawParams: TdxBarEditLikeControlDrawParams; ARect: TRect;
  AInClientArea: Boolean);

  function GetArrowSize(const AArrowRect: TRect): Integer;
  begin
    Result := cxRectWidth(AArrowRect) div 4;
    if not Odd(Result) then
      Inc(Result);
  end;

begin
  ComboControlDrawSimpleButton(ADrawParams, ARect, ComboControlButtonBrush(ADrawParams));
  ComboControlDrawArrow(ADrawParams, ARect, GetArrowSize(ARect), ComboControlArrowColor(ADrawParams));
end;

class procedure TdxBarPainter.ComboControlDrawSimpleButton(const ADrawParams: TdxBarEditLikeControlDrawParams; var ARect: TRect; ABrush: HBRUSH);
begin
  // Required
end;

class function TdxBarPainter.DropDownListBoxBorderSize: Integer;
begin
  Result := 2;
end;

procedure TdxBarPainter.DropDownListBoxDrawBorder(DC: HDC; AColor: TColor; ARect: TRect);
begin
  FrameRect(DC, ARect, GetSysColorBrush(COLOR_BTNSHADOW));
  InflateRect(ARect, -1, -1);
  FrameRectByColor(DC, ARect, AColor);
end;

class function TdxBarPainter.SubMenuControlHasBand: Boolean;
begin
  Result := False;
end;

class function TdxBarPainter.SubMenuControlIsOffsetRecentGroupNeeded: Boolean;
begin
  Result := False;
end;

class function TdxBarPainter.SubMenuControlArrowsOffset: Integer;
begin
  Result := 2;
end;

class function TdxBarPainter.SubMenuControlArrowWidth(ATextSize: Integer): Integer;
begin
  Result := ATextSize div 4 * 3 + 1;
end;

function TdxBarPainter.SubMenuControlBeginGroupRect(
  ABarSubMenuControl: TdxBarSubMenuControl; AControl: TdxBarItemControl;
  const AItemRect: TRect): TRect;
begin
  Result := AItemRect;
  if AControl.FChangeRecentGroup and AControl.NonRecent then
    Dec(Result.Top);
  Result.Bottom := Result.Top;
  Dec(Result.Top, ABarSubMenuControl.BeginGroupSize);
end;

function TdxBarPainter.SubMenuControlBeginGroupSize: Integer;
begin
  Result := 4 + 2 + 4;
end;

class function TdxBarPainter.SubMenuControlBorderSize: Integer;
begin
  Result := SubMenuControlNCBorderSize + SubMenuControlClientBorderSize;
end;

class function TdxBarPainter.SubMenuControlNCBorderSize: Integer;
begin
  Result := 1;
end;

class function TdxBarPainter.SubMenuControlClientBorderSize: Integer;
begin
  Result := 1;
end;

procedure TdxBarPainter.SubMenuControlCalcDrawingConsts(ACanvas: TcxCanvas;
  ATextSize: Integer; AScaleFactor: TdxScaleFactor; out AMenuArrowWidth, AMarkSize: Integer);
var
  AArrowSize: Integer;
begin
  AMenuArrowWidth := SubMenuControlArrowWidth(ATextSize);
  AMarkSize := ACanvas.TextHeight('0') + 1;
  AArrowSize := SubMenuControlMarkArrowSize(AMarkSize);
  if Odd(AArrowSize) then
    AMarkSize := (AArrowSize - 1) * 2 + 2 * 3;
end;

class function TdxBarPainter.SubMenuControlInternalBorderSize: Integer;
begin
  Result := 0;
end;

class function TdxBarPainter.SubMenuControlInternalBorderOffset: Integer;
begin
  Result := 0;
end;

class function TdxBarPainter.SubMenuControlContentRectOffset(ABarSubMenuControl: TdxBarSubMenuControl): TRect;
var
  AOffset: Integer;
begin
  AOffset := SubMenuControlClientBorderSize;
  Result := Rect(AOffset, AOffset, AOffset, AOffset);
end;

class function TdxBarPainter.SubMenuControlDetachCaptionAreaSize(ABarSubMenuControl: TdxBarSubMenuControl): Integer;
begin
  Result := 2 + ABarSubMenuControl.DetachCaptionSize + 1;
end;

procedure TdxBarPainter.SubMenuControlDrawScrollButton(ABarSubMenuControl: TdxBarSubMenuControl; ACanvas: TcxCanvas; AArrowDirection: TcxArrowDirection);
begin
  // do nothing
end;

procedure TdxBarPainter.SubMenuControlDrawBackground(ABarSubMenuControl: TdxBarSubMenuControl;
  ACanvas: TcxCanvas; ARect: TRect; ABrush: HBRUSH; AColor: TColor);
begin
  FillBackgroundRect(ACanvas.Handle, ARect, ARect, ABrush, AColor, ABarSubMenuControl.GetBackgroundBitmap);
end;

procedure TdxBarPainter.SubMenuControlDrawBorder(ABarSubMenuControl: TdxBarSubMenuControl;
  DC: HDC; R: TRect);
begin
  with R do
  begin
    FillRect(DC, Rect(Left, Top, Left + 1, Bottom - 1), COLOR_BTNFACE + 1);
    FillRect(DC, Rect(Left + 1, Top, Right - 1, Top + 1), COLOR_BTNFACE + 1);
  end;
  DrawEdge(DC, R, BDR_RAISEDOUTER, BF_BOTTOMRIGHT);
  if ABarSubMenuControl.Detachable then
  begin
    InflateRect(R, -1, -1);
    DrawEdge(DC, R, BDR_RAISEDINNER, BF_RECT - BF_BOTTOM);
    InflateRect(R, -1, -1);
    R.Bottom := R.Top + ABarSubMenuControl.DetachCaptionAreaSize - 1;
    FrameRect(DC, R, GetSysColorBrush(COLOR_BTNFACE));
    SubMenuControlDrawDetachCaption(ABarSubMenuControl, DC, ABarSubMenuControl.DetachCaptionRect);
  end;
end;

procedure TdxBarPainter.SubMenuControlDrawClientBorder(ABarSubMenuControl: TdxBarSubMenuControl;
  DC: HDC; const R: TRect; ABrush: HBRUSH);
var
  ARect: TRect;
begin
  ARect := R;
  if ABarSubMenuControl.Detachable then
    ARect.Top := ARect.Top - 2;
  DrawEdge(DC, ARect, BDR_RAISEDINNER, BF_RECT);
  InflateRect(ARect, -1, -1);
  FrameRect(DC, ARect, ABrush);
end;

procedure TdxBarPainter.SubMenuControlDrawDetachCaption(ABarSubMenuControl: TdxBarSubMenuControl;
  DC: HDC; R: TRect);
const
  Colors: array[Boolean] of COLORREF = (COLOR_INACTIVECAPTION, COLOR_ACTIVECAPTION);
begin
  FillRect(DC, R, Colors[ABarSubMenuControl.DetachCaptionSelected] + 1);
end;

procedure TdxBarPainter.SubMenuControlDrawBeginGroup(ABarSubMenuControl: TdxBarSubMenuControl;
  AControl: TdxBarItemControl; ACanvas: TcxCanvas; const ABeginGroupRect: TRect);
var
  R: TRect;
  ABrush: HBRUSH;
  LD, RD: Integer;
  AOpaque: Boolean;
  ADC: HDC;
begin
  ADC := ACanvas.Handle;
  RD := Byte(AControl.FNonRecent);
  R := ABeginGroupRect;
  if AControl.FChangeRecentGroup and AControl.FNonRecent then
  begin
    RD := 0;
    ABrush := ABarSubMenuControl.ToolbarBrush;
  end
  else
    ABrush := ABarSubMenuControl.BkBrush;
  LD := RD * Ord(ABarSubMenuControl.BarSize = 0);
  AOpaque := AControl.FNonRecent and not AControl.FChangeRecentGroup;
  DrawBackground(AControl, ADC, Rect(R.Left - LD, R.Top, R.Right + 2 * RD, R.Bottom), ABrush, AOpaque);
  InflateRect(R, -SubMenuBeginGroupIndent, -4);
  SubMenuControlDrawSeparator(ACanvas, R);
end;

class procedure TdxBarPainter.SubMenuControlDrawItemFrame(ABarSubMenuControl: TdxBarSubMenuControl;
  AControl: TdxBarItemControl; DC: HDC; AItemRect: TRect; AIndex: Integer);
begin
// do nothing
end;

procedure TdxBarPainter.SubMenuControlDrawSeparator(ACanvas: TcxCanvas; const ARect: TRect);
var
  R: TRect;
begin
  R := ARect;
  DrawEdge(ACanvas.Handle, R, EDGE_ETCHED, BF_TOP);
end;

class function TdxBarPainter.SubMenuControlGetBandSize(ABarSubMenuControl: TdxBarSubMenuControl): Integer;
begin
  Result := ABarSubMenuControl.IconAreaSize;
end;

class function TdxBarPainter.SubMenuControlGetControlContentIndent(ABarSubMenuControl: TdxBarSubMenuControl): Integer;
begin
  Result := ABarSubMenuControl.BarSize + ABarSubMenuControl.IconAreaSize;
  CorrectButtonControlDefaultHeight(Result);
end;

class function TdxBarPainter.SubMenuControlMarkArrowSize(AMarkSize: Integer): Integer;
begin
  Result := (AMarkSize - 2 * (2 + 1)) div 2;
end;

class function TdxBarPainter.SubMenuControlNormalItemHeight(AScaleFactor: TdxScaleFactor): Integer;
begin
  Result := AScaleFactor.Apply(19);
end;

class procedure TdxBarPainter.SubMenuControlOffsetDetachCaptionRect(ABarSubMenuControl: TdxBarSubMenuControl; var R: TRect);
begin
  R := cxRectInflate(R, ABarSubMenuControl.ScaleFactor.Apply(-3));
end;

class procedure TdxBarPainter.SubMenuControlPrepareBkBrush(ABarSubMenuControl: TdxBarSubMenuControl; var ABkBrush: HBRUSH);
begin
  if BarAllowHotTrack then
    ABkBrush := SubMenuControlToolbarItemsBrush(ABarSubMenuControl);
end;

class function TdxBarPainter.SubMenuControlTextSize(ACanvas: TcxCanvas; AScaleFactor: TdxScaleFactor): Integer;
begin
  Result := GetDefaultTextSize(ACanvas, AScaleFactor);
end;

class function TdxBarPainter.SubMenuControlToolbarItemsBrush(ABarSubMenuControl: TdxBarSubMenuControl): HBRUSH;
begin
  Result := COLOR_BTNFACE + 1;
end;

procedure TdxBarPainter.ApplicationMenuDrawButton(const ADrawParams: TdxBarApplicationMenuButtonControlDrawParams; var R: TRect);
begin
  // do nothing
end;

procedure TdxBarPainter.ApplicationMenuDrawBackground(
  ABarSubMenuControl: TdxBarSubMenuControl; ACanvas: TcxCanvas; const R, AItemsArea: TRect);
begin
  ACanvas.ExcludeClipRect(AItemsArea);
  SubMenuControlDrawBackground(ABarSubMenuControl, ACanvas, R, ABarSubMenuControl.ToolbarDownedBrush, clNone);
end;

function TdxBarPainter.ApplicationMenuContentButtonOffsets: TRect;
begin
  Result := cxNullRect;
end;

function TdxBarPainter.ApplicationMenuButtonTextColor(AEnabled, ASelected: Boolean): TColor;
begin
  if AEnabled then
    Result := clWindowText
  else
    Result := clGrayText;
end;

function TdxBarPainter.ApplicationMenuGetFrameSizes: TRect;
begin
  Result := cxNullRect;
end;

function TdxBarPainter.ExtraMenuHeaderTextColor: TColor;
begin
  Result := clBtnText;
end;

function TdxBarPainter.ExtraMenuPinButtonSize: Integer;
begin
  Result := 30;
end;

function TdxBarPainter.ExtraMenuSeparatorSize: Integer;
begin
  Result := MenuSeparatorSize;
end;

procedure TdxBarPainter.ExtraMenuDrawButton(
  ADrawParams: TdxBarExtraMenuButtonControlDrawParams; const ARect: TRect);
begin
end;

function TdxBarPainter.ExtraMenuButtonTextColor(AEnabled, ASelected: Boolean): TColor;
begin
  Result := clDefault;
end;

procedure TdxBarPainter.ExtraMenuControlDrawBackground(AExtraMenuControl: TCustomdxBarControl;
  ACanvas: TcxCanvas; ARect: TRect; ABrush: HBRUSH; AColor: TColor);
begin
  FillBackgroundRect(ACanvas.Handle, ARect, ARect, ABrush, AColor, AExtraMenuControl.GetBackgroundBitmap);
end;

procedure TdxBarPainter.ExtraMenuControlDrawBeginGroup(AExtraMenuControl: TCustomdxBarControl;
  ACanvas: TcxCanvas; ABeginGroupRect: TRect; AToolbarBrush: HBRUSH; AHorz: Boolean);
begin
  BarDrawBeginGroup(AExtraMenuControl, ACanvas.Handle, ABeginGroupRect, AToolbarBrush, AHorz);
end;

class procedure TdxBarPainter.EditDrawInterior(ABarEditControl: TdxBarEditControl;
  ABarEdit: TdxBarEdit; ACanvas: TCanvas; R: TRect; ItemLink: TdxBarItemLink);
var
  ADC: HDC;
  S: string;
  AFormat: Cardinal;
begin
  ADC := ACanvas.Handle;
  FillRect(ADC, R, ACanvas.Brush.Handle); // draw only client area
  EditOffsetInteriorRect(ABarEditControl, R);
  if ABarEdit.FocusedItemLink = ItemLink then
    S := ABarEdit.CurText
  else
    S := ABarEdit.Text;

  AFormat := DT_NOPREFIX;
  if ABarEditControl.UseRightToLeftAlignment then
    AFormat := AFormat or DT_RIGHT;
  if ABarEditControl.Parent.UseRightToLeftReading then
    AFormat := AFormat or DT_RTLREADING;
  SetBkMode(ADC, TRANSPARENT);
  cxDrawText(ADC, S, R, AFormat);
  SetBkMode(ADC, OPAQUE);
end;

procedure TdxBarPainter.EditGetRealLookAndFeel(ABarManager: TdxBarManager; ALookAndFeel: TcxLookAndFeel);
begin
  ABarManager.GetRealLookAndFeel(ALookAndFeel);
end;

function TdxBarPainter.EditGetEnabledBkColor(ABarItemControl: TdxBarCustomEditControl): COLORREF;
begin
  Result := GetSysColor(COLOR_WINDOW);
end;

function TdxBarPainter.EditGetDisabledBkColor(ABarItemControl: TdxBarCustomEditControl): COLORREF;
begin
  Result := dxGetBrushData(ABarItemControl.Parent.BkBrush).lbColor;
end;

function TdxBarPainter.EditGetBkColor(const ADrawParams: TdxBarEditLikeControlDrawParams): COLORREF;
var
  AEditViewParams: TcxViewParams;
begin
  with ADrawParams do
    if Enabled then
    begin
      BarEditControl.Item.GetEditViewParams(AEditViewParams);
      Result := AEditViewParams.Color;
      if Result = COLORREF(clDefault) then
        Result := EditGetEnabledBkColor(BarEditControl);
    end
    else
      Result := EditGetDisabledBkColor(BarEditControl);
end;

function TdxBarPainter.EditGetEnabledTextColor: COLORREF;
begin
  Result := GetSysColor(COLOR_WINDOWTEXT);
end;

function TdxBarPainter.EditGetDisabledTextColor: COLORREF;
begin
  Result := GetSysColor(COLOR_GRAYTEXT);
end;

function TdxBarPainter.EditGetTextColor(ABarItemControl: TdxBarCustomEditControl): COLORREF;
var
  AEditViewParams: TcxViewParams;
begin
  if ABarItemControl.Enabled then
  begin
    ABarItemControl.Item.GetEditViewParams(AEditViewParams);
    Result := AEditViewParams.TextColor;
    if Result = COLORREF(clDefault) then
      Result := EditGetEnabledTextColor;
  end
  else
    Result := EditGetDisabledTextColor;
end;

function TdxBarPainter.EditButtonAllowOffsetContent: Boolean;
begin
  Result := True;
end;

procedure TdxBarPainter.EditButtonDrawBackground(const ADrawParams: TdxBarEditLikeControlDrawParams; AState: Integer;
  ARect: TRect; ABrush: HBrush);
begin
// do nothing
end;

function TdxBarPainter.EditButtonAllowCompositeFrame: Boolean;
begin
  Result := False;
end;

class function TdxBarPainter.EditButtonAllowHotTrack(const ADrawParams: TdxBarItemControlDrawParams): Boolean;
begin
  Result := ADrawParams.DrawSelected;
end;

function TdxBarPainter.EditButtonIsCustomBorder: Boolean;
begin
  Result := False;
end;

function TdxBarPainter.EditButtonIsCustomBackground(AState: Integer): Boolean;
begin
  Result := False;
end;

procedure TdxBarPainter.EditButtonCorrectDefaultWidth(var ADefaultWidth: Integer);
begin
  // do nothing
end;

procedure TdxBarPainter.EditButtonDrawBorder(
  const ADrawParams: TdxBarItemControlDrawParams; AState: Integer; var ADrawRect: TRect; out AContentRect: TRect);
begin
  // do nothing
end;

class procedure TdxBarPainter.CustomComboDrawItem(ABarCustomCombo: TdxBarCustomCombo;
  ACanvas: TCanvas; AIndex: Integer; ARect: TRect; AState: TOwnerDrawState; AInteriorIsDrawing: Boolean);
var
  S: string;
  W: Integer;
begin
  if AIndex = -1 then
    S := ABarCustomCombo.Text
  else
    S := ABarCustomCombo.Items[AIndex];
  ACanvas.FillRect(ARect);
  if (ACanvas is TControlCanvas) and TControlCanvas(ACanvas).Control.UseRightToLeftAlignment then
  begin
    W := ACanvas.TextWidth(S);
    ACanvas.TextOut(ARect.Right - W - 3, ARect.Top, S);
  end
  else
    ACanvas.TextOut(ARect.Left + 2, ARect.Top, S);
end;

procedure TdxBarPainter.DrawEditLikeControl(const ADrawParams: TdxBarEditLikeControlDrawParams; ARect: TRect);
begin
  with ADrawParams do
  begin
    EditControlDrawBackground(ADrawParams);

    if DrawSelected and BarEditControl.Parent.AllowSelectionFrame then
      EditControlDrawSelectionFrame(ADrawParams, ARect);

    BarEditControl.DrawFrame;

    if cpIcon in ViewStructure then
      EditControlDrawGlyph(ADrawParams);

    if cpText in ViewStructure then
      EditControlDrawCaption(ADrawParams);

    BarEditControl.DrawTextField;
  end;
end;

class function TdxBarPainter.EditControlBorderOffsets(APaintType: TdxBarPaintType): TRect;
begin
  Result := Rect(2, 2, 2, 2);
end;

procedure TdxBarPainter.EditControlDrawBackground(const ADrawParams: TdxBarEditLikeControlDrawParams);

  procedure DrawControlAreaBackground;
  begin
    with ADrawParams do
    begin
      Canvas.SaveClipRegion;
      try
        Canvas.ExcludeClipRect(BarEditControl.FParts[ecpEdit]);
        if Canvas.RectVisible(BarEditControl.GetEditRect) then
        begin
          DrawBackground(BarEditControl, Canvas.Handle, BarEditControl.GetEditRect,
            BarEditControl.CaptionBkBrush, EditControlCaptionBackgroundIsOpaque(ADrawParams));
        end;
      finally
        Canvas.RestoreClipRegion;
      end;
    end;
  end;

begin
  with ADrawParams do
  begin
    if (cpText in ViewStructure) or (PaintType = ptMenu) and SubMenuControlHasBand and not (cpIcon in ViewStructure) then
      DrawBackground(BarEditControl, Canvas.Handle, BarEditControl.FParts[ecpText],
        BarEditControl.CaptionBkBrush, EditControlCaptionBackgroundIsOpaque(ADrawParams));

    if (cpIcon in ViewStructure) and (PaintType <> ptMenu) then
      DrawBackground(BarEditControl, Canvas.Handle, BarEditControl.FParts[ecpIcon], BarEditControl.CaptionBkBrush,
        EditControlCaptionBackgroundIsOpaque(ADrawParams));

    DrawControlAreaBackground;
  end;
end;

procedure TdxBarPainter.EditControlDrawBorder(
  const ADrawParams: TdxBarEditLikeControlDrawParams; var ARect: TRect);
var
  ABrush: HBRUSH;
begin
  with ADrawParams do
  begin
    if DrawSelected then
      DrawEdge(Canvas.Handle, ARect, BDR_SUNKENOUTER, BF_RECT)
    else
      DrawBackgroundFrameRect(BarEditControl, Canvas.Handle, ARect,
        BarEditControl.Parent.BkBrush, BarEditControl.FNonRecent);
    InflateRect(ARect, -1, -1);
    if Enabled or IsTransparent then
      ABrush := BarEditControl.Parent.BkBrush
    else
      ABrush := GetSysColorBrush(COLOR_BTNHIGHLIGHT);
    DrawBackgroundFrameRect(BarEditControl, Canvas.Handle, ARect, ABrush, BarEditControl.FNonRecent or
      (DrawSelected or not Enabled) and not IsTransparent);
    InflateRect(ARect, -1, -1);
  end;
end;

procedure TdxBarPainter.EditControlDrawCaption(const ADrawParams: TdxBarEditLikeControlDrawParams);
var
  ATextRect: TRect;
  ATextAlignment: UINT;
begin
  with ADrawParams do
  begin
    ATextRect := BarEditControl.FParts[ecpText];
    if ViewLayout = ivlGlyphControlCaption then
      if UseRightToLeftAlignment then
        ATextRect.Left := ATextRect.Left - 1
      else
        ATextRect.Right := ATextRect.Right + 1;

    if ADrawParams.PaintType = ptMenu then
      if UseRightToLeftAlignment then
      begin
        ATextRect.Left := ATextRect.Left + EditControlIndents(ADrawParams, cpText).Right;
        ATextRect.Right := ATextRect.Right - EditControlIndents(ADrawParams, cpText).Left;
      end
      else
      begin
        ATextRect.Left := ATextRect.Left + EditControlIndents(ADrawParams, cpText).Left;
        ATextRect.Right := ATextRect.Right - EditControlIndents(ADrawParams, cpText).Right;
      end;

    ATextAlignment := DT_CENTER;
    DrawItemText(BarEditControl, Canvas.Handle, Caption, ATextRect, ATextAlignment, Enabled,
    DrawSelected and (PaintType = ptMenu), False, False, IsFlatItemTextForMenu);
  end;
end;

procedure TdxBarPainter.EditControlDrawSelectionFrame(const ADrawParams: TdxBarEditLikeControlDrawParams; const ARect: TRect);
begin
  FrameFlatSelRect(ADrawParams.Canvas.Handle, ARect);
end;

procedure TdxBarPainter.EditControlDrawGlyph(const ADrawParams: TdxBarEditLikeControlDrawParams);
var
  ARect: TRect;
  AIndents: TRect;
  ALeftIndent, ARightIndent: Integer;
begin
  with ADrawParams do
  begin
    ARect := BarEditControl.FParts[ecpIcon];
    if (PaintType <> ptMenu) and (ViewSize <> cvsLarge) then
    begin
      AIndents := EditControlIndents(ADrawParams, cpIcon);
      if UseRightToLeftAlignment then
      begin
        ALeftIndent := AIndents.Right;
        ARightIndent := AIndents.Left;
      end
      else
      begin
        ALeftIndent := AIndents.Left;
        ARightIndent := AIndents.Right;
      end;
      Inc(ARect.Left, ALeftIndent);
      Dec(ARect.Right, ARightIndent);
    end;

    DrawGlyph(BarEditControl, Canvas.Handle, ARect, ARect, PaintType, False,
      EditControlGlyphIsDrawSelected(BarEditControl), False, False, False, True, False, False);
  end;
end;

class function TdxBarPainter.EditControlCaptionBackgroundIsOpaque(
  const ADrawParams: TdxBarEditLikeControlDrawParams): Boolean;
begin
  with ADrawParams do
    Result := (PaintType = ptMenu) and (DrawSelected or ADrawParams.BarItemControl.FNonRecent);
end;

class function TdxBarPainter.EditControlCaptionRightIndentIsOpaque(
  const ADrawParams: TdxBarEditLikeControlDrawParams): Boolean;
begin
  with ADrawParams do
    Result := (PaintType = ptMenu) and (ADrawParams.BarItemControl.FNonRecent);
end;

procedure TdxBarPainter.EditControlDrawTextField(ABarEditControl: TdxBarEditControl; ACanvas: TcxCanvas; const ARect: TRect);
begin
  ACanvas.Font.Color := EditGetTextColor(ABarEditControl);
  ACanvas.Brush.Color := EditGetBkColor(ABarEditControl.DrawParams);
  ACanvas.Handle; // RequiredState(csAllValid)

  ACanvas.SaveClipRegion;
  try
    ACanvas.IntersectClipRect(ARect);
    ABarEditControl.Item.DrawInterior(ABarEditControl, ACanvas.Canvas, ARect, ABarEditControl.ItemLink);
  finally
    ACanvas.RestoreClipRegion;
  end;
end;

function TdxBarPainter.EditControlGetBackgroundColor(const ADrawParams: TdxBarItemControlDrawParams): TColor;
begin
  Result := clDefault;
end;

function TdxBarPainter.EditControlGetContentRect(APaintType: TdxBarPaintType; const ARect: TRect): TRect;
begin
  Result := cxRectContent(ARect, EditControlBorderOffsets(APaintType));
end;

function TdxBarPainter.EditControlGetTextColor(const ADrawParams: TdxBarItemControlDrawParams): TColor;
begin
  Result := clDefault;
end;

class function TdxBarPainter.EditControlShowIconDefault(const ADrawParams: TdxBarEditLikeControlDrawParams): Boolean;
begin
  Result := False;
end;

class function TdxBarPainter.EditControlIndents(
  const ADrawParams: TdxBarEditLikeControlDrawParams; ADrawAreaType: TdxBarItemControlPart): TRect;
begin
  if ADrawAreaType = cpText then
    Result := Rect(EditControlCaptionLeftIndent(ADrawParams), 0, EditControlCaptionRightIndent(ADrawParams), 0)
  else
    if ADrawParams.PaintType = ptMenu then
      Result := EditControlSubMenuGlyphIndents(ADrawParams)
    else
    begin
      Result := cxNullRect;
      Result.Left := (ADrawParams.DefaultButtonSize.cx - ADrawParams.BarItemControl.GetGlyphSize(ADrawParams.ViewSize).cx) div 2;
      Result.Right := ADrawParams.ScaleFactor.Apply(GetControlTextIndents.Left);
    end;
end;

class function TdxBarPainter.EditControlCaptionLeftIndent(const ADrawParams: TdxBarEditLikeControlDrawParams): Integer;
begin
  if not (cpIcon in ADrawParams.ViewStructure) then
    Result := EditControlCaptionSimpleIndent(ADrawParams)
  else
    if ADrawParams.PaintType <> ptMenu then
      Result := 0
    else
      Result := EditControlCaptionSubMenuIndent(ADrawParams) //In SubMenu
end;

class function TdxBarPainter.EditControlCaptionRightIndent(const ADrawParams: TdxBarEditLikeControlDrawParams): Integer;
begin
  Result := EditControlCaptionComplexIndent(ADrawParams);
end;

class function TdxBarPainter.EditControlCaptionSubMenuIndent(
  const ADrawParams: TdxBarEditLikeControlDrawParams): Integer;
begin
  Result := 2;
end;

class function TdxBarPainter.EditControlCaptionSimpleIndent(const ADrawParams: TdxBarEditLikeControlDrawParams): Integer;
begin
  Result := 2
end;

class function TdxBarPainter.EditControlCaptionComplexIndent(const ADrawParams: TdxBarEditLikeControlDrawParams): Integer;
begin
  Result := 4;
end;

class function TdxBarPainter.EditControlSubMenuGlyphIndents(
  const ADrawParams: TdxBarEditLikeControlDrawParams): TRect;
begin
  Result := Rect(4, 0, 0, 0);
end;

class function TdxBarPainter.EditControlGetRightCaptionIndentBrush(
  ABarEditControl: TdxBarCustomEditControl): HBRUSH;
begin
  Result := ABarEditControl.Parent.BkBrush;
end;

class function TdxBarPainter.EditControlGlyphIsDrawSelected(
  ABarEditControl: TdxBarCustomEditControl): Boolean;
begin
  Result := False;
end;

class procedure TdxBarPainter.EditControlUpdateWndText(ABarEditControl: TdxBarEditControl;
  AHandle: HWND; ANotEqual: Boolean);
begin
  if ANotEqual then
    SendMessage(AHandle, WM_COMMAND, MAKEWPARAM(0, EN_CHANGE), AHandle);
  SendMessage(AHandle, EM_SETSEL, 0, -1);
end;

function TdxBarPainter.ColorComboHasCompleteFrame: Boolean;
begin
  Result := False;
end;

function TdxBarPainter.IsCustomColorButtonVisible(
  const ADrawParams: TdxBarColorComboControlDrawParams): Boolean;
begin
  Result := cxRectWidth(ADrawParams.BarItemControl.FParts[clcpCustomColorButton]) <> 0;
end;

procedure TdxBarPainter.ColorComboCorrectFrameRect(
  const ADrawParams: TdxBarColorComboControlDrawParams; var ARect: TRect);
begin
  if ColorComboHasCompleteFrame and IsCustomColorButtonVisible(ADrawParams) then
    ARect.Right := ADrawParams.BarItemControl.FParts[clcpCustomColorButton].Right + GetCustomColorButtonIndents(ADrawParams.PaintType).Right;
end;

function TdxBarPainter.GetCustomColorButtonIndents(APaintType: TdxBarPaintType): TRect;
begin
  Result := Rect(1, 2, 1, 2);
end;

procedure TdxBarPainter.ColorComboDrawCustomButton(
  const ADrawParams: TdxBarColorComboControlDrawParams; ARect: TRect);
begin
  with ADrawParams do
    FrameAndFillRect(BarItemControl, Canvas.Handle, ARect, Enabled, DrawSelected, IsPressed);
  DrawDots(ADrawParams, ARect);
end;

procedure TdxBarPainter.ColorComboDrawCustomButtonAdjacentZone(
  const ADrawParams: TdxBarColorComboControlDrawParams; ARect: TRect);
begin
  with ADrawParams do
  begin
    DrawBackgroundFrameRect(BarItemControl, Canvas.Handle, ARect, BarItemControl.Parent.BkBrush, False);
    InflateRect(ARect, 0, -1);
    DrawBackgroundFrameRect(BarItemControl, Canvas.Handle, ARect, BarItemControl.Parent.BkBrush, False);
  end;
end;

procedure TdxBarPainter.SysPanelCalcSize(var AClientRect, AGripRect, ACloseButtonRect: TRect;
  var Corner: TdxCorner; Combo: TdxBarItem; AllowResizing: Boolean; AScaleFactor: TdxScaleFactor);

  function GetSysPanelBorders: TRect;
  begin
    Result := cxEmptyRect;
    if Corner in [coBottomLeft, coBottomRight] then
      Result.Top := 1
    else
      Result.Bottom := 1;
  end;

var
  APanelRect: TRect;
begin
  if AllowResizing then
    GetLookAndFeelPainter.CalculateScaledPopupPanelClientRect(AClientRect, APanelRect,
      AGripRect, ACloseButtonRect, Corner, cxRect(1, 1, 1, 1), GetSysPanelBorders, AScaleFactor);
end;

procedure TdxBarPainter.SysPanelDraw(
  AHandle: HWND; AllowResizing, MouseAboveCloseButton, CloseButtonIsTracking: Boolean;
  CloseButtonRect, GripRect: TRect; Corner: TdxCorner; AScaleFactor: TdxScaleFactor);
begin
  if AllowResizing then
    GetLookAndFeelPainter.DrawScaledPopupNCPanel(AHandle, MouseAboveCloseButton,
      CloseButtonIsTracking, Corner, CloseButtonRect, GripRect, GetSysPanelBorderColor, AScaleFactor);
end;

class function TdxBarPainter.SysPanelSize(AScaleFactor: TdxScaleFactor): Integer;
begin
  Result := dxDropDownNCHeight;
end;

class function TdxBarPainter.IsDateNavigatorFlat: Boolean;
begin
  Result := False;
end;

procedure TdxBarPainter.DateNavigatorDrawButton(ABarItem: TdxBarItem;
  DC: HDC; R: TRect; const ACaption: string; APressed: Boolean; AScaleFactor: TdxScaleFactor);
var
  AOffset: Integer;
  APrevPen: HPEN;
begin
  AOffset := 0;
  with R do
  begin
    if APressed then
    begin
      DrawFrameControl(DC, R, DFC_BUTTON, DFCS_BUTTONPUSH or DFCS_PUSHED);
      AOffset := 1;
    end
    else
    begin
      APrevPen := SelectObject(DC, CreatePen(PS_SOLID, 1, GetSysColor(COLOR_BTNTEXT)));
      MoveToEx(DC, Left, Bottom - 1, nil);
      LineTo(DC, Right - 1, Bottom - 1);
      LineTo(DC, Right - 1, Top);
      DeleteObject(SelectObject(DC, APrevPen));

      APrevPen := SelectObject(DC, CreatePen(PS_SOLID, 1, GetSysColor(COLOR_BTNFACE)));
      LineTo(DC, Left, Top);
      LineTo(DC, Left, Bottom - 1);
      DeleteObject(SelectObject(DC, APrevPen));

      APrevPen := SelectObject(DC, CreatePen(PS_SOLID, 1, GetSysColor(COLOR_BTNSHADOW)));
      MoveToEx(DC, Left + 1, Bottom - 2, nil);
      LineTo(DC, Right - 2, Bottom - 2);
      LineTo(DC, Right - 2, Top + 1);
      DeleteObject(SelectObject(DC, APrevPen));

      APrevPen := SelectObject(DC, CreatePen(PS_SOLID, 1, GetSysColor(COLOR_BTNHIGHLIGHT)));
      MoveToEx(DC, Left + 1, Bottom - 3, nil);
      LineTo(DC, Left + 1, Top + 1);
      LineTo(DC, Right - 2, Top + 1);
      DeleteObject(SelectObject(DC, APrevPen));

      SetPixel(DC, Right - 2, Top + 1, GetSysColor(COLOR_BTNFACE));
    end;
    R := cxRectInflate(R, -AScaleFactor.Apply(2));
  end;
  // draw button's caption
  DateNavigatorDrawButtonCaption(DC, R, AOffset, ACaption, True);
end;

function TdxBarPainter.DateNavigatorHeaderColor: TColor;
begin
  Result := clBtnFace;
end;

function TdxBarPainter.GetSpinEditArrowPos(const ADrawParams: TdxBarSpinEditDrawParams; ARect: TRect; AButtonIndex: Integer): TPoint;
begin
  with ADrawParams do
  begin
    Result.X := ARect.Left + ArrowSize.cy;
    ARect.Top := (ARect.Top + ARect.Bottom - ArrowSize.cy) div 2 + Byte(AButtonIndex = secButtonUp) * (ArrowSize.cy - 1);
    Result.Y := ARect.Top;
  end;
end;

procedure TdxBarPainter.SpinEditCorrectFrameRect(const ADrawParams: TdxBarItemControlDrawParams; var ARect: TRect);
begin
  ARect.Right := ADrawParams.BarItemControl.FParts[secButtonUp].Left - GetSpinEditButtonIndents(ADrawParams.PaintType).Left;
end;

function TdxBarPainter.GetSpinEditArrowSize(AHeight: Integer): TSize;
begin
  Result.cy := (AHeight div 2 - 2) div 2;
  Result.cx := 2 * Result.cy - 1;
end;

function TdxBarPainter.GetSpinEditButtonBounds(const ADrawParams: TdxBarSpinEditDrawParams; const ARect: TRect; AButton: TdxBarSpinEditButton): TRect;

  function IsButtonsWidthTooLarge(AButtonsWidth: Integer): Boolean;
  begin
    Result := AButtonsWidth >= cxRectWidth(ADrawParams.BarEditControl.GetEditRect) div 2;
  end;

begin
  Result := ARect;
  Result.Left := Result.Right - GetSpinEditButtonWidth(ADrawParams.PaintType, ARect) - GetSpinEditButtonIndents(ADrawParams.PaintType).Left -
    GetSpinEditButtonIndents(ADrawParams.PaintType).Right;

  if IsButtonsWidthTooLarge(cxRectWidth(Result)) then
    Result.Left := Result.Right
  else
  begin
    Result := cxRectContent(Result, GetSpinEditButtonIndents(ADrawParams.PaintType));
    case AButton of
      sbUp: Result.Bottom := (Result.Bottom + Result.Top) div 2;
      sbDown: Result.Top := (Result.Bottom + Result.Top) div 2;
    end;
  end;
end;

function TdxBarPainter.GetSpinEditButtonIndents(APaintType: TdxBarPaintType): TRect;
begin
  Result := Rect(1, 0, 1, 0);
end;

function TdxBarPainter.GetSpinEditButtonWidth(APaintType: TdxBarPaintType; const ARect: TRect): Integer;
var
  AArrowSize: TSize;
begin
  AArrowSize := GetSpinEditArrowSize(cxRectHeight(ARect));
  Result := AArrowSize.cx + 2 * (1 + 1 + AArrowSize.cy);
  Result := Result - GetSpinEditButtonIndents(APaintType).Left -
    GetSpinEditButtonIndents(APaintType).Right
end;

function TdxBarPainter.GetSpinEditButtonState(const ADrawParams: TdxBarSpinEditDrawParams; AButtonIndex: Integer): TcxButtonState;
begin
  with ADrawParams do
  if not Enabled then
    Result := cxbsDisabled
  else
    if AButtonIndex = ActiveButtonIndex then
      Result := cxbsPressed
    else
      if AButtonIndex = HotPartIndex then
        Result := cxbsHot
      else
        Result := cxbsNormal;
end;

procedure TdxBarPainter.SpinEditControlDrawButton(const ADrawParams: TdxBarSpinEditDrawParams; ARect: TRect; AButtonIndex: Integer);

   procedure OffsetArrowPosIfActive(var AArrowPos: TPoint);
   begin
     if AButtonIndex = ADrawParams.ActiveButtonIndex then
       AArrowPos := cxPointOffset(AArrowPos, 1, 1);
   end;

var
  AArrowPos: TPoint;
begin
  with ADrawParams do
  begin
    FrameAndFillRect(BarEditControl, Canvas.Handle, ARect, Enabled, DrawSelected,
      ActiveButtonIndex = AButtonIndex);
    AArrowPos := GetSpinEditArrowPos(ADrawParams, ARect, AButtonIndex);
    OffsetArrowPosIfActive(AArrowPos);
    DrawSpinEditArrow(ADrawParams, AArrowPos, AButtonIndex);
  end;
end;

procedure TdxBarPainter.SpinEditControlDrawButtonsAdjacentZone(const ADrawParams: TdxBarSpinEditDrawParams; const ARect: TRect);
begin
  with ADrawParams do
    DrawBackground(BarEditControl, Canvas.Handle, ARect, BarEditControl.Parent.BkBrush, False);
end;

class function TdxBarPainter.ProgressControlBarBrushColor: TColorRef;
begin
  Result := GetSysColor(COLOR_HIGHLIGHT);
end;

function TdxBarPainter.CanUpdateBarPartly: Boolean;
begin
  Result := False;
end;

function TdxBarPainter.ProgressControlBarHeight(ABarItemControl: TdxBarItemControl): Integer;
begin
  Result := 12;
end;

class function TdxBarPainter.ProgressControlIndent(const ADrawParams: TdxBarItemControlDrawParams): Integer;
begin
  Result := 0;
end;

procedure TdxBarPainter.ProgressControlDrawBar(const ADrawParams: TdxBarProgressControlDrawParams; BarR: TRect; ABarBrushColor: TColorRef);

  procedure CalculateBandRect;
  var
    ABeginPos, AEndPos: ^Integer;
  begin
    with BarR do
      if ADrawParams.PaintType = ptVert then
      begin
        ABeginPos := @Top;
        AEndPos := @Bottom;
      end
      else
      begin
        ABeginPos := @Left;
        AEndPos := @Right;
      end;
    with ADrawParams do
      AEndPos^ := ABeginPos^ + MulDiv(AEndPos^ - ABeginPos^, Position - Min, Max - Min);
  end;

  procedure DrawBand;
  var
    ABarBrush: HBRUSH;
  begin
    ABarBrush := CreateSolidBrush(ABarBrushColor);
    try
      if ADrawParams.Smooth then
        ProgressControlFillContent(ADrawParams, BarR, ABarBrush)
      else
        ProgressControlDrawChunks(ADrawParams, BarR, ABarBrush);
    finally
      DeleteObject(ABarBrush);
    end;
  end;

begin
  ProgressControlDrawBackground(ADrawParams, BarR);
  CalculateBandRect;
  DrawBand;
end;

procedure TdxBarPainter.ProgressControlFillContent(const ADrawParams: TdxBarItemControlDrawParams; const R: TRect; ABarBrush: HBRUSH);
begin
  FillRect(ADrawParams.Canvas.Handle, R, ABarBrush);
end;

procedure TdxBarPainter.ProgressControlFillDiscreteContent(const ADrawParams: TdxBarItemControlDrawParams; const R: TRect; ABarBrush: HBRUSH);
begin
  ProgressControlFillContent(ADrawParams, R, ABarBrush);
end;

procedure TdxBarPainter.ProgressControlDrawBackground(const ADrawParams: TdxBarItemControlDrawParams; var BarR: TRect);
begin
  with ADrawParams do
    DrawBackground(BarItemControl, Canvas.Handle, BarR, BarItemControl.Parent.BkBrush, False);
end;

procedure TdxBarPainter.ProgressControlDrawChunks(const ADrawParams: TdxBarItemControlDrawParams; BarR: TRect; ABarBrush: HBRUSH);
var
  ALimit, AStep: Integer;
  ABeginPos, AEndPos: ^Integer;
begin
  with ADrawParams do
  begin
    with BarR do
      if PaintType = ptVert then
      begin
        ABeginPos := @Top;
        AEndPos := @Bottom;
      end
      else
      begin
        ABeginPos := @Left;
        AEndPos := @Right;
      end;
      ALimit := AEndPos^;
      if PaintType = ptVert then
        AStep := MulDiv(cxRectWidth(BarR), 2, 3)
      else
        AStep := MulDiv(cxRectHeight(BarR), 2, 3);
      repeat
        AEndPos^ := ABeginPos^ + AStep;
        if AEndPos^ > ALimit then AEndPos^ := ALimit;
        ProgressControlFillDiscreteContent(ADrawParams, BarR, ABarBrush);
        ABeginPos^ := AEndPos^;
        Inc(AEndPos^, 2);
        if AEndPos^ > ALimit then AEndPos^ := ALimit;
        ABeginPos^ := AEndPos^;
      until AEndPos^ = ALimit;
    end;
end;

class function TdxBarPainter.ContainerControlSubMenuOffset: Integer;
begin
  Result := 0;
end;

class function TdxBarPainter.InPlaceSubItemControlBrush: HBRUSH;
begin
  Result := GetSysColorBrush(COLOR_BTNSHADOW);
end;

class function TdxBarPainter.InPlaceSubItemGetArrowWidth(const ADrawParams: TdxBarInPlaceSubItemControlDrawParams): Integer;
begin
  Result := ADrawParams.BarItemControl.SubMenuParent.TextSize;
end;

class function TdxBarPainter.InPlaceSubItemGetTextIndent: Integer;
begin
  Result := 5;
end;

function TdxBarPainter.InPlaceSubItemControlIsFlatItemText(const ADrawParams: TdxBarInPlaceSubItemControlDrawParams): Boolean;
begin
  Result := ADrawParams.DrawSelected;
end;

function TdxBarPainter.InPlaceSubItemControlIsArrowSelected(const ADrawParams: TdxBarInPlaceSubItemControlDrawParams): Boolean;
begin
  Result := True;
end;

procedure TdxBarPainter.InPlaceSubItemControlDrawArrow(const ADrawParams: TdxBarInPlaceSubItemControlDrawParams;
  ADirection: TcxArrowDirection; ARect: TRect);
var
  ASize: Integer;
begin
  with ADrawParams do
  begin
    ASize := ArrowSize.cy;
    ARect.Left := ARect.Right - ArrowSize.cx;
    if not IsExpanded then
      Inc(ARect.Left, ASize);
    DrawLargeItemArrow(Canvas.Handle, ARect, ADirection, ASize,
      InPlaceSubItemControlIsArrowSelected(ADrawParams), True, IsFlatItemText, GetItemArrowColor(ADrawParams));
  end;
end;

procedure TdxBarPainter.InPlaceSubItemControlDrawBackground(const ADrawParams: TdxBarInPlaceSubItemControlDrawParams; ARect: TRect);
const
  InternalSeparatorSize = 1;
var
  ABrush: HBRUSH;
begin
  with ADrawParams do
  begin
    FillRect(Canvas.Handle, cxRectInflate(ARect, 0, cxRectHeight(ARect) - InternalSeparatorSize, 0, 0), BarItemControl.Parent.BkBrush);

    Dec(ARect.Bottom, InternalSeparatorSize);

    if DrawSelected then
      ABrush := BarItemControl.Parent.ToolbarSelBrush
    else
      ABrush := InPlaceSubItemControlBrush;

    DrawBackground(BarItemControl, Canvas.Handle, ARect, ABrush, True{Opaque});

    if DrawSelected then
      FrameFlatSelRect(Canvas.Handle, ARect);
  end;
end;

procedure TdxBarPainter.InPlaceSubItemControlDrawInMenu(const ADrawParams: TdxBarInPlaceSubItemControlDrawParams; ARect: TRect);
const
  Arrows: array[Boolean] of TcxArrowDirection = (adRight, adDown);
begin
  with ADrawParams do
  begin
    InPlaceSubItemControlDrawBackground(ADrawParams, ARect);

    Inc(ARect.Left, InPlaceSubItemGetTextIndent);
    DrawItemText(BarItemControl, Canvas.Handle, Caption,
      ARect, DT_LEFT, True, True, False, False, InPlaceSubItemControlIsFlatItemText(ADrawParams));

    if Enabled then
      InPlaceSubItemControlDrawArrow(ADrawParams, Arrows[IsExpanded], ARect);
  end;
end;

procedure TdxBarPainter.DrawStaticBackground(const ADrawParams: TdxBarStaticLikeControlDrawParams; ARect: TRect);
begin
  with ADrawParams do
    DrawBackground(BarItemControl, Canvas.Handle, ARect, BarItemControl.BkBrush, StaticBackgroundIsOpaque(ADrawParams));
end;

procedure TdxBarPainter.DrawStaticBorder(const ADrawParams: TdxBarStaticLikeControlDrawParams; var ARect: TRect);
const
  Borders: array[TdxBarStaticBorderStyle] of Integer =
    (0, BDR_SUNKENOUTER, BDR_RAISEDINNER, EDGE_ETCHED, 0);
begin
  with ADrawParams do
  begin
    if BorderStyle = sbsNone then Exit;
    if BorderStyle = sbsBump then
    begin
      DrawEdge(Canvas.Handle, ARect, BDR_RAISEDINNER, BF_RECT);
      InflateRect(ARect, -1, -1);
      DrawEdge(Canvas.Handle, ARect, BDR_SUNKENOUTER, BF_RECT);
      InflateRect(ARect, -1, -1);
    end
    else
    begin
      DrawEdge(Canvas.Handle, ARect, Borders[BorderStyle], BF_RECT);
      ARect := cxRectContent(ARect, BorderOffsets);
    end;
  end;
end;

procedure TdxBarPainter.DrawStaticGlyphAndCaption(const ADrawParams: TdxBarStaticLikeControlDrawParams; const ARect: TRect);

  function IsGlyphCenter: Boolean;
  begin
    Result := ADrawParams.AllowCenter;
    if ADrawParams.PaintType = ptMenu then
      Result := Result and not (cpText in ADrawParams.ViewStructure);
  end;

  function GetGlyphRect: TRect;
  begin
    Result := ARect;
    with ADrawParams do
      case PaintType of
        ptMenu:
          if not IsGlyphCenter then
            Result := SubMenuControlGetItemIconRealRect(ARect, BarItemControl.Parent.IconAreaSize, UseRightToLeftAlignment);
        ptHorz:
          if cpText in ViewStructure then
            if UseRightToLeftAlignment then
              Result.Left := Result.Right - DefaultButtonSize.cx
            else
              Result.Right := Result.Left + DefaultButtonSize.cx;
        ptVert:
          if cpText in ViewStructure then
            Result.Bottom := Result.Top + DefaultButtonSize.cy;
      end;
  end;

  function IsTextCenter: Boolean;
  begin
    Result := ADrawParams.AllowCenter and (ADrawParams.Alignment = taCenter);
  end;

  function GetTextIndent: Integer;
  begin
    Result := 0;
    with ADrawParams do
      if cpIcon in ViewStructure then
        case PaintType of
          ptHorz: Result := DefaultButtonSize.cx + 2;
          ptVert: Result := DefaultButtonSize.cy + 2;
          ptMenu:
            if Alignment = taLeftJustify then
              Result := SubMenuControlGetItemTextIndent(ADrawParams)
        end
      else
        if not IsTextCenter then
          Result := BarItemControl.Parent.TextSize div 4;
  end;

  function GetTextRect: TRect;
  var
    ALeftJustify: Boolean;
  begin
    Result := ARect;
    with ADrawParams do
    begin
      ALeftJustify := Alignment = taLeftJustify;
      if PaintType in [ptMenu, ptHorz] then
      begin
        if ALeftJustify or IsTextCenter then
          Inc(Result.Left, GetTextIndent)
        else
          Dec(Result.Right, 2);
        if UseRightToLeftAlignment then
          Result := TdxRightToLeftLayoutConverter.ConvertRect(Result, ARect);
      end
      else
        if ALeftJustify or IsTextCenter then
          Inc(Result.Top, GetTextIndent)
        else
          Dec(Result.Bottom, 2);
    end;
  end;

begin
  with ADrawParams do
  begin
    DrawStaticBackground(ADrawParams, ARect);
    if cpIcon in ViewStructure then
      DrawGlyph(BarItemControl, Canvas.Handle, GetGlyphRect, cxEmptyRect,
        PaintType, False, False, False, False, False, IsGlyphCenter, True, False);
    if cpText in ViewStructure then
      DrawItemText(BarItemControl, Canvas.Handle, Caption, GetTextRect,
        SystemAlignmentsHorz[Alignment], Enabled, False, PaintType = ptVert, True, False);
  end;
end;

procedure TdxBarPainter.DrawStaticLikeControl(const ADrawParams: TdxBarStaticLikeControlDrawParams; var ARect: TRect; const AIndentsRect: TRect);

  procedure DrawIndents;

    procedure DrawLeftIndent;
    var
      R: TRect;
      AIndent: Integer;
    begin
      R := ARect;
      if ADrawParams.UseRightToLeftAlignment and (ADrawParams.PaintType <> ptVert) then
        AIndent := AIndentsRect.Right
      else
        AIndent := AIndentsRect.Left;
      if AIndent <> 0 then
      begin
        if ADrawParams.PaintType = ptVert then
        begin
          Inc(ARect.Top, AIndent);
          R.Bottom := ARect.Top;
        end
        else
        begin
          Inc(ARect.Left, AIndent);
          R.Right := ARect.Left;
        end;
        with ADrawParams do
          DrawBackground(BarItemControl, Canvas.Handle, R, BarItemControl.Parent.BkBrush, False);
      end;
    end;

    procedure DrawRightIndent;
    var
      R: TRect;
      AIndent: Integer;
    begin
      R := ARect;
      if ADrawParams.UseRightToLeftAlignment and (ADrawParams.PaintType <> ptVert) then
        AIndent := AIndentsRect.Left
      else
        AIndent := AIndentsRect.Right;
      if AIndent <> 0 then
      begin
        if ADrawParams.PaintType = ptVert then
        begin
          R.Bottom := ARect.Bottom;
          Dec(ARect.Bottom, AIndent);
          R.Top := ARect.Bottom;
        end
        else
        begin
          R.Right := ARect.Right;
          Dec(ARect.Right, AIndent);
          R.Left := ARect.Right;
        end;
        with ADrawParams do
          DrawBackground(BarItemControl, Canvas.Handle, R, BarItemControl.Parent.BkBrush, False);
      end;
    end;

  begin
    DrawLeftIndent;
    DrawRightIndent;
  end;

begin
  with ADrawParams do
  begin
    DrawIndents;
    DrawStaticBorder(ADrawParams, ARect);
    BarStaticControl.DrawInterior(ARect);
  end;
end;

class function TdxBarPainter.StaticBackgroundIsOpaque(const ADrawParams: TdxBarItemControlDrawParams): Boolean;
begin
  Result := ADrawParams.BarItemControl.IsBkColorAssigned;
end;

function TdxBarPainter.StaticControlGetBorderOffsets(AParent: TCustomdxBarControl; ABorderStyle: TdxBarStaticBorderStyle): TRect;
const
  Widths: array[TdxBarStaticBorderStyle] of Integer = (0, 1, 1, 2, 2);
var
  ABorderWidth: Integer;
begin
  ABorderWidth := Widths[ABorderStyle];
  Result := Rect(ABorderWidth, ABorderWidth, ABorderWidth, ABorderWidth);
end;

class function TdxBarPainter.SeparatorControlGetIndents(const ADrawParams: TdxBarSeparatorControlDrawParams;
  ADrawAreaType: TdxBarItemControlPart): TRect;
begin
  Result := cxRect(6, 0, 0, 0);
end;

function TdxBarPainter.SubMenuGetSeparatorSize: Integer;
begin
  Result := MenuSeparatorSize;
end;

procedure TdxBarPainter.DrawSeparatorGlyphAndCaption(
  const ADrawParams: TdxBarSeparatorControlDrawParams; const ARect: TRect);
begin
  DrawStaticGlyphAndCaption(ADrawParams, ARect);
end;

procedure TdxBarPainter.DrawSeparatorControl(
  const ADrawParams: TdxBarSeparatorControlDrawParams; const ARect: TRect);
begin
  with ADrawParams do
    if cpText in ADrawParams.ViewStructure then
    begin
      DrawSeparatorGlyphAndCaption(ADrawParams, ARect);
      if not IsTop then
        DrawSeparatorControlLine(Canvas, cxRectSetTop(ARect, ARect.Top, SeparatorControlSeparatorSize));
      DrawSeparatorControlLine(Canvas, cxRectSetBottom(ARect, ARect.Bottom, SeparatorControlSeparatorSize));
    end
    else
      if PaintType = ptMenu then
        SubMenuControlDrawBeginGroup(BarItemControl.SubMenuParent, BarItemControl, Canvas, ARect)
      else
        BarDrawBeginGroup(BarItemControl.Parent, Canvas.Handle, ARect,
          BarItemControl.Parent.ToolbarBrush, False);
end;

procedure TdxBarPainter.DrawSeparatorControlLine(ACanvas: TcxCanvas; const R: TRect);
begin
  SubMenuControlDrawSeparator(ACanvas, R);
end;

procedure TdxBarPainter.SeparatorControlGetTextColors(ABarItemControl: TdxBarItemControl;
  AEnabled, ASelected, AFlat: Boolean; var AColor1, AColor2: TColor);
begin
  GetDefaultTextColors(ABarItemControl, AEnabled, ASelected, AFlat, AColor1, AColor2);
end;

function TdxBarPainter.SeparatorControlSeparatorSize: Integer;
begin
  Result := SubMenuGetSeparatorSize;
end;

function TdxBarPainter.ScreenTipGetColorPalette: IdxColorPalette;
begin
  Result := GetLookAndFeelPainter.ScreenTipGetColorPalette;
end;

function TdxBarPainter.ScreenTipGetDescriptionTextColor: TColor;
begin
  Result := GetLookAndFeelPainter.ScreenTipGetDescriptionTextColor;
end;

function TdxBarPainter.ScreenTipGetTitleTextColor: TColor;
begin
  Result := GetLookAndFeelPainter.ScreenTipGetTitleTextColor;
end;

function TdxBarPainter.ScreenTipGetFooterLineSize: Integer;
begin
  Result := GetLookAndFeelPainter.ScreenTipGetFooterLineSize;
end;

procedure TdxBarPainter.ScreenTipDrawBackground(ACanvas: TcxCanvas; ARect: TRect);
begin
  GetLookAndFeelPainter.ScreenTipDrawBackground(ACanvas, ARect);
end;

procedure TdxBarPainter.ScreenTipDrawFooterLine(ACanvas: TcxCanvas; const ARect: TRect);
begin
  GetLookAndFeelPainter.ScreenTipDrawFooterLine(ACanvas, ARect);
end;

class function TdxBarPainter.HasEditControlExternalFrame(
  APaintType: TdxBarPaintType; ASelected: Boolean): Boolean;
begin
  Result := False;
end;

class function TdxBarPainter.IsCompoundPainting: Boolean;
begin
  Result := False;
end;

class function TdxBarPainter.NeedDoubleBuffer: Boolean;
begin
  Result := False;
end;

procedure TdxBarPainter.DrawToolbarContentPart(
  ABarControl: TdxBarControl; ACanvas: TcxCanvas);
begin
  with ABarControl do
    FillBackground(Canvas.Handle, ClientRect, ToolbarBrush, clNone, True);
end;

procedure TdxBarPainter.DrawToolbarNonContentPart(ABarControl: TdxBarControl; DC: HDC);
begin
end;

class function TdxBarPainter.GetDefaultArrowSignSize(AScaleFactor: TdxScaleFactor): TSize;
begin
  Result := AScaleFactor.Apply(Size(5, 3));
end;

function TdxBarPainter.GetToolbarCaptionRect(ABarControl: TdxBarControl; const ARect: TRect): TRect;
begin
  Result := ARect;
  InflateRect(Result, -BorderSizeX(ABarControl.ScaleFactor), -BorderSizeY(ABarControl.ScaleFactor));
  Result.Bottom := Result.Top + BarCaptionSize(ABarControl.ScaleFactor);
end;

function TdxBarPainter.AllowLargeIcons: Boolean;
begin
  Result := True;
end;

procedure TdxBarPainter.DoDrawText(ADC: HDC; const AText: string; var ARect: TRect; AFormat: UINT);
begin
  cxDrawText(ADC, AText, ARect, AFormat);
end;

procedure TdxBarPainter.ButtonLikeControlCorrectCaptionParams(
  const ADrawParams: TdxBarButtonLikeControlDrawParams; var ATextBounds: TRect;
  const AImageBounds: TRect; out ATextAlignment, AFormat: DWORD);

  procedure OffsetTextBounds(var ATextBounds: TRect);
  begin
    if not IsMenuItem(ADrawParams.BarItemControl) then
      OffsetCaptionBounds(ADrawParams.Downed, ADrawParams.DrawDowned, ATextBounds);
  end;

var
  AGlyphLayout: TdxBarGlyphLayout;
  R: TRect;
begin
  AFormat := DT_SINGLELINE;
  if ADrawParams.ViewSize = cvsLarge then
  begin
    ATextAlignment := DT_CENTER;
    AGlyphLayout := GetGlyphLayout(ADrawParams);
    if ADrawParams.UseRightToLeftAlignment then
      case AGlyphLayout of
        glLeft:
          if ADrawParams.PaintType = ptHorz then
            AGlyphLayout := glRight;
        glRight:
          if ADrawParams.PaintType = ptHorz then
            AGlyphLayout := glLeft;
        glTop:
          if ADrawParams.PaintType = ptVert then
            AGlyphLayout := glBottom;
      else //glBottom
        if ADrawParams.PaintType = ptVert then
          AGlyphLayout := glTop;
      end;
    case AGlyphLayout of
      glLeft:
        begin
          if ADrawParams.UseRightToLeftAlignment and (ADrawParams.PaintType = ptHorz) then
            ATextAlignment := DT_RIGHT
          else
            ATextAlignment := DT_LEFT;
          if ADrawParams.PaintType = ptHorz then
            ATextBounds.Left := AImageBounds.Right + 3
          else
            ATextBounds.Top := AImageBounds.Bottom + 3;
        end;
      glRight:
        begin
          if ADrawParams.UseRightToLeftAlignment and (ADrawParams.PaintType = ptHorz) then
            ATextAlignment := DT_LEFT
          else
            ATextAlignment := DT_RIGHT;
          if ADrawParams.PaintType = ptHorz then
            ATextBounds.Right := AImageBounds.Left - 3
          else
            ATextBounds.Bottom := AImageBounds.Top - 3;
        end;
      glTop:
        if ADrawParams.PaintType = ptHorz then
          ATextBounds.Top := AImageBounds.Bottom
        else
          ATextBounds.Right := AImageBounds.Left;
      glBottom:
        if ADrawParams.PaintType = ptHorz then
          ATextBounds.Bottom := AImageBounds.Top
        else
          ATextBounds.Left := AImageBounds.Right;
    end;
  end
  else
  begin
    R := ATextBounds;
    ATextAlignment := DT_LEFT;
    if cpIcon in ADrawParams.ViewStructure then
      if ADrawParams.PaintType = ptHorz then
        Inc(ATextBounds.Left, ADrawParams.DefaultButtonSize.cx)
      else
        Inc(ATextBounds.Top, ADrawParams.DefaultButtonSize.cy)
    else
      if ADrawParams.PaintType = ptHorz then
        Inc(ATextBounds.Left, ADrawParams.BarItemControl.GetControlCaptionOffset)
      else
        Inc(ATextBounds.Top, ADrawParams.BarItemControl.GetControlCaptionOffset);

    OffsetTextBounds(ATextBounds);
    if ADrawParams.UseRightToLeftAlignment then
      ATextBounds := TdxRightToLeftLayoutConverter.ConvertRect(ATextBounds, R);
  end;
end;

function TdxBarPainter.GetBorderSize: Integer;
begin
  Result := 0;
end;

function TdxBarPainter.GetIconAreaSize(ABarControl: TCustomdxBarControl): Integer;
var
  AIconAreaOffset: Integer;
begin
  AIconAreaOffset := ABarControl.ScaleFactor.Apply(4); // !
  case ABarControl.ItemLinks.ItemSize of
    misNormal:
      Result := ABarControl.TextSize;
  else //misLarge
    Result := Round((ABarControl.ScaleFactor.Apply(DefaultGlyphSize) * 2 + AIconAreaOffset * 2) * ABarControl.Ratio);
  end;
  CorrectButtonControlDefaultHeight(Result);
end;

procedure TdxBarPainter.DrawGlyphBorder(ABarItemControl: TdxBarItemControl;
  DC: HDC; ABrush: HBRUSH; NeedBorder: Boolean; R: TRect; PaintType: TdxBarPaintType;
  IsGlyphEmpty, Selected, Down, DrawDowned, ADroppedDown, IsSplit: Boolean);
begin
  // Required
end;

procedure TdxBarPainter.DrawGlyphCheckMark(ABarItemControl: TdxBarItemControl; DC: HDC; X, Y, DoubleSize: Integer);
begin
  // Required
  // TODO: make default from Flat?
end;

procedure TdxBarPainter.DrawGlyphEmptyImage(ABarItemControl: TdxBarItemControl; DC: HDC; R: TRect;
  APaintType: TdxBarPaintType; ADown: Boolean);
var
  ADoubleSize: Integer;
  AIsRightToLeft: Boolean;
begin
  if (APaintType = ptMenu) and ADown then
  begin
    ADoubleSize := 1 + Abs(ABarItemControl.Parent.Font.Height) div 18;
    AIsRightToLeft := ABarItemControl.UseRightToLeftAlignment;
    cxRightToLeftDependentDraw(DC, R, AIsRightToLeft,
      procedure
      begin
        DrawGlyphCheckMark(ABarItemControl, DC,
          (R.Left + R.Right - ADoubleSize * 9) div 2,
          (R.Top + R.Bottom - ADoubleSize * 7) div 2, ADoubleSize);
      end);
  end;
end;

class procedure TdxBarPainter.DrawItemArrow(DC: HDC; R: TRect; AScaleFactor: TdxScaleFactor;
  ArrowType: TcxArrowDirection; Enabled, Selected, Flat: Boolean; AColor: TColor = clDefault);
begin
  dxBar.DrawItemArrow(DC, R, AScaleFactor, ArrowType = adDown, Enabled, Selected, Flat, AColor);
end;

procedure TdxBarPainter.DrawLargeItemArrow(DC: HDC; R: TRect;
  ArrowType: TcxArrowDirection; Size: Integer; Selected, Enabled, Flat: Boolean; AColor: TColor = clDefault);
begin
  dxBar.DrawLargeItemArrow(DC, R, ArrowType, Size, Selected, Enabled, Flat, AColor);
end;

class procedure TdxBarPainter.FrameFlatSelRect(DC: HDC; const R: TRect);
begin
  // do nothing
end;

procedure TdxBarPainter.GetImageParams(AItemControl: TdxBarItemControl; const ADrawRect: TRect;
  APaintType: TdxBarPaintType; AViewStructure: TdxBarItemControlViewStructure; AViewSize: TdxBarItemControlViewSize;
  ACenter, ASelected, ADowned, ADrawDowned: Boolean; var AGlyphEmpty: Boolean; out AGlyph: TdxSmartGlyph;
  out AImages: TCustomImageList; out AImageIndex: Integer; out ADrawImageEnabled: Boolean; out AImageBounds: TRect);
var
  AEnabled: TdxDefaultBoolean;
  AImageSize: TSize;
begin
  if AItemControl.GetCurrentImage(AViewSize, ASelected, AGlyph, AImages, AImageIndex, AEnabled) then
    AImageSize := AItemControl.GetGlyphSize(AViewSize, AGlyph, AImages, AImageIndex)
  else
  begin
    AImageSize := AItemControl.GetDefaultGlyphSize(AViewSize);
    AEnabled := bDefault;
    AGlyphEmpty := True;
  end;

  if AEnabled <> bDefault then
    ADrawImageEnabled := AEnabled = bTrue
  else
    ADrawImageEnabled := AItemControl.Enabled;

  if (AViewSize = cvsLarge) and (APaintType <> ptMenu) then
    AImageBounds := GetLargeImageBounds(AItemControl, AImageSize, ADrawRect, APaintType, AViewStructure)
  else
    AImageBounds := GetSmallImageBounds(AItemControl, AImageSize, ADrawRect,
      APaintType, AViewStructure, ACenter, AGlyphEmpty, AItemControl.BarManager.StretchGlyphs, ADowned, ADrawDowned);
end;

function TdxBarPainter.GetLargeButtonBorderHeight: Integer;
begin
  Result := 1 + 2 + 2 + 1;
end;

function TdxBarPainter.GetLargeButtonBorderWidth: Integer;
begin
  Result := 1 + 4 + 4 + 1;
end;

function TdxBarPainter.GetLargeImageBounds(AItemControl: TdxBarItemControl; const AImageSize: TSize;
  const ADrawRect: TRect; APaintType: TdxBarPaintType; AViewStructure: TdxBarItemControlViewStructure): TRect;

  function GetImageOffset(AGlyphLayout: TdxBarGlyphLayout): TPoint;
  begin
    Result := cxRectCenter(ADrawRect, AImageSize).TopLeft;
    if cpText in AViewStructure then
    begin
      case APaintType of
        ptHorz:
          case AGlyphLayout of
            glLeft:
              Result.X := ADrawRect.Left + 4;
            glRight:
              Result.X := ADrawRect.Right - 4 - AImageSize.cx;
            glTop:
              Result.Y := ADrawRect.Top + 2;
            glBottom:
              Result.Y := ADrawRect.Bottom - 2 - AImageSize.cy;
          end;
        ptVert:
          case AGlyphLayout of
            glLeft:
              Result.Y := ADrawRect.Top + 4;
            glRight:
              Result.Y := ADrawRect.Bottom - 4 - AImageSize.cy;
            glTop:
              Result.X := ADrawRect.Right - 2 - AImageSize.cx;
            glBottom:
              Result.X := ADrawRect.Left + 2;
          end;
      end;
    end;
  end;

var
  AOffset: TPoint;
  AGlyphLayout: TdxBarGlyphLayout;
begin
  AGlyphLayout := (AItemControl.Item as TdxBarButtonLikeItem).GlyphLayout;
  if AItemControl.UseRightToLeftAlignment then
    case AGlyphLayout of
      glLeft:
        if APaintType = ptHorz then
          AGlyphLayout := glRight;
      glRight:
        if APaintType = ptHorz then
          AGlyphLayout := glLeft;
      glTop:
        if APaintType = ptVert then
          AGlyphLayout := glBottom;
    else //glBottom
      if APaintType = ptVert then
        AGlyphLayout := glTop;
    end;

  AOffset := GetImageOffset(AGlyphLayout);
  Result := cxRectBounds(AOffset.X, AOffset.Y, AImageSize.cx, AImageSize.cy);
end;

class function TdxBarPainter.GetSmallImageBounds(AItemControl: TdxBarItemControl; const AImageSize: TSize;
  const ADrawRect: TRect; APaintType: TdxBarPaintType; AViewStructure: TdxBarItemControlViewStructure;
  ACenter, AGlyphEmpty, AStretchGlyph, ADowned, ADrawDowned: Boolean): TRect;

  procedure GetDimensions(out AWidth, AHeight: Integer);
  begin
    AWidth := cxRectWidth(ADrawRect);
    AHeight := cxRectHeight(ADrawRect);
    if not ACenter then
      case APaintType of
        ptHorz:
          AWidth := AItemControl.FDrawParams.DefaultButtonSize.cx;
        ptVert:
          AHeight := AItemControl.FDrawParams.DefaultButtonSize.cy;
      end;
  end;

  procedure GetRealImageDimensions(AWidth, AHeight: Integer; out AImageWidth, AImageHeight: Integer);
  var
    ARatio: Double;
    ASize: TSize;
  begin
    AImageWidth := AImageSize.cx;
    AImageHeight := AImageSize.cy;
    if APaintType = ptMenu then
    begin
      if AStretchGlyph then
      begin
        ARatio := AItemControl.Parent.Ratio;
        AImageWidth := Round(AImageWidth * ARatio);
        AImageHeight := Round(AImageHeight * ARatio);
        if (AImageWidth > AImageSize.cx) and (AImageHeight > AImageSize.cy) and Odd(AWidth - AImageWidth) and Odd(AHeight - AImageHeight) then
        begin
          Dec(AImageWidth);
          Dec(AImageHeight);
        end;
      end
    end
    else
      if AItemControl.UseLargeIcons then
        if AItemControl.BarManager.IsLargeImagesForLargeIcons then
        begin
          ASize := dxGetImageSize(AItemControl.BarManager.LargeImages, AItemControl.ScaleFactor);
          AImageHeight := ASize.cy;
          AImageWidth := ASize.cx;
        end
        else
          if not (AItemControl.BarManager.UseLargeImagesForLargeIcons and IsGlyphAssigned(AItemControl.LargeGlyph)) then
          begin
            AImageWidth := 2 * AImageWidth;
            AImageHeight := 2 * AImageHeight;
          end;
  end;

  function GetImageBounds(AWidth, AHeight, AImageWidth, AImageHeight: Integer): TRect;
  begin
    Result := Bounds(ADrawRect.Left + (AWidth - AImageWidth) div 2, ADrawRect.Top + (AHeight - AImageHeight) div 2, AImageWidth, AImageHeight);
    if ADowned then
      OffsetRect(Result, GlyphDownShift(AItemControl), GlyphDownShift(AItemControl));
    if ADrawDowned then
      OffsetRect(Result, GlyphDrawDownedShift(AItemControl, ADowned), GlyphDrawDownedShift(AItemControl, ADowned));
    if AItemControl.UseRightToLeftAlignment then
      Result := TdxRightToLeftLayoutConverter.ConvertRect(Result, ADrawRect);
  end;

var
  AWidth, AHeight, AImageWidth, AImageHeight: Integer;
begin
  Result := cxRect(AImageSize);
  GetDimensions(AWidth, AHeight);

  begin
    GetRealImageDimensions(AWidth, AHeight, AImageWidth, AImageHeight);
    Result := GetImageBounds(AWidth, AHeight, AImageWidth, AImageHeight);
  end;
end;

function TdxBarPainter.GetDefaultEnabledTextColor(
  ABarItemControl: TdxBarItemControl; ASelected, AFlat: Boolean): TColor;
begin
  if ASelected and not AFlat then
    Result := GetSysColor(COLOR_HIGHLIGHTTEXT)
  else
    Result := GetSysColor(COLOR_BTNTEXT);
end;

procedure TdxBarPainter.GetDefaultTextColors(ABarItemControl: TdxBarItemControl;
  AEnabled, ASelected, AFlat: Boolean; var AColor1, AColor2: TColor);
begin
  if AEnabled then
  begin
    AColor1 := GetEnabledTextColor(ABarItemControl, ASelected, AFlat);
    AColor2 := AColor1;
  end
  else
    GetDisabledTextColors(ABarItemControl, ASelected, AFlat, AColor1, AColor2);
end;

procedure TdxBarPainter.GetDisabledTextColors(
  ABarItemControl: TdxBarItemControl; ASelected, AFlat: Boolean;
  var AColor1, AColor2: TColor);
begin
  if ASelected or AFlat then
  begin
    AColor1 := GetSysColor(COLOR_GRAYTEXT);
    AColor2 := AColor1;
  end
  else
  begin
    AColor1 := GetSysColor(COLOR_BTNHIGHLIGHT);
    AColor2 := GetSysColor(COLOR_BTNSHADOW);
  end;
end;

function TdxBarPainter.GetEnabledTextColor(
  ABarItemControl: TdxBarItemControl; ASelected, AFlat: Boolean): TColor;
begin
  Result := GetDefaultEnabledTextColor(ABarItemControl, ASelected, AFlat);
end;

function TdxBarPainter.GetItemArrowColor(const ADrawParams: TdxBarButtonLikeControlDrawParams): TColor;
begin
  if UseTextColorForItemArrow then
    with ADrawParams do
      BarItemControl.GetTextColors(Enabled, IsTextSelected, IsFlatText, Result, Result)
  else
    Result := clDefault;
end;

class function TdxBarPainter.GetFaded(ABarControl: TCustomdxBarControl): Boolean;
begin
  Result := ABarControl.BarManager.MakeDisabledImagesFaded;
end;

class function TdxBarPainter.IsFadingAvailable: Boolean;
begin
  Result := Supports(Self, IdxFadingPainterHelper);
end;

class function TdxBarPainter.IgnoreGlyphOpaque: Boolean;
begin
  Result := False;
end;

class function TdxBarPainter.IgnoreNonRecentColor: Boolean;
begin
  Result := False;
end;

class function TdxBarPainter.IsMenuItem(ABarItemControl: TdxBarItemControl): Boolean;
begin
  Result := False;
end;

class function TdxBarPainter.UseTextColorForItemArrow: Boolean;
begin
  Result := False;
end;

class function TdxBarPainter.GetBarItemControlHintPosition(
  ABarControl: TCustomdxBarControl; const AItemBounds: TRect;
  const ACursorPos: TPoint; AHeight: Integer): TPoint;
begin
  Result := ACursorPos;
  ABarControl.AdjustHintWindowPosition(Result,
    dxMapWindowRect(ABarControl.Handle, 0, AItemBounds), AHeight);
end;

function TdxBarPainter.CreateHintViewInfo(ABarManager: TdxBarManager; AHintText: string; const AShortCut: string;
  AScreenTip: TdxScreenTip): TdxBarCustomHintViewInfo;
begin
  Result := TdxBarHintViewInfo.Create(ABarManager, AHintText, AShortCut, GetMouseCursorPos);
end;

function TdxBarPainter.IsCustomHintSupported: Boolean;
begin
  Result := True;
end;

class function TdxBarPainter.BarIsBarSmall(ABarControl: TdxBarControl;
  const R: TRect): Boolean;
begin
  with R do
    Result := Bottom - Top <= 1 + 3 + 5 + 3 + 3 + 1;
end;

class function TdxBarPainter.BarCaptionBkColor(ABarControl: TdxBarControl;
  AMainFormActive: Boolean): COLORREF;
const
  CaptionBkColors: array[Boolean] of Integer =
    (COLOR_INACTIVECAPTION, COLOR_ACTIVECAPTION);
begin
  Result := GetSysColor(CaptionBkColors[AMainFormActive]);
end;

function TdxBarPainter.BarCaptionColor(ABarControl: TdxBarControl): COLORREF;
begin
  Result := GetSysColor(COLOR_CAPTIONTEXT);
end;

class function TdxBarPainter.BarMarkArrowColor(ABarControl: TdxBarControl;
  AState: TdxBarMarkState): COLORREF;
begin
  Result := GetSysColor(COLOR_CAPTIONTEXT);
end;

procedure TdxBarPainter.BarDrawGrip(ABarControl: TdxBarControl; DC: HDC; R: TRect; AToolbarBrush: HBRUSH);
begin
  if IsNativeBackground and ABarControl.BarManager.FThemeAvailable then
    TdxBarXPPainter.BarDrawNativeGrip(ABarControl, DC, R, AToolbarBrush)
  else
    InternalDrawBarSizeGrip(DC, R, ABarControl.UseRightToLeftAlignment);
end;

procedure TdxBarPainter.BarDrawMarkArrow(ABarControl: TdxBarControl; DC: HDC; MarkR: TRect);
var
  AColor: COLORREF;
  ASize: TSize;
  P: array[1..3] of TPoint;
begin
  ASize := ABarControl.ScaleFactor.Apply(cxSize(MarkSizeArrowX, MarkSizeArrowY));
  P[1] := cxRectCenter(MarkR, ASize).TopLeft;
  if Odd(P[1].Y) then Inc(P[1].Y);
  P[2] := Point(P[1].X + ASize.cx - 1, P[1].Y);
  P[3] := Point(P[1].X + ASize.cx div 2, P[1].Y + ASize.cy - 1);
  AColor := BarMarkArrowColor(ABarControl, ABarControl.MarkDrawState);
  PolygonByColor(DC, P, AColor, AColor);
end;

class procedure TdxBarPainter.BarDrawMarkAtPos(ABarControl: TdxBarControl;
  DC: HDC; const ItemRect: TRect; Offset: Integer);
var
  APen: HPEN;
  X, Y: Integer;
begin
  APen := SelectObject(DC, CreatePen(PS_SOLID, 1, GetSysColor(COLOR_BTNTEXT)));
  if ABarControl.Horizontal then
  begin
    X := Offset;
    Y := 4 - Byte(BarIsBarSmall(ABarControl, ItemRect));
    MoveToEx(DC, X, Y, nil);
    LineTo(DC, X + 2, Y + 2);
    LineTo(DC, X - 1, Y + 5);
    MoveToEx(DC, X + 1, Y, nil);
    LineTo(DC, X + 3, Y + 2);
    LineTo(DC, X, Y + 5);
  end
  else
  begin
    X := ABarControl.ClientWidth - 8;
    MoveToEx(DC, X, Offset, nil);
    LineTo(DC, X + 2, Offset + 2);
    LineTo(DC, X + 5, Offset - 1);
    MoveToEx(DC, X, Offset + 1, nil);
    LineTo(DC, X + 2, Offset + 3);
    LineTo(DC, X + 5, Offset);
  end;
  ReverseGDIObject(DC, APen);
end;

procedure TdxBarPainter.BarDrawMarkBackground(ABarControl: TdxBarControl;
  DC: HDC; ItemRect: TRect; AToolbarBrush: HBRUSH);
begin
  // Required
end;

procedure TdxBarPainter.BarDrawMarkElements(ABarControl: TdxBarControl; DC: HDC; ItemRect: TRect);

  function Scale(V: Integer): Integer;
  begin
    Result := ABarControl.ScaleFactor.Apply(V);
  end;

  procedure DrawArrow(X, Y: Integer; Vertical: Boolean);
  var
    AColor: COLORREF;
    P: array[1..3] of TPoint;
  begin
    if Vertical then
    begin
      P[1] := Point(X, Y);
      P[2] := Point(X, Y + Scale(4));
      P[3] := Point(X - Scale(2), Y + Scale(2));
    end
    else
    begin
      P[1] := Point(X, Y);
      P[2] := Point(X + Scale(4), Y);
      P[3] := Point(X + Scale(2), Y + Scale(2));
    end;
    AColor := GetSysColor(GetDrawMarkElementColor(ABarControl));
    PolygonByColor(DC, P, AColor, AColor);
  end;

begin
  if ABarControl.Horizontal then
    ItemRect := cxRectCenterHorizontally(ItemRect, Scale(11))
  else
    ItemRect := cxRectCenterVertically(ItemRect, Scale(11));

  if BarAllowQuickCustomizing then
    if ABarControl.Horizontal then
      DrawArrow(ItemRect.Left + Scale(3), ItemRect.Bottom - Scale(7) + Scale(Byte(BarIsBarSmall(ABarControl, ItemRect))), False)
    else
      DrawArrow(ItemRect.Left + Scale(5), ItemRect.Top + Scale(3), True);

  if ABarControl.FTruncated then
    if ABarControl.Horizontal then
    begin
      BarDrawMarkAtPos(ABarControl, DC, ItemRect, ItemRect.Left + Scale(2));
      BarDrawMarkAtPos(ABarControl, DC, ItemRect, ItemRect.Left + Scale(6));
    end
    else
    begin
      BarDrawMarkAtPos(ABarControl, DC, ItemRect, ItemRect.Top + Scale(2));
      BarDrawMarkAtPos(ABarControl, DC, ItemRect, ItemRect.Top + Scale(6));
    end;
end;

class procedure TdxBarPainter.BarOffsetFloatingBarCaption(ABarControl: TdxBarControl; var X: Integer; var R: TRect);
begin
  if ABarControl.UseRightToLeftAlignment then
    X := ABarControl.MarkNCRect.Left - ABarControl.ScaleFactor.Apply(3 * FloatToolbarMarkIndent)
  else
    X := ABarControl.MarkNCRect.Right + ABarControl.ScaleFactor.Apply(3 * FloatToolbarMarkIndent);
end;

class function TdxBarPainter.GetDrawMarkElementColor(ABarControl: TdxBarControl): Integer;
begin
  Result := COLOR_BTNTEXT;
end;

procedure TdxBarPainter.ButtonLikeControlDrawCaption(
  const ADrawParams: TdxBarButtonLikeControlDrawParams;
  const ATextBounds: TRect; ATextAlignment, AFormat: DWORD);
begin
  with ADrawParams do
    DrawItemText(BarItemControl, Canvas.Handle, Caption, ATextBounds,
      ATextAlignment, Enabled, IsTextSelected, PaintType = ptVert, False, IsFlatText, AFormat);
end;

class function TdxBarPainter.GetControlTextIndents: TRect;
begin
  Result := Rect(4, 0, 0, 0);
end;

class function TdxBarPainter.GetControlCaptionRect(const ADrawParams: TdxBarItemControlDrawParams): TRect;
begin
  if cxRectIsEmpty(ADrawParams.FCaptionRect) then
    ADrawParams.FCaptionRect := GetControlCaptionRectCore(ADrawParams);
  Result := ADrawParams.FCaptionRect;
end;

class function TdxBarPainter.GetControlCaptionRectCore(const ADrawParams: TdxBarItemControlDrawParams): TRect;
begin
  Result := cxGetTextRect(ADrawParams.Canvas.Handle, ADrawParams.Caption, 1);
end;

class function TdxBarPainter.GetGlyphLayout(const ADrawParams: TdxBarButtonLikeControlDrawParams): TdxBarGlyphLayout;
begin
  if (ADrawParams.ViewSize = cvsLarge) and (ADrawParams.BarItemControl.Item is TdxBarButtonLikeItem) then
    Result := TdxBarButtonLikeItem(ADrawParams.BarItemControl.Item).GlyphLayout
  else
    Result := glLeft;
end;

procedure TdxBarPainter.InflateSizeForArrow(const ADrawParams: TdxBarButtonLikeControlDrawParams; var ASize: Integer);
begin
  if ADrawParams.SplitDropDown then
  begin
    if (ADrawParams.PaintType <> ptMenu) and ADrawParams.IsDropDown then
      Inc(ASize, GetControlTextIndents.Right + ADrawParams.ArrowSize.cx);
  end
  else
    if not ADrawParams.IsMenuItem then
      Inc(ASize, ADrawParams.BarItemControl.Parent.TextSize div 2);
end;

function TdxBarPainter.GetDotSpaceAfter(ADotWidth: Integer): Integer;
begin
  Result := ADotWidth;
end;

function TdxBarPainter.GetCustomColorButtonBounds(const ADrawParams: TdxBarColorComboControlDrawParams; ARect: TRect): TRect;

  function IsCustomButtonTooLarge(AButtonWidth: Integer): Boolean;
  begin
    Result := AButtonWidth >= (cxRectWidth(ADrawParams.BarEditControl.GetEditRect) div 2);
  end;

begin
  Result := ARect;
  Result.Left := Result.Right -
    GetCustomColorButtonWidth(ADrawParams.PaintType, ARect) -
    cxMarginsWidth(GetCustomColorButtonIndents(ADrawParams.PaintType));
  if IsCustomButtonTooLarge(cxRectWidth(Result)) or not ADrawParams.IsShowCustomColorButton then
    Result.Left := Result.Right
  else
    Result := cxRectContent(Result, GetCustomColorButtonIndents(ADrawParams.PaintType));
end;

function TdxBarPainter.GetCustomColorButtonWidth(APaintType: TdxBarPaintType; const ARect: TRect): Integer;
begin
  Result := (cxRectHeight(ARect) - 2 - 2) div 7 * 7 + 2 + 2 - GetCustomColorButtonIndents(APaintType).Left - GetCustomColorButtonIndents(APaintType).Right;
end;

procedure TdxBarPainter.DrawDot(const ADrawParams: TdxBarEditLikeControlDrawParams; ARect: TRect);
begin
  if ADrawParams.Enabled then
    if IsHighContrastWhite and ADrawParams.DrawSelected then
      FillRect(ADrawParams.Canvas.Handle, ARect, COLOR_BTNFACE + 1)
    else
      FillRect(ADrawParams.Canvas.Handle, ARect, COLOR_BTNTEXT + 1)
  else
    DrawDisabledShadowRect(ADrawParams.BarItemControl, ADrawParams.Canvas.Handle, ARect);
end;

procedure TdxBarPainter.DrawDots(const ADrawParams: TdxBarEditLikeControlDrawParams; ARect: TRect);

  procedure CalculateFirstDotBounds(ADotWidth: Integer; var ARect: TRect);
  var
    ALeftIndent, ASpaceAfter: Integer;
  begin
    ALeftIndent := (cxRectWidth(ARect) - ADotWidth * 5) div 2;
    ARect.Right := ARect.Left + ADotWidth;
    ARect.Top := ARect.Bottom - ADotWidth;
    ASpaceAfter := GetDotSpaceAfter(ADotWidth);
    OffsetRect(ARect, ALeftIndent, - ASpaceAfter);
  end;

const
  DotsCount = 3;
var
  ADotWidth, I: Integer;
begin
  with ADrawParams do
  begin
    ADotWidth := (ARect.Right - ARect.Left) div 7;
    CalculateFirstDotBounds(ADotWidth, ARect);
    OffsetEllipsisBounds(IsPressed, ARect);
    for I := 0 to DotsCount - 1 do
    begin
      DrawDot(ADrawParams, ARect);
      OffsetRect(ARect, ADotWidth * 2, 0);
    end;
  end;
end;

procedure TdxBarPainter.DropDownGalleryDrawBackground(DC: HDC; const R: TRect);
begin
  FillRectByColor(DC, R, GetLookAndFeelPainter.DefaultInactiveColor);
end;

procedure TdxBarPainter.DropDownGalleryDrawBorder(ABarSubMenuControl: TdxBarSubMenuControl; DC: HDC; const R: TRect);
begin
  cxPaintCanvas.BeginPaint(DC);
  try
    GetLookAndFeelPainter.DrawBorder(cxPaintCanvas, R);
  finally
    cxPaintCanvas.EndPaint;
  end;
end;

procedure TdxBarPainter.DropDownGalleryDrawBottomSizeGrip(DC: HDC; const R: TRect);
begin
  BarDrawSizeGrip(DC, DropDownGalleryGetSizeGripRect(R, coBottomRight));
end;

procedure TdxBarPainter.DropDownGalleryDrawBottomSizeGripEx(ABarSubMenuControl: TdxBarSubMenuControl; DC: HDC; const R: TRect);
const
  SizeGripCorner: array [Boolean] of TdxCorner = (coBottomRight, coBottomLeft);
begin
  InternalDrawBarSizeGrip(DC, DropDownGalleryGetSizeGripRect(R, SizeGripCorner[ABarSubMenuControl.UseRightToLeftAlignment]),
    ABarSubMenuControl.UseRightToLeftAlignment);
end;

procedure TdxBarPainter.DropDownGalleryDrawBottomSizingBand(DC: HDC; const R: TRect);
begin
  FillRectByColor(DC, R, GetLookAndFeelPainter.DefaultHeaderColor);
end;

procedure TdxBarPainter.DropDownGalleryDrawBottomVerticalSizeGrip(DC: HDC; const R: TRect);
begin
  DropDownGalleryDrawVerticalSizeGrip(DC, Rect(R.Left, R.Top + 1, R.Right, R.Bottom));
end;

procedure TdxBarPainter.DropDownGalleryDrawFilterBand(DC: HDC; const R: TRect);
begin
  FillRectByColor(DC, R, GetLookAndFeelPainter.DefaultHeaderBackgroundColor);
end;

procedure TdxBarPainter.DropDownGalleryDrawGroupHeaderBackground(DC: HDC; const R: TRect);
begin
  cxPaintCanvas.BeginPaint(DC);
  try
    GetLookAndFeelPainter.DrawScaledHeader(cxPaintCanvas, R, R, [nBottom], [bBottom],
      cxbsNormal, taLeftJustify, vaCenter, False, False, '', cxPaintCanvas.Font,
      clBlack, clBtnFace, dxDefaultScaleFactor);
  finally
    cxPaintCanvas.EndPaint;
  end;
end;

procedure TdxBarPainter.DropDownGalleryDrawTopSizeGrip(DC: HDC; const R: TRect);
begin
  BarDrawSizeGrip(DC, DropDownGalleryGetSizeGripRect(R, coTopRight));
end;

procedure TdxBarPainter.DropDownGalleryDrawTopSizeGripEx(ABarSubMenuControl: TdxBarSubMenuControl; DC: HDC; const R: TRect);
const
  SizeGripCorner: array [Boolean] of TdxCorner = (coTopRight, coTopLeft);
begin
  InternalDrawBarSizeGrip(DC, DropDownGalleryGetSizeGripRect(R, SizeGripCorner[ABarSubMenuControl.UseRightToLeftAlignment]),
    ABarSubMenuControl.UseRightToLeftAlignment);
end;

procedure TdxBarPainter.DropDownGalleryDrawTopSizingBand(DC: HDC; const R: TRect);
begin
  FillRectByColor(DC, R, GetLookAndFeelPainter.DefaultHeaderColor);
end;

procedure TdxBarPainter.DropDownGalleryDrawTopVerticalSizeGrip(DC: HDC;
  const R: TRect);
begin
  DropDownGalleryDrawVerticalSizeGrip(DC, Rect(R.Left, R.Top, R.Right, R.Bottom - 1));
end;

procedure TdxBarPainter.DropDownGalleryDrawVerticalSizeGrip(DC: HDC; const R: TRect);
var
  ARect: TRect;
begin
  ARect := Rect(0, R.Top, 0, R.Bottom);
  ARect.Right := DropDownGalleryVerticalSizeGripBitmapSize.cx *
    cxRectHeight(ARect) div DropDownGalleryVerticalSizeGripBitmapSize.cy;
  OffsetRect(ARect, (cxRectWidth(R) - cxRectWidth(ARect)) div 2, 0);
  BarDrawSizeGrip(DC, ARect);
end;

function TdxBarPainter.DropDownGalleryGetSizeGripRect(const ABandRect: TRect; ACorner: TdxCorner): TRect;
var
  AOffsets: TRect;
begin
  if ACorner in [coTopLeft, coTopRight] then
    AOffsets := cxRect(0, -1, -2, -3)
  else
    AOffsets := cxRect(0, -3, -2, -1);
  Result := cxRectInflate(ABandRect, AOffsets);
  Result.Left := Result.Right - cxRectHeight(Result);
  if ACorner in [coTopLeft, coBottomLeft] then
    Result := TdxRightToLeftLayoutConverter.ConvertRect(Result, ABandRect);
end;

function TdxBarPainter.DropDownGalleryGetClientBorderSize: Integer;
begin
  Result := 1;
end;

function TdxBarPainter.DropDownGalleryGetContentOffsets(APart: Integer): TRect;
begin
  Result := cxNullRect;
end;

function TdxBarPainter.DropDownGalleryGetFilterBandSeparatorColor: TColor;
begin
  Result := GetLookAndFeelPainter.DefaultHeaderColor;
end;

function TdxBarPainter.DropDownGalleryGetFilterBandTextColor(AState: Integer): TColor;
begin
  if AState = DXBAR_HOT then
    Result := GetLookAndFeelPainter.DefaultSelectionTextColor
  else
    Result := GetLookAndFeelPainter.DefaultHeaderTextColor;
end;

function TdxBarPainter.DropDownGalleryGetGroupHeaderTextColor: TColor;
begin
  Result := GetLookAndFeelPainter.DefaultHeaderTextColor;
end;

function TdxBarPainter.DropDownGalleryGetName: string;
begin
  Result := '';
end;

function TdxBarPainter.DropDownGalleryGetNCBorderSize: Integer;
begin
  Result := 1;
end;

function TdxBarPainter.DropDownGalleryGetScrollBarWidth(AControlHeight: Integer; const AControlMargins: TRect): Integer;
begin
  Result := (AControlHeight - cxMarginsHeight(AControlMargins)) div 4;
  dxAdjustToTouchableSize(Result);
end;

function TdxBarPainter.DropDownGalleryGetSizingBandHeight(
  AIconSize, ATextSize: Integer; AScaleFactor: TdxScaleFactor): Integer;
begin
  Result := GetButtonHeight(AIconSize, ATextSize, AScaleFactor);
end;

procedure TdxBarPainter.DropDownGalleryDrawItem(DC: HDC; const R: TRect; AState: Integer; AScaleFactor: TdxScaleFactor);

  function RibbonStateToItemState(AState: Integer): TcxButtonState;
  begin
    case AState of
      DXBAR_PRESSED, DXBAR_CHECKED:
        Result := cxbsPressed;
      DXBAR_HOTCHECK, DXBAR_ACTIVE:
        Result := cxbsHot;
      else
        Result := cxbsNormal;
    end;
  end;

begin
  cxPaintCanvas.BeginPaint(DC);
  try
    GetLookAndFeelPainter.DrawScaledButton(cxPaintCanvas, R, '', RibbonStateToItemState(AState), AScaleFactor);
  finally
    cxPaintCanvas.EndPaint;
  end;
end;

procedure TdxBarPainter.DropDownGalleryDrawScrollBarBackgroundEx(ABarSubItemControl: TdxBarSubItemControl; DC: HDC;
  const R: TRect; AScaleFactor: TdxScaleFactor);
begin
  cxPaintCanvas.BeginPaint(DC);
  try
    if ABarSubItemControl <> nil then
      cxPaintCanvas.UseRightToLeftAlignment := ABarSubItemControl.UseRightToLeftAlignment;
    GetLookAndFeelPainter.DrawScaledScrollBarBackground(cxPaintCanvas, R, False, AScaleFactor);
  finally
    cxPaintCanvas.EndPaint;
  end;
end;

procedure TdxBarPainter.DropDownGalleryDrawScrollBarBackground(DC: HDC; const R: TRect; AScaleFactor: TdxScaleFactor);
begin
  DropDownGalleryDrawScrollBarBackgroundEx(nil, DC, R, AScaleFactor);
end;

procedure TdxBarPainter.DropDownGalleryDrawScrollBarPart(DC: HDC; const R:
  TRect; APart: TcxScrollBarPart; AState: TcxButtonState; AScaleFactor: TdxScaleFactor);
begin
  DropDownGalleryDrawScrollBarPartEx(nil, DC, R, APart, AState, AScaleFactor);
end;

procedure TdxBarPainter.DropDownGalleryDrawScrollBarPartEx(ABarSubItemControl: TdxBarSubItemControl; DC: HDC; const R: TRect;
  APart: TcxScrollBarPart; AState: TcxButtonState; AScaleFactor: TdxScaleFactor);
begin
  cxPaintCanvas.BeginPaint(DC);
  try
    if ABarSubItemControl <> nil then
      cxPaintCanvas.UseRightToLeftAlignment := ABarSubItemControl.UseRightToLeftAlignment;
    GetLookAndFeelPainter.DrawScaledScrollBarPart(cxPaintCanvas, False, R, APart, AState, AScaleFactor);
  finally
    cxPaintCanvas.EndPaint;
  end;
end;

procedure TdxBarPainter.DropDownGalleryDrawSelectionFrame(ACanvas: TcxCanvas; const R: TRect; AState: Integer);
begin
  ACanvas.FrameRect(R, GetLookAndFeelPainter.DefaultHeaderColor, 2);
end;

procedure TdxBarPainter.DropDownGalleryItemGetTextColors(ABarItemControl: TdxBarItemControl;
  AEnabled, ASelected, AFlat: Boolean; var AColor1, AColor2: TColor);
begin
  GetDefaultTextColors(ABarItemControl, AEnabled, ASelected, AFlat, AColor1, AColor2);
end;

class procedure TdxBarPainter.ComboControlDrawArrow(const ADrawParams: TdxBarEditLikeControlDrawParams;
  const ARect: TRect; ASize: Integer; AColor: TColor);
begin
  if not IsFlatItemText and not ADrawParams.Enabled then
    AColor := clDefault;
  dxBar.DrawLargeItemArrow(ADrawParams.Canvas.Handle, ARect, adDown, ASize, False, ADrawParams.Enabled, IsFlatItemText, AColor);
end;

procedure TdxBarPainter.SubMenuControlFillScrollArrow(ACanvas: TcxCanvas; ARect: TRect; AColor: TColor);
begin
  FillRectByColor(ACanvas.Handle, ARect, AColor);
end;

procedure TdxBarPainter.SubMenuControlDrawScrollArrow(ABarSubMenuControl: TdxBarSubMenuControl;
  ACanvas: TcxCanvas; const AArrowRect: TRect; AColor: COLORREF; AArrowDirection: TcxArrowDirection);
var
  P: TcxArrowPoints;
begin
  CalculateArrowPoints(AArrowRect, SubMenuControlGetScrollArrowSize(ABarSubMenuControl.TextSize), AArrowDirection, P);
  ACanvas.SaveClipRegion;
  try
    SetArrowRegion(ACanvas, AArrowDirection, P, roSet);
    SubMenuControlFillScrollArrow(ACanvas, GetArrowRectByPoints(P, AArrowDirection), AColor);
  finally
    ACanvas.RestoreClipRegion;
  end;
  SetArrowRegion(ACanvas, AArrowDirection, P, roSubtract);
end;

procedure TdxBarPainter.SubMenuControlDrawScrollBand(ABarSubMenuControl: TdxBarSubMenuControl; ACanvas: TcxCanvas; AArrowDirection: TcxArrowDirection);
var
  ARect: TRect;
begin
  ARect := SubMenuControlGetScrollBandBounds(ABarSubMenuControl, AArrowDirection);
  SubMenuControlDrawScrollArrow(ABarSubMenuControl, ACanvas, ARect, GetSysColor(COLOR_BTNTEXT), AArrowDirection);
  SubMenuControlDrawScrollButton(ABarSubMenuControl, ACanvas, AArrowDirection);
  SubMenuControlDrawNonRecentGroupSeparator(ABarSubMenuControl, ACanvas, AArrowDirection);
  if SubMenuControlUseScrollButtons then
    DrawBackground(ABarSubMenuControl.TopItemControl, ACanvas.Handle, ARect, ABarSubMenuControl.ToolbarItemsBrush, False)
  else
    SubMenuControlDrawScrollBandBackground(ABarSubMenuControl, ACanvas, AArrowDirection);
end;

procedure TdxBarPainter.SubMenuControlDrawScrollBandBackground(ABarSubMenuControl: TdxBarSubMenuControl; ACanvas: TcxCanvas; AArrowDirection: TcxArrowDirection);
var
  AControl: TdxBarItemControl;
begin
  case AArrowDirection of
    adUp:
      AControl := ABarSubMenuControl.TopItemControl;
  else {adDown}
    AControl := ABarSubMenuControl.BottomItemControl;
  end;
  DrawBackground(AControl, ACanvas.Handle, ABarSubMenuControl.GetItemRectEx(AControl, True),
    ABarSubMenuControl.ToolbarItemsBrush, False);
end;

procedure TdxBarPainter.SubMenuControlDrawNonRecentGroupSeparator(ABarSubMenuControl: TdxBarSubMenuControl; ACanvas: TcxCanvas; AArrowDirection: TcxArrowDirection);
const
  BrushColors: array[Boolean] of COLORREF = (COLOR_BTNHIGHLIGHT, COLOR_BTNSHADOW);
var
  R: TRect;
begin
  with ABarSubMenuControl do
    if (AArrowDirection = adDown) and BottomItemControl.FChangeRecentGroup then
    begin
      R := GetItemRectEx(BottomItemControl, True);
      R := Rect(R.Left - 1, R.Top, R.Right + 1, R.Top + 1);
      DrawBackground(BottomItemControl, ACanvas.Handle, R,
        BrushColors[BottomItemControl.FNonRecent] + 1, False);
      ACanvas.SetClipRegion(TcxRegion.Create(R), roSubtract);
    end
end;

function TdxBarPainter.SubMenuControlGetScrollBandBounds(ABarSubMenuControl: TdxBarSubMenuControl; AArrowDirection: TcxArrowDirection): TRect;
var
  AScrollAreaSize: Integer;
begin
  AScrollAreaSize := SubMenuControlGetScrollBandSize(ABarSubMenuControl);
  Result := ABarSubMenuControl.FItemsRect;
  if AArrowDirection = adUp then
    Result.Bottom := Result.Top + AScrollAreaSize
  else
    Result.Top := Result.Bottom - AScrollAreaSize;
end;

function TdxBarPainter.SubMenuControlGetScrollBandSize(ABarSubMenuControl: TdxBarSubMenuControl): Integer;
begin
  Result := ABarSubMenuControl.TextSize;
end;

class function TdxBarPainter.SubMenuControlGetScrollArrowSize(ATextSize: Integer): Integer;
begin
  Result := ATextSize div 3 - 1
end;

procedure TdxBarPainter.SubMenuControlDrawMarkContent(ABarSubMenuControl: TdxBarSubMenuControl;
  DC: HDC; R: TRect; ASelected: Boolean);
var
  APen: HPEN;
  ASize, X, Y, I: Integer;

  procedure DrawOneMark(const Y: Integer);
  begin
    MoveToEx(DC, X, Y, nil);
    LineTo(DC, X + ASize div 2, Y + ASize div 2);
    LineTo(DC, X + ASize + 1, Y - 1);
  end;

var
  AColor: COLORREF;
begin
  ASize := ABarSubMenuControl.MarkArrowSize;
  if IsHighContrastWhite and IsFlatItemText and ASelected then
    AColor := GetSysColor(COLOR_BTNFACE)
  else
    AColor := GetSysColor(COLOR_BTNTEXT);
  APen := SelectObject(DC, CreatePen(PS_SOLID, 1, AColor));
  X := (R.Left + R.Right - (ASize + 1)) div 2;
  Y := R.Top + (ABarSubMenuControl.MarkSize - 2 * ASize) div 2;
  for I := Y to Y + ASize - 1 do
    DrawOneMark(I + Byte(I >= Y + ASize div 2) * ASize div 2);
  ReverseGDIObject(DC, APen);
end;

procedure TdxBarPainter.SubMenuControlDrawMarkBand(
  ABarSubMenuControl: TdxBarSubMenuControl; const AMarkRect: TRect; ASelected: Boolean);

  procedure DrawMarkBackground(ABarSubMenuControl: TdxBarSubMenuControl; ADC: HDC; const AMarkRect: TRect);
  begin
    ABarSubMenuControl.FillBackground(ADC, AMarkRect, ABarSubMenuControl.ToolbarItemsBrush, clNone, True);
    if ASelected then
      SubMenuControlDrawMarkSelection(ABarSubMenuControl, ADC, AMarkRect);
  end;

var
  ABitmap: TcxBitmap;
begin
  ABitmap := TcxBitmap.CreateSize(AMarkRect);
  try
    ABitmap.cxCanvas.WindowOrg := AMarkRect.TopLeft;
    DrawMarkBackground(ABarSubMenuControl, ABitmap.Canvas.Handle, AMarkRect);
    SubMenuControlDrawMarkContent(ABarSubMenuControl, ABitmap.Canvas.Handle, AMarkRect, ASelected);
    ABarSubMenuControl.Canvas.CopyRect(AMarkRect, ABitmap.Canvas, AMarkRect);
  finally
    FreeAndNil(ABitmap);
  end;
  ABarSubMenuControl.Canvas.SetClipRegion(TcxRegion.Create(AMarkRect), roSubtract);
end;

procedure TdxBarPainter.SubMenuControlDrawMarkSelection(
  ABarSubMenuControl: TdxBarSubMenuControl; ADC: HDC; const AMarkRect: TRect);
var
  R: TRect;
begin
  R := AMarkRect;
  DrawEdge(ADC, R, BDR_RAISEDINNER, BF_RECT);
  ABarSubMenuControl.PreparePalette(ADC);
  DrawBackground(ABarSubMenuControl.BottomItemControl, ADC, cxRectInflate(R, -1, -1),
    ABarSubMenuControl.FLightBrush, False);
  ABarSubMenuControl.UnpreparePalette(ADC);
end;

class function TdxBarPainter.SubMenuControlUseScrollButtons: Boolean;
begin
  Result := True;
end;

function TdxBarPainter.SubMenuControlUseSingleMenuWindowMode: Boolean;
begin
  Result := False;
end;

class procedure TdxBarPainter.EditOffsetInteriorRect(ABarEditControl: TdxBarCustomEditControl; var R: TRect);
var
  AOffsets: TRect;
  AHeightCorrection: Integer;
begin
  GetEditTextParams(AOffsets, AHeightCorrection);
  R := cxRectContent(R, AOffsets);
end;

procedure TdxBarPainter.DrawSpinEditArrow(const ADrawParams: TdxBarSpinEditDrawParams; AArrowPos: TPoint; AButtonIndex: Integer);
begin
  with ADrawParams do
  begin
    if Enabled then
      SpinEditControlDrawArrowByPoints(ADrawParams, AArrowPos, COLOR_BTNTEXT, AButtonIndex)
    else
    begin
      SpinEditControlDrawArrowByPoints(ADrawParams, Point(AArrowPos.X + 1, AArrowPos.Y + 1), COLOR_BTNHIGHLIGHT, AButtonIndex);
      SpinEditControlDrawArrowByPoints(ADrawParams, AArrowPos, COLOR_BTNSHADOW, AButtonIndex);
    end;
  end;
end;

class procedure TdxBarPainter.SpinEditControlDrawArrowByPoints(const ADrawParams: TdxBarSpinEditDrawParams;
  AStartPoint: TPoint; AColorIndex: Integer; AButtonIndex: Integer);
var
  P: array[1..3] of TPoint;
  AColor: COLORREF;
begin
  P[1] := Point(AStartPoint.X, AStartPoint.Y);
  P[2] := Point(AStartPoint.X + ADrawParams.ArrowSize.cx - 1, AStartPoint.Y);
  if AButtonIndex = secButtonUp then
    P[3] := Point(AStartPoint.X + ADrawParams.ArrowSize.cx div 2,
      AStartPoint.Y - ADrawParams.ArrowSize.cx div 2)
  else
    P[3] := Point(AStartPoint.X + ADrawParams.ArrowSize.cx div 2,
      AStartPoint.Y + ADrawParams.ArrowSize.cx div 2);

  AColor := GetSysColor(AColorIndex);
  PolygonByColor(ADrawParams.Canvas.Handle, P, AColor, AColor);
end;

class function TdxBarPainter.GetSysPanelBorderColor: TColor;
begin
  Result := clWindowFrame;
end;

function TdxBarPainter.GetLookAndFeelPainter: TcxCustomLookAndFeelPainter;
begin
  Result := cxLookAndFeelPaintersManager.GetPainter(lfsStandard);
end;

class procedure TdxBarPainter.DateNavigatorDrawButtonCaption(DC: HDC; const R: TRect;
  AOffset: Integer; const ACaption: string; AOpaque: Boolean);
var
  AFlags: Integer;
  ASize: TSize;
  APrevBkMode: Integer;
begin
  cxGetTextExtentPoint32(DC, ACaption, ASize);
  SetTextColor(DC, GetSysColor(COLOR_BTNTEXT));
  SetBkColor(DC, GetSysColor(COLOR_BTNFACE));
  AFlags := ETO_CLIPPED;
  APrevBkMode := GetBkMode(DC);
  if AOpaque then
    AFlags := AFlags or ETO_OPAQUE
  else
    SetBkMode(DC, TRANSPARENT);
  cxExtTextOut(DC, ACaption, cxPointOffset(cxRectCenter(R, ASize).TopLeft, AOffset, AOffset), R, AFlags);
  SetBkMode(DC, APrevBkMode);
end;

procedure TdxBarPainter.InternalCalculateComboParts(
  const ADrawParams: TdxBarEditLikeControlDrawParams; var AParts: array of TRect);
begin
  AParts[ccpDropButton].Left := AParts[ccpDropButton].Right - ADrawParams.BarItemControl.Parent.ComboBoxArrowWidth;
  AParts[ecpEdit].Right := AParts[ccpDropButton].Left - ComboControlArrowOffset;
end;

procedure TdxBarPainter.InternalDrawBarSizeGrip(DC: HDC; const R: TRect; AIsRightToLeftLayout: Boolean);
var
  ARect: TRect;
begin
  ARect := R;
  cxRightToLeftDependentDraw(DC, ARect, AIsRightToLeftLayout,
    procedure
    begin
      BarDrawSizeGrip(DC, ARect);
    end);
end;

{ TdxBarStandardPainter }

class procedure TdxBarStandardPainter.DrawDisabledShadowRect(ABarItemControl: TdxBarItemControl;
  DC: HDC; R: TRect);
begin
  OffsetRect(R, 1, 1);
  FillRect(DC, R, COLOR_BTNHIGHLIGHT + 1);
  OffsetRect(R, -1, -1);
  inherited DrawDisabledShadowRect(ABarItemControl, DC, R);
end;

procedure TdxBarStandardPainter.DrawItemBackgroundInSubMenu(const ADrawParams: TdxBarButtonLikeControlDrawParams; R: TRect);
var
  ADC: HDC;
  AIconRect: TRect;
  AOpaque: Boolean;
  Brush: HBRUSH;
begin
  with ADrawParams do
  begin
    AIconRect := SubMenuControlGetItemIconRealRect(R, BarItemControl.Parent.IconAreaSize, UseRightToLeftAlignment);
    ADC := Canvas.Handle;

    if DrawSelected and not HasIcon and not Downed then
      Brush := BarItemControl.Parent.ToolbarSelBrush
    else
      Brush := BarItemControl.BkBrush;

    AOpaque := DrawSelected or BarItemControl.FNonRecent;

    if UseRightToLeftAlignment then
    begin
      R.Right := AIconRect.Left - 1;
      DrawBackground(BarItemControl, ADC, Rect(R.Right, AIconRect.Top, AIconRect.Left, AIconRect.Bottom), Brush, AOpaque);
      if AIconRect.Top > R.Top then
        DrawBackground(BarItemControl, ADC, Rect(R.Right, R.Top, AIconRect.Right, AIconRect.Top), Brush, AOpaque);
      if AIconRect.Bottom < R.Bottom then
        DrawBackground(BarItemControl, ADC, Rect(R.Right, AIconRect.Bottom, AIconRect.Right, R.Bottom), Brush, AOpaque);
    end
    else
    begin
      R.Left := AIconRect.Right + 1;
      DrawBackground(BarItemControl, ADC, Rect(AIconRect.Right, AIconRect.Top, R.Left, AIconRect.Bottom), Brush, AOpaque);
      if AIconRect.Top > R.Top then
        DrawBackground(BarItemControl, ADC, Rect(AIconRect.Left, R.Top, R.Left, AIconRect.Top), Brush, AOpaque);
      if AIconRect.Bottom < R.Bottom then
        DrawBackground(BarItemControl, ADC, Rect(AIconRect.Left, AIconRect.Bottom, R.Left, R.Bottom), Brush, AOpaque);
    end;
    if DrawSelected then
      Brush := BarItemControl.Parent.ToolbarSelBrush
    else
      Brush := BarItemControl.BkBrush;
    DrawBackground(BarItemControl, ADC, R, Brush, AOpaque);
  end;
end;

class procedure TdxBarStandardPainter.FrameAndFillRect(ABarItemControl: TdxBarItemControl;
  DC: HDC; var R: TRect; Enabled, Selected, Pressed: Boolean);
const
  Borders: array[Boolean] of Integer = (BDR_RAISEDINNER, BDR_SUNKENOUTER);
var
  Brush: HBRUSH;
begin
  Brush := ABarItemControl.Parent.BkBrush;
  if Selected then
    DrawEdge(DC, R, Borders[Pressed], BF_RECT)
  else
    FrameRect(DC, R, ABarItemControl.Parent.BkBrush);
  InflateRect(R, -1, -1);
  FillRect(DC, R, Brush);
end;

class function TdxBarStandardPainter.GlyphBkgndBrush(ABarItemControl: TdxBarItemControl;
  APaintType: TdxBarPaintType; AGlyphEmpty, ASelected, ADowned, ADrawDowned, ADroppedDown,
  AForceUseBkBrush, AGrayScale: Boolean): HBRUSH;
begin
  if ADowned and ABarItemControl.Enabled then
    if ASelected then
      Result := ABarItemControl.Parent.ToolbarDownedSelBrush
    else
      Result := ABarItemControl.Parent.ToolbarDownedBrush
  else
    if ASelected and (APaintType = ptMenu) and AGlyphEmpty and not ADowned then
      Result := ABarItemControl.Parent.ToolbarSelBrush
    else
      Result := ABarItemControl.BkBrush;
end;

class function TdxBarStandardPainter.GlyphDownShift(ABarItemControl: TdxBarItemControl): Integer;
begin
  Result := 1;
end;

class function TdxBarStandardPainter.GlyphDrawDownedShift(ABarItemControl: TdxBarItemControl;
  ADown: Boolean): Integer;
begin
  Result := 1;
end;

class function TdxBarStandardPainter.LoweredBorderSize(ABarItemControl: TdxBarItemControl): Integer;
begin
  Result := 1;
end;

function TdxBarStandardPainter.BeforeFingersSize: Integer;
begin
  Result := 2;
end;

function TdxBarStandardPainter.FingersSize(ABarControl: TdxBarControl): Integer;
begin
  Result := BeforeFingersSize + 2 * GripperSize(ABarControl) + 1;
end;

class procedure TdxBarStandardPainter.GetEditTextVerticalOffsets(out ATop, ABottom: Integer);
begin
  ATop := 0;
  ABottom := 2;
end;

class function TdxBarStandardPainter.BarAllowHotTrack: Boolean;
begin
  Result := False;
end;

class function TdxBarStandardPainter.BarAllowQuickCustomizing: Boolean;
begin
  Result := False;
end;

procedure TdxBarStandardPainter.BarDrawCloseButton(ABarControl: TdxBarControl; DC: HDC; R: TRect);
const
  Pushes: array[Boolean] of Integer = (0, DFCS_PUSHED);
begin
  FrameRectByColor(DC, R, ABarControl.CaptionBkColor);
  R := cxRectInflate(R, ABarControl.ScaleFactor.Apply(-1));
  DrawFrameControl(DC, R, DFC_CAPTION, DFCS_CAPTIONCLOSE or Pushes[ABarControl.CloseButtonState = msPressed]);
end;

procedure TdxBarStandardPainter.BarDrawDockedBarBorder(ABarControl: TdxBarControl;
  DC: HDC; R: TRect; AToolbarBrush: HBRUSH);

  procedure DrawFinger;
  begin
    DrawEdge(DC, R, BDR_RAISEDINNER, BF_RECT);
    if ABarControl.Horizontal then
      SetPixel(DC, R.Left, R.Bottom - 1, GetSysColor(COLOR_BTNHIGHLIGHT))
    else
      SetPixel(DC, R.Right - 1, R.Top, GetSysColor(COLOR_BTNHIGHLIGHT));
    InflateRect(R, -1, -1);
    FillRect(DC, R, GetSysColorBrush(COLOR_BTNFACE));
    InflateRect(R, 1, 1);
    ExcludeClipRect(DC, R.Left, R.Top, R.Right, R.Bottom);
  end;

var
  AGripperSize: Integer;
begin
  DrawEdge(DC, R, BDR_RAISEDINNER, BF_RECT);
  InflateRect(R, -2, -2);
  if ABarControl.CanMoving then
  begin
    AGripperSize := GripperSize(ABarControl);
    if ABarControl.Horizontal then
    begin
      if ABarControl.UseRightToLeftAlignment then
      begin
        Dec(R.Right, BeforeFingersSize);
        R.Left := R.Right - AGripperSize;
      end
      else
      begin
        Inc(R.Left, BeforeFingersSize);
        R.Right := R.Left + AGripperSize;
      end;
    end
    else
    begin
      Inc(R.Top, BeforeFingersSize);
      R.Bottom := R.Top + AGripperSize;
    end;
    DrawFinger;
    if ABarControl.Horizontal then
    begin
      if ABarControl.UseRightToLeftAlignment then
        AGripperSize := - AGripperSize;
      OffsetRect(R, AGripperSize, 0)
    end
    else
      OffsetRect(R, 0, AGripperSize);
    DrawFinger;
  end;
end;

procedure TdxBarStandardPainter.BarDrawFloatingBarBorder(ABarControl: TdxBarControl;
  DC: HDC; R, CR: TRect; AToolbarBrush: HBRUSH);
begin
  DrawEdge(DC, R, EDGE_RAISED, BF_RECT);
  InflateRect(R, -2, -2);
  FrameRect(DC, R, GetSysColorBrush(COLOR_BTNFACE));
  InflateRect(R, -1, -1);
  FrameRect(DC, R, GetSysColorBrush(COLOR_BTNFACE));
end;

procedure TdxBarStandardPainter.BarDrawMDIButton(ABarControl: TdxBarControl;
  AButton: TdxBarMDIButton; AState: Integer; DC: HDC; R: TRect);
const
  Borders: array[Boolean] of Integer = (BDR_RAISEDINNER, BDR_SUNKENOUTER);
var
  AFlat, ClipRgnExists: Boolean;
  Rgn1, Rgn2: HRGN;
  AFlags: Integer;
begin
  AFlat :=
    (AButton = mdibClose) and ABarControl.BarManager.FlatCloseButton and
    ABarControl.MDIButtonsOnBar and not ABarControl.RealMDIButtonsOnBar;
  Rgn1 := 0;
  ClipRgnExists := False;
  if AFlat then
  begin
    Rgn1 := CreateRectRgn(0, 0, 0, 0);
    ClipRgnExists := GetClipRgn(DC, Rgn1) = 1;
    InflateRect(R, -1, -1);
    Rgn2 := CreateRectRgnIndirect(R);
    SelectClipRgn(DC, Rgn2);
    DeleteObject(Rgn2);
    InflateRect(R, 1, 1);
  end;

  AFlags := 0;
  if AState = DXBAR_DISABLED then
    AFlags := AFlags or DFCS_INACTIVE
  else
    if AState = DXBAR_PRESSED then
      AFlags := AFlags or DFCS_PUSHED;
  DrawFrameControl(DC, R, DFC_CAPTION,
    MDIButtonStyles[AButton] or AFlags or Byte(AFlat) * DFCS_FLAT);

  if AFlat then
  begin
    if ClipRgnExists then
      SelectClipRgn(DC, Rgn1)
    else
      SelectClipRgn(DC, 0);
    DeleteObject(Rgn1);
    DrawEdge(DC, R, Borders[AState = DXBAR_PRESSED], BF_RECT);
  end;
end;

class function TdxBarStandardPainter.BarHorSize: Integer;
begin
  Result := dxBarHorSize;
end;

function TdxBarStandardPainter.BarMarkItemRect(ABarControl: TdxBarControl): TRect;
var
  R: TRect;
begin
  if ABarControl.DockingStyle = dsNone then
  begin
    R := ABarControl.GetCaptionRect;
    Result := R;
    Result.Right := Result.Left + 3 + 7 + 3;
    if ABarControl.UseRightToLeftAlignment then
      Result := TdxRightToLeftLayoutConverter.ConvertRect(Result, R);
  end
  else
    Result := inherited BarMarkItemRect(ABarControl);
end;

class function TdxBarStandardPainter.BarTopSize: Integer;
begin
  Result := dxBarTopSize;
end;

class function TdxBarStandardPainter.BarBottomSize: Integer;
begin
  Result := dxBarBottomSize;
end;

class function TdxBarStandardPainter.BarUseSystemClose: Boolean;
begin
  Result := True;
end;

class function TdxBarStandardPainter.BarUseSystemNCBorder: Boolean;
begin
  Result := True;
end;

class function TdxBarStandardPainter.SubMenuBeginGroupIndent: Integer;
begin
  Result := 2;
end;

procedure TdxBarStandardPainter.DrawButtonControlArrowBackground(const ADrawParams: TdxBarButtonLikeControlDrawParams;
  var R1: TRect; ABrush: HBRUSH);
const
  Borders: array[Boolean] of Integer = (BDR_RAISEDINNER, BDR_SUNKENOUTER);
var
  R: TRect;
begin
  inherited;
  with ADrawParams do
    if DrawSelected then
      DrawEdge(Canvas.Handle, R1, Borders[DroppedDown], BF_RECT)
    else
      if PaintType = ptMenu then
      begin
        if UseRightToLeftAlignment then
          R := cxRectSetWidth(R1, R1.Right + 1, 2)
        else
          R := cxRectSetWidth(R1, R1.Left - 1, 2);
        DrawEdge(Canvas.Handle, R, EDGE_ETCHED, BF_LEFT or BF_RIGHT);
      end;
end;

class procedure TdxBarStandardPainter.ComboControlDrawSimpleButton(const ADrawParams: TdxBarEditLikeControlDrawParams; var ARect: TRect; ABrush: HBRUSH);
const
  Borders: array[Boolean] of Integer = (BDR_RAISEDINNER, BDR_SUNKENOUTER);
var
  ASpaceBrush: HBRUSH;
begin
  with ADrawParams do
  begin
    if DrawSelected and Enabled then
    begin
      DrawEdge(Canvas.Handle, ARect, Borders[DroppedDown], BF_RECT);
      ASpaceBrush := BarEditControl.Parent.BkBrush;
    end
    else
    begin
      if Enabled then
        ASpaceBrush := BarEditControl.EditBkBrush
      else
        ASpaceBrush := BarEditControl.Parent.BkBrush;
      FrameRect(Canvas.Handle, ARect, ASpaceBrush);
    end;
    if UseRightToLeftAlignment then
      FillRect(Canvas.Handle, Rect(ARect.Right, ARect.Top, ARect.Right + 1, ARect.Bottom), ASpaceBrush)
    else
      FillRect(Canvas.Handle, Rect(ARect.Left - 1, ARect.Top, ARect.Left, ARect.Bottom), ASpaceBrush);
    InflateRect(ARect, -1, -1);
    FillRect(Canvas.Handle, ARect, ABrush);
    if DroppedDown then
      OffsetRect(ARect, 1, 1);
  end;
end;

procedure TdxBarStandardPainter.DropDownListBoxDrawBorder(DC: HDC; AColor: TColor; ARect: TRect);
begin
  DrawEdge(DC, ARect, EDGE_RAISED, BF_RECT);
end;

class procedure TdxBarStandardPainter.SubMenuControlDrawItemFrame(ABarSubMenuControl: TdxBarSubMenuControl;
  AControl: TdxBarItemControl; DC: HDC; AItemRect: TRect; AIndex: Integer);

  procedure DrawChangeRecentGroupLine(ALeftDelta: Integer);
  const
    ABrushColors: array[Boolean] of COLORREF = (COLOR_BTNHIGHLIGHT, COLOR_BTNSHADOW);
  var
    R: TRect;
    ASeparatorIndex: Integer;
  begin
    R := AItemRect;
    if not AControl.FNonRecent and ABarSubMenuControl.ViewInfo.IsAssociatedWithSeparator(AControl, ASeparatorIndex) then
      R.Top := ABarSubMenuControl.ViewInfo.SeparatorInfos[ASeparatorIndex].Bounds.Top;
    with R do
    begin
      Bottom := Top;
      Dec(Top);
      Dec(Left, ALeftDelta);
      Inc(Right);
    end;
    FillRect(DC, R, GetSysColor(ABrushColors[AControl.FNonRecent]));
  end;

var
  ALeftDelta: Integer;
begin
  ALeftDelta := Ord(ABarSubMenuControl.BarSize = 0);
  if AControl.FChangeRecentGroup then
    DrawChangeRecentGroupLine(ALeftDelta);

  if AControl.FNonRecent then
    with AItemRect do
    begin
      if (AIndex = 0) and not ABarSubMenuControl.Detachable then
      begin
        FillRect(DC, Rect(Left - ALeftDelta, Top - 1, Right + 2, Top), ABarSubMenuControl.BkBrush);
        SetPixel(DC, Right + 1, Top - 2, GetSysColor(COLOR_BTNHIGHLIGHT));
      end;
      FillRect(DC, Rect(Left - ALeftDelta, Top, Left, Bottom), ABarSubMenuControl.BkBrush);
      FillRect(DC, Rect(Right, Top, Right + 2, Bottom), ABarSubMenuControl.BkBrush);
      if AIndex = AControl.ItemLink.Owner.VisibleItemCount - 1 then
      begin
        FillRect(DC, Rect(Left - ALeftDelta, Bottom, Right + 2, ABarSubMenuControl.ClientHeight), ABarSubMenuControl.BkBrush);
        if ALeftDelta <> 0 then
          SetPixel(DC, Left - 2, ABarSubMenuControl.ClientHeight - 1, GetSysColor(COLOR_BTNHIGHLIGHT));
      end;
    end;
end;

class function TdxBarStandardPainter.SubMenuControlIsOffsetRecentGroupNeeded: Boolean;
begin
  Result := True;
end;

class function TdxBarStandardPainter.SubMenuControlContentRectOffset(ABarSubMenuControl: TdxBarSubMenuControl): TRect;
begin
  Result := inherited SubMenuControlContentRectOffset(ABarSubMenuControl);
  if ABarSubMenuControl.Detachable then
    Result.Top := 0;
end;

class function TdxBarStandardPainter.SubMenuControlClientBorderSize: Integer;
begin
  Result := 2;
end;

function TdxBarStandardPainter.CanUpdateBarPartly: Boolean;
begin
  Result := True;
end;

function TdxBarStandardPainter.GetBorderSize: Integer;
begin
  Result := 2;
end;

class function TdxBarStandardPainter.GetCaptionOffsets: TRect;
begin
  Result := Rect(2, 1, 2, 1);
end;

procedure TdxBarStandardPainter.DrawGlyphBorder(ABarItemControl: TdxBarItemControl;
  DC: HDC; ABrush: HBRUSH; NeedBorder: Boolean; R: TRect; PaintType: TdxBarPaintType;
  IsGlyphEmpty, Selected, Down, DrawDowned, ADroppedDown, IsSplit: Boolean);
const
  Borders: array[Boolean] of Integer = (BDR_RAISEDINNER, BDR_SUNKENOUTER);
begin
  if Down or (Selected and ((PaintType <> ptMenu) or not IsGlyphEmpty)) then
    DrawEdge(DC, R, Borders[Down or DrawDowned or ADroppedDown and not IsSplit], BF_RECT)
  else
    if NeedBorder then
      DrawBackgroundFrameRect(ABarItemControl, DC, R, ABrush, Selected or Down or
        DrawDowned or ABarItemControl.FNonRecent or ABarItemControl.IsBkColorAssigned);
end;

procedure TdxBarStandardPainter.DrawGlyphCheckMark(ABarItemControl: TdxBarItemControl; DC: HDC; X, Y, DoubleSize: Integer);
const
  Colors: array[Boolean] of TColor = (clBlack, clWhite);
var
  OffsetY, I: Integer;

  procedure DrawOneMark;
  begin
    with ABarItemControl.Canvas do
    begin
      MoveTo(X + DoubleSize * 1, Y + OffsetY + DoubleSize * 2);
      LineTo(X + DoubleSize * 3, Y + OffsetY + DoubleSize * 4);
      LineTo(X + DoubleSize * 8, Y + OffsetY - DoubleSize * 1);
    end;
    Inc(OffsetY);
  end;

begin
  with ABarItemControl.Canvas do
    if ABarItemControl.Enabled then
    begin
      OffsetY := 0;
      Pen.Color := clSilver;
      for I := 1 to DoubleSize do DrawOneMark;
      Pen.Color := Colors[GetSysColor(COLOR_BTNFACE) = 0];
      for I := 1 to 2 * DoubleSize do DrawOneMark;
      Pen.Color := Colors[GetSysColor(COLOR_BTNFACE) <> 0];
      for I := 1 to DoubleSize do DrawOneMark;
      MoveTo(X + DoubleSize - 1, Y + DoubleSize * 3 - (DoubleSize - 1));
      LineTo(X + DoubleSize - 1, Y + DoubleSize * 5 + (DoubleSize - 1));
      MoveTo(X + DoubleSize * 8, Y - DoubleSize * 1 + 2);
      LineTo(X + DoubleSize * 8, Y + DoubleSize * 3);
    end
    else
    begin
      OffsetY := 1;
      Pen.Color := GetSysColor(COLOR_BTNSHADOW);
      for I := 1 to 2 * DoubleSize do DrawOneMark;
      Pen.Color := GetSysColor(COLOR_BTNHIGHLIGHT);
      for I := 0 to DoubleSize - 1 do
      begin
        MoveTo(X + DoubleSize * 4 - (DoubleSize - 1),
          Y + DoubleSize * 6 + (DoubleSize - 1 - I));
        LineTo(X + DoubleSize * 9, Y + DoubleSize * 1 - I);
        MoveTo(X + DoubleSize * 4, Y + DoubleSize * 7 - I);
        LineTo(X + DoubleSize * 9, Y + DoubleSize * 2 - I);
      end;
    end;
end;

class function TdxBarStandardPainter.IgnoreGlyphOpaque: Boolean;
begin
  Result := True;
end;

class function TdxBarStandardPainter.BarIsBarSmall(ABarControl: TdxBarControl;
  const R: TRect): Boolean;
begin
  Result := False;
end;

class procedure TdxBarStandardPainter.BarDrawMarkAtPos(ABarControl: TdxBarControl;
  DC: HDC; const ItemRect: TRect; Offset: Integer);
var
  Pen: HPEN;
  X: Integer;
begin
  if ABarControl.Horizontal then
  begin
    Pen := SelectObject(DC, CreatePen(PS_SOLID, 1, GetSysColor(COLOR_BTNHIGHLIGHT)));
    X := Offset;
    MoveToEx(DC, X - 1, 1, nil);
    LineTo(DC, X + 2, 4);
    MoveToEx(DC, X + 3, 4, nil);
    LineTo(DC, X - 1, 8);
    ReverseGDIObject(DC, Pen);

    Pen := SelectObject(DC, CreatePen(PS_SOLID, 1, GetSysColor(COLOR_BTNSHADOW)));
    MoveToEx(DC, X, 1, nil);
    LineTo(DC, X + 2, 3);
    LineTo(DC, X + 2, 4);
    LineTo(DC, X - 1, 7);
    ReverseGDIObject(DC, Pen);
  end
  else
  begin
    Pen := SelectObject(DC, CreatePen(PS_SOLID, 1, GetSysColor(COLOR_BTNSHADOW)));
    X := ABarControl.ClientWidth - 8;
    MoveToEx(DC, X, Offset, nil);
    LineTo(DC, X + 4, Offset + 4);
    MoveToEx(DC, X + 4, Offset + 1, nil);
    LineTo(DC, X + 6, Offset - 1);
    ReverseGDIObject(DC, Pen);

    Pen := SelectObject(DC, CreatePen(PS_SOLID, 1, GetSysColor(COLOR_BTNHIGHLIGHT)));
    MoveToEx(DC, X + 1, Offset, nil);
    LineTo(DC, X + 3, Offset + 2);
    LineTo(DC, X + 4, Offset + 2);
    LineTo(DC, X + 7, Offset - 1);
    ReverseGDIObject(DC, Pen);
  end;
end;

procedure TdxBarStandardPainter.BarDrawMarkBackground(ABarControl: TdxBarControl;
  DC: HDC; ItemRect: TRect; AToolbarBrush: HBRUSH);
begin
  ABarControl.FillBackground(DC, ItemRect, AToolbarBrush, clNone, True);
end;

function TdxBarStandardPainter.GetLookAndFeelPainter: TcxCustomLookAndFeelPainter;
begin
  Result := cxLookAndFeelPaintersManager.GetPainter(lfsFlat);
end;

{ TdxBarEnhancedPainter }

function TdxBarEnhancedPainter.BeforeFingersSize: Integer;
begin
  Result := 1;
end;

function TdxBarEnhancedPainter.FingersSize(ABarControl: TdxBarControl): Integer;
begin
  Result := BeforeFingersSize + GripperSize(ABarControl) + 2;
end;

class function TdxBarEnhancedPainter.SubMenuBeginGroupIndent: Integer;
begin
  Result := 12;
end;

class function TdxBarEnhancedPainter.BarAllowQuickCustomizing: Boolean;
begin
  Result := True;
end;

procedure TdxBarEnhancedPainter.BarDrawDockedBarBorder(ABarControl: TdxBarControl;
  DC: HDC; R: TRect; AToolbarBrush: HBRUSH);

  procedure DrawFinger;
  begin
    DrawEdge(DC, R, BDR_RAISEDINNER, BF_RECT);
    InflateRect(R, -1, -1);
    FillRect(DC, R, GetSysColorBrush(COLOR_BTNFACE));
    InflateRect(R, 1, 1);
    ExcludeClipRect(DC, R.Left, R.Top, R.Right, R.Bottom);
  end;

var
  R1: TRect;
begin
  R1 := R;
  DrawEdge(DC, R, BDR_RAISEDINNER, BF_RECT);
  InflateRect(R, -2, -2);
  if ABarControl.CanMoving then
  begin
    if ABarControl.Horizontal then
    begin
      Inc(R.Left, BeforeFingersSize);
      R.Right := R.Left + GripperSize(ABarControl);
      if ABarControl.UseRightToLeftAlignment then
        R := TdxRightToLeftLayoutConverter.ConvertRect(R, R1);
      InflateRect(R, 0, -1);
    end
    else
    begin
      Inc(R.Top, BeforeFingersSize);
      R.Bottom := R.Top + GripperSize(ABarControl);
      InflateRect(R, -1, 0);
    end;
    DrawFinger;
  end;
end;

class procedure TdxBarEnhancedPainter.BarDrawMarkAtPos(ABarControl: TdxBarControl;
  DC: HDC; const ItemRect: TRect; Offset: Integer);
begin
  TdxBarPainter.BarDrawMarkAtPos(ABarControl, DC, ItemRect, Offset);
end;

procedure TdxBarEnhancedPainter.BarDrawMarkBackground(ABarControl: TdxBarControl;
  DC: HDC; ItemRect: TRect; AToolbarBrush: HBRUSH);
const
  MarkEdges: array[msSelected..msPressed] of UINT = (BDR_RAISEDINNER, BDR_SUNKENOUTER);
begin
  if ABarControl.MarkDrawState = msNone then
    FrameRect(DC, ItemRect, AToolbarBrush)
  else
    DrawEdge(DC, ItemRect, MarkEdges[ABarControl.MarkDrawState], BF_RECT);
  InflateRect(ItemRect, -1, -1);
  ABarControl.FillBackground(DC, ItemRect, AToolbarBrush, clNone, True);
  InflateRect(ItemRect, 1, 1);
end;

{ TdxBarFlatPainter }

procedure TdxBarFlatPainter.CalculateSpinEditParts(const ADrawParams: TdxBarSpinEditDrawParams;
  var AParts, AAreaParts: array of TRect);
begin
  inherited;
  Inc(AParts[secButtonUp].Bottom);
end;

class function TdxBarFlatPainter.GetControlCaptionOffset(ABarItemControl: TdxBarItemControl): Integer;
begin
  if ABarItemControl.IsMenuItem then
    Result := 8
  else
    Result := inherited GetControlCaptionOffset(ABarItemControl);
end;

procedure TdxBarFlatPainter.DrawItemBackgroundInSubMenu(const ADrawParams: TdxBarButtonLikeControlDrawParams; R: TRect);
var
  AIconRect: TRect;
  AOpaque: Boolean;
  ABrush: HBRUSH;
  ADC: HDC;
  I: Integer;
begin
  with ADrawParams do
  begin
    AIconRect := SubMenuControlGetItemIconRealRect(R, BarItemControl.Parent.IconAreaSize, UseRightToLeftAlignment);
    ADC := Canvas.Handle;

    AOpaque := DrawSelected or BarItemControl.FNonRecent;
    if DrawSelected then
      FrameFlatSelRect(ADC, R)
    else
      if UseRightToLeftAlignment then
      begin
        I := R.Right - 1 - BarItemControl.Parent.IconAreaSize;

        ABrush := BarItemControl.BarManager.FlatToolbarsBrush;
        DrawBackground(BarItemControl, ADC, Rect(I, R.Top, R.Right, R.Top + 1), ABrush, AOpaque);
        DrawBackground(BarItemControl, ADC, Rect(I, R.Bottom - 1, R.Right, R.Bottom), ABrush, AOpaque);
        DrawBackground(BarItemControl, ADC, Rect(R.Right - 1, R.Top + 1, R.Right, R.Bottom - 1), ABrush, AOpaque);

        ABrush := BarItemControl.Parent.BkBrush;
        DrawBackground(BarItemControl, ADC, Rect(R.Left, R.Top, I, R.Top + 1), ABrush, AOpaque);
        DrawBackground(BarItemControl, ADC, Rect(R.Left, R.Bottom - 1, I, R.Bottom), ABrush, AOpaque);
        DrawBackground(BarItemControl, ADC, Rect(R.Left, R.Top + 1, R.Left + 1, R.Bottom - 1), ABrush, AOpaque);
      end
      else
      begin
        I := R.Left + 1 + BarItemControl.Parent.IconAreaSize;

        ABrush := BarItemControl.BarManager.FlatToolbarsBrush;
        DrawBackground(BarItemControl, ADC, Rect(R.Left, R.Top, I, R.Top + 1), ABrush, AOpaque);
        DrawBackground(BarItemControl, ADC, Rect(R.Left, R.Bottom - 1, I, R.Bottom), ABrush, AOpaque);
        DrawBackground(BarItemControl, ADC, Rect(R.Left, R.Top + 1, R.Left + 1, R.Bottom - 1), ABrush, AOpaque);

        ABrush := BarItemControl.Parent.BkBrush;
        DrawBackground(BarItemControl, ADC, Rect(I, R.Top, R.Right, R.Top + 1), ABrush, AOpaque);
        DrawBackground(BarItemControl, ADC, Rect(I, R.Bottom - 1, R.Right, R.Bottom), ABrush, AOpaque);
        DrawBackground(BarItemControl, ADC, Rect(R.Right - 1, R.Top + 1, R.Right, R.Bottom - 1), ABrush, AOpaque);
      end;
    InflateRect(R, -1, -1);

    if DrawSelected then
      ABrush := BarItemControl.Parent.ToolbarSelBrush
    else
      ABrush := BarItemControl.BarManager.FlatToolbarsBrush;

    if UseRightToLeftAlignment then
    begin
      R.Right := AIconRect.Left - 2;
      DrawBackground(BarItemControl, ADC, Rect(R.Right, AIconRect.Top, AIconRect.Left, AIconRect.Bottom), ABrush, AOpaque);
      if AIconRect.Top > R.Top then
        DrawBackground(BarItemControl, ADC, Rect(R.Right, R.Top, AIconRect.Right, AIconRect.Top), ABrush, AOpaque);
      if AIconRect.Bottom < R.Bottom then
        DrawBackground(BarItemControl, ADC, Rect(R.Right, AIconRect.Bottom, AIconRect.Right, R.Bottom), ABrush, AOpaque);
    end
    else
    begin
      R.Left := AIconRect.Right + 2;
      DrawBackground(BarItemControl, ADC, Rect(AIconRect.Right, AIconRect.Top, R.Left, AIconRect.Bottom), ABrush, AOpaque);
      if AIconRect.Top > R.Top then
        DrawBackground(BarItemControl, ADC, Rect(AIconRect.Left, R.Top, R.Left, AIconRect.Top), ABrush, AOpaque);
      if AIconRect.Bottom < R.Bottom then
        DrawBackground(BarItemControl, ADC, Rect(AIconRect.Left, AIconRect.Bottom, R.Left, R.Bottom), ABrush, AOpaque);
    end;

    if DrawSelected then
      ABrush := BarItemControl.Parent.ToolbarSelBrush
    else
      ABrush := BarItemControl.BkBrush;
    DrawBackground(BarItemControl, ADC, R, ABrush, AOpaque);
  end;
end;

class procedure TdxBarFlatPainter.DrawLowered(DC: HDC; var R: TRect);
begin
  FrameRect(DC, R, GetSysColorBrush(COLOR_BTNSHADOW));
  InflateRect(R, -1, -1); // LoweredBorderSize(ABarItemControl) = 1
end;

procedure TdxBarFlatPainter.DrawStaticBorder(const ADrawParams: TdxBarStaticLikeControlDrawParams; var ARect: TRect);
var
  AContentRect: TRect;
begin
  with ADrawParams do
  begin
    AContentRect := cxRectContent(ARect, BorderOffsets);
    Canvas.SaveClipRegion;
    Canvas.ExcludeClipRect(AContentRect);
    FillRect(Canvas.Handle, ARect, StaticBorderBrush(BarItemControl, BorderStyle));
    Canvas.RestoreClipRegion;
    ARect := AContentRect;
  end;
end;

class procedure TdxBarFlatPainter.FrameAndFillRect(ABarItemControl: TdxBarItemControl;
  DC: HDC; var R: TRect; Enabled, Selected, Pressed: Boolean);
var
  Brush: HBRUSH;
begin
  Brush := ABarItemControl.Parent.BkBrush;
  if Selected then
  begin
    FrameFlatSelRect(DC, R);
    if Pressed then
      Brush := ABarItemControl.Parent.ToolbarDownedSelBrush
    else
      Brush := ABarItemControl.Parent.ToolbarSelBrush;
  end
  else
    FrameRect(DC, R, ABarItemControl.Parent.BkBrush);
  InflateRect(R, -1, -1);
  FillRect(DC, R, Brush);
end;

class function TdxBarFlatPainter.GlyphBkgndBrush(ABarItemControl: TdxBarItemControl;
  APaintType: TdxBarPaintType; AGlyphEmpty, ASelected, ADowned, ADrawDowned, ADroppedDown,
  AForceUseBkBrush, AGrayScale: Boolean): HBRUSH;
begin
  if ADroppedDown then
    if ADowned then
      Result := ABarItemControl.Parent.ToolbarDownedSelBrush
    else
      Result := ABarItemControl.Parent.BarControlOwnerBrush
  else
    if ASelected then
      if ADowned or ADrawDowned then
        Result := ABarItemControl.Parent.ToolbarDownedSelBrush
      else
        Result := ABarItemControl.Parent.ToolbarSelBrush
    else
      if ADowned then
        Result := ABarItemControl.Parent.ToolbarDownedBrush
      else
        if (APaintType = ptMenu) and not AForceUseBkBrush then
          Result := GetToolbarBrush(ABarItemControl)
        else
          Result := ABarItemControl.BkBrush;
end;

class function TdxBarFlatPainter.IsFlatGlyphImage: Boolean;
begin
  Result := True;
end;

class function TdxBarFlatPainter.IsFlatItemText: Boolean;
begin
  Result := True;
end;

class function TdxBarFlatPainter.IsGlyphImageBackgroundOpaque(ABarItemControl: TdxBarItemControl;
  ADown, ADrawDowned, ASelected, AGlyphEmpty: Boolean): Boolean;
begin
  Result := inherited IsGlyphImageBackgroundOpaque(ABarItemControl, ADown, ADrawDowned, ASelected, AGlyphEmpty);
  if not AGlyphEmpty then
    Result := Result or ADown or ADrawDowned or ASelected;
end;

class function TdxBarFlatPainter.IsGlyphImageHasShadow: Boolean;
begin
  Result := True;
end;

class function TdxBarFlatPainter.LoweredBorderSize(ABarItemControl: TdxBarItemControl): Integer;
begin
  Result := 1;
end;

class function TdxBarFlatPainter.StaticBorderBrush(ABarItemControl: TdxBarItemControl;
  ABorderStyle: TdxBarStaticBorderStyle): HBRUSH;
begin
  Result := GetSysColorBrush(COLOR_BTNSHADOW);
end;

class function TdxBarFlatPainter.TextAreaOffset(ABarItemControl: TdxBarItemControl): Integer;
begin
  // WARNING!!! sync with Indent
  if ABarItemControl.Parent.Kind = bkSubMenu then
    Result := 1 + ABarItemControl.Parent.TextSize + 2
  else
    Result := 0;
end;

function TdxBarFlatPainter.BeforeFingersSize: Integer;
begin
  Result := 1;
end;

function TdxBarFlatPainter.FingersSize(ABarControl: TdxBarControl): Integer;
begin
  Result := BeforeFingersSize + GripperSize(ABarControl) + 2;
end;

class function TdxBarFlatPainter.RealButtonArrowWidth(ABarManager: TdxBarManager): Integer;
begin
  Result := inherited RealButtonArrowWidth(ABarManager);
  Dec(Result);
end;

class function TdxBarFlatPainter.RealLargeButtonArrowWidth(ABarManager: TdxBarManager): Integer;
begin
  Result := inherited RealLargeButtonArrowWidth(ABarManager) - 1;
end;

class function TdxBarFlatPainter.SubMenuBeginGroupIndent: Integer;
begin
  Result := 8;
end;

class function TdxBarFlatPainter.BarChildrenHaveShadows(ABarControl: TCustomdxBarControl): Boolean;
begin
  Result := True;
end;

class procedure TdxBarFlatPainter.BarDrawBarControlOwner(ACustomBarControl: TCustomdxBarControl;
  DC: HDC; R: TRect; ABarControl: TCustomdxBarControl);
begin
  BarDrawBarControlOwnerBorder(ACustomBarControl, DC, R, nil, ABarControl);
  InflateRect(R, -1, -1);
  FillRect(DC, R, ACustomBarControl.BarControlOwnerBrush);
end;

class procedure TdxBarFlatPainter.BarDrawBarControlOwnerBorder(ACustomBarControl: TCustomdxBarControl;
  DC: HDC; R: TRect; ABarItemControl: TdxBarItemControl; ABarControl: TCustomdxBarControl);
var
  AClipRgn: HRGN;
  AClipRgnExists: Boolean;

  procedure DrawBarControlOwnerLink;
  var
    ALinkR, ATempRect, CR, WR: TRect;
    AOrigin: TPoint;
    AHandle: HWND;
  begin
    AClipRgn := 0;
    if not ABarControl.HandleAllocated then Exit;
    ALinkR := ABarControl.OwnerLinkBounds[True];

    if ABarControl.OwnerControl = nil then // !!!
    begin
      GetDCOrgEx(DC, AOrigin);
      OffsetRect(ALinkR, -AOrigin.X, -AOrigin.Y);
    end
    else
    begin
      AHandle := ABarControl.OwnerControl.Handle;
      GetClientRect(AHandle, CR);
      CR := dxMapWindowRect(AHandle, 0, CR);
      if IntersectRect(ATempRect, CR, ALinkR) then // client area
        OffsetRect(ALinkR, -CR.Left, -CR.Top)
      else
      begin
        WR := cxGetWindowRect(AHandle);               // NC
        OffsetRect(ALinkR, -WR.Left, -WR.Top);
      end;
    end;
    BarDrawBarControlOwnerLink(ACustomBarControl, DC, R, ALinkR, ABarItemControl);
    AClipRgn := CreateRectRgn(0, 0, 0, 0);
    AClipRgnExists := GetClipRgn(DC, AClipRgn) = 1;
    with ALinkR do
      ExcludeClipRect(DC, Left, Top, Right, Bottom);
  end;

begin
  DrawBarControlOwnerLink;
  BarDrawBarControlOwnerFrame(ACustomBarControl, DC, R);
  if AClipRgn <> 0 then
  begin
    if AClipRgnExists then
      SelectClipRgn(DC, AClipRgn)
    else
      SelectClipRgn(DC, 0);
    DeleteObject(AClipRgn);
  end;
end;

class procedure TdxBarFlatPainter.BarDrawBarControlOwnerFrame(ACustomBarControl: TCustomdxBarControl;
  DC: HDC; R: TRect);
begin
  FrameRect(DC, R, ACustomBarControl.BarManager.FlatToolbarsBorderBrush);
end;

class procedure TdxBarFlatPainter.BarDrawBarControlOwnerLink(ACustomBarControl: TCustomdxBarControl;
  DC: HDC; R, ALinkR: TRect; ABarItemControl: TdxBarItemControl);
begin
  FillRect(DC, ALinkR, ACustomBarControl.BarControlOwnerBrush);
end;

class function TdxBarFlatPainter.BarToolbarBrush(ABarControl: TCustomdxBarControl): HBRUSH;
begin
  Result := ABarControl.BarManager.FlatToolbarsBrush;
end;

class function TdxBarFlatPainter.BarToolbarBrushEx(ABarControl: TdxBarControl): HBRUSH;
begin
  if not (ABarControl.IsMainMenu or ABarControl.IsStatusBar) then
    Result := inherited BarToolbarBrushEx(ABarControl)
  else
    Result := GetSysColorBrush(COLOR_BTNFACE);
end;

class function TdxBarFlatPainter.BarToolbarDownedBrush(ABarControl: TCustomdxBarControl): HBRUSH;
begin
  Result := ABarControl.BarManager.FlatToolbarsDownedBrush;
end;

class function TdxBarFlatPainter.BarToolbarDownedSelBrush(ABarControl: TCustomdxBarControl): HBRUSH;
begin
  Result := ABarControl.BarManager.FlatToolbarsDownedSelBrush;
end;

class function TdxBarFlatPainter.BarToolbarSelBrush(ABarControl: TCustomdxBarControl): HBRUSH;
begin
  Result := ABarControl.BarManager.FlatToolbarsSelBrush;
end;

function TdxBarFlatPainter.BarBeginGroupSideSize: Integer;
begin
  Result := (BarBeginGroupSize - 1{|}) div 2;
end;

function TdxBarFlatPainter.BarBeginGroupSize: Integer;
begin
  Result := 2 + 1{|} + 2;
end;

procedure TdxBarFlatPainter.BarDrawBeginGroup(ABarControl: TCustomdxBarControl;
  DC: HDC; ABeginGroupRect: TRect; AToolbarBrush: HBRUSH; AHorz: Boolean);
begin
  with ABeginGroupRect do
    if AHorz then
    begin
      ABarControl.FillBackground(DC,
        Rect(Left, Top, Right, Top + BarBeginGroupSideSize),
        AToolbarBrush, clNone, True);
      ABarControl.FillBackground(DC,
        Rect(Left, Bottom - BarBeginGroupSideSize, Right, Bottom),
        AToolbarBrush, clNone, True);
      InflateRect(ABeginGroupRect, 0, -BarBeginGroupSideSize);
      FillRect(DC, Rect(Left, Top, Right, Top + 1), COLOR_BTNSHADOW + 1);
    end
    else
    begin
      ABarControl.FillBackground(DC,
        Rect(Left, Top, Left + BarBeginGroupSideSize, Bottom),
        AToolbarBrush, clNone, True);
      ABarControl.FillBackground(DC,
        Rect(Right - BarBeginGroupSideSize, Top, Right, Bottom),
        AToolbarBrush, clNone, True);
      InflateRect(ABeginGroupRect, -BarBeginGroupSideSize, 0);
      FillRect(DC, Rect(Left, Top, Left + 1, Bottom), COLOR_BTNSHADOW + 1);
    end;
end;

procedure TdxBarFlatPainter.BarDrawCloseButton(ABarControl: TdxBarControl; DC: HDC; R: TRect);
begin
  BarDrawCaptionElement(ABarControl, DC, R, ABarControl.CloseButtonState);
  cxPaintCanvas.BeginPaint(DC);
  try
    cxLookAndFeelPaintersManager.GetPainter(lfsFlat).DrawScaledButtonCross(
      cxPaintCanvas, R, BarMarkArrowColor(ABarControl, ABarControl.CloseButtonState),
      cxbsNormal, ABarControl.ScaleFactor);
  finally
    cxPaintCanvas.EndPaint;
  end;
end;

procedure TdxBarFlatPainter.BarDrawDockedBarBorder(ABarControl: TdxBarControl;
  DC: HDC; R: TRect; AToolbarBrush: HBRUSH);

  procedure DrawFinger;
  var
    I: Integer;
    Brush: HBRUSH;
  begin
    if ABarControl.Horizontal then
      for I := R.Top to R.Bottom - 1 do
      begin
        if Odd(I - R.Top) then
          Brush := AToolbarBrush
        else
          Brush := COLOR_BTNSHADOW + 1;
        FillRect(DC, Rect(R.Left, I, R.Right, I + 1), Brush);
      end
    else
      for I := R.Left to R.Right - 1 do
      begin
        if Odd(I - R.Left) then
          Brush := AToolbarBrush
        else
          Brush := COLOR_BTNSHADOW + 1;
        FillRect(DC, Rect(I, R.Top, I + 1, R.Bottom), Brush);
      end;
  end;

begin
  FrameRect(DC, R, GetSysColorBrush(COLOR_BTNFACE));
  InflateRect(R, -1, -1);
  FillRect(DC, Rect(R.Left, R.Top, R.Left + 1, R.Top + 1), COLOR_BTNFACE + 1);
  FillRect(DC, Rect(R.Right - 1, R.Top, R.Right, R.Top + 1), COLOR_BTNFACE + 1);
  FillRect(DC, Rect(R.Left, R.Bottom - 1, R.Left + 1, R.Bottom), COLOR_BTNFACE + 1);
  FillRect(DC, Rect(R.Right - 1, R.Bottom - 1, R.Right, R.Bottom), COLOR_BTNFACE + 1);
  InflateRect(R, -1, -1);
  if ABarControl.CanMoving then
  begin
    if ABarControl.Horizontal then
    begin
      if ABarControl.UseRightToLeftAlignment then
      begin
        Dec(R.Right, BeforeFingersSize);
        R.Left := R.Right - GripperSize(ABarControl);
      end
      else
      begin
        Inc(R.Left, BeforeFingersSize);
        R.Right := R.Left + GripperSize(ABarControl);
      end;
      InflateRect(R, 0, -3);
    end
    else
    begin
      Inc(R.Top, BeforeFingersSize);
      R.Bottom := R.Top + GripperSize(ABarControl);
      InflateRect(R, -3, 0);
    end;
    DrawFinger;
  end;
end;

procedure TdxBarFlatPainter.BarDrawFloatingBarBorder(ABarControl: TdxBarControl;
  DC: HDC; R, CR: TRect; AToolbarBrush: HBRUSH);
var
  I: Integer;
begin
  FrameRect(DC, R, ABarControl.BarManager.FlatToolbarsBorderBrush);
  InflateRect(R, -1, -1);
  FrameRect(DC, R, GetSysColorBrush(COLOR_BTNHIGHLIGHT));
  for I := R.Left + 1 to CR.Left - 1 do
  begin
    InflateRect(R, -1, -1);
    FrameRect(DC, R, AToolbarBrush);
  end;
end;

procedure TdxBarFlatPainter.BarDrawMark(ABarControl: TdxBarControl; DC: HDC; MarkR: TRect);

  procedure DrawBackground;
  var
    R: TRect;
  begin
    if ABarControl.HasCloseButton then
    begin
      R := MarkR;
      if ABarControl.UseRightToLeftAlignment then
      begin
        R.Right := R.Left;
        R.Left := R.Right - ABarControl.ScaleFactor.Apply(FloatToolbarMarkIndent);
      end
      else
      begin
        R.Left := R.Right;
        R.Right := R.Left + ABarControl.ScaleFactor.Apply(FloatToolbarMarkIndent);
      end;
      FillRectByColor(DC, R, ABarControl.CaptionBkColor);
    end;
    if ABarControl.MarkDrawState = msPressed then
      BarDrawBarControlOwner(ABarControl, DC, MarkR, ABarControl.FQuickPopup)
    else
      BarDrawCaptionElement(ABarControl, DC, MarkR, ABarControl.MarkDrawState);
  end;

begin
  DrawBackground;
  inherited BarDrawMark(ABarControl, DC, MarkR);
end;

procedure TdxBarFlatPainter.BarDrawMDIButton(ABarControl: TdxBarControl;
  AButton: TdxBarMDIButton; AState: Integer; DC: HDC; R: TRect);
const
  Enables: array[Boolean] of Integer = (DFCS_INACTIVE, 0);
var
  ABitmap: TBitmap;
  ABrush: HBRUSH;
begin
  InflateRect(R, -1, -1);
  ABitmap := cxCreateBitmap(R, cxDoubleBufferedBitmapPixelFormat);
  try
    DrawFrameControl(ABitmap.Canvas.Handle,
      Rect(-1, -1, ABitmap.Width + 1, ABitmap.Height + 1),
      DFC_CAPTION, MDIButtonStyles[AButton] or DFCS_FLAT or
      Enables[AState <> DXBAR_DISABLED]);

    if AState in [DXBAR_ACTIVE, DXBAR_HOT, DXBAR_PRESSED] then
    begin
      case AState of
        DXBAR_ACTIVE:
          ABrush := ABarControl.ToolbarDownedBrush;
        DXBAR_HOT:
          ABrush := ABarControl.ToolbarSelBrush;
      else{DXBAR_PRESSED}
        ABrush := ABarControl.ToolbarDownedSelBrush;
      end;

      FillRect(DC, R, ABrush);
      FrameFlatSelRect(DC, cxRectInflate(R, 1, 1));
    end
    else
      ABarControl.FillBackground(DC, cxRectInflate(R, 1, 1), ABarControl.BkBrush, clNone, True);

    TransparentDraw(DC, R, ABitmap);
  finally
    ABitmap.Free;
  end;
end;

class function TdxBarFlatPainter.BarToolbarBrushEx2(ABarControl: TdxBarControl): HBRUSH;
begin
  Result := GetSysColorBrush(COLOR_WINDOW);
end;

class procedure TdxBarFlatPainter.DrawQuickCustItemFrame(ABarItemControl: TdxBarItemControl;
  DC: HDC; var R, ARect: TRect; Selected: Boolean);
begin
  inherited;
  if not Selected then
    DrawBackgroundFrameRect(ABarItemControl, DC, R, BarToolbarBrush(ABarItemControl.Parent), False);

  InflateRect(R, -1, -1);
end;

class procedure TdxBarFlatPainter.DrawQuickCustItemFrameSelected(ABarItemControl: TdxBarItemControl;
  DC: HDC; WholeR, R: TRect; Selected: Boolean);
begin
  if Selected then
  begin
    FrameFlatSelRect(DC, WholeR);
    if ABarItemControl.UseRightToLeftAlignment then
    begin
      R.Right := R.Left;
      R.Left := R.Right - 2; // paint over!
    end
    else
    begin
      R.Left := R.Right;
      R.Right := R.Left + 2; // paint over!
    end;
    FillRect(DC, R, ABarItemControl.Parent.ToolbarSelBrush);
  end;
end;

class function TdxBarFlatPainter.IsQuickControlPopupOnRight: Boolean;
begin
  Result := True;
end;

function TdxBarFlatPainter.ButtonControlArrowBrush(const ADrawParams: TdxBarItemControlDrawParams): HBRUSH;
begin
  with ADrawParams do
    if DrawSelected then
      if DroppedDown or IsHighContrastWhite then
        Result := BarItemControl.Parent.ToolbarDownedSelBrush
      else
        Result := BarItemControl.Parent.ToolbarSelBrush
    else
      Result := inherited ButtonControlArrowBrush(ADrawParams);
end;

class procedure TdxBarFlatPainter.CorrectButtonControlDefaultHeight(var DefaultHeight: Integer);
begin
  Inc(DefaultHeight, 2);
end;

class procedure TdxBarFlatPainter.CorrectButtonControlDefaultWidth(var DefaultWidth: Integer);
begin
  Inc(DefaultWidth, 2 + 1 + 6);
end;

procedure TdxBarFlatPainter.DrawButtonControlArrowBackground(const ADrawParams: TdxBarButtonLikeControlDrawParams;
  var R1: TRect; ABrush: HBRUSH);
begin
  inherited;
  with ADrawParams do
    if (PaintType = ptMenu) or not DroppedDown then
      DrawFrameRect(BarItemControl, Canvas.Handle, R1, ABrush, PaintType, DrawSelected, Downed);
end;

function TdxBarFlatPainter.ComboControlArrowColor(ADrawParams: TdxBarItemControlDrawParams): TColor;
begin
  Result := inherited ComboControlArrowColor(ADrawParams);
  with ADrawParams do
    if DrawSelected then
    begin
      if DroppedDown or IsHighContrastWhite then
        Result := clHighlightText;
    end
    else
      if not Enabled then
        Result := clBtnShadow;
end;

function TdxBarFlatPainter.ComboControlButtonBrush(const ADrawParams: TdxBarItemControlDrawParams): HBRUSH;
begin
   Result := inherited ComboControlButtonBrush(ADrawParams);
   with ADrawParams do
      if (PaintType = ptMenu) and not DrawSelected then
        Result := BarItemControl.Parent.ToolbarBrush;
end;

class procedure TdxBarFlatPainter.ComboControlDrawSimpleButton(const ADrawParams: TdxBarEditLikeControlDrawParams; var ARect: TRect; ABrush: HBRUSH);
var
  ASpaceBrush: HBRUSH;
begin
  with ADrawParams do
  begin
    if DrawSelected then
    begin
      InflateRect(ARect, 1, 1);
      FrameFlatSelRect(Canvas.Handle, ARect);
    end
    else
    begin
      if Enabled then
        ASpaceBrush := BarEditControl.EditBkBrush
      else
        ASpaceBrush := BarEditControl.Parent.BkBrush;
      FrameRect(Canvas.Handle, ARect, ASpaceBrush);
      FillRect(Canvas.Handle, Rect(ARect.Left - 1, ARect.Top, ARect.Left, ARect.Bottom), ASpaceBrush);
    end;
    InflateRect(ARect, -1, -1);
    FillRect(Canvas.Handle, ARect, ABrush);
  end;
end;

class function TdxBarFlatPainter.SubMenuControlArrowsOffset: Integer;
begin
  Result := 1;
end;

function TdxBarFlatPainter.SubMenuControlBeginGroupRect(
  ABarSubMenuControl: TdxBarSubMenuControl; AControl: TdxBarItemControl;
  const AItemRect: TRect): TRect;
begin
  Result := AItemRect;
  Result.Bottom := Result.Top;
  Dec(Result.Top, SubMenuControlBeginGroupSize);
end;

function TdxBarFlatPainter.SubMenuControlBeginGroupSize: Integer;
begin
  Result := 2 + 1 + 2;
end;

procedure TdxBarFlatPainter.SubMenuControlCalcDrawingConsts(ACanvas: TcxCanvas;
  ATextSize: Integer; AScaleFactor: TdxScaleFactor; out AMenuArrowWidth, AMarkSize: Integer);
var
  AArrowSize: Integer;
begin
  inherited;
  AArrowSize := SubMenuControlMarkArrowSize(AMarkSize - 2);
  if Odd(AArrowSize) then
    AMarkSize := (AArrowSize - 1) * 2 + 2 * 3;
end;

class function TdxBarFlatPainter.SubMenuControlDetachCaptionAreaSize(ABarSubMenuControl: TdxBarSubMenuControl): Integer;
begin
  Result := ABarSubMenuControl.DetachCaptionSize + 1;
end;

class function TdxBarFlatPainter.SubMenuControlGetItemIconRect(const AItemRect: TRect; AIconAreaSize: Integer): TRect;
begin
  Result := inherited SubMenuControlGetItemIconRect(cxRectInflate(AItemRect, -1, -1), AIconAreaSize - 2)
end;

class function TdxBarFlatPainter.SubMenuControlGetItemTextRect(const ADrawParams: TdxBarButtonLikeControlDrawParams; const AItemRect: TRect): TRect;
begin
  Result := inherited SubMenuControlGetItemTextRect(ADrawParams, cxRectInflate(AItemRect, 0, -1, -1, -1));
end;

class function TdxBarFlatPainter.SubMenuControlGetItemTextIndent(const ADrawParams: TdxBarItemControlDrawParams): Integer;
begin
  Result := inherited SubMenuControlGetItemTextIndent(ADrawParams) + 6;
end;

procedure TdxBarFlatPainter.SubMenuControlDrawBorder(ABarSubMenuControl: TdxBarSubMenuControl;
  DC: HDC; R: TRect);

  procedure DrawFlatBorder;
  begin
    FrameRect(DC, R, ABarSubMenuControl.BarManager.FlatToolbarsBorderBrush);
    BarDrawOwnerLink(ABarSubMenuControl, DC);
  end;

begin
  with R do
  begin
    DrawFlatBorder;
    if ABarSubMenuControl.Detachable then
    begin
      InflateRect(R, -1, -1);
      Bottom := Top + 1;
      FillRect(DC, R, COLOR_WINDOW + 1);
      Top := Bottom;
      Bottom := Top + ABarSubMenuControl.DetachCaptionSize;
      FillRect(DC, Rect(Left, Top, Left + 1, Bottom), COLOR_WINDOW + 1);
      FillRect(DC, Rect(Right - 1, Top, Right, Bottom), COLOR_WINDOW + 1);
      SubMenuControlDrawDetachCaption(ABarSubMenuControl, DC, ABarSubMenuControl.DetachCaptionRect);
    end;
  end
end;

procedure TdxBarFlatPainter.SubMenuControlDrawClientBorder(ABarSubMenuControl: TdxBarSubMenuControl;
  DC: HDC; const R: TRect; ABrush: HBRUSH);
begin
  FrameRect(DC, R, ABarSubMenuControl.ToolbarItemsBrush);
  if ABarSubMenuControl.UseRightToLeftAlignment then
    FillRect(DC, Rect(R.Right - 1, R.Top + 1, R.Right, R.Bottom - 1), ABrush)
  else
    FillRect(DC, Rect(R.Left, R.Top + 1, R.Left + 1, R.Bottom - 1), ABrush);
end;

procedure TdxBarFlatPainter.SubMenuControlDrawDetachCaption(ABarSubMenuControl: TdxBarSubMenuControl;
  DC: HDC; R: TRect);
const
  MarkSize = 33;
  Colors: array[Boolean] of COLORREF = (COLOR_BTNSHADOW, COLOR_BTNTEXT);
var
  Brush: HBRUSH;
  I: Integer;
begin
  if ABarSubMenuControl.DetachCaptionSelected then
  begin
    FrameFlatSelRect(DC, R);
    InflateRect(R, -1, -1);
    Brush := ABarSubMenuControl.ToolbarSelBrush;
  end
  else
    Brush := ABarSubMenuControl.BarManager.FlatToolbarsBrush;
  FillRect(DC, R, Brush);
  Brush := Colors[ABarSubMenuControl.DetachCaptionSelected] + 1;
  with R do
  begin
    InflateRect(R, -(Right - Left - MarkSize) div 2, -1);
    Right := Left + MarkSize;
    for I := Top to Bottom - 1 do
      if not Odd(I - Top) then
        FillRect(DC, Rect(Left, I, Right, I + 1), Brush);
  end;
end;

procedure TdxBarFlatPainter.SubMenuControlDrawBeginGroup(ABarSubMenuControl: TdxBarSubMenuControl;
  AControl: TdxBarItemControl; ACanvas: TcxCanvas; const ABeginGroupRect: TRect);
var
  R: TRect;
  ABrush: HBRUSH;
  LD, RD: Integer;
  AOpaque: Boolean;
  ADC: HDC;
begin
  ADC := ACanvas.Handle;
  R := ABeginGroupRect;
  if not IgnoreNonRecentColor and AControl.FChangeRecentGroup and AControl.FNonRecent then
    ABrush := SubMenuControlToolbarItemsBrush(ABarSubMenuControl)
  else
    ABrush := ABarSubMenuControl.BkBrush;
  AOpaque := not IgnoreNonRecentColor and AControl.FNonRecent and not AControl.FChangeRecentGroup;
  if ABarSubMenuControl.UseRightToLeftAlignment then
  begin
    LD := R.Right - AControl.TextAreaOffset;
    DrawBackground(AControl, ADC, Rect(LD, R.Top, R.Right, R.Bottom), ABarSubMenuControl.BarManager.FlatToolbarsBrush, AOpaque);
    DrawBackground(AControl, ADC, Rect(R.Left, R.Top, LD, R.Bottom), ABrush, AOpaque);
  end
  else
  begin
    LD := R.Left + AControl.TextAreaOffset;
    DrawBackground(AControl, ADC, Rect(R.Left, R.Top, LD, R.Bottom), ABarSubMenuControl.BarManager.FlatToolbarsBrush, AOpaque);
    DrawBackground(AControl, ADC, Rect(LD, R.Top, R.Right, R.Bottom), ABrush, AOpaque);
  end;
  RD := (R.Top + R.Bottom) div 2;
  if ABarSubMenuControl.UseRightToLeftAlignment then
    SubMenuControlDrawSeparator(ACanvas, Rect(R.Left - 1, RD, LD - SubMenuBeginGroupIndent, RD + 1))
  else
    SubMenuControlDrawSeparator(ACanvas, Rect(LD + SubMenuBeginGroupIndent, RD, R.Right + 1, RD + 1));
end;

procedure TdxBarFlatPainter.SubMenuControlDrawSeparator(ACanvas: TcxCanvas; const ARect: TRect);
begin
  ACanvas.FrameRect(ARect, SubMenuControlGetSeparatorColor, 1, [bTop]);
end;

class function TdxBarFlatPainter.SubMenuControlGetSeparatorColor: TColor;
begin
  Result := GetSysColor(COLOR_BTNSHADOW);
end;

class function TdxBarFlatPainter.SubMenuControlMarkArrowSize(AMarkSize: Integer): Integer;
begin
  Result := (AMarkSize - 2 * 2) div 2;
  if (Result > 4) and Odd(Result) then
    Dec(Result);
end;

class function TdxBarFlatPainter.SubMenuControlNormalItemHeight(AScaleFactor: TdxScaleFactor): Integer;
begin
  Result := inherited SubMenuControlNormalItemHeight(AScaleFactor) + 1;
end;

class procedure TdxBarFlatPainter.SubMenuControlOffsetDetachCaptionRect(ABarSubMenuControl: TdxBarSubMenuControl; var R: TRect);
begin
  R := cxRectInflate(R, ABarSubMenuControl.ScaleFactor.Apply(-2));
end;

class function TdxBarFlatPainter.SubMenuControlTextSize(ACanvas: TcxCanvas; AScaleFactor: TdxScaleFactor): Integer;
begin
  Result := inherited SubMenuControlTextSize(ACanvas, AScaleFactor) + 1;
end;

class function TdxBarFlatPainter.SubMenuControlToolbarItemsBrush(ABarSubMenuControl: TdxBarSubMenuControl): HBRUSH;
begin
  Result := GetSysColorBrush(COLOR_WINDOW);
end;

class procedure TdxBarFlatPainter.CustomComboDrawItem(ABarCustomCombo: TdxBarCustomCombo;
  ACanvas: TCanvas; AIndex: Integer; ARect: TRect; AState: TOwnerDrawState;
  AInteriorIsDrawing: Boolean);
var
  S: string;
  W: Integer;
begin
  if AIndex = -1 then
    S := ABarCustomCombo.Text
  else
    S := ABarCustomCombo.Items[AIndex];
  ACanvas.FillRect(ARect);
  if (ACanvas is TControlCanvas) and TControlCanvas(ACanvas).Control.UseRightToLeftAlignment then
  begin
    W := ACanvas.TextWidth(S);
    ACanvas.TextOut(ARect.Right - W - 3, ARect.Top + Byte(AInteriorIsDrawing) * 2, S);
  end
  else
    ACanvas.TextOut(ARect.Left + 2, ARect.Top + Byte(AInteriorIsDrawing) * 2, S);
end;

class function TdxBarFlatPainter.EditControlBorderOffsets(APaintType: TdxBarPaintType): TRect;
begin
  Result := Rect(1, 1, 1, 1);
end;

procedure TdxBarFlatPainter.EditControlDrawBorder(
  const ADrawParams: TdxBarEditLikeControlDrawParams; var ARect: TRect);
begin
  with ADrawParams do
  begin
    if DrawSelected then
      FrameFlatSelRect(Canvas.Handle, ARect)
    else
      if (PaintType = ptMenu) and not IsTransparent then
        FrameRect(Canvas.Handle, ARect, BarEditControl.Parent.ToolbarBrush)
      else
        if not Enabled and not IsTransparent then
          FrameRect(Canvas.Handle, ARect, GetSysColorBrush(COLOR_BTNSHADOW))
        else
          DrawBackgroundFrameRect(BarEditControl, Canvas.Handle, ARect, BarEditControl.Parent.BkBrush,
            IsTransparent and BarEditControl.FNonRecent);
    InflateRect(ARect, -1, -1);
  end;
end;

procedure TdxBarFlatPainter.EditControlDrawSelectionFrame(const ADrawParams: TdxBarEditLikeControlDrawParams; const ARect: TRect);
begin
  inherited;
  ExcludeFrameRegion(ADrawParams.Canvas, ARect, cxRectInflate(ARect, -1, -1));
end;

class function TdxBarFlatPainter.EditControlCaptionRightIndentIsOpaque(
  const ADrawParams: TdxBarEditLikeControlDrawParams): Boolean;
begin
  with ADrawParams do
    Result := (PaintType = ptMenu) and (DrawSelected or BarItemControl.FNonRecent);
end;

class function TdxBarFlatPainter.EditControlCaptionSubMenuIndent(const ADrawParams: TdxBarEditLikeControlDrawParams): Integer;
begin
  Result := SubMenuControlGetItemTextIndent(ADrawParams) - ADrawParams.BarItemControl.Parent.GetIconAreaSize;
end;

class function TdxBarFlatPainter.EditControlCaptionSimpleIndent(const ADrawParams: TdxBarEditLikeControlDrawParams): Integer;
begin
  Result := 6;
end;

class function TdxBarFlatPainter.EditControlCaptionComplexIndent(const ADrawParams: TdxBarEditLikeControlDrawParams): Integer;
begin
  Result := 5;
end;

class function TdxBarFlatPainter.EditControlSubMenuGlyphIndents(const ADrawParams: TdxBarEditLikeControlDrawParams): TRect;
begin
  Result := Rect(7, 0, 0, 0);
end;

class function TdxBarFlatPainter.EditControlGetRightCaptionIndentBrush(ABarEditControl: TdxBarCustomEditControl): HBRUSH;
begin
  Result := ABarEditControl.CaptionBkBrush;
end;

class function TdxBarFlatPainter.EditControlGlyphIsDrawSelected(ABarEditControl: TdxBarCustomEditControl): Boolean;
begin
  Result := ABarEditControl.DrawSelected and (ABarEditControl.GetPaintType = ptMenu)
end;

class function TdxBarFlatPainter.HasEditControlExternalFrame(
  APaintType: TdxBarPaintType; ASelected: Boolean): Boolean;
begin
  Result := ASelected and (APaintType = ptMenu);
end;

function TdxBarFlatPainter.CanUpdateBarPartly: Boolean;
begin
  Result := True;
end;

class function TdxBarFlatPainter.IsDateNavigatorFlat: Boolean;
begin
  Result := True;
end;

procedure TdxBarFlatPainter.DateNavigatorDrawButton(ABarItem: TdxBarItem;
  DC: HDC; R: TRect; const ACaption: string; APressed: Boolean; AScaleFactor: TdxScaleFactor);
begin
  with R do
  begin
    FrameRect(DC, R, GetSysColorBrush(COLOR_BTNSHADOW));
    InflateRect(R, -1, -1);
    FrameRect(DC, R, GetSysColorBrush(COLOR_BTNFACE));
    InflateRect(R, -1, -1);
  end;
  DateNavigatorDrawButtonCaption(DC, R, 0, ACaption, True);
end;

procedure TdxBarFlatPainter.SpinEditControlDrawButton(const ADrawParams: TdxBarSpinEditDrawParams; ARect: TRect; AButtonIndex: Integer);
var
  AArrowPos: TPoint;
begin
  with ADrawParams do
  begin
    FrameAndFillRect(BarEditControl, Canvas.Handle, ARect, Enabled, DrawSelected,
      ActiveButtonIndex = AButtonIndex);
    AArrowPos := GetSpinEditArrowPos(ADrawParams, ARect, AButtonIndex);
    DrawSpinEditArrow(ADrawParams, AArrowPos, AButtonIndex);
  end;
end;

class function TdxBarFlatPainter.ContainerControlSubMenuOffset: Integer;
begin
  Result := 2 + 1 + 6;
end;

function TdxBarFlatPainter.InPlaceSubItemControlIsFlatItemText(const ADrawParams: TdxBarInPlaceSubItemControlDrawParams): Boolean;
begin
  Result := inherited InPlaceSubItemControlIsFlatItemText(ADrawParams) and IsFlatItemTextForMenu;
end;

function TdxBarFlatPainter.InPlaceSubItemControlIsArrowSelected(const ADrawParams: TdxBarInPlaceSubItemControlDrawParams): Boolean;
begin
  Result := not ADrawParams.DrawSelected or IsHighContrastWhite;
end;

function TdxBarFlatPainter.GetBorderSize: Integer;
begin
  Result := 1;
end;

procedure TdxBarFlatPainter.DrawGlyphBorder(ABarItemControl: TdxBarItemControl;
  ADC: HDC; ABrush: HBRUSH; ANeedBorder: Boolean; R: TRect; APaintType: TdxBarPaintType;
  AGlyphEmpty, ASelected, ADowned, ADrawDowned, ADroppedDown, AIsSplit: Boolean);
begin
  if ADroppedDown then
    BarDrawBarControlOwnerBorder(ABarItemControl.Parent, ADC, R, ABarItemControl, ABarItemControl.OwnedBarControl)
  else
    if ADowned or (ASelected and (APaintType <> ptMenu)) then
      FrameFlatSelRect(ADC, R)
    else
      if ANeedBorder then
        DrawBackgroundFrameRect(ABarItemControl, ADC, R, ABrush, ASelected or ADowned or
          ADrawDowned or ABarItemControl.FNonRecent or ABarItemControl.IsBkColorAssigned);
end;

procedure TdxBarFlatPainter.DrawGlyphCheckMark(ABarItemControl: TdxBarItemControl; DC: HDC; X, Y, DoubleSize: Integer);
var
  OffsetY, I: Integer;

  procedure DrawOneMark;
  begin
    with ABarItemControl.Canvas do
    begin
      MoveTo(X + DoubleSize * 1, Y + OffsetY + DoubleSize * 2);
      LineTo(X + DoubleSize * 3, Y + OffsetY + DoubleSize * 4);
      LineTo(X + DoubleSize * 8, Y + OffsetY - DoubleSize * 1);
    end;
    Inc(OffsetY);
  end;

begin
  with ABarItemControl.Canvas do
    if ABarItemControl.Enabled then
    begin
      OffsetY := 0;
      if IsHighContrastWhite or IsHighContrast2 then
        Pen.Color := clWhite
      else
        Pen.Color := clBlack;

      for I := 1 to 2 * DoubleSize do
        DrawOneMark;
    end
    else
    begin
      OffsetY := 1;
      Pen.Color := GetSysColor(COLOR_BTNSHADOW);
      for I := 1 to 2 * DoubleSize do
        DrawOneMark;
    end;
end;

class procedure TdxBarFlatPainter.DrawFrameRect(ABarItemControl: TdxBarItemControl;
  ADC: HDC; const ARect: TRect; ABrush: HBRUSH; APaintType: TdxBarPaintType; ASelected, ADowned: Boolean);
begin
  if (APaintType = ptMenu) or ASelected or ADowned then
    if (APaintType = ptMenu) and not ASelected then
      FrameRect(ADC, ARect, GetSysColorBrush(COLOR_BTNSHADOW))
    else
      FrameFlatSelRect(ADC, ARect)
  else
    FrameRect(ADC, ARect, ABarItemControl.Parent.BkBrush);
end;

class procedure TdxBarFlatPainter.FrameFlatSelRect(DC: HDC; const R: TRect);
begin
  if IsHighContrastBlack or IsHighContrast2 then
    FrameRectByColor(DC, R, clHighlightText)
  else
    dxBar.FrameFlatSelRect(DC, R);
end;

class function TdxBarFlatPainter.GetToolbarBrush(ABarItemControl: TdxBarItemControl): HBRUSH;
begin
  Result := ABarItemControl.BarManager.FlatToolbarsBrush;
end;

class function TdxBarFlatPainter.BarCaptionBkColor(ABarControl: TdxBarControl;
  AMainFormActive: Boolean): COLORREF;
begin
  Result := inherited BarCaptionBkColor(ABarControl, False);
end;

class function TdxBarFlatPainter.BarMarkArrowColor(ABarControl: TdxBarControl;
  AState: TdxBarMarkState): COLORREF;
begin
  if AState <> msNone then
    Result := GetSysColor(COLOR_BTNTEXT)
  else
    Result := inherited BarMarkArrowColor(ABarControl, AState);
end;

procedure TdxBarFlatPainter.BarDrawMarkBackground(ABarControl: TdxBarControl;
  DC: HDC; ItemRect: TRect; AToolbarBrush: HBRUSH);
begin
  if ABarControl.MarkDrawState = msPressed then
    BarDrawBarControlOwner(ABarControl, DC, ItemRect, ABarControl.FQuickPopup)
  else
  begin
    if ABarControl.MarkDrawState = msNone then
      FrameRect(DC, ItemRect, AToolbarBrush)
    else
      FrameFlatSelRect(DC, ItemRect);
    InflateRect(ItemRect, -1, -1);
    if ABarControl.MarkDrawState = msSelected then
    begin
      AToolbarBrush := ABarControl.ToolbarSelBrush;
      FillRect(DC, ItemRect, AToolbarBrush);
    end
    else
      ABarControl.FillBackground(DC, ItemRect, AToolbarBrush, clNone, True);
    InflateRect(ItemRect, 1, 1);
  end;
end;

class procedure TdxBarFlatPainter.BarOffsetFloatingBarCaption(ABarControl: TdxBarControl; var X: Integer; var R: TRect);
begin
  if ABarControl.UseRightToLeftAlignment then
  begin
    Dec(X, ABarControl.ScaleFactor.Apply(2));
    R.Left := ABarControl.MarkNCRect.Right;
  end
  else
  begin
    Inc(X, ABarControl.ScaleFactor.Apply(2));
    R.Right := ABarControl.MarkNCRect.Left;
  end;
end;

class function TdxBarFlatPainter.GetDrawMarkElementColor(ABarControl: TdxBarControl): Integer;
begin
  if IsHighContrastWhite and (ABarControl.MarkDrawState = msSelected) then
    Result := COLOR_BTNFACE
  else
    Result := inherited GetDrawMarkElementColor(ABarControl);
end;

procedure TdxBarFlatPainter.SubMenuControlDrawNonRecentGroupSeparator(ABarSubMenuControl: TdxBarSubMenuControl; ACanvas: TcxCanvas; AArrowDirection: TcxArrowDirection);
begin
// do nothing
end;

procedure TdxBarFlatPainter.SubMenuControlDrawMarkSelection(
  ABarSubMenuControl: TdxBarSubMenuControl; ADC: HDC; const AMarkRect: TRect);
begin
  FrameFlatSelRect(ADC, AMarkRect);
  DrawBackground(ABarSubMenuControl.BottomItemControl, ADC, cxRectInflate(AMarkRect, -1, -1), ABarSubMenuControl.ToolbarSelBrush, True);
end;

procedure TdxBarFlatPainter.DrawSpinEditArrow(const ADrawParams: TdxBarSpinEditDrawParams; AArrowPos: TPoint; AButtonIndex: Integer);
var
  AColor: Integer;
begin
  with ADrawParams do
  begin
    if Enabled then
    begin
      if IsHighContrastWhite and DrawSelected then
        AColor := COLOR_BTNFACE
      else
        AColor := COLOR_BTNTEXT;
    end
    else
      AColor := COLOR_BTNSHADOW;

    SpinEditControlDrawArrowByPoints(ADrawParams, AArrowPos, AColor, AButtonIndex);
  end;
end;

class function TdxBarFlatPainter.GetSysPanelBorderColor: TColor;
begin
  Result := clBtnShadow;
end;

function TdxBarFlatPainter.GetLookAndFeelPainter: TcxCustomLookAndFeelPainter;
begin
  Result := cxLookAndFeelPaintersManager.GetPainter(lfsUltraFlat);
end;

{ TdxBarOffice11Painter }

procedure TdxBarOffice11Painter.DrawItemBackgroundInSubMenu(const ADrawParams: TdxBarButtonLikeControlDrawParams; R: TRect);
var
  AIconRect: TRect;
  AOpaque: Boolean;
  ABrush: HBRUSH;
  ADC: HDC;
  I: Integer;
begin
  with ADrawParams do
  begin
    AIconRect := SubMenuControlGetItemIconRealRect(R, BarItemControl.Parent.IconAreaSize, UseRightToLeftAlignment);
    ADC := Canvas.Handle;

    AOpaque := DrawSelected;
    if DrawSelected then
      FrameFlatSelRect(ADC, R)
    else
    begin
      if UseRightToLeftAlignment then
      begin
        I := R.Right - 1 - BarItemControl.Parent.IconAreaSize;

        ABrush := BarItemControl.Parent.BkBrush;
        DrawBackground(BarItemControl, ADC, Rect(I, R.Top, R.Right, R.Top + 1), ABrush, AOpaque);
        DrawBackground(BarItemControl, ADC, Rect(I, R.Bottom - 1, R.Right, R.Bottom), ABrush, AOpaque);
        DrawBackground(BarItemControl, ADC, Rect(R.Right - 1, R.Top + 1, R.Right, R.Bottom - 1), ABrush, AOpaque);

        ABrush := BarItemControl.Parent.BkBrush;
        DrawBackground(BarItemControl, ADC, Rect(R.Left, R.Top, I, R.Top + 1), ABrush, AOpaque);
        DrawBackground(BarItemControl, ADC, Rect(R.Left, R.Bottom - 1, I, R.Bottom), ABrush, AOpaque);
        DrawBackground(BarItemControl, ADC, Rect(R.Left, R.Top + 1, R.Left + 1, R.Bottom - 1), ABrush, AOpaque);
      end
      else
      begin
        I := R.Left + 1 + BarItemControl.Parent.IconAreaSize;

        ABrush := BarItemControl.Parent.BkBrush;
        DrawBackground(BarItemControl, ADC, Rect(R.Left, R.Top, I, R.Top + 1), ABrush, AOpaque);
        DrawBackground(BarItemControl, ADC, Rect(R.Left, R.Bottom - 1, I, R.Bottom), ABrush, AOpaque);
        DrawBackground(BarItemControl, ADC, Rect(R.Left, R.Top + 1, R.Left + 1, R.Bottom - 1), ABrush, AOpaque);

        ABrush := BarItemControl.Parent.BkBrush;
        DrawBackground(BarItemControl, ADC, Rect(I, R.Top, R.Right, R.Top + 1), ABrush, AOpaque);
        DrawBackground(BarItemControl, ADC, Rect(I, R.Bottom - 1, R.Right, R.Bottom), ABrush, AOpaque);
        DrawBackground(BarItemControl, ADC, Rect(R.Right - 1, R.Top + 1, R.Right, R.Bottom - 1), ABrush, AOpaque);
      end;
    end;
    InflateRect(R, -1, -1);

    if DrawSelected then
      ABrush := BarItemControl.Parent.ToolbarSelBrush
    else
      ABrush := BarItemControl.Parent.BkBrush;

    if UseRightToLeftAlignment then
    begin
      R.Right := AIconRect.Left - 2;
      DrawBackground(BarItemControl, ADC, Rect(R.Right, AIconRect.Top, AIconRect.Left, AIconRect.Bottom), ABrush, AOpaque);
      if AIconRect.Top > R.Top then
        DrawBackground(BarItemControl, ADC, Rect(R.Right, R.Top, AIconRect.Right, AIconRect.Top), ABrush, AOpaque);
      if AIconRect.Bottom < R.Bottom then
        DrawBackground(BarItemControl, ADC, Rect(R.Right, AIconRect.Bottom, AIconRect.Right, R.Bottom), ABrush, AOpaque);
    end
    else
    begin
      R.Left := AIconRect.Right + 2;
      DrawBackground(BarItemControl, ADC, Rect(AIconRect.Right, AIconRect.Top, R.Left, AIconRect.Bottom), ABrush, AOpaque);
      if AIconRect.Top > R.Top then
        DrawBackground(BarItemControl, ADC, Rect(AIconRect.Left, R.Top, R.Left, AIconRect.Top), ABrush, AOpaque);
      if AIconRect.Bottom < R.Bottom then
        DrawBackground(BarItemControl, ADC, Rect(AIconRect.Left, AIconRect.Bottom, R.Left, R.Bottom), ABrush, AOpaque);
    end;
    if DrawSelected then
      ABrush := BarItemControl.Parent.ToolbarSelBrush
    else
      ABrush := BarItemControl.Parent.BkBrush;
    DrawBackground(BarItemControl, ADC, R, ABrush, AOpaque);
  end;
end;

class procedure TdxBarOffice11Painter.FrameAndFillRect(ABarItemControl: TdxBarItemControl;
  DC: HDC; var R: TRect; Enabled, Selected, Pressed: Boolean);
var
  Brush: HBRUSH;
begin
  if Selected then
  begin
    FrameFlatSelRect(DC, R);
    if Pressed then
      Brush := ABarItemControl.Parent.ToolbarDownedSelBrush
    else
      Brush := ABarItemControl.Parent.ToolbarSelBrush;
  end
  else
  begin
    if Enabled then
    begin
      FrameRect(DC, R, ABarItemControl.Parent.BkBrush);
      Brush := dxOffice11OwnerControlDownedBrush;
    end
    else
    begin
      FrameRectByColor(DC, R, dxOffice11TextDisabledColor);
      Brush := GetSysColorBrush(COLOR_BTNFACE);
    end;
  end;
  InflateRect(R, -1, -1);
  FillRect(DC, R, Brush);
end;

class function TdxBarOffice11Painter.IsFlatGlyphImage: Boolean;
begin
  Result := False;
end;

class function TdxBarOffice11Painter.IsGlyphImageHasShadow: Boolean;
begin
  Result := False;
end;

class function TdxBarOffice11Painter.IsItemTextSelectedInverted: Boolean;
begin
  if IsXPStandardScheme then
    Result := False
  else
    Result := inherited IsItemTextSelectedInverted;
end;

class function TdxBarOffice11Painter.StaticBorderBrush(ABarItemControl: TdxBarItemControl;
  ABorderStyle: TdxBarStaticBorderStyle): HBRUSH;
begin
  Result := dxOffice11StaticBorderBrush;
end;

function TdxBarOffice11Painter.BeforeFingersSize: Integer;
begin
  Result := inherited BeforeFingersSize + BarBeforeFingersIndent;
end;

class function TdxBarOffice11Painter.BorderSizeX(AScaleFactor: TdxScaleFactor): Integer;
begin
  Result := AScaleFactor.Apply(3);
end;

class function TdxBarOffice11Painter.BorderSizeY(AScaleFactor: TdxScaleFactor): Integer;
begin
  Result := AScaleFactor.Apply(3);
end;

class function TdxBarOffice11Painter.EmptyFingersSize: Integer;
begin
  Result := 2;
end;

procedure TdxBarOffice11Painter.DockControlFillBackground(ADockControl: TdxDockControl;
  DC: HDC; ADestR, ASourceR, AWholeR: TRect; ABrush: HBRUSH; AColor: TColor);

  procedure FillBackgroundTempBitmap(ABitmap: TBitmap);
  var
    AColor1, AColor2: TColor;
  begin
    with AWholeR do
    begin
      ABitmap.Width := Right - Left;
      ABitmap.Height := Bottom - Top;
    end;
    GetDockColors(ADockControl, AColor1, AColor2);
    FillGradientRect(ABitmap.Canvas.Handle, AWholeR, AColor1, AColor2, True);
  end;

begin
  if ADockControl.BackgroundTempBitmap.Empty then
    FillBackgroundTempBitmap(ADockControl.BackgroundTempBitmap);
  cxBitBlt(DC, ADockControl.BackgroundTempBitmap.Canvas.Handle, ADestR, ASourceR.TopLeft, SRCCOPY);
end;

class function TdxBarOffice11Painter.IsNativeBackground: Boolean;
begin
  Result := True;
end;

class function TdxBarOffice11Painter.BarControlOwnerBrush(ABarManager: TdxBarManager): HBRUSH;
begin
  Result := dxOffice11OwnerControlDownedBrush;
end;

class procedure TdxBarOffice11Painter.BarDrawBarControlOwnerFrame(ACustomBarControl: TCustomdxBarControl;
  DC: HDC; R: TRect);
begin
  FrameRect(DC, R, dxOffice11DropDownBorderBrush1);
end;

class procedure TdxBarOffice11Painter.BarDrawBarControlOwnerLink(ACustomBarControl: TCustomdxBarControl;
  DC: HDC; R, ALinkR: TRect; ABarItemControl: TdxBarItemControl);
var
  AColor: TColor;
begin
  if (ABarItemControl = nil) or not IsMenuGradient(ABarItemControl) then
    inherited
  else
  begin
    if (ALinkR.Right - ALinkR.Left) > (ALinkR.Bottom - ALinkR.Top) then // Horz
    begin
      if ALinkR.Top > ((R.Bottom + R.Top) div 2) then // bottom
        AColor := dxOffice11MenuDownedColor2
      else
        AColor := dxOffice11MenuDownedColor1;
    end
    else
    begin
      if ALinkR.Left > ((R.Right + R.Left) div 2) then // right
        AColor := dxOffice11MenuDownedColor2
      else
        AColor := dxOffice11MenuDownedColor1;
    end;
    FillRectByColor(DC, ALinkR, AColor);
  end;
end;

procedure TdxBarOffice11Painter.BarDrawDockedBackground(ABarControl: TdxBarControl;
  DC: HDC; ADestR, ASourceR: TRect; ABrush: HBRUSH; AColor: TColor);
var
  AWholeR: TRect;
  AClipRgn: HRGN;
  AClipRgnExists: Boolean;
begin
  if (ABarControl.Bar.BorderStyle = bbsNone) or
      (ABarControl.IsMainMenu or ABarControl.IsBackgroundBitmap) then
    inherited
  else
  begin
    SaveClipRgn(DC, AClipRgn, AClipRgnExists);
    with ADestR do
      IntersectClipRect(DC, Left, Top, Right, Bottom);

    AWholeR := GetBarGradientRect(ABarControl);
    OffsetRect(AWholeR, -(ASourceR.Left - ADestR.Left), -(ASourceR.Top - ADestR.Top)); // NC offset

    Office11FillTubeGradientRect(DC, AWholeR, dxOffice11ToolbarsColor1, dxOffice11ToolbarsColor2,
      (ABarControl is TdxBarControl) and TdxBarControl(ABarControl).Vertical);
    RestoreClipRgn(DC, AClipRgn, AClipRgnExists);
  end;
end;

procedure TdxBarOffice11Painter.BarDrawFloatingBackground(
  ABarControl: TCustomdxBarControl; DC: HDC; ADestR, ASourceR: TRect; ABrush: HBRUSH; AColor: TColor);
var
  AClipRgn: HRGN;
  AClipRgnExists: Boolean;
begin
  if ABarControl.IsInternal or ABarControl.IsBackgroundBitmap then
    inherited
  else
  begin
    SaveClipRgn(DC, AClipRgn, AClipRgnExists);
    try
      IntersectClipRect(DC, ADestR.Left, ADestR.Top, ADestR.Right, ADestR.Bottom);
      FillGradientRect(DC, cxRectUnion(ADestR, ABarControl.ClientRect),
        dxOffice11ToolbarsColor1, dxOffice11ToolbarsColor2, False);
    finally
      RestoreClipRgn(DC, AClipRgn, AClipRgnExists);
    end;
  end;
end;

class procedure TdxBarOffice11Painter.BarDrawOwnerLink(ABarControl: TCustomdxBarControl;
  DC: HDC);
var
  R: TRect;
begin
  R := ABarControl.OwnerLinkBounds[False];
  if not IsRectEmpty(R) then
    FillRect(DC, R, dxOffice11DropDownBorderBrush2);
end;

function TdxBarOffice11Painter.BarHasShadow(ABarControl: TCustomdxBarControl): Boolean;
begin
  Result := ABarControl.IsPopup;
end;

class function TdxBarOffice11Painter.BarToolbarBrush(ABarControl: TCustomdxBarControl): HBRUSH;
begin
  // TODO: ?
  Result := dxOffice11MenuBrush;
end;

class function TdxBarOffice11Painter.BarToolbarBrushEx(ABarControl: TdxBarControl): HBRUSH;
begin
  // TODO
  if not (ABarControl.IsMainMenu or ABarControl.IsStatusBar) then
    Result := inherited BarToolbarBrushEx(ABarControl)
  else
    Result := GetSysColorBrush(COLOR_BTNFACE);
end;

class function TdxBarOffice11Painter.BarToolbarDownedBrush(ABarControl: TCustomdxBarControl): HBRUSH;
begin
  Result := dxOffice11DownedBrush;
end;

class function TdxBarOffice11Painter.BarToolbarDownedSelBrush(ABarControl: TCustomdxBarControl): HBRUSH;
begin
  Result := dxOffice11DownedSelectedBrush;
end;

class function TdxBarOffice11Painter.BarToolbarSelBrush(ABarControl: TCustomdxBarControl): HBRUSH;
begin
  Result := dxOffice11ToolbarSelectedBrush;
end;

function TdxBarOffice11Painter.ComboBoxArrowWidth(ABarControl: TCustomdxBarControl; cX: Integer): Integer;
begin
  Result := ABarControl.ScaleFactor.Apply(13);
end;

class function TdxBarOffice11Painter.BarBeforeFingersIndent: Integer;
begin
  Result := 2;
end;

procedure TdxBarOffice11Painter.BarBorderPaintSizes(ABarControl: TdxBarControl;
  var R: TRect);
begin
  BarBorderSizes(ABarControl.Bar, ABarControl.DockingStyle, R);
end;

procedure TdxBarOffice11Painter.BarBorderSizes(ABar: TdxBar; AStyle: TdxBarDockingStyle;
  var R: TRect);
begin
  if ABar.IsMainMenu then
//    SetRectEmpty(R)
  begin
    if AStyle in [dsTop, dsBottom] then
      R := Rect(0, 2, 0, 2)
    else
      R := Rect(2, 0, 2, 0);
  end
  else
    inherited;
end;

procedure TdxBarOffice11Painter.BarDrawBeginGroup(ABarControl: TCustomdxBarControl;
  DC: HDC; ABeginGroupRect: TRect; AToolbarBrush: HBRUSH; AHorz: Boolean);
begin
  ABarControl.FillBackground(DC, ABeginGroupRect, AToolbarBrush, clNone, True);
  with ABeginGroupRect do
    if AHorz then
    begin
      InflateRect(ABeginGroupRect, 0, -BarBeginGroupSideSize);
      FillRect(DC, Rect(Left + 3, Top, Right - 4, Top + 1),
        dxOffice11BarSeparatorBrush1);
      FillRect(DC, Rect(Left + 3 + 1, Top + 1, Right - 4 + 1, Top + 2),
        dxOffice11BarSeparatorBrush2);
    end
    else
    begin
      InflateRect(ABeginGroupRect, -BarBeginGroupSideSize, 0);
      FillRect(DC, Rect(Left, Top + 3, Left + 1, Bottom - 4),
        dxOffice11BarSeparatorBrush1);
      FillRect(DC, Rect(Left + 1, Top + 3 + 1, Left + 1 + 1, Bottom - 4 + 1),
        dxOffice11BarSeparatorBrush2);
    end;
end;

class procedure TdxBarOffice11Painter.BarDrawCaptionElement(ABarControl: TdxBarControl;
  DC: HDC; R: TRect; AState: TdxBarMarkState);
var
  AColor: TColor;
begin
  if AState <> msNone then
  begin
    Office11FrameSelectedRect(DC, R);
    InflateRect(R, -1, -1);
    if AState = msSelected then
      AColor := dxOffice11SelectedColor1
    else
      AColor := dxOffice11SelectedColor2;
    FillRectByColor(DC, R, AColor);
  end
  else
    FillRectByColor(DC, R, ABarControl.CaptionBkColor);
end;

procedure TdxBarOffice11Painter.BarDrawDockedBarBorder(ABarControl: TdxBarControl;
  DC: HDC; R: TRect; AToolbarBrush: HBRUSH);
var
  B1: HBRUSH;
  AMarkColor1, AMarkColor2, AColor6, AColor9: TColor;

  procedure DrawFinger(ARect: TRect);
  begin
  // TODO: !
//  if ABarControl.Bar.NotDocking = [Low(TdxBarDockingStyle)..High(TdxBarDockingStyle)] then Exit;
    InflateRect(ARect, -2, -2);
    if ABarControl.Horizontal then
    begin
      if ABarControl.UseRightToLeftAlignment then
      begin
        Dec(ARect.Right, BeforeFingersSize);
        ARect.Left := ARect.Right - GripperSize(ABarControl);
      end
      else
      begin
        Inc(ARect.Left, BeforeFingersSize);
        ARect.Right := ARect.Left + GripperSize(ABarControl);
      end;
      InflateRect(ARect, 0, -3);
    end
    else
    begin
      Inc(ARect.Top, BeforeFingersSize);
      ARect.Bottom := ARect.Top + GripperSize(ABarControl);
      InflateRect(ARect, -3, 0);
    end;
    BarDrawFingerElements(ABarControl, DC, ARect, ABarControl.Horizontal);
  end;

  procedure FillParentBackground(DC: HDC; const R: TRect);
  begin
    BarFillParentBackground(ABarControl, DC, R, R, AToolbarBrush, clNone);
  end;

  procedure FillBackground(DC: HDC; const R: TRect);
  begin
    BarDrawDockedBackground(ABarControl, DC, R, R, AToolbarBrush, clNone);
  end;

  procedure DrawLeftBorder(var ARect: TRect);
  var
    ADockColor, AC11pxColor, AColor1, AColor2, AColor: TColor;
    R: TRect;
    AIsRightToLeft: Boolean;
  begin
    GetDockColors(ABarControl.DockControl, AColor1, AColor2);
    with ARect do
    begin
      if ABarControl.Horizontal then
      begin
        AIsRightToLeft := ABarControl.UseRightToLeftAlignment;
        if AIsRightToLeft then
        begin
          FillParentBackground(DC, Rect(Right - BarBeforeFingersIndent, Top, Right , Bottom));
          Dec(ARect.Right, BarBeforeFingersIndent);
        end
        else
        begin
          FillParentBackground(DC, Rect(Left, Top, Left + BarBeforeFingersIndent, Bottom));
          Inc(ARect.Left, BarBeforeFingersIndent);
        end;
        FillParentBackground(DC, Rect(Left, Top, Right, Top + 1));
        Inc(ARect.Top);
        if AIsRightToLeft then
        begin
          // only for Horizontal
          FillParentBackground(DC, Rect(Right - 1, Bottom - 2, Right, Bottom - 1));
          FillParentBackground(DC, Rect(Right - 2, Bottom - 1, Right - 1, Bottom));
          // left
          FillBackground(DC, Rect(Right - 1, Top + 2, Right, Bottom - 3));
          // edge pixels
          SetPixel(DC, Right - 2, Bottom - 3, dxOffice11BarBorderColors[2]);
          // #3 = (Dock, #2, 50%)
          ADockColor := GetGradientColorRect(ABarControl.DockControl.ClientRect,
            ABarControl.PointBarToDock(Point(Right, Top)).X, AColor1, AColor2, True);
          AColor := dxGetMiddleRGB(ADockColor, dxOffice11BarBorderColors[2], 50);
          SetPixel(DC, Right - 1, Bottom - 3, ColorToRGB(AColor));
          SetPixel(DC, Right - 2, Bottom - 2, ColorToRGB(AColor));
          // #4 = Dock, C1 + 1px
          ADockColor := GetGradientColorRect(ABarControl.DockControl.ClientRect,
            ABarControl.PointBarToDock(Point(Right, Top)).X, AColor1, AColor2, True);
          AC11pxColor := GetGradientColorRect(GetBarGradientRect(ABarControl),
            Top + 1, dxOffice11ToolbarsColor1,
            dxOffice11ToolbarsColor2, False);
          AColor := dxGetMiddleRGB(ADockColor, AC11pxColor, 50);
          SetPixel(DC, Right - 1, Top + 1, AColor);
          SetPixel(DC, Right - 2, Top, AColor);
        end
        else
        begin
          // only for Horizontal
          FillParentBackground(DC, Rect(Left, Bottom - 2, Left + 1, Bottom - 1));
          FillParentBackground(DC, Rect(Left + 1, Bottom - 1, Left + 2, Bottom));
          // left
          FillBackground(DC, Rect(Left, Top + 2, Left + 1, Bottom - 3));
          // edge pixels
          SetPixel(DC, Left + 1, Bottom - 3, dxOffice11BarBorderColors[2]);
          // #3 = (Dock, #2, 50%)
          ADockColor := GetGradientColorRect(ABarControl.DockControl.ClientRect,
            ABarControl.PointBarToDock(Point(Left, Top)).X, AColor1, AColor2, True);
          AColor := dxGetMiddleRGB(ADockColor, dxOffice11BarBorderColors[2], 50);
          SetPixel(DC, Left, Bottom - 3, ColorToRGB(AColor));
          SetPixel(DC, Left + 1, Bottom - 2, ColorToRGB(AColor));
          // #4 = Dock, C1 + 1px
          ADockColor := GetGradientColorRect(ABarControl.DockControl.ClientRect,
            ABarControl.PointBarToDock(Point(Left, Top)).X, AColor1, AColor2, True);
          AC11pxColor := GetGradientColorRect(GetBarGradientRect(ABarControl),
            Top + 1, dxOffice11ToolbarsColor1,
            dxOffice11ToolbarsColor2, False);
          AColor := dxGetMiddleRGB(ADockColor, AC11pxColor, 50);
          SetPixel(DC, Left, Top + 1, AColor);
          SetPixel(DC, Left + 1, Top, AColor);
        end;
      end
      else
      begin
        FillParentBackground(DC, Rect(Left, Top, Right, Top + BarBeforeFingersIndent));
        Inc(ARect.Top, BarBeforeFingersIndent);
        FillParentBackground(DC, Rect(Left, Top, Left + 1, Bottom));
        Inc(ARect.Left);

        R := Rect(Left, Top + 2, Left + 1, Bottom - 2);
        Dec(R.Bottom, ABarControl.GetMarkSize);
        FillBackground(DC, R);

        FillBackground(DC, Rect(Left + 2, Top, Right - 2, Top + 1));
        // edge pixels
        SetPixel(DC, Right - 2, Top + 1, dxOffice11BarBorderColors[2]);
        // #3 = (Dock, #2, 50%)
        ADockColor := GetGradientColorRect(ABarControl.DockControl.ClientRect,
          ABarControl.PointBarToDock(Point(Left, Top)).X, AColor1, AColor2, True);
        AColor := dxGetMiddleRGB(ADockColor, dxOffice11BarBorderColors[2], 50);
        SetPixel(DC, Right - 2, Top, ColorToRGB(AColor));
        SetPixel(DC, Right - 1, Top + 1, ColorToRGB(AColor));
        // #4 = Dock, C1 + 1px
        ADockColor := GetGradientColorRect(ABarControl.DockControl.ClientRect,
          ABarControl.PointBarToDock(Point(Left, Top)).X, AColor1, AColor2, True);
        AC11pxColor := GetGradientColorRect(GetBarGradientRect(ABarControl),
          Left, dxOffice11ToolbarsColor1,
          dxOffice11ToolbarsColor2, True);
        AColor := dxGetMiddleRGB(ADockColor, AC11pxColor, 50);
        SetPixel(DC, Left, Top + 1, AColor);
        SetPixel(DC, Left + 1, Top, AColor);
      end;
    end;
  end;

  procedure DrawTopBorder(ARect: TRect);
  var
    ADockColor, AC11pxColor, AColor1, AColor2, AColor: TColor;
    R: TRect;
    AIsRightToLeft: Boolean;
  begin
    AIsRightToLeft := ABarControl.UseRightToLeftAlignment;
    GetDockColors(ABarControl.DockControl, AColor1, AColor2);
    with ARect do
    begin
      if ABarControl.Horizontal then
      begin
        R := Rect(Left + 2, Top, Right - 2, Top + 1);

        if AIsRightToLeft then
          Inc(R.Left, ABarControl.GetMarkSize)
        else
          Dec(R.Right, ABarControl.GetMarkSize);
        FillBackground(DC, R);

        if AIsRightToLeft then
          ADockColor := GetGradientColorRect(ABarControl.DockControl.ClientRect,
            ABarControl.PointBarToDock(Point(Left, Top)).X, AColor1, AColor2, True)
        else
          ADockColor := GetGradientColorRect(ABarControl.DockControl.ClientRect,
            ABarControl.PointBarToDock(Point(Right, Top)).X, AColor1, AColor2, True);

        if ABarControl.MarkExists then
        begin
          if AIsRightToLeft then
          begin
            // #6
            SetPixel(DC, Left + ABarControl.MarkSize, Top, AColor6);
            SetPixel(DC, Left + 1, Top + 1, AColor6);
            // #5 = #6, C1+1px
            AC11pxColor := GetGradientColorRect(GetBarGradientRect(ABarControl),
              Top + 1, dxOffice11ToolbarsColor1,
              dxOffice11ToolbarsColor2, False);
            AColor := dxGetMiddleRGB(AColor6, AC11pxColor, 50);
            SetPixel(DC, Left + ABarControl.MarkSize + 1, Top, AColor);
            // #7 = #6, Dock
            AColor := dxGetMiddleRGB(AColor6, ADockColor, 50);
            SetPixel(DC, Left + 1, Top, AColor);
            SetPixel(DC, Left, Top + 1, AColor);
          end
          else
          begin
            // #6
            SetPixel(DC, Right - ABarControl.MarkSize - 1, Top, AColor6);
            SetPixel(DC, Right - 2, Top + 1, AColor6);
            // #5 = #6, C1+1px
            AC11pxColor := GetGradientColorRect(GetBarGradientRect(ABarControl),
              Top + 1, dxOffice11ToolbarsColor1,
              dxOffice11ToolbarsColor2, False);
            AColor := dxGetMiddleRGB(AColor6, AC11pxColor, 50);
            SetPixel(DC, Right - ABarControl.MarkSize - 2, Top, AColor);
            // #7 = #6, Dock
            AColor := dxGetMiddleRGB(AColor6, ADockColor, 50);
            SetPixel(DC, Right - 2, Top, AColor);
            SetPixel(DC, Right - 1, Top + 1, AColor);
          end;
        end
        else
        begin
          if AIsRightToLeft then
          begin
            // #5 = Dock, C1 + 1px
            AC11pxColor := GetGradientColorRect(GetBarGradientRect(ABarControl),
              Top + 1, dxOffice11ToolbarsColor1,
              dxOffice11ToolbarsColor2, False);
            AColor := dxGetMiddleRGB(ADockColor, AC11pxColor, 50);
            SetPixel(DC, Left + 1, Top, AColor);
            SetPixel(DC, Left, Top + 1, AColor);
          end
          else
          begin
            // #5 = Dock, C1 + 1px
            AC11pxColor := GetGradientColorRect(GetBarGradientRect(ABarControl),
              Top + 1, dxOffice11ToolbarsColor1,
              dxOffice11ToolbarsColor2, False);
            AColor := dxGetMiddleRGB(ADockColor, AC11pxColor, 50);
            SetPixel(DC, Right - 2, Top, AColor);
            SetPixel(DC, Right - 1, Top + 1, AColor);
          end;
        end;
      end
      else
      begin
        ADockColor := GetGradientColorRect(ABarControl.DockControl.ClientRect,
          ABarControl.PointBarToDock(Point(Left, Bottom)).X, AColor1, AColor2, True);
        if ABarControl.MarkExists then
        begin
          // #5 = #6, C1+1px
          AC11pxColor := GetGradientColorRect(GetBarGradientRect(ABarControl),
            Left + 1, dxOffice11ToolbarsColor1,
            dxOffice11ToolbarsColor2, True);
          AColor := dxGetMiddleRGB(AColor6, AC11pxColor, 50);
          SetPixel(DC, Left, Bottom - ABarControl.MarkSize - 2, AColor);
          // #6
          SetPixel(DC, Left, Bottom - ABarControl.MarkSize - 1, AColor6);
          SetPixel(DC, Left + 1, Bottom - 2, AColor6);
          // #7 = #6, Dock
          AColor := dxGetMiddleRGB(AColor6, ADockColor, 50);
          SetPixel(DC, Left, Bottom - 2, AColor);
          SetPixel(DC, Left + 1, Bottom - 1, AColor);
        end
        else
        begin
          if AIsRightToLeft then
          begin
            // #5 = Dock, C1 + 1px
            AC11pxColor := GetGradientColorRect(GetBarGradientRect(ABarControl),
              Right - 1, dxOffice11ToolbarsColor1,
              dxOffice11ToolbarsColor2, True);
            AColor := dxGetMiddleRGB(ADockColor, AC11pxColor, 50);
            SetPixel(DC, Right - 1, Bottom - 2, AColor);
            SetPixel(DC, Right - 2, Bottom - 1, AColor);
          end
          else
          begin
            // #5 = Dock, C1 + 1px
            AC11pxColor := GetGradientColorRect(GetBarGradientRect(ABarControl),
              Left + 1, dxOffice11ToolbarsColor1,
              dxOffice11ToolbarsColor2, True);
            AColor := dxGetMiddleRGB(ADockColor, AC11pxColor, 50);
            SetPixel(DC, Left, Bottom - 2, AColor);
            SetPixel(DC, Left + 1, Bottom - 1, AColor);
          end;
        end;
      end;
    end;
  end;

  procedure DrawRightBorder(ARect: TRect);
  var
    R: TRect;
    AClipRgn: HRGN;
    AClipRgnExists: Boolean;
    ADockColor, AColor1, AColor2, AColor: TColor;
    AIsRightToLeft: Boolean;
  begin
    AIsRightToLeft := ABarControl.UseRightToLeftAlignment;
    with ARect do
    begin
      if ABarControl.Horizontal then
      begin
        if not ABarControl.MarkExists then
        begin
          if AIsRightToLeft then
            R := Rect(Left + 1, Top + 1, Left + 2, Bottom - 2)
          else
            R := Rect(Right - 2, Top + 1, Right - 1, Bottom - 2);
          FillBackground(DC, R);
        end;
      end
      else
      begin
        R := Rect(Right - 2, Top + 2, Right - 1, Bottom - 2);
        Dec(R.Bottom, ABarControl.GetMarkSize);
        FillBackground(DC, R);
      end;

      if ABarControl.MarkExists then
      begin
        SaveClipRgn(DC, AClipRgn, AClipRgnExists);
        if ABarControl.Horizontal then
        begin
          if AIsRightToLeft then
          begin
            IntersectClipRect(DC, Left + ABarControl.MarkSize + 2 - 2, Top, Left + 2, Top + 1);
            AddClipRect(DC, Rect(Left, Top + 2, Left + 2, Bottom - 2));
            AddClipRect(DC, Rect(Left + 2, Bottom - 1, Left + ABarControl.MarkSize + 1, Bottom));
            AddClipRect(DC, Rect(Left + 1, Bottom - 2, Left + ABarControl.MarkSize, Bottom - 1));
            R := Rect(Left, Top, Left + ABarControl.MarkSize + 1, Bottom);
          end
          else
          begin
            IntersectClipRect(DC, Right - ABarControl.MarkSize - 2 + 2, Top, Right - 2, Top + 1);
            AddClipRect(DC, Rect(Right - 2, Top + 2, Right, Bottom - 2));
            AddClipRect(DC, Rect(Right - ABarControl.MarkSize - 1, Bottom - 1, Right - 2, Bottom));
            AddClipRect(DC, Rect(Right - ABarControl.MarkSize, Bottom - 2, Right - 1, Bottom - 1));
            R := Rect(Right - ABarControl.MarkSize - 1, Top, Right, Bottom);
          end;
        end
        else
        begin
          IntersectClipRect(DC, Left, Bottom - ABarControl.MarkSize, Left + 1, Bottom - 2);
          AddClipRect(DC, Rect(Left + 2, Bottom - 2, Right - 2, Bottom));
          AddClipRect(DC, Rect(Right - 2, Bottom - ABarControl.MarkSize, Right - 1, Bottom - 1));
          AddClipRect(DC, Rect(Right - 1, Bottom - ABarControl.MarkSize - 1, Right, Bottom - 2));
          R := Rect(Left, Bottom - ABarControl.MarkSize - 1, Right, Bottom);
        end;
        Office11FillTubeGradientRect(DC, R, AMarkColor1, AMarkColor2, not ABarControl.Horizontal);
        RestoreClipRgn(DC, AClipRgn, AClipRgnExists);
        // #8 = B, Dock
        GetDockColors(ABarControl.DockControl, AColor1, AColor2);
        if ABarControl.Horizontal and AIsRightToLeft then
        begin
          ADockColor := GetGradientColorRect(ABarControl.DockControl.ClientRect,
            ABarControl.PointBarToDock(Point(Left, Bottom)).X, AColor1, AColor2, True);
          AColor := dxGetMiddleRGB(AMarkColor2, ADockColor, 50);
          SetPixel(DC, Left, Bottom - 2, AColor);
          SetPixel(DC, Left + 1, Bottom - 1, AColor);
        end
        else
        begin
          ADockColor := GetGradientColorRect(ABarControl.DockControl.ClientRect,
            ABarControl.PointBarToDock(Point(Right, Bottom)).X, AColor1, AColor2, True);
          AColor := dxGetMiddleRGB(AMarkColor2, ADockColor, 50);
          SetPixel(DC, Right - 1, Bottom - 2, AColor);
          SetPixel(DC, Right - 2, Bottom - 1, AColor);
        end;
      end
      else
      begin
        if ABarControl.Horizontal then
          if AIsRightToLeft then
            FillBackground(DC, Rect(Left, Top + 2, Left + 1, Bottom - 1))
          else
            FillBackground(DC, Rect(Right - 1, Top + 2, Right, Bottom - 1))
        else
          FillBackground(DC, Rect(Left + 2, Bottom - 1, Right - 1, Bottom));
      end;
    end;
  end;

  procedure DrawBottomBorder(ARect: TRect);
  var
    ADockColor, AColor1, AColor2, AColor: TColor;
    R: TRect;
    AIsRightToLeft: Boolean;
  begin
    AIsRightToLeft := ABarControl.UseRightToLeftAlignment;
    with ARect do
    begin
      if ABarControl.Horizontal then
      begin
        R := Rect(Left + 2, Bottom - 2, Right - 2, Bottom - 1);
        if AIsRightToLeft then
          Inc(R.Left, ABarControl.GetMarkSize)
        else
          Dec(R.Right, ABarControl.GetMarkSize);
        FillBackground(DC, R);
      end
      else
      begin
        if not ABarControl.MarkExists then
        begin
          R := Rect(Left + 1, Bottom - 2, Right - 2, Bottom - 1);
          FillBackground(DC, R);
        end;
      end;

      if ABarControl.MarkExists then
      begin
        // #9 = B, #2
        AColor := dxGetMiddleRGB(AMarkColor2, dxOffice11BarBorderColors[2], 50);
        if ABarControl.Horizontal then
        begin
          if AIsRightToLeft then
          begin
            SetPixel(DC, Left + 1 + ABarControl.MarkSize, Bottom - 1, AColor);
            SetPixel(DC, Left + ABarControl.MarkSize, Bottom - 2, AColor);
            SetPixel(DC, Left + 1 + ABarControl.MarkSize, Bottom - 2, dxOffice11BarBorderColors[2]);
            FillRect(DC, Rect(Left + 2 + ABarControl.MarkSize, Bottom - 1, Right - 2, Bottom), B1);
          end
          else
          begin
            SetPixel(DC, Right - 2 - ABarControl.MarkSize, Bottom - 1, AColor);
            SetPixel(DC, Right - 1 - ABarControl.MarkSize, Bottom - 2, AColor);
            SetPixel(DC, Right - 2 - ABarControl.MarkSize, Bottom - 2, dxOffice11BarBorderColors[2]);
            FillRect(DC, Rect(Left + 2, Bottom - 1, Right - 2 - ABarControl.MarkSize, Bottom), B1);
          end;
        end
        else
        begin
          SetPixel(DC, Right - 2, Bottom - 1 - ABarControl.MarkSize, AColor);
          SetPixel(DC, Right - 1, Bottom - 2 - ABarControl.MarkSize, AColor);
          SetPixel(DC, Right - 2, Bottom - 2 - ABarControl.MarkSize, dxOffice11BarBorderColors[2]);
          FillRect(DC, Rect(Right - 1, Top + 2, Right, Bottom - ABarControl.MarkSize - 2), B1);
        end;
      end
      else
      begin
        if AIsRightToLeft and ABarControl.Horizontal then
        begin
          // #9 = Dock, #2
          GetDockColors(ABarControl.DockControl, AColor1, AColor2);
          ADockColor := GetGradientColorRect(ABarControl.DockControl.ClientRect,
            ABarControl.PointBarToDock(Point(Left, Bottom)).X, AColor1, AColor2, True);
          AColor := dxGetMiddleRGB(dxOffice11BarBorderColors[2], ADockColor, 50);
          SetPixel(DC, Left + 1, Bottom - 1, AColor);
          SetPixel(DC, Left, Bottom - 2, AColor);
          SetPixel(DC, Left + 1, Bottom - 2, dxOffice11BarBorderColors[2]);
        end
        else
        begin
          // #9 = Dock, #2
          GetDockColors(ABarControl.DockControl, AColor1, AColor2);
          ADockColor := GetGradientColorRect(ABarControl.DockControl.ClientRect,
            ABarControl.PointBarToDock(Point(Right, Bottom)).X, AColor1, AColor2, True);
          AColor := dxGetMiddleRGB(dxOffice11BarBorderColors[2], ADockColor, 50);
          SetPixel(DC, Right - 2, Bottom - 1, AColor);
          SetPixel(DC, Right - 1, Bottom - 2, AColor);
          SetPixel(DC, Right - 2, Bottom - 2, dxOffice11BarBorderColors[2]);
        end;
        if ABarControl.Horizontal then
          FillRect(DC, Rect(Left + 2, Bottom - 1, Right - 2, Bottom), B1)
        else
          FillRect(DC, Rect(Right - 1, Top + 2, Right, Bottom - 2), B1);
      end;
    end;
  end;

  procedure DrawBorder(ARect: TRect);
  begin
    DrawLeftBorder(ARect);
    DrawTopBorder(ARect);
    DrawRightBorder(ARect);
    DrawBottomBorder(ARect);
    with ARect do
    begin
      FillParentBackground(DC, Rect(Left, Top, Left + 1, Top + 1));
      FillParentBackground(DC, Rect(Right - 1, Top, Right, Top + 1));
      FillParentBackground(DC, Rect(Left, Bottom - 1, Left + 1, Bottom));
      FillParentBackground(DC, Rect(Right - 1, Bottom - 1, Right, Bottom));
    end;
  end;

  procedure DrawMainMenuBorder(ARect: TRect);
  begin
    if ABarControl.Horizontal then
    begin
      FillParentBackground(DC, Rect(ARect.Left, ARect.Top, ARect.Right, ARect.Top + 2));
      FillParentBackground(DC, Rect(ARect.Left, ARect.Bottom - 2, ARect.Right, ARect.Bottom));
    end
    else
    begin
      FillParentBackground(DC, Rect(ARect.Left, ARect.Top, ARect.Left + 2, ARect.Bottom));
      FillParentBackground(DC, Rect(ARect.Right - 2, ARect.Top, ARect.Right, ARect.Bottom));
    end;
  end;

begin
  B1 := CreateSolidBrush(dxOffice11BarBorderColors[1]);
  GetMarkColors(ABarControl, AMarkColor1, AMarkColor2, AColor6, AColor9);
  if ABarControl.IsMainMenu then
    DrawMainMenuBorder(R)
  else
    if ABarControl.Bar.BorderStyle = bbsSingle then
      DrawBorder(R);
  if ABarControl.CanMoving then
    DrawFinger(R);
  DeleteObject(B1);
end;

procedure TdxBarOffice11Painter.BarDrawFloatingBarBorder(ABarControl: TdxBarControl;
  DC: HDC; R, CR: TRect; AToolbarBrush: HBRUSH);
var
  I: Integer;
  B1, B2: HBRUSH;
begin
  if not ABarControl.IsInternal then
  begin
    B1 := CreateSolidBrush(dxOffice11BarFloatingBorderColor1);
    B2 := CreateSolidBrush(dxOffice11BarFloatingBorderColor2);
    FrameRect(DC, R, B1);
    InflateRect(R, -1, -1);
    FrameRect(DC, R, B1);
    InflateRect(R, -1, -1);
    FrameRect(DC, R, B2);
    with R do
    begin
      FillRect(DC, Rect(Left, Top, Left + 1, Top + 1), B1);
      FillRect(DC, Rect(Right - 1, Top, Right, Top + 1), B1);
      FillRect(DC, Rect(Right - 1, Bottom - 1, Right, Bottom), B1);
      FillRect(DC, Rect(Left, Bottom - 1, Left + 1, Bottom), B1);
    end;
    DeleteObject(B2);
    DeleteObject(B1);
  end
  else
  begin
    FrameRect(DC, R, dxOffice11DropDownBorderBrush1);
    for I := R.Left + 1 to CR.Left - 1 do
    begin
      InflateRect(R, -1, -1);
      FrameRect(DC, R, AToolbarBrush);
    end;
  end;
end;

procedure TdxBarOffice11Painter.BarDrawFloatingBarCaption(ABarControl: TdxBarControl;
  DC: HDC; R, CR: TRect; AToolbarBrush: HBRUSH; AScaleFactor: TdxScaleFactor);
begin
  AToolbarBrush := CreateSolidBrush(dxOffice11BarFloatingBorderColor3);
  inherited;
  DeleteObject(AToolbarBrush);
end;

function TdxBarOffice11Painter.BarMarkRect(ABarControl: TdxBarControl): TRect;
begin
  Result := inherited BarMarkRect(ABarControl);
  if not IsSimpleMark(ABarControl) then
    case ABarControl.DockingStyle of
      dsTop, dsBottom:
        begin
          Dec(Result.Top, 1);
          if ABarControl.UseRightToLeftAlignment then
            Dec(Result.Left, 2)
          else
            Inc(Result.Right, 2);
          Inc(Result.Bottom, 1);
        end;
      dsLeft, dsRight:
        begin
          Dec(Result.Left, 1);
          Inc(Result.Right, 1);
          Inc(Result.Bottom, 2);
        end;
    end;
end;

procedure TdxBarOffice11Painter.BarMarkRectInvalidate(ABarControl: TdxBarControl);
begin
  inherited;
  if ABarControl.DockingStyle <> dsNone then
    SendMessage(ABarControl.Handle, WM_NCPAINT, 0, 0);
end;

class function TdxBarOffice11Painter.SubMenuControlGetSeparatorColor: TColor;
begin
  Result := dxOffice11BarSeparatorColor1;
end;

class function TdxBarOffice11Painter.SubMenuControlToolbarItemsBrush(ABarSubMenuControl: TdxBarSubMenuControl): HBRUSH;
begin
  Result := dxOffice11MenuBrush;
end;

class function TdxBarOffice11Painter.SubMenuControlHasBand: Boolean;
begin
  Result := True;
end;

class function TdxBarOffice11Painter.SubMenuControlIsSingleMenuBorder(ABarSubMenuControl: TdxBarSubMenuControl): Boolean;
begin
  Result := not ABarSubMenuControl.GetBackgroundBitmap.Empty or (ABarSubMenuControl.BarSize <> 0);
end;

class procedure TdxBarOffice11Painter.SubMenuControlOffsetDetachCaptionRect(
  ABarSubMenuControl: TdxBarSubMenuControl; var R: TRect);
begin
  InflateRect(R, -ABarSubMenuControl.ScaleFactor.Apply(2), -ABarSubMenuControl.ScaleFactor.Apply(4));
end;

procedure TdxBarOffice11Painter.SubMenuControlCalcDrawingConsts(ACanvas: TcxCanvas;
  ATextSize: Integer; AScaleFactor: TdxScaleFactor; out AMenuArrowWidth, AMarkSize: Integer);
begin
  inherited;
  AMarkSize := dxOffice11SubMenuExpandBitmap.Height + SubMenuControlMarkBorderSize;
end;

class function TdxBarOffice11Painter.SubMenuControlDetachCaptionAreaSize(ABarSubMenuControl: TdxBarSubMenuControl): Integer;
begin
  Result := ABarSubMenuControl.DetachCaptionSize + 5;
end;

procedure TdxBarOffice11Painter.SubMenuControlDrawBackground(ABarSubMenuControl: TdxBarSubMenuControl;
  ACanvas: TcxCanvas; ARect: TRect; ABrush: HBRUSH; AColor: TColor);
var
  W1: Integer;
  W2: Integer;
  AColor1, AColor2: TColor;
  W: Integer;
begin
  if not ABarSubMenuControl.GetBackgroundBitmap.Empty then
    inherited
  else
  begin
    W1 := ABarSubMenuControl.GetIndent1;
    W2 := ABarSubMenuControl.GetIndent2;
    W := ABarSubMenuControl.ClientWidth;
    ACanvas.SaveClipRegion;
    try
      ACanvas.SetClipRegion(TcxRegion.Create(ARect), roIntersect);
      with ARect do
      begin
        // fill
        if ABarSubMenuControl.FNonRecent then
        begin
          AColor1 := dxOffice11MenuNonRecentIndentColor1;
          AColor2 := dxOffice11MenuNonRecentIndentColor2;
        end
        else
        begin
          AColor1 := dxOffice11MenuIndentColor1;
          AColor2 := dxOffice11MenuIndentColor2;
        end;
        if ABarSubMenuControl.UseRightToLeftAlignment then
        begin
          Office11FillTubeGradientRect(ACanvas.Handle, Rect(W - W1, Top, W, Bottom), AColor2, AColor1, True);
          if W2 <> 0 then
            FillRectByColor(ACanvas.Handle, Rect(W - W1 - W2, Top, W - W1, Bottom), AColor2);
          if Left < (W - W1 - W2) then
            FillRect(ACanvas.Handle, Rect(Left, Top, W - W1 - W2, Bottom), ABrush);
        end
        else
        begin
          Office11FillTubeGradientRect(ACanvas.Handle, Rect(0, Top, W1, Bottom), AColor1, AColor2, True);
          if W2 <> 0 then
            FillRectByColor(ACanvas.Handle, Rect(W1, Top, W1 + W2, Bottom), AColor2);
          if Right > (W1 + W2) then
            FillRect(ACanvas.Handle, Rect(W1 + W2, Top, Right, Bottom), ABrush);
        end;
      end;
    finally
      ACanvas.RestoreClipRegion;
    end;
  end;
end;

procedure TdxBarOffice11Painter.SubMenuControlDrawBorder(ABarSubMenuControl: TdxBarSubMenuControl;
  DC: HDC; R: TRect);

  procedure DrawFlatBorder;
  var
    ARect: TRect;
  begin
    FrameRect(DC, R, dxOffice11DropDownBorderBrush1);
    ARect := ABarSubMenuControl.OwnerLinkBounds[False];
    if not IsRectEmpty(ARect) then
      FillRect(DC, ARect, dxOffice11MenuBrush);
  end;

begin
  with R do
  begin
    DrawFlatBorder;
    if ABarSubMenuControl.Detachable then
    begin
      InflateRect(R, -1, -1);
      Bottom := Top + ABarSubMenuControl.DetachCaptionSize + 3 + 2;
      FrameRect(DC, R, dxOffice11MenuBrush);
      InflateRect(R, 0, -1);
      FillRect(DC, Rect(Left, Top, Right, Top + 2), dxOffice11MenuBrush);
      FillRect(DC, Rect(Left, Bottom - 1, Right, Bottom), dxOffice11MenuBrush);
      SubMenuControlDrawDetachCaption(ABarSubMenuControl, DC, ABarSubMenuControl.DetachCaptionRect);
    end;
  end
end;

procedure TdxBarOffice11Painter.SubMenuControlDrawClientBorder(ABarSubMenuControl: TdxBarSubMenuControl;
  DC: HDC; const R: TRect; ABrush: HBRUSH);
begin
  if SubMenuControlIsSingleMenuBorder(ABarSubMenuControl) then
    FrameRect(DC, R, dxOffice11MenuBrush)
  else
  begin
    FillRect(DC, Rect(R.Left, R.Top, R.Right, R.Top + 1), dxOffice11MenuBrush);
    FillRect(DC, Rect(R.Left, R.Bottom - 1, R.Right, R.Bottom), dxOffice11MenuBrush);
    if ABarSubMenuControl.UseRightToLeftAlignment then
    begin
      FillRect(DC, Rect(R.Left, R.Top, R.Left + 1, R.Bottom), dxOffice11MenuBrush);
      // Indent
      FillRectByColor(DC, Rect(R.Right - 1, R.Top + 1, R.Right, R.Bottom - 1), dxOffice11MenuIndentColor1);
    end
    else
    begin
      FillRect(DC, Rect(R.Right - 1, R.Top, R.Right, R.Bottom), dxOffice11MenuBrush);
      // Indent
      FillRectByColor(DC, Rect(R.Left, R.Top + 1, R.Left + 1, R.Bottom - 1), dxOffice11MenuIndentColor1);
    end;
  end;
end;

procedure TdxBarOffice11Painter.SubMenuControlDrawDetachCaption(ABarSubMenuControl: TdxBarSubMenuControl;
  DC: HDC; R: TRect);
var
  ABrush: HBRUSH;
  DXY: Integer;
begin
  if ABarSubMenuControl.DetachCaptionSelected then
  begin
    Office11FrameSelectedRect(DC, R);
    InflateRect(R, -1, -1);
    ABrush := dxOffice11DetachableSelectedBrush;
    DXY := 0;
  end
  else
  begin
    ABrush := dxOffice11DetachableBrush;
    DXY := 1;
  end;
  FillRect(DC, R, ABrush);
  // draw marks
  InflateRect(R, -(((R.Right - R.Left + DXY * 2) div 4)), -(DXY + 1));
  BarDrawFingerElements(ABarSubMenuControl, DC, R, False);
end;

procedure TdxBarOffice11Painter.DropDownListBoxDrawBorder(DC: HDC; AColor: TColor; ARect: TRect);
begin
  FrameRect(DC, ARect, dxOffice11DropDownBorderBrush1);
  InflateRect(ARect, -1, -1);
  FrameRect(DC, ARect, dxOffice11DropDownBorderBrush2);
end;

class function TdxBarOffice11Painter.BarToolbarBrushEx2(ABarControl: TdxBarControl): HBRUSH;
begin
  Result := dxOffice11MenuBrush;
end;

class procedure TdxBarOffice11Painter.DrawQuickCustItemFrameSelected(ABarItemControl: TdxBarItemControl;
  DC: HDC; WholeR, R: TRect; Selected: Boolean);
begin
  if Selected then
  begin
    Office11FrameSelectedRect(DC, WholeR);
    if ABarItemControl.UseRightToLeftAlignment then
    begin
      R.Right := R.Left;
      R.Left := R.Right - 2; // paint over!
    end
    else
    begin
      R.Left := R.Right;
      R.Right := R.Left + 2; // paint over!
    end;
    FillRect(DC, R, ABarItemControl.Parent.ToolbarSelBrush);
  end;
end;

function TdxBarOffice11Painter.ButtonControlArrowBrush(const ADrawParams: TdxBarItemControlDrawParams): HBRUSH;
begin
  with ADrawParams do
    if Enabled then
      if DrawSelected then
        if DroppedDown then
          Result := BarItemControl.Parent.ToolbarDownedSelBrush
        else
          Result := BarItemControl.Parent.ToolbarSelBrush
      else
        Result := BarItemControl.Parent.BkBrush
    else
      Result := GetSysColorBrush(COLOR_BTNFACE);
end;

function TdxBarOffice11Painter.EditButtonIsCustomBackground(AState: Integer): Boolean;
begin
  Result := AState in [DXBAR_NORMAL, DXBAR_ACTIVE];
end;

procedure TdxBarOffice11Painter.EditButtonDrawBackground(const ADrawParams: TdxBarEditLikeControlDrawParams; AState: Integer;
  ARect: TRect; ABrush: HBrush);
begin
  if ADrawParams.PaintType = ptMenu then
    FillRect(ADrawParams.Canvas.Handle, ARect, dxOffice11OwnerControlDownedBrush)
  else
    DrawBackground(ADrawParams.BarItemControl, ADrawParams.Canvas.Handle, ARect, ABrush, ADrawParams.BarItemControl.NonRecent);
end;

class function TdxBarOffice11Painter.EditControlBorderOffsets(APaintType: TdxBarPaintType): TRect;
begin
  Result := Rect(1, 1, 1, 1);
end;

procedure TdxBarOffice11Painter.EditControlDrawBorder(
  const ADrawParams: TdxBarEditLikeControlDrawParams; var ARect: TRect);
begin
  with ADrawParams do
  begin
    if DrawSelected then
      Office11FrameSelectedRect(Canvas.Handle, ARect)
    else
      if not Enabled and not IsTransparent then
        FrameRectByColor(Canvas.Handle, ARect, dxOffice11TextDisabledColor)
      else
        if (PaintType = ptMenu) and not IsTransparent then
          FrameRect(Canvas.Handle, ARect, dxOffice11OwnerControlDownedBrush)
        else
          DrawBackgroundFrameRect(BarEditControl, Canvas.Handle, ARect, BarEditControl.Parent.BkBrush, False);
    InflateRect(ARect, -1, -1);
  end;
end;

class function TdxBarOffice11Painter.EditControlCaptionBackgroundIsOpaque(
  const ADrawParams: TdxBarEditLikeControlDrawParams): Boolean;
begin
  Result := (ADrawParams.PaintType = ptMenu) and ADrawParams.DrawSelected;
end;

class function TdxBarOffice11Painter.EditControlCaptionSimpleIndent(const ADrawParams: TdxBarEditLikeControlDrawParams): Integer;
begin
  if ADrawParams.PaintType = ptMenu then
    Result := SubMenuControlGetItemTextIndent(ADrawParams)
  else
    Result := ADrawParams.BarItemControl.GetControlCaptionOffset;
end;

class function TdxBarOffice11Painter.EditControlCaptionRightIndentIsOpaque(
  const ADrawParams: TdxBarEditLikeControlDrawParams): Boolean;
begin
  Result := (ADrawParams.PaintType = ptMenu) and ADrawParams.DrawSelected;
end;

class function TdxBarOffice11Painter.EditControlShowIconDefault(
  const ADrawParams: TdxBarEditLikeControlDrawParams): Boolean;
begin
  Result := ADrawParams.PaintType = ptMenu;
end;

class function TdxBarOffice11Painter.EditControlSubMenuGlyphIndents(const ADrawParams: TdxBarEditLikeControlDrawParams): TRect;
begin
  Result := cxEmptyRect;
  Result.Left := ADrawParams.BarItemControl.SubMenuParent.GetIconAreaSize - ADrawParams.BarItemControl.GetGlyphSize(ADrawParams.ViewSize).cx;
end;

function TdxBarOffice11Painter.ComboControlArrowColor(ADrawParams: TdxBarItemControlDrawParams): TColor;
begin
  with ADrawParams do
    if Enabled then
    begin
      Result := dxOffice11TextEnabledColor;
      if DrawSelected then
        if IsHighContrastWhite then
          Result := clWhite
        else
          if DroppedDown and not IsXPStandardScheme then
            Result := ColorToRGB(clHighlightText);
    end
    else
      Result := dxOffice11TextDisabledColor;
end;

function TdxBarOffice11Painter.ComboControlButtonBrush(const ADrawParams: TdxBarItemControlDrawParams): HBRUSH;
begin
  Result := ButtonControlArrowBrush(ADrawParams);
  with ADrawParams do
    if DrawSelected then
      Result := BarItemControl.Parent.ToolbarSelBrush
    else
      if DroppedDown then
        Result := BarItemControl.Parent.ToolbarDownedSelBrush;
end;

class procedure TdxBarOffice11Painter.ComboControlDrawSimpleButton(const ADrawParams: TdxBarEditLikeControlDrawParams; var ARect: TRect; ABrush: HBRUSH);
var
  AColor1, AColor2: TColor;
  ASpaceBrush: HBRUSH;
begin
  with ADrawParams do
    if DrawSelected then
    begin
      InflateRect(ARect, 1, 1);
      Office11FrameSelectedRect(Canvas.Handle, ARect);
      InflateRect(ARect, -1, -1);
      GetSelectedColors(BarEditControl, DroppedDown, DrawSelected, AColor1, AColor2);
      FillGradientRect(Canvas.Handle, ARect, AColor1, AColor2, False);
      InflateRect(ARect, -1, -1);
    end
    else
    begin
      if Enabled then
        ASpaceBrush := BarEditControl.EditBkBrush
      else
        ASpaceBrush := ABrush;
      FrameRect(Canvas.Handle, ARect, ASpaceBrush);
      FillRect(Canvas.Handle, Rect(ARect.Left - 1, ARect.Top, ARect.Left, ARect.Bottom), ASpaceBrush);
      InflateRect(ARect, -1, -1);
      if (PaintType = ptMenu) and Enabled then
        FillRect(Canvas.Handle, ARect, dxOffice11OwnerControlDownedBrush)
      else
        DrawBackground(BarEditControl, Canvas.Handle, ARect, ABrush, not Enabled);
      if DroppedDown then
        OffsetRect(ARect, 1, 1);
    end;
end;

class function TdxBarOffice11Painter.ProgressControlIndent(const ADrawParams: TdxBarItemControlDrawParams): Integer;
begin
  Result := 0;
  if not (cpIcon in ADrawParams.ViewStructure) and (ADrawParams.PaintType = ptMenu) then
    Inc(Result, TdxBarSubMenuControl(ADrawParams.BarItemControl.Parent).GetIndent1);
end;

procedure TdxBarOffice11Painter.DateNavigatorDrawButton(ABarItem: TdxBarItem;
  DC: HDC; R: TRect; const ACaption: string; APressed: Boolean; AScaleFactor: TdxScaleFactor);
begin
  if not ABarItem.BarManager.FThemeAvailable then
    inherited
  else
    TdxBarXPPainter.DateNavigatorDrawNativeButton(ABarItem, DC, R, ACaption, APressed);
end;

function TdxBarOffice11Painter.DateNavigatorHeaderColor: TColor;
begin
  Result := dxOffice11DateHeaderColor;
end;

class function TdxBarOffice11Painter.InPlaceSubItemControlBrush: HBRUSH;
begin
  Result := dxOffice11InPlaceSubItemBrush;
end;

function TdxBarOffice11Painter.EditGetDisabledBkColor(ABarItemControl: TdxBarCustomEditControl): COLORREF;
begin
  Result := GetSysColor(COLOR_BTNFACE);
end;

function TdxBarOffice11Painter.EditGetDisabledTextColor: COLORREF;
begin
  Result := dxOffice11TextDisabledColor;
end;

procedure TdxBarOffice11Painter.DrawSeparatorGlyphAndCaption(const ADrawParams: TdxBarSeparatorControlDrawParams; const ARect: TRect);
var
  APrevBrush: HBRUSH;
begin
  APrevBrush := ADrawParams.BarItemControl.FBkBrush;
  ADrawParams.BarItemControl.FBkBrush := CreateSolidBrush(dxOffice11MenuIndentColor2);
  inherited;
  DeleteGDIObject(ADrawParams.BarItemControl.FBkBrush);
  ADrawParams.BarItemControl.FBkBrush := APrevBrush;
end;

procedure TdxBarOffice11Painter.DrawGlyphBorder(ABarItemControl: TdxBarItemControl;
  DC: HDC; ABrush: HBRUSH; NeedBorder: Boolean; R: TRect; PaintType: TdxBarPaintType; IsGlyphEmpty,
  Selected, Down, DrawDowned, ADroppedDown, IsSplit: Boolean);
var
  AOpaque, AVertical: Boolean;
  AColor1, AColor2: TColor;
begin
  if (PaintType = ptMenu) and Selected and IsGlyphEmpty and not Down or ABarItemControl.IsBkColorAssigned then
    FillRect(DC, R, ABrush)
  else
  begin
    AOpaque := Selected or Down or DrawDowned;
    AVertical := ABarItemControl.Parent.IsRealVertical;
    if ADroppedDown and IsMenuGradient(ABarItemControl) and not Down then
      FillGradientRect(DC, R, dxOffice11MenuDownedColor1,
        dxOffice11MenuDownedColor2, AVertical)
    else
    begin
      if (PaintType <> ptMenu) and AOpaque then
      begin
        GetSelectedColors(ABarItemControl, Down or DrawDowned, Selected, AColor1, AColor2);
        FillGradientRect(DC, R, AColor1, AColor2, AVertical);
      end
      else
        DrawBackground(ABarItemControl, DC, R, ABrush, AOpaque);
    end;

    if Down or (Selected and (PaintType <> ptMenu)) or ADroppedDown then
    begin
      if ADroppedDown then
        BarDrawBarControlOwnerBorder(ABarItemControl.Parent, DC, R, ABarItemControl, ABarItemControl.OwnedBarControl)
      else
        if Selected or
          (Down and (ABarItemControl is TdxBarButtonControl) and TdxBarButtonControl(ABarItemControl).Down) then
          Office11FrameSelectedRect(DC, R)
        else
          FrameRect(DC, R, dxOffice11SelectedBorderBrush);
    end
    else
      if NeedBorder then
        DrawBackgroundFrameRect(ABarItemControl, DC, R, ABrush, AOpaque);
  end;
end;

class procedure TdxBarOffice11Painter.DrawItemArrow(DC: HDC; R: TRect; AScaleFactor: TdxScaleFactor;
  ArrowType: TcxArrowDirection; Enabled, Selected, Flat: Boolean; AColor: TColor = clDefault);
begin
  Office11DrawItemArrow(DC, R, ArrowType = adDown, Enabled, Selected, Flat);
end;

procedure TdxBarOffice11Painter.DrawLargeItemArrow(DC: HDC; R: TRect;
  ArrowType: TcxArrowDirection; Size: Integer; Selected, Enabled, Flat: Boolean; AColor: TColor = clDefault);
begin
  Office11DrawLargeItemArrow(DC, R, ArrowType, Size, Selected, Enabled, Flat);
end;

class procedure TdxBarOffice11Painter.DrawFrameRect(ABarItemControl: TdxBarItemControl;
  ADC: HDC; const ARect: TRect; ABrush: HBRUSH; APaintType: TdxBarPaintType; ASelected, ADowned: Boolean);
begin
  if (APaintType = ptMenu) or ASelected or ADowned then
    if (APaintType = ptMenu) and not ASelected then
      FrameRect(ADC, ARect, dxOffice11BarSeparatorBrush1)
    else
      Office11FrameSelectedRect(ADC, ARect)
  else
    DrawBackgroundFrameRect(ABarItemControl, ADC, ARect, ABrush, False);
end;

class procedure TdxBarOffice11Painter.FrameFlatSelRect(DC: HDC; const R: TRect);
begin
  Office11FrameSelectedRect(DC, R);
end;

class function TdxBarOffice11Painter.GetBarGradientRect(ABarControl: TCustomdxBarControl): TRect;
begin
  Result := Rect(0, 0, ABarControl.Width, ABarControl.Height);
  if ABarControl is TdxBarControl then
  begin
    if TdxBarControl(ABarControl).Horizontal then
      InflateRect(Result, 0, -1)
    else
      InflateRect(Result, -1, 0);
  end;
end;

class procedure TdxBarOffice11Painter.GetDockColors(ADockControl: TdxDockControl; var AColor1, AColor2: TColor);
begin
  if ADockControl.Horizontal and ADockControl.UseRightToLeftAlignment then
  begin
    AColor1 := dxOffice11DockColor2;
    AColor2 := dxOffice11DockColor1;
  end
  else
  begin
    AColor1 := dxOffice11DockColor1;
    AColor2 := dxOffice11DockColor2;
  end;
  if ADockControl.Align = alLeft then
    AColor2 := AColor1
  else
    if ADockControl.Align = alRight then
      AColor1 := AColor2;
end;

class procedure TdxBarOffice11Painter.GetMarkColors(ABarControl: TdxBarControl;
  var AMarkColor1, AMarkColor2, AColor6, AColor9: TColor);
var
  I: Integer;
begin
  I := Integer(ABarControl.MarkDrawState) + 1;
  AMarkColor1 := dxOffice11BarMarkColors1[I];
  AMarkColor2 := dxOffice11BarMarkColors2[I];
  AColor6 := dxOffice11BarBorderMarkColors[1, I];
  AColor9 := dxOffice11BarBorderMarkColors[2, I];
end;

class procedure TdxBarOffice11Painter.GetSelectedColors(ABarItemControl: TdxBarItemControl;
  ADown, ASelected: Boolean; var AColor1, AColor2: TColor);
begin
  if ABarItemControl.Parent.IsInternal then
  begin
    if ADown then
      AColor1 := dxOffice11OwnerControlDownedColor
    else
      AColor1 := dxOffice11SelectedColor1;
    AColor2 := AColor1;
  end
  else
  begin
    if ADown then
    begin
      if not ASelected then
      begin
        AColor1 := dxOffice11SelectedDownColor1;
        AColor2 := dxOffice11SelectedDownColor2;
        if AColor1 = AColor2 then
        begin
          AColor1 := dxOffice11DownedColor; //dxOffice11SelectedColor1;
          AColor2 := AColor1;
        end;
      end
      else
      begin
        AColor1 := dxOffice11SelectedDownColor2;
        AColor2 := dxOffice11SelectedDownColor1;
      end;
    end
    else
    begin
      AColor1 := dxOffice11SelectedColor1;
      AColor2 := dxOffice11SelectedColor2;
    end;
  end;
end;

class function TdxBarOffice11Painter.GetToolbarBrush(ABarItemControl: TdxBarItemControl): HBRUSH;
begin
  Result := ABarItemControl.Parent.ToolbarBrush;
end;

function TdxBarOffice11Painter.GetDefaultEnabledTextColor(
  ABarItemControl: TdxBarItemControl; ASelected, AFlat: Boolean): TColor;
begin
  if (ABarItemControl.IsInvertTextColor or True) and ASelected and not AFlat then
  begin
    Result := dxOffice11InPlaceSubItemTextColor; // GetSysColor(COLOR_HIGHLIGHTTEXT)
    if IsHighContrastWhite then
      Result := clWhite;
  end
  else
    Result := dxOffice11TextEnabledColor;
end;

procedure TdxBarOffice11Painter.GetDisabledTextColors(
  ABarItemControl: TdxBarItemControl; ASelected, AFlat: Boolean;
  var AColor1, AColor2: TColor);
begin
  AColor1 := dxOffice11TextDisabledColor;
  AColor2 := AColor1;
end;

class function TdxBarOffice11Painter.GetFaded(ABarControl: TCustomdxBarControl): Boolean;
begin
  Result := True;
end;

class function TdxBarOffice11Painter.IgnoreNonRecentColor: Boolean;
begin
  Result := True;
end;

class function TdxBarOffice11Painter.IsMenuGradient(ABarItemControl: TdxBarItemControl): Boolean;
begin
  Result := not ABarItemControl.Parent.NeedShowGlyphAndCheckForItem and ((ABarItemControl is TdxBarSubItemControl) or
    ((ABarItemControl is TdxBarButtonControl) and TdxBarButtonControl(ABarItemControl).DroppedDownFlat));
end;

class function TdxBarOffice11Painter.IsSimpleMark(ABarControl: TdxBarControl): Boolean;
begin
  Result := (ABarControl.Bar.BorderStyle = bbsNone) or ABarControl.IsMainMenu;
end;

class function TdxBarOffice11Painter.BarCaptionBkColor(ABarControl: TdxBarControl;
  AMainFormActive: Boolean): COLORREF;
begin
  Result := dxOffice11BarFloatingCaptionColor;
end;

function TdxBarOffice11Painter.BarCaptionColor(ABarControl: TdxBarControl): COLORREF;
begin
  Result := dxOffice11BarFloatingCaptionTextColor1;
end;

class function TdxBarOffice11Painter.BarMarkArrowColor(ABarControl: TdxBarControl;
  AState: TdxBarMarkState): COLORREF;
begin
  case AState of
    msSelected:
      Result := dxOffice11BarFloatingCaptionTextColor2;
    msPressed:
      Result := dxOffice11BarFloatingCaptionTextColor3;
  else // msNone
    Result := dxOffice11BarFloatingCaptionTextColor1;
  end;
end;

class procedure TdxBarOffice11Painter.BarDrawFingerElements(ABarControl: TCustomdxBarControl;
  DC: HDC; ARect: TRect; AHorizontal: Boolean);
begin
  Office11DrawFingerElements(DC, ARect, AHorizontal, 0, 0, ABarControl.ScaleFactor);
end;

procedure TdxBarOffice11Painter.BarDrawMarkBackground(ABarControl: TdxBarControl;
  DC: HDC; ItemRect: TRect; AToolbarBrush: HBRUSH);
var
  R1, R2, R3: TRect;
  C1, C2, AColor6, C4: TColor;
  AC11pxColor, AColor: TColor;
begin
  // TODO: states and colors
  GetMarkColors(ABarControl, C1, C2, AColor6, C4);
  if (ABarControl.Bar.BorderStyle = bbsNone) or
    ABarControl.IsMainMenu then
  begin
    R2 := ItemRect;
{    if ABarControl.Bar.IsMainMenu then
    begin
      InflateRect(R2, 0, -1);
      with R2 do
      begin
        ABarControl.FillBackground(DC, Rect(Left, Top - 1, Right, Top), AToolbarBrush, clNone, True);
        ABarControl.FillBackground(DC, Rect(Left, Bottom, Right, Bottom + 1), AToolbarBrush, clNone, True);
      end;
    end;}
  end
  else
  begin
    R1 := ItemRect;
    R2 := ItemRect;
    if ABarControl.Horizontal then
    begin
      if ABarControl.UseRightToLeftAlignment then
      begin
        R1.Left := R1.Right - 2;
        Dec(R2.Right, 2);
        InflateRect(R2, 0, 2);
        R3 := Rect(R1.Left, R1.Top, R1.Left + 1, R1.Top + 1);
      end
      else
      begin
        R1.Right := R1.Left + 2;
        Inc(R2.Left, 2);
        InflateRect(R2, 0, 2);
        R3 := Rect(R1.Right - 1, R1.Top, R1.Right, R1.Top + 1);
      end;
      AC11pxColor := GetGradientColorRect(GetBarGradientRect(ABarControl),
        R3.Top + 2, dxOffice11ToolbarsColor1,
        dxOffice11ToolbarsColor2, False);
    end
    else
    begin
      R1.Bottom := R1.Top + 2;
      Inc(R2.Top, 2);
      InflateRect(R2, 2, 0);
      with R1 do
        R3 := Rect(Left, Bottom - 1, Left + 1, Bottom);
      AC11pxColor := GetGradientColorRect(GetBarGradientRect(ABarControl),
        R3.Left + 2, dxOffice11ToolbarsColor1,
        dxOffice11ToolbarsColor2, True);
    end;
    ABarControl.FillBackground(DC, R1, AToolbarBrush, clNone, True);

    AColor := dxGetMiddleRGB(AColor6, AC11pxColor, 50);
    SetPixel(DC, R3.Left, R3.Top, AColor);
  end;
  Office11FillTubeGradientRect(DC, R2, C1, C2, not ABarControl.Horizontal);
end;

procedure TdxBarOffice11Painter.BarDrawMarkElements(ABarControl: TdxBarControl; DC: HDC; ItemRect: TRect);

  function Scale(V: Integer): Integer;
  begin
    Result := ABarControl.ScaleFactor.Apply(V);
  end;

  procedure DrawArrow(X, Y: Integer; AVertical: Boolean; AColor: COLORREF);
  var
    AYOffset: Integer;
    P: array[1..3] of TPoint;
  begin
    AYOffset := Scale(3);
    if AVertical then
    begin
      FillRectByColor(DC, Rect(X, Y, X + Scale(1), Y + Scale(5)), AColor);
      P[1] := Point(X + AYOffset, Y);
      P[2] := Point(X + AYOffset, Y + Scale(4));
      P[3] := Point(X + AYOffset + Scale(2), Y + Scale(2));
    end
    else
    begin
      FillRectByColor(DC, Rect(X, Y, X + Scale(5), Y + Scale(1)), AColor);
      P[1] := Point(X, Y + AYOffset);
      P[2] := Point(X + Scale(4), Y + AYOffset);
      P[3] := Point(X + Scale(2), Y + Scale(2) + AYOffset);
    end;
    PolygonByColor(DC, P, AColor, AColor);
  end;

  procedure DrawArrows(X, Y: Integer; Vertical: Boolean);
  begin
    DrawArrow(X + Scale(1), Y + Scale(1), Vertical, dxOffice11BarMarkArrowColor2);
    DrawArrow(X, Y, Vertical, dxOffice11BarMarkArrowColor1);
  end;

  procedure DrawMark(X, Y: Integer; AVertical: Boolean; AColor: COLORREF);
  var
    P: array[1..3] of TPoint;
  begin
    if AVertical then
    begin
      P[1] := Point(X, Y);
      P[2] := Point(X + Scale(1), Y + Scale(1));
      P[3] := Point(X + Scale(2), Y);
    end
    else
    begin
      P[1] := Point(X, Y);
      P[2] := Point(X + Scale(1), Y + Scale(1));
      P[3] := Point(X, Y + Scale(2));
    end;
    PolygonByColor(DC, P, AColor, AColor);
  end;

  procedure DrawMarks(X, Y: Integer; Vertical: Boolean);
  var
    AOffsetX, AOffsetY: Integer;
  begin
    DrawMark(X + Scale(1), Y + Scale(1), Vertical, dxOffice11BarMarkArrowColor2);
    DrawMark(X, Y, Vertical, dxOffice11BarMarkArrowColor1);
    if Vertical then
    begin
      AOffsetX := 0;
      AOffsetY := Scale(4);
    end
    else
    begin
      AOffsetX := Scale(4);
      AOffsetY := 0;
    end;
    DrawMark(X + Scale(1) + AOffsetX, Y + Scale(1) + AOffsetY, Vertical, dxOffice11BarMarkArrowColor2);
    DrawMark(X + AOffsetX, Y + AOffsetY, Vertical, dxOffice11BarMarkArrowColor1);
  end;

var
  AOffsetX, AOffsetY: Integer;
begin
  with ItemRect do
  begin
    if (ABarControl.Bar.BorderStyle = bbsNone) or ABarControl.IsMainMenu then
    begin
      AOffsetX := Scale(2);
      AOffsetY := Scale(1);
    end
    else
    begin
      AOffsetX := 0;
      AOffsetY := 0;
    end;
    if ABarControl.Horizontal then
    begin
      if ABarControl.UseRightToLeftAlignment then
      begin
        DrawArrows(Left + Scale(1) + AOffsetX, Bottom - Scale(8) - AOffsetY, False);
        if ABarControl.FTruncated then
          DrawMarks(Left + Scale(2) + AOffsetX, Top + Scale(3) - AOffsetY, False); // TODO
      end
      else
      begin
        DrawArrows(Right - Scale(6) - AOffsetX, Bottom - Scale(8) - AOffsetY, False);
        if ABarControl.FTruncated then
          DrawMarks(Right - Scale(7) - AOffsetX, Top + Scale(3) - AOffsetY, False); // TODO
      end;
    end
    else
    begin
      DrawArrows(Right - Scale(8) - AOffsetY, Bottom - Scale(6) - AOffsetX, True);
      if ABarControl.FTruncated then
        DrawMarks(Left + Scale(3) - AOffsetX, Bottom - Scale(7) - AOffsetY, True); // TODO
    end;
  end;
end;

function TdxBarOffice11Painter.SubMenuControlMarkBorderSize: Integer;
begin
  Result := 2;
end;

function TdxBarOffice11Painter.SubMenuControlMarkContentRect(const ADrawRect: TRect): TRect;
var
  AMarkSize: TSize;
begin
  AMarkSize.cx := cxRectHeight(ADrawRect) - SubMenuControlMarkBorderSize;
  AMarkSize.cy := AMarkSize.cx;
  Result := cxRectCenter(ADrawRect, AMarkSize);
end;

procedure TdxBarOffice11Painter.SubMenuControlDrawMarkContent(ABarSubMenuControl: TdxBarSubMenuControl;
  DC: HDC; R: TRect; ASelected: Boolean);
begin
  TransparentDraw(DC, SubMenuControlMarkContentRect(R), dxOffice11SubMenuExpandBitmap);
end;

function TdxBarOffice11Painter.GetLookAndFeelPainter: TcxCustomLookAndFeelPainter;
begin
  Result := cxLookAndFeelPaintersManager.GetPainter(lfsOffice11);
end;

{ TdxBarXPPainter }

constructor TdxBarXPPainter.Create(AData: TdxNativeUInt);
begin
  inherited Create(AData);
  InitParams;
end;

class destructor TdxBarXPPainter.Finalize;
begin
  if FSelectedItemBrush <> 0 then
    DeleteObject(FSelectedItemBrush);
end;

procedure TdxBarXPPainter.DrawItemBackgroundInSubMenu(const ADrawParams: TdxBarButtonLikeControlDrawParams; R: TRect);
var
  ABrush: HBRUSH;
  ADC: HDC;
  AIconRect: TRect;
  AOpaque: Boolean;
begin
  with ADrawParams do
  begin
    AIconRect := SubMenuControlGetItemIconRealRect(R, BarItemControl.Parent.IconAreaSize, UseRightToLeftAlignment);
    ADC := Canvas.Handle;

    if DrawSelected and not HasIcon and not Downed then
      ABrush := BarItemControl.Parent.ToolbarSelBrush
    else
      ABrush := BarItemControl.Parent.BkBrush;

    AOpaque := DrawSelected or BarItemControl.FNonRecent;

    if UseRightToLeftAlignment then
    begin
      R.Right := AIconRect.Left - 1;
      DrawBackground(BarItemControl, ADC, Rect(R.Right, AIconRect.Top, AIconRect.Left, AIconRect.Bottom), ABrush, AOpaque);
      if AIconRect.Top > R.Top then
        DrawBackground(BarItemControl, ADC, Rect(R.Right, R.Top, AIconRect.Right, AIconRect.Top), ABrush, AOpaque);
      if AIconRect.Bottom < R.Bottom then
        DrawBackground(BarItemControl, ADC, Rect(R.Right, AIconRect.Bottom, AIconRect.Right, R.Bottom), ABrush, AOpaque);
    end
    else
    begin
      R.Left := AIconRect.Right + 1;
      DrawBackground(BarItemControl, ADC, Rect(AIconRect.Right, AIconRect.Top, R.Left, AIconRect.Bottom), ABrush, AOpaque);
      if AIconRect.Top > R.Top then
        DrawBackground(BarItemControl, ADC, Rect(AIconRect.Left, R.Top, R.Left, AIconRect.Top), ABrush, AOpaque);
      if AIconRect.Bottom < R.Bottom then
        DrawBackground(BarItemControl, ADC, Rect(AIconRect.Left, AIconRect.Bottom, R.Left, R.Bottom), ABrush, AOpaque);
    end;

    if DrawSelected then
      ABrush := BarItemControl.Parent.ToolbarSelBrush
    else
      ABrush := BarItemControl.Parent.BkBrush;

    DrawBackground(BarItemControl, ADC, R, ABrush, AOpaque);
  end;
end;

class function TdxBarXPPainter.GlyphBkgndBrush(ABarItemControl: TdxBarItemControl;
  APaintType: TdxBarPaintType; AGlyphEmpty, ASelected, ADowned, ADrawDowned, ADroppedDown,
  AForceUseBkBrush, AGrayScale: Boolean): HBRUSH;
begin
  if ASelected and (APaintType = ptMenu) and AGlyphEmpty and not ADowned then // TODO: ref func
    Result := ABarItemControl.Parent.ToolbarSelBrush
  else
    Result := ABarItemControl.BkBrush;
end;

class function TdxBarXPPainter.GlyphDownShift(ABarItemControl: TdxBarItemControl): Integer;
begin
  Result := 1;
end;

class function TdxBarXPPainter.GlyphDrawDownedShift(ABarItemControl: TdxBarItemControl;
  ADown: Boolean): Integer;
begin
  if not ADown then
    Result := 1
  else
    Result := 0;
end;

class function TdxBarXPPainter.IsFlatGlyphImage: Boolean;
begin
  Result := True;
end;

function TdxBarXPPainter.BeforeFingersSize: Integer;
begin
//  Result := 3;
  Result := 0;
end;

function TdxBarXPPainter.FingersSize(ABarControl: TdxBarControl): Integer;
begin
  Result := BeforeFingersSize + GripperSize(ABarControl) + 2;
end;

function TdxBarXPPainter.GripperSize(ABarControl: TdxBarControl): Integer;
begin
  Result := FdxBarXPPainterParams.GripperSize;
end;

class function TdxBarXPPainter.RealButtonArrowWidth(ABarManager: TdxBarManager): Integer;
begin
  Result := inherited RealButtonArrowWidth(ABarManager);
  Inc(Result, 3);
end;

class function TdxBarXPPainter.RealLargeButtonArrowWidth(ABarManager: TdxBarManager): Integer;
begin
  Result := inherited RealLargeButtonArrowWidth(ABarManager);
  Inc(Result, 3);
end;

procedure TdxBarXPPainter.DockControlFillBackground(ADockControl: TdxDockControl;
  DC: HDC; ADestR, ASourceR, AWholeR: TRect; ABrush: HBRUSH; AColor: TColor);

  procedure FillBackgroundTempBitmap(ABitmap: TBitmap);
  var
    ATheme: TdxTheme;
  begin
    ATheme := OpenTheme(totRebar);
    with AWholeR do
    begin
      ABitmap.Width := Right - Left;
      ABitmap.Height := Bottom - Top;
    end;
    DrawThemeBackground(ATheme, ABitmap.Canvas.Handle, 0, CHEVS_NORMAL, AWholeR);
  end;

  procedure DrawBarSeparators(DC: HDC);

    function GetRowBar(ARow: TdxDockRow): TdxBar;
    var
      I: Integer;
      ABar: TdxBar;
    begin
      if ARow.ColCount = 0 then
      begin
        Result := nil;
        Exit;
      end;
      Result := ARow.Cols[0].BarControl.Bar;
      if Result.BorderStyle = bbsNone then
        for I := 1 to ARow.ColCount - 1 do
        begin
          ABar := ARow.Cols[I].BarControl.Bar;
          if ABar.BorderStyle <> bbsNone then
          begin
            Result := ABar;
            Break;
          end;
        end;
    end;

    function IsNoBorder(ARow: TdxDockRow): Boolean;
    var
      ABar: TdxBar;
    begin
      ABar := GetRowBar(ARow);
      Result := (ABar <> nil) and ((ABar.BorderStyle = bbsNone) or ABar.IsStatusBar);
    end;

    procedure CalcLines(ARow: TdxDockRow; AHorz: Boolean;
      var AIsFirstLineNeeded, AIsLastLineNeeded: Boolean);
    var
      AIsTop, AIsBottom, AIsTopBottom, AIsLeft, AIsRight: Boolean;
    begin
      if IsNoBorder(ARow) then
      begin
        AIsFirstLineNeeded := False;
        AIsLastLineNeeded := False;
      end
      else
      begin
        AIsFirstLineNeeded := True;
        AIsLastLineNeeded := True;
        if AHorz then
        begin
          AIsTop := (ADockControl.DockingStyle = dsTop) and (ARow = ADockControl.Rows[0]);
          AIsBottom := (ADockControl.DockingStyle = dsBottom) and
            (ARow = ADockControl.Rows[ADockControl.RowCount - 1]);
          AIsTopBottom := (ADockControl.DockingStyle = dsTop) and
            (ARow = ADockControl.Rows[ADockControl.RowCount - 1]);
          if AIsTop then AIsFirstLineNeeded := False;
          if AIsBottom or AIsTopBottom then AIsLastLineNeeded := False;
        end
        else
        begin
          AIsLeft := (ADockControl.DockingStyle = dsLeft) and (ARow = ADockControl.Rows[0]);
          AIsRight := (ADockControl.DockingStyle = dsRight) and
            (ARow = ADockControl.Rows[ADockControl.RowCount - 1]);
          if AIsLeft then AIsFirstLineNeeded := False;
          if AIsRight then AIsLastLineNeeded := False;
        end;
      end;
    end;

  var
    I: Integer;
    R, R1, R2: TRect;
    AHorz: Boolean;
    AIsFirstLineNeeded, AIsLastLineNeeded: Boolean;
  begin
    AHorz := ADockControl.DockingStyle in [dsTop, dsBottom];
    for I := 0 to ADockControl.RowCount - 1 do
    begin
      // rects
      R := ADockControl.GetRectForRow(I);
      if AHorz then
      begin
        R1 := Rect(R.Left, R.Top, R.Right, R.Top + 1);
        R2 := Rect(R.Left, R.Bottom - 1, R.Right, R.Bottom);
      end
      else
      begin
        R1 := Rect(R.Left, R.Top, R.Left + 1, R.Bottom);
        R2 := Rect(R.Right - 1, R.Top, R.Right, R.Bottom);
      end;
      // draw
      CalcLines(ADockControl.Rows[I], AHorz, AIsFirstLineNeeded, AIsLastLineNeeded);
      if AIsFirstLineNeeded then
        FillRect(DC, R1, GetSysColorBrush(COLOR_BTNHIGHLIGHT));
      if AIsLastLineNeeded then
        FillRect(DC, R2, GetSysColorBrush(COLOR_BTNSHADOW)); // TODO: color?
    end;
  end;

begin
  if ADockControl.BackgroundTempBitmap.Empty then
  begin
    FillBackgroundTempBitmap(ADockControl.BackgroundTempBitmap);
    DrawBarSeparators(ADockControl.BackgroundTempBitmap.Canvas.Handle);
  end;
  cxBitBlt(DC, ADockControl.BackgroundTempBitmap.Canvas.Handle, ADestR, ASourceR.TopLeft, SRCCOPY);
end;

class function TdxBarXPPainter.IsNativeBackground: Boolean;
begin
  Result := True;
end;

{class function TdxBarXPPainter.BarChildrenHaveShadows(ABarControl: TCustomdxBarControl): Boolean;
begin
  Result := False;
end;}

class function TdxBarXPPainter.BarToolbarBrush(ABarControl: TCustomdxBarControl): HBRUSH;
begin
  Result := ABarControl.BarManager.ThemeToolbarsBrush;
end;

class function TdxBarXPPainter.BarToolbarBrushEx(ABarControl: TdxBarControl): HBRUSH;
begin
  Result := BarToolbarBrush(ABarControl);
end;

class function TdxBarXPPainter.BarToolbarDownedBrush(ABarControl: TCustomdxBarControl): HBRUSH;
begin
  // TODO
  Result := PatternBrush;
//  Result := ABarControl.BarManager.FlatToolbarsDownedBrush;
end;

class function TdxBarXPPainter.BarToolbarDownedSelBrush(ABarControl: TCustomdxBarControl): HBRUSH;
begin
  // TODO
  Result := GetSysColorBrush(COLOR_BTNFACE);
//  Result := ABarControl.BarManager.FlatToolbarsDownedSelBrush;
end;

class function TdxBarXPPainter.BarToolbarSelBrush(ABarControl: TCustomdxBarControl): HBRUSH;
begin
  // TODO
  if ABarControl.SelectedControl.Enabled or IsWinXP then
    Result := GetSelectedItemBrush
  else
    Result := GetSysColorBrush(COLOR_3DLIGHT);

//  Result := ABarControl.BarManager.FlatToolbarsSelBrush;
end;

function TdxBarXPPainter.ComboBoxArrowWidth(ABarControl: TCustomdxBarControl; cX: Integer): Integer;
begin
  Result := ABarControl.ScaleFactor.Apply(FdxBarXPPainterParams.ComboBoxArrowWidth);
end;

function TdxBarXPPainter.BarBeginGroupSideSize: Integer;
begin
  // don't use in xp painter
  Result := (BarBeginGroupSize - 1{|}) div 2;
end;

function TdxBarXPPainter.BarBeginGroupSize: Integer;
begin
  Result := FdxBarXPPainterParams.BarBeginGroupSize;
end;

class function TdxBarXPPainter.BarBorderSize: Integer;
begin
  Result := 0;
end;

procedure TdxBarXPPainter.BarCaptionFillBackground(ABarControl: TdxBarControl; DC: HDC; R: TRect; AToolbarBrush: HBRUSH);
const
  CaptionBkColors: array[Boolean] of Integer = (COLOR_INACTIVECAPTION, COLOR_ACTIVECAPTION);
begin
  FillRect(DC, R, GetSysColorBrush(CaptionBkColors[ABarControl.BarManager.MainFormActive]));
end;

class function TdxBarXPPainter.BarCaptionTransparent: Boolean;
begin
  Result := True;
end;

class function TdxBarXPPainter.BarCloseButtonSize(AScaleFactor: TdxScaleFactor): TSize;
begin
  Result := AScaleFactor.Apply(FdxBarXPPainterParams.BarCloseButtonSize, dxSystemScaleFactor);
end;

procedure TdxBarXPPainter.BarDrawBeginGroup(ABarControl: TCustomdxBarControl;
  DC: HDC; ABeginGroupRect: TRect; AToolbarBrush: HBRUSH; AHorz: Boolean);
var
  ATheme: TdxTheme;
begin
  ATheme := OpenTheme(totToolBar);
  // * IsThemeBackgroundPartiallyTransparent
  ABarControl.FillBackground(DC, ABeginGroupRect, AToolbarBrush, clNone, True);
  if AHorz then
    DrawThemeBackground(ATheme, DC, TP_SEPARATORVERT, TS_NORMAL, ABeginGroupRect)
  else
    DrawThemeBackground(ATheme, DC, TP_SEPARATOR, TS_NORMAL, ABeginGroupRect);
end;

procedure TdxBarXPPainter.BarDrawCloseButton(ABarControl: TdxBarControl; DC: HDC; R: TRect);
const
  ButtonStates: array [TdxBarMarkState] of Integer = (CBS_NORMAL, CBS_HOT, CBS_PUSHED);
begin
  DrawThemeBackground(OpenTheme(totWindow), DC, WP_SMALLCLOSEBUTTON, ButtonStates[ABarControl.CloseButtonState], R);
end;

procedure TdxBarXPPainter.BarDrawDockedBarBorder(ABarControl: TdxBarControl;
  DC: HDC; R: TRect; AToolbarBrush: HBRUSH);
const
  Grippers: array[Boolean] of Integer = (RP_GRIPPER, RP_GRIPPERVERT);
var
  ATheme: TdxTheme;
begin
  InflateRect(R, -2, -2);
  if not ABarControl.CanMoving then Exit;
  ATheme := OpenTheme(totRebar);
  if ABarControl.Horizontal then
  begin
    if ABarControl.UseRightToLeftAlignment then
    begin
      Dec(R.Right, BeforeFingersSize);
      R.Left := R.Right - GripperSize(ABarControl);
    end
    else
    begin
      Inc(R.Left, BeforeFingersSize);
      R.Right := R.Left + GripperSize(ABarControl);
    end;
    InflateRect(R, 0, -0);
  end
  else
  begin
    Inc(R.Top, BeforeFingersSize);
    R.Bottom := R.Top + GripperSize(ABarControl);
    InflateRect(R, -0, 0);
  end;
  // FillTransparent is not needed (FillBackgroundRgn)
  DrawThemeBackground(ATheme, DC, Grippers[ABarControl.Vertical], CHEVS_NORMAL, R);
end;

procedure TdxBarXPPainter.BarDrawFloatingBarBorder(ABarControl: TdxBarControl; DC: HDC; R, CR: TRect; AToolbarBrush: HBRUSH);
begin
  dxBarFlatPainter.BarDrawFloatingBarBorder(ABarControl, DC, R, CR, AToolbarBrush);
end;

class function TdxBarXPPainter.StatusBarNativeGripSize(ABarManager: TdxBarManager): TSize;
begin
  Result := FdxBarXPPainterParams.StatusBarGripSize;
end;

procedure TdxBarXPPainter.BarDrawMDIButton(ABarControl: TdxBarControl;
  AButton: TdxBarMDIButton; AState: Integer; DC: HDC; R: TRect);
const
  Buttons: array[TdxBarMDIButton] of Integer =
    (WP_MDIMINBUTTON, WP_MDIRESTOREBUTTON, WP_MDICLOSEBUTTON);
  States: array[TdxBarMDIButton, 1..4] of Integer = (
    (MINBS_DISABLED, MINBS_HOT, MINBS_NORMAL, MINBS_PUSHED),
    (RBS_DISABLED, RBS_HOT, RBS_NORMAL, RBS_PUSHED),
    (CBS_DISABLED, CBS_HOT, CBS_NORMAL, CBS_PUSHED));
var
  ATheme: TdxTheme;
begin
  ATheme := OpenTheme(totWindow);
  // * IsThemeBackgroundPartiallyTransparent
  // ABarControl.MDIButtonEnabled(AButton, MF_GRAYED)
  // MINBS_DISABLED, MINBS_HOT, MINBS_NORMAL, MINBS_PUSHED
  case AState of
    DXBAR_HOT:
      AState := 2;
    DXBAR_PRESSED:
      AState := 4;
    DXBAR_DISABLED:
      AState := 1;
  else{DXBAR_NORMAL, DXBAR_ACTIVE}
    AState := 3;
  end;
  ABarControl.FillBackground(DC, R, ABarControl.ToolbarBrush, clNone, True);
  DrawThemeBackground(ATheme, DC, Buttons[AButton], States[AButton, AState], R);
end;

class procedure TdxBarXPPainter.StatusBarFillNativeBackground(ABarControl: TdxBarControl;
  DC: HDC; ADestR, ASourceR, AWholeR: TRect; ABrush: HBRUSH; AColor: TColor);

  procedure FillBackgroundTempBitmap(ABitmap: TBitmap);
  var
    ATheme: TdxTheme;
  begin
    ATheme := OpenTheme(totStatus);
    with AWholeR do
    begin
      ABitmap.Width := Right - Left;
      ABitmap.Height := Bottom - Top;
    end;
    DrawThemeBackground(ATheme, ABitmap.Canvas.Handle, 0, 0, AWholeR);
  end;

begin
  if ABarControl.BackgroundTempBitmap.Empty then
    FillBackgroundTempBitmap(ABarControl.BackgroundTempBitmap);
  cxBitBlt(DC, ABarControl.BackgroundTempBitmap.Canvas.Handle, ADestR, ASourceR.TopLeft, SRCCOPY);
end;

class function TdxBarXPPainter.SubMenuControlArrowsOffset: Integer;
begin
  Result := 1;
end;

function TdxBarXPPainter.SubMenuControlBeginGroupRect(
  ABarSubMenuControl: TdxBarSubMenuControl; AControl: TdxBarItemControl;
  const AItemRect: TRect): TRect;
begin
  Result := AItemRect;
  Result.Bottom := Result.Top;
  Dec(Result.Top, ABarSubMenuControl.BeginGroupSize);
end;

function TdxBarXPPainter.SubMenuControlBeginGroupSize: Integer;
begin
  Result := FdxBarXPPainterParams.SubMenuControlBeginGroupSize;
end;

class function TdxBarXPPainter.SubMenuControlDetachCaptionAreaSize(ABarSubMenuControl: TdxBarSubMenuControl): Integer;
begin
  Result := ABarSubMenuControl.DetachCaptionSize + 1;
end;

procedure TdxBarXPPainter.SubMenuControlDrawBeginGroup(ABarSubMenuControl: TdxBarSubMenuControl;
  AControl: TdxBarItemControl; ACanvas: TcxCanvas; const ABeginGroupRect: TRect);
begin
  // * IsThemeBackgroundPartiallyTransparent
  DrawBackground(AControl, ACanvas.Handle, ABeginGroupRect, ABarSubMenuControl.BkBrush,
    AControl.FNonRecent and not AControl.FChangeRecentGroup);
  SubMenuControlDrawSeparator(ACanvas, ABeginGroupRect)
end;

procedure TdxBarXPPainter.SubMenuControlDrawSeparator(ACanvas: TcxCanvas; const ARect: TRect);
begin
  DrawThemeBackground(OpenTheme(totToolBar), ACanvas.Handle, TP_SEPARATORVERT, TS_NORMAL, ARect);
end;

procedure TdxBarXPPainter.SubMenuControlDrawBorder(ABarSubMenuControl: TdxBarSubMenuControl;
  DC: HDC; R: TRect);
begin
  FrameRect(DC, R, GetSysColorBrush(COLOR_BTNSHADOW));
  if ABarSubMenuControl.Detachable then
  begin
    InflateRect(R, -1, -1);
    R.Bottom := R.Top + ABarSubMenuControl.DetachCaptionAreaSize + 1;
    FrameRect(DC, R, ABarSubMenuControl.ToolbarItemsBrush);
    SubMenuControlDrawDetachCaption(ABarSubMenuControl, DC, ABarSubMenuControl.DetachCaptionRect);
  end;
end;

procedure TdxBarXPPainter.SubMenuControlDrawClientBorder(ABarSubMenuControl: TdxBarSubMenuControl;
  DC: HDC; const R: TRect; ABrush: HBRUSH);
begin
  FrameRect(DC, R, ABarSubMenuControl.ToolbarItemsBrush);
end;

class procedure TdxBarXPPainter.SubMenuControlOffsetDetachCaptionRect(ABarSubMenuControl: TdxBarSubMenuControl; var R: TRect);
begin
  R := cxRectInflate(R, ABarSubMenuControl.ScaleFactor.Apply(-2));
end;

class function TdxBarXPPainter.SubMenuControlToolbarItemsBrush(ABarSubMenuControl: TdxBarSubMenuControl): HBRUSH;
begin
  Result := GetSysColorBrush(COLOR_MENU);
end;

function TdxBarXPPainter.GetCustomColorButtonIndents(APaintType: TdxBarPaintType): TRect;
begin
  Result := Rect(1, 1, 1, 1);
end;

procedure TdxBarXPPainter.ColorComboDrawCustomButton(
  const ADrawParams: TdxBarColorComboControlDrawParams; ARect: TRect);
begin
  with ADrawParams do
    DrawGlyphBorder(BarItemControl, Canvas.Handle, BarItemControl.Parent.BkBrush, True,
      ARect, ptHorz, True, DrawSelected, False, IsPressed, False, False);
  DrawDots(ADrawParams, ARect);
end;

procedure TdxBarXPPainter.ColorComboDrawCustomButtonAdjacentZone(
  const ADrawParams: TdxBarColorComboControlDrawParams; ARect: TRect);
begin
  with ADrawParams do
    DrawBackgroundFrameRect(BarItemControl, Canvas.Handle, ARect, BarItemControl.Parent.BkBrush, False);
end;

class function TdxBarXPPainter.IsDateNavigatorFlat: Boolean;
begin
  Result := True;
end;

class procedure TdxBarXPPainter.DateNavigatorDrawNativeButton(ABarItem: TdxBarItem;
  DC: HDC; R: TRect; const ACaption: string; APressed: Boolean);
var
  ATheme: TdxTheme;
  AState: Integer;
  AOffset: Integer;
begin
  ATheme := OpenTheme(totToolbar);
  FillRect(DC, R, GetSysColorBrush(COLOR_WINDOW));
  if APressed then
  begin
    AState := TS_PRESSED;
    AOffset := 1;
  end
  else
  begin
    AState := TS_HOT;
    AOffset := 0;
  end;
  DrawThemeBackground(ATheme, DC, TP_BUTTON, AState, R);
  DateNavigatorDrawButtonCaption(DC, R, AOffset, ACaption, False);
end;

procedure TdxBarXPPainter.DateNavigatorDrawButton(ABarItem: TdxBarItem;
  DC: HDC; R: TRect; const ACaption: string; APressed: Boolean; AScaleFactor: TdxScaleFactor);
begin
  DateNavigatorDrawNativeButton(ABarItem, DC, R, ACaption, APressed);
end;

class function TdxBarXPPainter.SysPanelSize(AScaleFactor: TdxScaleFactor): Integer;
var
  ASizeGripSize: Integer;
begin
  Result := ThemeCloseButtonSize.cy + 2 * 2;
  ASizeGripSize := ThemeSizeGripSize.cy + 1;
  if Result < ASizeGripSize  then
    Result := ASizeGripSize;
end;

procedure TdxBarXPPainter.SpinEditControlDrawButton(const ADrawParams: TdxBarSpinEditDrawParams; ARect: TRect; AButtonIndex: Integer);
const
  AThemePartId: array [Boolean] of Integer = (SPNP_DOWN, SPNP_UP);
  AThemeSpinState: array[TcxButtonState] of Integer = (UPS_NORMAL, UPS_NORMAL, UPS_HOT, UPS_PRESSED, UPS_DISABLED);
begin
  with ADrawParams do
  begin
    // * IsThemeBackgroundPartiallyTransparent
    DrawBackground(BarEditControl, Canvas.Handle, ARect, BarEditControl.Parent.BkBrush, False);
    DrawThemeBackground(OpenTheme(totSpin), Canvas.Handle, AThemePartId[AButtonIndex = secButtonUp],
      AThemeSpinState[GetSpinEditButtonState(ADrawParams, AButtonIndex)], ARect);
  end;
end;

function TdxBarXPPainter.GetSpinEditButtonIndents(APaintType: TdxBarPaintType): TRect;
begin
  Result := cxEmptyRect;
end;

class function TdxBarXPPainter.ProgressControlBarBrushColor: TColorRef;
var
  ATheme: TdxTheme;
begin
  ATheme := OpenTheme(totProgress);
  if FAILED(GetThemeColor(ATheme, PP_CHUNK, 0, TMT_FILLCOLOR, Result)) then
    Result := inherited ProgressControlBarBrushColor;
end;

function TdxBarXPPainter.ProgressControlBarHeight(ABarItemControl: TdxBarItemControl): Integer;
begin
  Result := FdxBarXPPainterParams.ProgressControlBarHeight;
end;

procedure TdxBarXPPainter.ProgressControlDrawBackground(const ADrawParams: TdxBarItemControlDrawParams; var BarR: TRect);
const
  BarParts: array[Boolean] of Integer = (PP_BAR, PP_BARVERT);
var
  ATheme: TdxTheme;
  ABarPartId: Integer;
begin
  with ADrawParams do
  begin
    ATheme := OpenTheme(totProgress);
    ABarPartId := BarParts[PaintType = ptVert];
    if IsThemeBackgroundPartiallyTransparent(ATheme, ABarPartId, 0) then
      DrawBackground(BarItemControl, Canvas.Handle, BarR, BarItemControl.Parent.BkBrush, False);
    DrawThemeBackground(ATheme, Canvas.Handle, ABarPartId, 0, BarR);
    GetThemeBackgroundContentRect(ATheme, Canvas.Handle, ABarPartId, 0, BarR, BarR);
  end;
end;

procedure TdxBarXPPainter.ProgressControlDrawChunks(const ADrawParams: TdxBarItemControlDrawParams; BarR: TRect; ABarBrush: HBRUSH);
const
  ChunkParts: array[Boolean] of Integer = (PP_CHUNK, PP_CHUNKVERT);
var
  ATheme: TdxTheme;
  AChunkPartId: Integer;
begin
  ATheme := OpenTheme(totProgress);
  AChunkPartId := ChunkParts[ADrawParams.PaintType = ptVert];
  DrawThemeBackground(ATheme, ADrawParams.Canvas.Handle, AChunkPartId, 0, @BarR);
end;

function TdxBarXPPainter.EditGetEnabledBkColor(ABarItemControl: TdxBarCustomEditControl): COLORREF;
begin
  Result := ThemeEditColor(OpenTheme(totEdit), ETS_NORMAL);
end;

function TdxBarXPPainter.EditGetDisabledBkColor(ABarItemControl: TdxBarCustomEditControl): COLORREF;
begin
  Result := ThemeEditColor(OpenTheme(totEdit), ETS_DISABLED);
end;

function TdxBarXPPainter.EditGetEnabledTextColor: COLORREF;
begin
  Result := ThemeEditTextColor(OpenTheme(totEdit), ETS_NORMAL);
end;

function TdxBarXPPainter.EditGetDisabledTextColor: COLORREF;
begin
  Result := ThemeEditTextColor(OpenTheme(totEdit), ETS_DISABLED);
end;

function TdxBarXPPainter.SubMenuGetSeparatorSize: Integer;
begin
  Result := FdxBarXPPainterParams.SubMenuControlBeginGroupSize;
end;

class function TdxBarXPPainter.IsQuickControlPopupOnRight: Boolean;
begin
  Result := True;
end;

class function TdxBarXPPainter.NeedDoubleBuffer: Boolean;
begin
  Result := True;
end;

function TdxBarXPPainter.IsButtonControlArrowFlat: Boolean;
begin
  Result := True;
end;

function TdxBarXPPainter.GetButtonBorderHeight(AScaleFactor: TdxScaleFactor): Integer;
begin
  Result := FdxBarXPPainterParams.ButtonBorderHeight;
end;

function TdxBarXPPainter.GetButtonBorderWidth(AScaleFactor: TdxScaleFactor): Integer;
begin
  Result := GetButtonBorderHeight(AScaleFactor);
end;

class procedure TdxBarXPPainter.CorrectButtonControlDefaultHeight(var DefaultHeight: Integer);
begin
  Inc(DefaultHeight, 1);
end;

procedure TdxBarXPPainter.DrawBarMarkState(
  ABarControl: TdxBarControl; DC: HDC; const R: TRect; AState: TdxBarMarkState);
const
  States: array[TdxBarMarkState] of Integer = (TS_NORMAL, TS_HOT, TS_PRESSED);
var
  ATheme: TdxTheme;
  ARect: TRect;
begin
  ARect := R;
  ATheme := OpenTheme(totToolbar);
  ABarControl.FillBackground(DC, ARect, ABarControl.ToolbarBrush, clNone, True);
  if ABarControl.Bar.BorderStyle = bbsNone then
  begin
    if ABarControl.Horizontal then
      InflateRect(ARect, 0, -2)
    else
      InflateRect(ARect, -2, 0);
  end;
  DrawThemeBackground(ATheme, DC, TP_BUTTON, States[AState], ARect);
end;

function TdxBarXPPainter.BarMarkIsOpaque: Boolean;
begin
  Result := True;
end;

procedure TdxBarXPPainter.DrawButtonBackground(
  const ADrawParams: TdxBarButtonLikeControlDrawParams);
var
  ARect: TRect;
begin
  ARect := ADrawParams.BarItemControl.ItemBounds;
  if ADrawParams.SplitDropDown and ADrawParams.IsDropDown then
    if ADrawParams.UseRightToLeftAlignment then
      Inc(ARect.Left, ADrawParams.ArrowSize.cx)
    else
      Dec(ARect.Right, ADrawParams.ArrowSize.cx);

  DrawGlyphBorder(ADrawParams.BarItemControl, ADrawParams.Canvas.Handle,
    ADrawParams.BarItemControl.BkBrush, True, ARect, ADrawParams.PaintType,
    True, ADrawParams.DrawSelected, ADrawParams.Downed, ADrawParams.DrawDowned,
    ADrawParams.DroppedDown, ADrawParams.SplitDropDown and ADrawParams.IsDropDown);

  if ADrawParams.IsDropDown and not ADrawParams.IsMenuItem then
  begin
    if ADrawParams.SplitDropDown then
      DrawSplitControlArrow(ADrawParams, ADrawParams.BarItemControl.ItemBounds)
    else
      DrawAssociateControlArrow(ADrawParams, ADrawParams.BarItemControl.ItemBounds);
  end;
end;

procedure TdxBarXPPainter.DrawButtonControlArrow(
  const ADrawParams: TdxBarButtonLikeControlDrawParams; R1: TRect);
begin
  if ADrawParams.PaintType = ptMenu then
    inherited DrawButtonControlArrow(ADrawParams, R1);
end;

procedure TdxBarXPPainter.DrawButtonControlArrowBackground(
  const ADrawParams: TdxBarButtonLikeControlDrawParams; var R1: TRect; ABrush: HBRUSH);

  function GetState: Integer;
  begin
    with ADrawParams do
      if not (Enabled and DropDownEnabled) then
        Result := TS_DISABLED
      else
        if DroppedDown or IsArrowButtonDowned(PaintType, IsPressed) then
          Result := TS_PRESSED
        else
          if Downed and (PaintType <> ptMenu) then
            Result := TS_CHECKED
          else
            if DrawSelected then
              Result := TS_HOT
            else
              Result := TS_NORMAL;
  end;

  procedure dxRotateButtonDraw(ATheme: TdxTheme; ACanvas: TcxCanvas; iPartId, iStateId: Integer;
    ARect: TRect; AScaleFactor: TdxScaleFactor);
  var
    ABitmap: TcxBitmap;
  begin
    ABitmap := TcxBitmap.CreateSize(ARect);
    try
      cxBitBlt(ABitmap.Canvas.Handle, ACanvas.Handle, ABitmap.ClientRect, ARect.TopLeft, SRCCOPY);
      ABitmap.Rotate(ra180, True);
      if not IsWinXP then
        TcxWinXPLookAndFeelPainter.DrawScaledThemeBackground(ATheme, ABitmap.Canvas.Handle, TP_SPLITBUTTONDROPDOWN, GetState,
          cxRectSetNullOrigin(ARect), AScaleFactor, False, False)
      else
        DrawThemeBackground(ATheme, ABitmap.Canvas.Handle, TP_SPLITBUTTONDROPDOWN, GetState, cxRectSetNullOrigin(ARect));

      ABitmap.Rotate(ra180, True);
      cxDrawBitmap(ACanvas.Handle, ABitmap, ARect, cxNullPoint);
    finally
      ABitmap.Free;
    end;
  end;

var
  ATheme: TdxTheme;
begin
  inherited;
  with ADrawParams do
  begin
    ATheme := OpenTheme(totToolBar);
    // * IsThemeBackgroundPartiallyTransparent
    if PaintType = ptMenu then
      DrawThemeBackground(ATheme, Canvas.Handle, TP_BUTTON, GetState, R1)
    else
      if UseRightToLeftAlignment then
        dxRotateButtonDraw(ATheme, Canvas, TP_SPLITBUTTONDROPDOWN, GetState, R1, ScaleFactor)
      else
        if not IsWinXP then
          TcxWinXPLookAndFeelPainter.DrawScaledThemeBackground(ATheme, Canvas.Handle, TP_SPLITBUTTONDROPDOWN, GetState,
            R1, ScaleFactor, False, False)
        else
          DrawThemeBackground(ATheme, Canvas.Handle, TP_SPLITBUTTONDROPDOWN, GetState, R1);
  end;
end;

class function TdxBarXPPainter.EditControlBorderOffsets(APaintType: TdxBarPaintType): TRect;
begin
  Result := FdxBarXPPainterParams.EditControlBorderOffsets;
end;

procedure TdxBarXPPainter.EditControlDrawBorder(
  const ADrawParams: TdxBarEditLikeControlDrawParams; var ARect: TRect);
var
  ATheme: TdxTheme;
  AClipRgn: HRGN;
  AClipRgnExists: Boolean;
  AEditState: Integer;
  R: TRect;
begin
  with ADrawParams do
  begin
    ATheme := OpenTheme(totEdit);
    AEditState := ThemeEditState(BarEditControl);
    R := ARect;
    GetThemeBackgroundContentRect(ATheme, Canvas.Handle, EP_EDITTEXT, AEditState, R, ARect);
    SaveClipRgn(Canvas.Handle, AClipRgn, AClipRgnExists);
    with ARect do
      ExcludeClipRect(Canvas.Handle, Left, Top, Right, Bottom);
    if (not Enabled or (PaintType = ptMenu)) and not IsTransparent or DrawSelected then
      DrawThemeBackground(ATheme, Canvas.Handle, EP_EDITTEXT, AEditState, R)
    else
      DrawBackground(BarEditControl, Canvas.Handle, R, BarEditControl.Parent.BkBrush, BarEditControl.FNonRecent);
    RestoreClipRgn(Canvas.Handle, AClipRgn, AClipRgnExists);
  end;
end;

class function TdxBarXPPainter.EditControlCaptionRightIndentIsOpaque(
  const ADrawParams: TdxBarEditLikeControlDrawParams): Boolean;
begin
  with ADrawParams do
    Result := (PaintType = ptMenu) and (DrawSelected or BarItemControl.FNonRecent);
end;

class function TdxBarXPPainter.EditControlCaptionSimpleIndent(
  const ADrawParams: TdxBarEditLikeControlDrawParams): Integer;
begin
  Result := 6;
end;

class function TdxBarXPPainter.EditControlCaptionComplexIndent(const ADrawParams: TdxBarEditLikeControlDrawParams): Integer;
begin
  Result := 5;
end;

class function TdxBarXPPainter.EditControlSubMenuGlyphIndents(
  const ADrawParams: TdxBarEditLikeControlDrawParams): TRect;
begin
  Result := Rect(5, 0, 0, 0);
end;

class function TdxBarXPPainter.EditControlGetRightCaptionIndentBrush(ABarEditControl: TdxBarCustomEditControl): HBRUSH;
begin
  Result := ABarEditControl.CaptionBkBrush;
end;

class procedure TdxBarXPPainter.CustomComboDrawItem(ABarCustomCombo: TdxBarCustomCombo;
  ACanvas: TCanvas; AIndex: Integer; ARect: TRect; AState: TOwnerDrawState;
  AInteriorIsDrawing: Boolean);
begin
  TdxBarFlatPainter.CustomComboDrawItem(ABarCustomCombo, ACanvas,
    AIndex, ARect, AState, AInteriorIsDrawing);
end;

class function TdxBarXPPainter.ComboControlArrowOffset: Integer;
begin
  Result := 0;
end;

procedure TdxBarXPPainter.ComboControlDrawArrowButton(
  const ADrawParams: TdxBarEditLikeControlDrawParams; ARect: TRect;
  AInClientArea: Boolean);

  function GetState: Integer;
  begin
    with ADrawParams do
      if not Enabled then
        Result := CBXS_DISABLED
      else
        if DroppedDown then
          Result := CBXS_PRESSED
        else
          if DrawSelected then
            Result := CBXS_HOT
          else
            Result := CBXS_NORMAL;
  end;

var
  AButtonState: Integer;
begin
  AButtonState := GetState;
  if IsThemeBackgroundPartiallyTransparent(OpenTheme(totComboBox),
    CP_DROPDOWNBUTTON, AButtonState) then
    FillRectByColor(ADrawParams.Canvas.Handle, ARect, EditGetBkColor(ADrawParams));
  DrawThemeBackground(OpenTheme(totComboBox), ADrawParams.Canvas.Handle,
    CP_DROPDOWNBUTTON, AButtonState, ARect);
end;

procedure TdxBarXPPainter.DrawGlyphBorder(ABarItemControl: TdxBarItemControl;
  DC: HDC; ABrush: HBRUSH; NeedBorder: Boolean; R: TRect; PaintType: TdxBarPaintType; IsGlyphEmpty,
  Selected, Down, DrawDowned, ADroppedDown, IsSplit: Boolean);
var
  ATheme: TdxTheme;
  AState: Integer;
begin
  ATheme := OpenTheme(totToolBar);
  // * IsThemeBackgroundPartiallyTransparent
  if (PaintType = ptMenu) and (Selected or ABarItemControl.FNonRecent) and
    IsGlyphEmpty and not Down or ABarItemControl.IsBkColorAssigned then
      FillRect(DC, R, ABrush)
  else
  begin
    DrawBackground(ABarItemControl, DC, R, ABrush, False);
    if IsMenuItem(ABarItemControl) and (PaintType <> ptMenu) and
      (Selected or DrawDowned or Down or ADroppedDown) then
        FillRect(DC, R, GetSelectedItemBrush) // ***
    else
    begin
      if not ABarItemControl.Enabled then
        AState := TS_DISABLED
      else
        if DrawDowned then
          AState := TS_PRESSED
        else
          if Down or ADroppedDown and not IsSplit then
            AState := TS_CHECKED
          else
            if Selected then
              AState := TS_HOT
            else
              AState := TS_NORMAL;

      if IsSplit then
        DrawThemeBackground(ATheme, DC, TP_SPLITBUTTON, AState, R)
      else
        DrawThemeBackground(ATheme, DC, TP_BUTTON, AState, R);
    end;
  end;
end;

procedure TdxBarXPPainter.DrawGlyphCheckMark(ABarItemControl: TdxBarItemControl; DC: HDC; X, Y, DoubleSize: Integer);
begin
  dxBarFlatPainter.DrawGlyphCheckMark(ABarItemControl, DC, X, Y, DoubleSize);
end;

class function TdxBarXPPainter.GetFaded(ABarControl: TCustomdxBarControl): Boolean;
begin
  Result := True;
end;

class function TdxBarXPPainter.IsMenuItem(ABarItemControl: TdxBarItemControl): Boolean;
begin
  Result := ABarItemControl.IsMenuItem;
end;

class procedure TdxBarXPPainter.BarDrawNativeGrip(ABarControl: TdxBarControl;
  DC: HDC; R: TRect; AToolbarBrush: HBRUSH);
const
  ACorner: array [Boolean] of TdxCorner = (coBottomRight, coBottomLeft);
begin
  cxPaintCanvas.BeginPaint(DC);
  try
    dxRotateSizeGrip(cxPaintCanvas, R, clNone, ACorner[ABarControl.UseRightToLeftAlignment], InternalDrawBarGripSize);
  finally
    cxPaintCanvas.EndPaint;
  end;
end;

procedure TdxBarXPPainter.BarDrawMarkBackground(ABarControl: TdxBarControl;
  DC: HDC; ItemRect: TRect; AToolbarBrush: HBRUSH);
begin
  DrawBarMarkState(ABarControl, DC, ItemRect, ABarControl.MarkDrawState);
end;

class procedure TdxBarXPPainter.BarOffsetFloatingBarCaption(ABarControl: TdxBarControl; var X: Integer; var R: TRect);
begin
  TdxBarFlatPainter.BarOffsetFloatingBarCaption(ABarControl, X, R);
end;

function TdxBarXPPainter.GetDefaultEnabledTextColor(ABarItemControl: TdxBarItemControl; ASelected, AFlat: Boolean): TColor;
begin
  if ASelected and not AFlat and IsWinXP then
    Result := GetSysColor(COLOR_HIGHLIGHTTEXT)
  else
    Result := GetSysColor(COLOR_BTNTEXT);
end;

procedure TdxBarXPPainter.GetDisabledTextColors(ABarItemControl: TdxBarItemControl; ASelected, AFlat: Boolean;
  var AColor1, AColor2: TColor);
begin
  AColor1 := GetSysColor(COLOR_GRAYTEXT);
  AColor2 := AColor1;
end;

function TdxBarXPPainter.GetDotSpaceAfter(ADotWidth: Integer): Integer;
begin
  Result := ADotWidth * 2;
end;

procedure TdxBarXPPainter.DrawDot(const ADrawParams: TdxBarEditLikeControlDrawParams; ARect: TRect);
begin
  if ADrawParams.Enabled then
    FillRect(ADrawParams.Canvas.Handle, ARect, COLOR_BTNTEXT + 1)
  else
    inherited;
end;

function TdxBarXPPainter.GetLookAndFeelPainter: TcxCustomLookAndFeelPainter;
begin
  Result := cxLookAndFeelPaintersManager.GetPainter(lfsNative);
end;

procedure TdxBarXPPainter.BarBeginGroupSizeInit;
var
  ATheme: TdxTheme;
  ASize: TSize;
begin
  ATheme := OpenTheme(totToolBar);
  GetThemePartSize(ATheme, 0, TP_SEPARATOR, TS_NORMAL, TS_MIN, ASize);
  FdxBarXPPainterParams.BarBeginGroupSize := ASize.cx;
end;

procedure TdxBarXPPainter.BarCloseButtonSizeInit;
begin
  GetThemePartSize(OpenTheme(totWindow), 0, WP_SMALLCLOSEBUTTON, CBS_NORMAL, TS_TRUE, FdxBarXPPainterParams.BarCloseButtonSize);
end;

procedure TdxBarXPPainter.ButtonBorderHeightInit;
var
  R, RC: TRect;
begin
  R := Rect(0, 0, 100, 100);
  GetThemeBackgroundContentRect(OpenTheme(totToolBar), 0, TP_SPLITBUTTON, TS_NORMAL, R, RC); // ?
  FdxBarXPPainterParams.ButtonBorderHeight := cxRectHeight(R) - cxRectHeight(RC);
end;

procedure TdxBarXPPainter.ComboBoxArrowWidthInit;
var
  ASize: TSize;
begin
  if IsWinSevenOrLater then
    ASize.cx := GetSystemMetrics(SM_CYHSCROLL)
  else
    GetThemePartSize(OpenTheme(totComboBox), 0, CP_DROPDOWNBUTTON, CBXS_NORMAL, TS_TRUE, ASize);

  FdxBarXPPainterParams.ComboBoxArrowWidth := dxSystemScaleFactor.Revert(ASize.cx);
end;

procedure TdxBarXPPainter.EditControlBorderOffsetsInit;
var
  AContentRect, R: TRect;
begin
  R := Rect(0, 0, 100, 100);
  GetThemeBackgroundContentRect(OpenTheme(totEdit), 0, EP_EDITTEXT, ETS_NORMAL, R, AContentRect);
  FdxBarXPPainterParams.EditControlBorderOffsets := Rect(AContentRect.Left, AContentRect.Top,
    R.Right - AContentRect.Right, R.Bottom - AContentRect.Bottom);
end;

class function TdxBarXPPainter.GetSelectedItemBrush: HBRUSH;
begin
  if IsWinVistaOrLater and (dxColorToHSV(GetSysColor(COLOR_BTNTEXT)).V < 0.08) then
  begin
    if FSelectedItemBrush = 0 then
      FSelectedItemBrush := CreateSolidBrush(dxGetLighterColor(GetSysColor(COLOR_MENUHILIGHT), 40));
    Result := FSelectedItemBrush;
  end
  else
    Result := GetSysColorBrush(COLOR_MENUHILIGHT);
end;

procedure TdxBarXPPainter.GripperSizeInit;
var
  ATheme: TdxTheme;
  ASize: TSize;
begin
  ATheme := OpenTheme(totRebar);
  GetThemePartSize(ATheme, 0, RP_GRIPPER, CHEVS_NORMAL, TS_TRUE, ASize);
  FdxBarXPPainterParams.GripperSize := ASize.cx;
end;

procedure TdxBarXPPainter.InitParams;
begin
  BarBeginGroupSizeInit;
  BarCloseButtonSizeInit;
  ButtonBorderHeightInit;
  ComboBoxArrowWidthInit;
  EditControlBorderOffsetsInit;
  GripperSizeInit;
  ProgressControlBarHeightInit;
  SubMenuControlBeginGroupSizeInit;
  StatusBarGripSizeInit;
end;

procedure TdxBarXPPainter.ProgressControlBarHeightInit;
var
  ATheme: TdxTheme;
  ASize: TSize;
  R, CR: TRect;
begin
  ATheme := OpenTheme(totProgress);
  GetThemePartSize(ATheme, 0, PP_CHUNK, 0, TS_TRUE, ASize);
  GetThemeBackgroundContentRect(ATheme, 0, PP_BAR, 0, R, CR);
  FdxBarXPPainterParams.ProgressControlBarHeight := ASize.cy + (R.Right - R.Left) - (CR.Right - CR.Left);
end;

procedure TdxBarXPPainter.StatusBarGripSizeInit;
begin
  GetThemePartSize(OpenTheme(totStatus), 0, SP_GRIPPER, 0, TS_TRUE, FdxBarXPPainterParams.StatusBarGripSize);
end;

procedure TdxBarXPPainter.SubMenuControlBeginGroupSizeInit;
var
  ATheme: TdxTheme;
  ASize: TSize;
begin
  ATheme := OpenTheme(totToolBar);
  GetThemePartSize(ATheme, 0, TP_SEPARATORVERT, TS_NORMAL, TS_TRUE, ASize);
  FdxBarXPPainterParams.SubMenuControlBeginGroupSize := ASize.cy;
end;

class function TdxBarXPPainter.IsArrowButtonDowned(APaintStyle: TdxBarPaintType; AIsPressed: Boolean): Boolean;
begin
  Result := (APaintStyle <> ptMenu) and AIsPressed;
end;

class procedure TdxBarXPPainter.InternalDrawBarGripSize(ACanvas: TcxCanvas; const ARect: TRect);
var
  ATheme: TdxTheme;
begin
  ATheme := OpenTheme(totStatus);
  // * IsThemeBackgroundPartiallyTransparent
  DrawThemeBackground(ATheme, ACanvas.Handle, SP_GRIPPER, 0, ARect);
end;

{ TdxBarSkinnedPainter }

constructor TdxBarSkinnedPainter.Create(AData: TdxNativeUInt);
begin
  inherited Create(AData);
  FSkinnedObject := TObject(AData);
end;

procedure TdxBarSkinnedPainter.CalculateButtonParts(
  const ADrawParams: TdxBarButtonLikeControlDrawParams; var AParts: array of TRect; const AItemRect: TRect);
var
  ACaptionHeight: Integer;
begin
  if ADrawParams.IsDropDown then
  begin
    if (ADrawParams.PaintType = ptMenu) or (ADrawParams.ViewSize = cvsSmall) then
      inherited
    else
    begin
      ACaptionHeight := cxRectHeight(cxGetTextRect(ADrawParams.Canvas.Handle, ADrawParams.Caption, GetMaxLineCount, True)) + 2{!!!};
      AParts[bcpDropButton].Top := AParts[bcpDropButton].Bottom - ACaptionHeight;
      AParts[bcpButton].Bottom := AParts[bcpDropButton].Top;
    end;
  end;
end;

procedure TdxBarSkinnedPainter.CalculateSpinEditParts(const ADrawParams: TdxBarSpinEditDrawParams;
  var AParts, AAreaParts: array of TRect);
begin
  inherited;
  Dec(AParts[secButtonUp].Bottom);
  AParts[ecpEdit].Right := AParts[secButtonUp].Left;
end;

procedure TdxBarSkinnedPainter.DrawArrow(ADC: HDC; ARect: TRect; AArrowState: Integer; AScaleFactor: TdxScaleFactor);
begin
  Skin.DrawBackground(ADC, cxRectCenter(ARect, GetDefaultArrowSignSize(AScaleFactor)), SkinGetArrowID, AArrowState);
end;

function TdxBarSkinnedPainter.SkinGetArrowID: Integer;
begin
  Result := DXBAR_ARROWDOWN;
end;

class function TdxBarSkinnedPainter.GetDefaultTextSize(ACanvas: TcxCanvas; AScaleFactor: TdxScaleFactor): Integer;
begin
  Result := cxTextHeight(ACanvas.Handle) + AScaleFactor.Apply(3);
end;

procedure TdxBarSkinnedPainter.DrawItemBackgroundInSubMenu(const ADrawParams: TdxBarButtonLikeControlDrawParams; R: TRect);

  procedure InternalDrawBackground(AControlPart, ASkinPart: Integer);

    function InternalGetPartState: Integer;
    begin
      if (AControlPart = bcpDropButton) and ADrawParams.DroppedDown or
        (AControlPart = bcpButton) and ADrawParams.DrawSelected and (ADrawParams.ViewSize <> cvsLarge) then
        Result := DXBAR_HOT
      else
        Result := GetPartState(ADrawParams, AControlPart);
    end;

  begin
    Skin.DrawBackground(ADrawParams.Canvas.Handle,
      ADrawParams.BarItemControl.FParts[AControlPart], ASkinPart, InternalGetPartState);
  end;

var
  AButtonPart, AGlyphPart, ADropButtonPart: Integer;
begin
  with ADrawParams do
  begin
    DrawBackground(BarItemControl, Canvas.Handle, R, 0, False);
    if DrawSelected then
    begin
      AButtonPart := DXBAR_MENUITEM;
      AGlyphPart := DXBAR_MENUITEM_GLYPH;
      ADropButtonPart := DXBAR_MENUITEM_DROPBUTTON;

      if SplitDropDown and IsDropDown then
      begin
        InternalDrawBackground(bcpButton, AGlyphPart);
        InternalDrawBackground(bcpDropButton, ADropButtonPart);
      end
      else
        InternalDrawBackground(bcpButton, AButtonPart);
    end;
  end;
end;

procedure TdxBarSkinnedPainter.DrawGlyphAndBkgnd(ABarItemControl: TdxBarItemControl; ADC: HDC; const R, AGlyphRect: TRect;
  APaintType: TdxBarPaintType; AGlyph: TdxSmartGlyph; AImages: TCustomImageList; AImageIndex: Integer;
  AGlyphEmpty, ASelected, ADowned, ADrawDowned, ADroppedDown, AForceUseBkBrush, AGrayScale, AIsSplit, AEnabled: Boolean;
  AColorPalette: IdxColorPalette);

  function GetState: Integer;
  begin
    if not ABarItemControl.Enabled then
      Result := DXBAR_DISABLED
    else
      if ASelected then
        Result := DXBAR_HOT
      else
        Result := DXBAR_NORMAL;
  end;

var
  ABarManager: TdxBarManager;
  ACheckRect: TRect;
  ACheckSize: Integer;
begin
  if (APaintType = ptMenu) and ADowned then
  begin
    ACheckSize := Min(cxRectWidth(R), cxRectHeight(R));
    ACheckRect := cxRectCenter(R, cxSize(ACheckSize, ACheckSize));
    InflateRect(ACheckRect, -1, -1);
    if AGlyphEmpty then
      Skin.DrawBackground(ADC, ACheckRect, DXBAR_MENUCHECKMARK, GetState)
    else
      Skin.DrawBackground(ADC, ACheckRect, DXBAR_MENUCHECK, GetState);
  end;

  if not AGlyphEmpty then
  begin
    ABarManager := ABarItemControl.BarManager;
    TransparentDraw(ABarItemControl, ADC, 0, R, AGlyphRect, AGlyph, AImages, AImageIndex, ABarManager.ImageListBkColor,
      AEnabled, AGrayScale, False {Flat}, ASelected, ADowned, ADrawDowned, False{Shadow}, GetFaded(ABarItemControl.Parent){Faded},
      ABarManager.ImageOptions.SmoothGlyphs, ABarManager.ImageOptions.UseLeftBottomPixelAsTransparent, AColorPalette);
  end;
end;

function TdxBarSkinnedPainter.GetToolbarContentOffsets(ABar: TdxBar;
  ADockingStyle: TdxBarDockingStyle; AScaleFactor: TdxScaleFactor; AHasSizeGrip: Boolean): TRect;
begin
  Result := Skin.GetContentOffsets(GetToolbarSkinPart(ABar.Control));
end;

function TdxBarSkinnedPainter.GetToolbarsOffsetForAutoAlign: Integer;
begin
  Result := Skin.GetPartSize(DXBAR_TOOLBAR);
end;

class function TdxBarSkinnedPainter.RealButtonArrowWidth(ABarManager: TdxBarManager): Integer;
begin
  Result := 13;
end;

class function TdxBarSkinnedPainter.LoweredBorderSize(ABarItemControl: TdxBarItemControl): Integer;
begin
  Result := 0;
end;

function TdxBarSkinnedPainter.BarLinkedOwnerHasShadow(ABarControl: TCustomdxBarControl): Boolean;
begin
  Result := False;
end;

procedure TdxBarSkinnedPainter.BarDrawBackground(ABarControl: TdxBarControl; ADC: HDC;
  const ADestRect, ASourceRect: TRect; ABrush: HBRUSH; AColor: TColor);
begin
  cxPaintCanvas.BeginPaint(ADC);
  try
    cxPaintCanvas.SetClipRegion(TcxRegion.Create(ADestRect), roIntersect);
    DrawToolbarContentPart(ABarControl, cxPaintCanvas);
  finally
    cxPaintCanvas.EndPaint;
  end;
end;

procedure TdxBarSkinnedPainter.BarDrawDockedBackground(
  ABarControl: TdxBarControl; DC: HDC; ADestR, ASourceR: TRect; ABrush: HBRUSH; AColor: TColor);
begin
  Skin.DrawBackground(DC, ADestR, GetToolbarSkinPart(ABarControl), GetBarControlState(ABarControl));
end;

function TdxBarSkinnedPainter.ComboBoxArrowWidth(ABarControl: TCustomdxBarControl; cX: Integer): Integer;
begin
  if Skin.GetName <> '' then
    Result := ABarControl.ScaleFactor.Apply(19)
  else
    Result := cX + ABarControl.ScaleFactor.Apply(8);
end;

procedure TdxBarSkinnedPainter.SetWindowRgn(AHandle: THandle; const AWindowRect: TRect; ARedraw: Boolean = False);
var
  ARegion: HRGN;
begin
  if Skin.UseRoundedWindowCorners then
    ARegion := CreateRoundRectRgn(0, 0, AWindowRect.Right + 1, AWindowRect.Bottom + 1, 2, 2)
  else
    ARegion := 0;

  Windows.SetWindowRgn(AHandle, ARegion, ARedraw);
end;

procedure TdxBarSkinnedPainter.BarDrawBeginGroup(
  ABarControl: TCustomdxBarControl; DC: HDC; ABeginGroupRect: TRect;
  AToolbarBrush: HBRUSH; AHorz: Boolean);
const
  PartMap: array[Boolean] of Integer = (DXBAR_ITEMSEPARATOR_VERT, DXBAR_ITEMSEPARATOR);
begin
  Skin.DrawBackground(DC, ABeginGroupRect, PartMap[AHorz]);
end;

class function TdxBarSkinnedPainter.GetTailAreaSize(const ADrawParams: TdxBarItemControlDrawParams): Integer;
begin
  if ADrawParams.ViewSize = cvsLarge then
    Result := ADrawParams.BarItemControl.Parent.TextSize
  else
    Result := inherited GetTailAreaSize(ADrawParams);
end;

function TdxBarSkinnedPainter.GetButtonBorderHeight(AScaleFactor: TdxScaleFactor): Integer;
begin
  Result := cxMarginsHeight(Skin.GetContentOffsets(DXBAR_SMALLBUTTON));
end;

function TdxBarSkinnedPainter.GetButtonBorderWidth(AScaleFactor: TdxScaleFactor): Integer;
begin
  Result := cxMarginsWidth(Skin.GetContentOffsets(DXBAR_SMALLBUTTON));
end;

function TdxBarSkinnedPainter.GetLargeButtonBorderHeight: Integer;
begin
  Result := cxMarginsHeight(Skin.GetContentOffsets(DXBAR_LARGEBUTTON));
end;

function TdxBarSkinnedPainter.GetLargeButtonBorderWidth: Integer;
begin
  Result := cxMarginsWidth(Skin.GetContentOffsets(DXBAR_LARGEBUTTON));
end;

function TdxBarSkinnedPainter.GetButtonHeight(AIconSize, ATextSize: Integer; AScaleFactor: TdxScaleFactor): Integer;
begin
  Result := Max(GetSmallIconSize(AScaleFactor), ATextSize) + GetButtonBorderHeight(AScaleFactor);
  if Odd(Result) then
    Inc(Result);
end;

function TdxBarSkinnedPainter.GetButtonWidth(AIconSize, ATextSize: Integer; AScaleFactor: TdxScaleFactor): Integer;
begin
  Result := Max(GetSmallIconSize(AScaleFactor), ATextSize) + GetButtonBorderWidth(AScaleFactor);
  if Odd(Result) then
    Inc(Result);
end;

class procedure TdxBarSkinnedPainter.CorrectButtonControlDefaultHeight(var DefaultHeight: Integer);
begin
// do nothing
end;

procedure TdxBarSkinnedPainter.DrawBackButtonControlArrow(
  const ADrawParams: TdxBarButtonLikeControlDrawParams; ARect: TRect);
begin
  ButtonLikeControlDrawMenuArrow(ADrawParams, adLeft, ARect);
end;

procedure TdxBarSkinnedPainter.DrawButtonLikeControl(
  const ADrawParams: TdxBarButtonLikeControlDrawParams; ARect: TRect);
var
  AImageBounds: TRect;
begin
  if ADrawParams.PaintType = ptMenu then
    DrawGlyphAndTextInSubMenu(ADrawParams, ARect)
  else
  begin
    if not dxFader.DrawFadeImage(ADrawParams.BarItemControl, ADrawParams.Canvas.Handle, ARect) then
      DrawButtonBackground(ADrawParams);

    ARect := cxRectContent(ARect, ADrawParams.ContentOffset);
    DrawGlyph(ADrawParams.BarItemControl, ADrawParams.Canvas.Handle, ARect, ARect, AImageBounds,
      ADrawParams.PaintType, ADrawParams.ViewStructure, ADrawParams.ViewSize, not (cpIcon in ADrawParams.ViewStructure),
      ADrawParams.DrawSelected, ADrawParams.Downed, ADrawParams.DrawDowned, ADrawParams.DroppedDown, False, False, False,
      ADrawParams.SplitDropDown and ADrawParams.IsDropDown);
    DrawButtonLikeControlCaption(ADrawParams, ARect, AImageBounds);
  end;
  if ADrawParams.IsDropDown and not ADrawParams.IsMenuItem then
  begin
    if ADrawParams.SplitDropDown then
      DrawSplitControlArrow(ADrawParams, ARect)
    else
      DrawAssociateControlArrow(ADrawParams, ARect);
  end;
end;

procedure TdxBarSkinnedPainter.DropDownGalleryDrawBackground(DC: HDC; const R: TRect);
begin
  Skin.DrawBackground(DC, R, DXBAR_DROPDOWNGALLERY);
end;

procedure TdxBarSkinnedPainter.DropDownGalleryDrawBorder(
  ABarSubMenuControl: TdxBarSubMenuControl; DC: HDC; const R: TRect);
var
  ARect: TRect;
begin
  cxPaintCanvas.BeginPaint(DC);
  try
    ARect := cxRectOffset(ABarSubMenuControl.ClientRect, ABarSubMenuControl.GetClientOffset.TopLeft);
    cxPaintCanvas.ExcludeClipRect(ARect);
    Skin.DrawBackground(DC, R, DXBAR_DROPDOWNBORDER);
  finally
    cxPaintCanvas.EndPaint;
  end;
end;

procedure TdxBarSkinnedPainter.DropDownGalleryDrawBottomSizeGrip(DC: HDC; const R: TRect);
begin
  Skin.DrawBackground(DC, R, DXBAR_DROPDOWNGALLERY_BOTTOMSIZEGRIP);
end;

procedure TdxBarSkinnedPainter.DropDownGalleryDrawBottomSizeGripEx(ABarSubMenuControl: TdxBarSubMenuControl; DC: HDC; const R: TRect);
begin
  DropDownGalleryDrawBottomSizeGrip(DC, R);
end;

procedure TdxBarSkinnedPainter.DropDownGalleryDrawBottomSizingBand(DC: HDC; const R: TRect);
begin
  Skin.DrawBackground(DC, R, DXBAR_DROPDOWNGALLERY_BOTTOMSIZINGBAND);
end;

procedure TdxBarSkinnedPainter.DropDownGalleryDrawBottomVerticalSizeGrip(
  DC: HDC; const R: TRect);
begin
  Skin.DrawBackground(DC, R, DXBAR_DROPDOWNGALLERY_BOTTOMVERTICALSIZEGRIP);
end;

procedure TdxBarSkinnedPainter.DropDownGalleryDrawFilterBand(DC: HDC; const R: TRect);
begin
  Skin.DrawBackground(DC, R, DXBAR_GALLERYFILTERBAND);
end;

procedure TdxBarSkinnedPainter.DropDownGalleryDrawTopSizeGrip(DC: HDC; const R: TRect);
begin
  Skin.DrawBackground(DC, R, DXBAR_DROPDOWNGALLERY_TOPSIZEGRIP);
end;

procedure TdxBarSkinnedPainter.DropDownGalleryDrawTopSizeGripEx(ABarSubMenuControl: TdxBarSubMenuControl; DC: HDC; const R: TRect);
begin
  DropDownGalleryDrawTopSizeGrip(DC, R);
end;

procedure TdxBarSkinnedPainter.DropDownGalleryDrawTopSizingBand(DC: HDC; const R: TRect);
begin
  Skin.DrawBackground(DC, R, DXBAR_DROPDOWNGALLERY_TOPSIZINGBAND);
end;

procedure TdxBarSkinnedPainter.DropDownGalleryDrawTopVerticalSizeGrip(DC: HDC; const R: TRect);
begin
  Skin.DrawBackground(DC, R, DXBAR_DROPDOWNGALLERY_TOPVERTICALSIZEGRIP);
end;

procedure TdxBarSkinnedPainter.DropDownGalleryDrawGroupHeaderBackground(DC: HDC; const R: TRect);
begin
  Skin.DrawBackground(DC, R, DXBAR_GALLERYGROUPHEADERBACKGROUND);
end;

procedure TdxBarSkinnedPainter.DropDownGalleryDrawItem(
  DC: HDC; const R: TRect; AState: Integer; AScaleFactor: TdxScaleFactor);
begin
  Skin.DrawBackground(DC, R, DXBAR_SMALLBUTTON, AState);
end;

procedure TdxBarSkinnedPainter.DropDownGalleryDrawScrollBarBackground(
  DC: HDC; const R: TRect; AScaleFactor: TdxScaleFactor);
begin
  DropDownGalleryDrawScrollBarBackgroundEx(nil, DC, R, AScaleFactor);
end;

procedure TdxBarSkinnedPainter.DropDownGalleryDrawScrollBarBackgroundEx(ABarSubItemControl: TdxBarSubItemControl; DC: HDC; const R: TRect; AScaleFactor: TdxScaleFactor);
begin
  Skin.DrawBackground(DC, R, DXBAR_SCROLLBARVERT_BACKGROUND);
end;

procedure TdxBarSkinnedPainter.DropDownGalleryDrawScrollBarPartEx(ABarSubItemControl: TdxBarSubItemControl; DC: HDC; const R: TRect; APart: TcxScrollBarPart; AState: TcxButtonState; AScaleFactor:
    TdxScaleFactor);
const
  StateMap: array[TcxButtonState] of Integer = (
    DXBAR_NORMAL, DXBAR_NORMAL, DXBAR_HOT, DXBAR_PRESSED, DXBAR_DISABLED
  );
  PartMap: array[TcxScrollBarPart] of Integer = (
    0, DXBAR_SCROLLBARVERT_LINEUP, DXBAR_SCROLLBARVERT_LINEDOWN,
    DXBAR_SCROLLBARVERT_THUMBNAIL, DXBAR_SCROLLBARVERT_PAGEUP, DXBAR_SCROLLBARVERT_PAGEDOWN
  );
begin
  if PartMap[APart] <> 0 then
    Skin.DrawBackground(DC, R, PartMap[APart], StateMap[AState]);
end;

procedure TdxBarSkinnedPainter.DropDownGalleryDrawSelectionFrame(ACanvas: TcxCanvas; const R: TRect; AState: Integer);
begin
  Skin.DrawBackground(ACanvas.Handle, R, DXBAR_GALLERYGROUPITEM_SELECTIONFRAME, AState);
end;

procedure TdxBarSkinnedPainter.DropDownGalleryItemGetTextColors(
  ABarItemControl: TdxBarItemControl; AEnabled, ASelected, AFlat: Boolean;
  var AColor1, AColor2: TColor);
const
  ItemTextPartMap: array [TdxBarPaintType] of Integer = (
    DXBAR_INRIBBONGALLERYITEM_TEXTCOLOR,
    DXBAR_DROPDOWNGALLERYITEM_TEXTCOLOR,
    DXBAR_INRIBBONGALLERYITEM_TEXTCOLOR
  );
begin
  AColor1 := Skin.GetPartColor(ItemTextPartMap[ABarItemControl.GetPaintType],
    GetPartState(ABarItemControl.FDrawParams, icpControl));
  AColor2 := AColor1;
end;

function TdxBarSkinnedPainter.DropDownGalleryGetName: string;
begin
  Result := Skin.GetName;
end;

function TdxBarSkinnedPainter.DropDownGalleryGetClientBorderSize: Integer;
begin
  Result := 0;
end;

function TdxBarSkinnedPainter.DropDownGalleryGetContentOffsets(APart: Integer): TRect;
begin
  Result := Skin.GetContentOffsets(APart);
end;

function TdxBarSkinnedPainter.DropDownGalleryGetFilterBandSeparatorColor: TColor;
begin
  Result := Skin.GetPartColor(DXBAR_DROPDOWNBORDER_INNERLINE);
end;

function TdxBarSkinnedPainter.DropDownGalleryGetFilterBandTextColor(AState: Integer): TColor;
begin
  Result := Skin.GetPartColor(DXBAR_GALLERYFILTERBANDTEXT, AState);
end;

function TdxBarSkinnedPainter.DropDownGalleryGetNCBorderSize: Integer;
begin
  Result := 2;
end;

function TdxBarSkinnedPainter.DropDownGalleryGetGroupHeaderTextColor: TColor;
begin
  Result := Skin.GetPartColor(DXBAR_GALLERYGROUPHEADERTEXT);
end;

procedure TdxBarSkinnedPainter.DrawButtonControlArrow(const ADrawParams: TdxBarButtonLikeControlDrawParams; R1: TRect);
begin
  if ADrawParams.PaintType = ptMenu then
    ButtonLikeControlDrawMenuArrow(ADrawParams, adRight, R1)
  else
    if ADrawParams.ViewSize <> cvsLarge then
    begin
      DrawArrow(ADrawParams.Canvas.Handle, GetArrowRect(ADrawParams, R1),
        GetButtonPartState(ADrawParams, bcpDropButton), ADrawParams.ScaleFactor);
    end;
end;

procedure TdxBarSkinnedPainter.DrawSplitControlArrow(const ADrawParams: TdxBarButtonLikeControlDrawParams; ARect: TRect);
var
  ARatio: Double;
begin
  DrawButtonControlArrow(ADrawParams, ARect);

  if (ADrawParams.PaintType = ptMenu) and (ADrawParams.ViewSize <> cvsLarge) and not ADrawParams.DrawSelected then
  begin
    ARect := GetArrowRect(ADrawParams, ARect);
    ARatio := Max(1, cxRectHeight(ARect) / SubMenuControlNormalItemHeight(ADrawParams.ScaleFactor));
    InflateRect(ARect, 0, -Round((cxRectHeight(ARect) - 14 * ARatio) / 2));
    ADrawParams.Canvas.DrawComplexFrame(ARect, Skin.GetPartColor(DXBAR_MENUARROWSEPARATOR), clNone, [bLeft]);
  end;
end;

procedure TdxBarSkinnedPainter.DrawAssociateControlArrow(const ADrawParams: TdxBarButtonLikeControlDrawParams; ARect: TRect);
begin
  DrawButtonControlArrow(ADrawParams, ARect);
end;

function TdxBarSkinnedPainter.GetBorderSize: Integer;
begin
  Result := 2;
end;

function TdxBarSkinnedPainter.GetIconAreaSize(ABarControl: TCustomdxBarControl): Integer;
begin
  Result := inherited GetIconAreaSize(ABarControl);
  if (ABarControl.Kind = bkSubMenu) and (ABarControl.ItemLinks.ItemSize = misNormal) then
    Inc(Result, MenuSeparatorSize);
end;

procedure TdxBarSkinnedPainter.ButtonLikeControlCorrectCaptionParams(
  const ADrawParams: TdxBarButtonLikeControlDrawParams; var ATextBounds: TRect;
  const AImageBounds: TRect; out ATextAlignment, AFormat: DWORD);
var
  ACaptionRect: TRect;
begin
  AFormat := DT_END_ELLIPSIS or DT_SINGLELINE;
  ACaptionRect := GetControlCaptionRect(ADrawParams);
  if ADrawParams.ViewSize = cvsLarge then
  begin
    ATextBounds := cxRectOffset(ACaptionRect,
      ATextBounds.Left + (cxRectWidth(ATextBounds) - cxRectWidth(ACaptionRect)) div 2,
      ATextBounds.Top + cxRectHeight(ATextBounds) - (cxRectHeight(ACaptionRect) + 1));
    ATextAlignment := DT_CENTER;
  end
  else
  begin
    if cpIcon in ADrawParams.ViewStructure then
    begin
      if ADrawParams.UseRightToLeftAlignment then
        ATextBounds.Right := AImageBounds.Left - GetControlTextIndents.Left
      else
        ATextBounds.Left := AImageBounds.Right + GetControlTextIndents.Left;
    end
    else
    begin
      if ADrawParams.UseRightToLeftAlignment then
        ATextBounds.Right := ATextBounds.Right - ADrawParams.BarItemControl.GetControlCaptionOffset
      else
        ATextBounds.Left := ATextBounds.Left + ADrawParams.BarItemControl.GetControlCaptionOffset;
    end;
    InflateRect(ATextBounds, 0, -(cxRectHeight(ATextBounds) - cxRectHeight(ACaptionRect)) div 2);
    ATextAlignment := DT_LEFT;
  end;
end;

function TdxBarSkinnedPainter.AllowLargeIcons: Boolean;
begin
  Result := False;
end;

procedure TdxBarSkinnedPainter.BarDrawMarkElements(ABarControl: TdxBarControl; DC: HDC; ItemRect: TRect);

  function GetMarkState: Integer;
  begin
    case ABarControl.MarkDrawState of
      msSelected:
        Result := DXBAR_HOT;
      msPressed:
        Result := DXBAR_PRESSED;
    else {msNone}
      Result := DXBAR_NORMAL;
    end;
  end;

var
  APart: Integer;
  AState: Integer;
begin
  if ABarControl.FTruncated then
    APart := SkinGetTruncateMarkID
  else
    APart := SkinGetMarkArrowID;
  AState := GetMarkState;
  Skin.DrawBackground(DC, ItemRect, APart, AState);
end;

function TdxBarSkinnedPainter.SkinGetMarkArrowID: Integer;
begin
  Result := DXBAR_MARKARROW;
end;

function TdxBarSkinnedPainter.SkinGetTruncateMarkID: Integer;
begin
  Result := DXBAR_MARKTRUNCATED;
end;

procedure TdxBarSkinnedPainter.DropDownListBoxDrawBorder(DC: HDC; AColor: TColor; ARect: TRect);
begin
  Skin.DrawBackground(DC, ARect, DXBAR_DROPDOWNBORDER, DXBAR_NORMAL);
end;

class function TdxBarSkinnedPainter.SubMenuControlHasBand: Boolean;
begin
  Result := True;
end;

class function TdxBarSkinnedPainter.SubMenuControlArrowWidth(ATextSize: Integer): Integer;
begin
  Result := ATextSize;
end;

function TdxBarSkinnedPainter.SubMenuControlBeginGroupSize: Integer;
begin
  Result := 3;
end;

class function TdxBarSkinnedPainter.SubMenuControlDetachCaptionAreaSize(ABarSubMenuControl: TdxBarSubMenuControl): Integer;
begin
  Result := 2 + ABarSubMenuControl.DetachCaptionSize + 1;
end;

class function TdxBarSkinnedPainter.SubMenuControlGetItemIconRect(const AItemRect: TRect; AIconAreaSize: Integer): TRect;
begin
  Result := TdxBarPainter.SubMenuControlGetItemIconRect(AItemRect, AIconAreaSize);
end;

class function TdxBarSkinnedPainter.SubMenuControlGetItemTextIndent(const ADrawParams: TdxBarItemControlDrawParams): Integer;
begin
  with ADrawParams.BarItemControl do
    if SubMenuParent.ItemLinks.ItemSize = misNormal then
      Result := SubMenuParent.IconAreaSize + SubMenuControlTextIndent
    else
      Result := SubMenuParent.IconAreaSize + 4; //!
end;

procedure TdxBarSkinnedPainter.SubMenuControlDrawScrollBandBackground(ABarSubMenuControl: TdxBarSubMenuControl; ACanvas: TcxCanvas; AArrowDirection: TcxArrowDirection);
begin
// do nothing
end;

procedure TdxBarSkinnedPainter.SubMenuControlDrawScrollButton(ABarSubMenuControl: TdxBarSubMenuControl; ACanvas: TcxCanvas; AArrowDirection: TcxArrowDirection);
var
  AState: Integer;
  ARect: TRect;
begin
  ARect := SubMenuControlGetScrollBandBounds(ABarSubMenuControl, AArrowDirection);
  if (AArrowDirection = adUp) and (ABarSubMenuControl.MouseOnUpArrow) or
    (AArrowDirection = adDown) and (ABarSubMenuControl.MouseOnDownArrow) then
    AState := DXBAR_HOT
  else
    AState := DXBAR_NORMAL;

  ABarSubMenuControl.FillBackgroundEx(ACanvas, ARect, 0, clNone, True);
  Skin.DrawBackground(ACanvas.Handle, ARect, DXBAR_MENUSCROLLAREA, AState);
  ACanvas.ExcludeClipRect(ARect);
end;

procedure TdxBarSkinnedPainter.SubMenuControlDrawBackground(ABarSubMenuControl: TdxBarSubMenuControl;
  ACanvas: TcxCanvas; ARect: TRect; ABrush: HBRUSH; AColor: TColor);
begin
  SubMenuControlDrawItemBackground(ABarSubMenuControl, ACanvas, ARect);
end;

procedure TdxBarSkinnedPainter.SubMenuControlDrawBeginGroup(ABarSubMenuControl: TdxBarSubMenuControl;
  AControl: TdxBarItemControl; ACanvas: TcxCanvas; const ABeginGroupRect: TRect);
var
  ASeparatorRect: TRect;
begin
  ASeparatorRect := cxRect(ABeginGroupRect.Left + ABarSubMenuControl.GetIndent1 + SubMenuControlTextIndent,
    ABeginGroupRect.Bottom - SubMenuGetSeparatorSize,
    ABeginGroupRect.Right,
    ABeginGroupRect.Bottom);
  if ABarSubMenuControl.UseRightToLeftAlignment then
    ASeparatorRect := TdxRightToLeftLayoutConverter.ConvertRect(ASeparatorRect, ABeginGroupRect);
  SubMenuControlDrawBackground(ABarSubMenuControl, ACanvas, ABeginGroupRect, 0, clNone);
  SubMenuControlDrawSeparator(ACanvas, ASeparatorRect);
end;

procedure TdxBarSkinnedPainter.SubMenuControlDrawSeparator(ACanvas: TcxCanvas; const ARect: TRect);
begin
  Skin.DrawBackground(ACanvas.Handle, ARect, DXBAR_MENUSEPARATORHORZ, DXBAR_NORMAL);
end;

procedure TdxBarSkinnedPainter.SubMenuControlDrawBorder(
  ABarSubMenuControl: TdxBarSubMenuControl; DC: HDC; R: TRect);
var
  ARect: TRect;
begin
  cxPaintCanvas.BeginPaint(DC);
  try
    ARect := cxRectOffset(ABarSubMenuControl.ClientRect, ABarSubMenuControl.GetClientOffset.TopLeft);
    cxPaintCanvas.ExcludeClipRect(ARect);

    Skin.DrawBackground(DC, R, DXBAR_DROPDOWNBORDER, DXBAR_NORMAL);

    if ABarSubMenuControl.Detachable then
    begin
      InflateRect(R, -SubMenuControlBorderSize, -SubMenuControlBorderSize);
      FillRectByColor(DC, R, Skin.GetPartColor(DXBAR_MENUDETACHCAPTIONAREA));
      SubMenuControlDrawDetachCaption(ABarSubMenuControl, DC, ABarSubMenuControl.DetachCaptionRect);
    end;
  finally
    cxPaintCanvas.EndPaint;
  end;
end;

procedure TdxBarSkinnedPainter.SubMenuControlDrawClientBorder(
  ABarSubMenuControl: TdxBarSubMenuControl; DC: HDC; const R: TRect; ABrush: HBRUSH);
begin
  // no client border
end;

procedure TdxBarSkinnedPainter.SubMenuControlDrawDetachCaption(
  ABarSubMenuControl: TdxBarSubMenuControl; DC: HDC; R: TRect);
const
  DetachCaptionStates: array[Boolean] of Integer = (DXBAR_NORMAL, DXBAR_HOT);
begin
  Skin.DrawBackground(DC, R, DXBAR_MENUDETACHCAPTION, DetachCaptionStates[ABarSubMenuControl.DetachCaptionSelected]);
end;

procedure TdxBarSkinnedPainter.SubMenuControlDrawItemBackground(
  ABarSubMenuControl: TdxBarSubMenuControl; ACanvas: TcxCanvas; AItemRect: TRect);
var
  AContentRect, ABarRect, ABandRect, ASeparatorRect, AControlRect: TRect;
begin
  cxRectIntersect(AContentRect, ABarSubMenuControl.ContentRect, AItemRect);
  ABarRect := ABarSubMenuControl.BarRect;

  if ABarSubMenuControl.UseRightToLeftAlignment then
  begin
    ABandRect := Rect(ABarRect.Left - ABarSubMenuControl.BandSize, AContentRect.Top,
      ABarRect.Left, AContentRect.Bottom);
    ASeparatorRect := Rect(ABandRect.Left - MenuSeparatorSize, AContentRect.Top,
      ABandRect.Left, AContentRect.Bottom);
    AControlRect := Rect(AContentRect.Left, AContentRect.Top, ASeparatorRect.Left, AContentRect.Bottom);
  end
  else
  begin
    ABandRect := Rect(ABarRect.Right, AContentRect.Top,
      ABarRect.Right + ABarSubMenuControl.BandSize, AContentRect.Bottom);
    ASeparatorRect := Rect(ABandRect.Right, AContentRect.Top,
      ABandRect.Right + MenuSeparatorSize, AContentRect.Bottom);
    AControlRect := Rect(ASeparatorRect.Right, AContentRect.Top, AContentRect.Right, AContentRect.Bottom);
  end;

  if ABarSubMenuControl.ItemLinks.ItemSize = misNormal then
  begin
    Skin.DrawBackground(ACanvas.Handle, ABandRect, DXBAR_MENUGLYPH);
    Skin.DrawBackground(ACanvas.Handle, ASeparatorRect, DXBAR_MENUSEPARATORVERT);
  end
  else
  begin
    Skin.DrawBackground(ACanvas.Handle, ABandRect, DXBAR_MENUCONTENT);
    Skin.DrawBackground(ACanvas.Handle, ASeparatorRect, DXBAR_MENUCONTENT);
  end;
  Skin.DrawBackground(ACanvas.Handle, AControlRect, DXBAR_MENUCONTENT);
end;

class function TdxBarSkinnedPainter.SubMenuControlGetBandSize(ABarSubMenuControl: TdxBarSubMenuControl): Integer;
begin
  Result := SubMenuControlInternalBorderSize + ABarSubMenuControl.IconAreaSize - MenuSeparatorSize;
end;

class function TdxBarSkinnedPainter.SubMenuControlNormalItemHeight(AScaleFactor: TdxScaleFactor): Integer;
begin
  Result := AScaleFactor.Apply(22);
end;

class function TdxBarSkinnedPainter.SubMenuControlTextIndent: Integer;
begin
  Result := 7;
end;

class function TdxBarSkinnedPainter.SubMenuControlInternalBorderSize: Integer;
begin
  Result := 2;
end;

class function TdxBarSkinnedPainter.SubMenuControlInternalBorderOffset: Integer;
begin
  Result := 1;
end;

class function TdxBarSkinnedPainter.SubMenuControlTextSize(ACanvas: TcxCanvas; AScaleFactor: TdxScaleFactor): Integer;
begin
  Result := GetDefaultTextSize(ACanvas, AScaleFactor) +
    (SubMenuControlInternalBorderSize + AScaleFactor.Apply(SubMenuControlInternalBorderOffset)) * 2;
end;

class function TdxBarSkinnedPainter.SubMenuControlNCBorderSize: Integer;
begin
  Result := 2;
end;

class function TdxBarSkinnedPainter.SubMenuControlClientBorderSize: Integer;
begin
  Result := 0;
end;

procedure TdxBarSkinnedPainter.ApplicationMenuDrawButton(
  const ADrawParams: TdxBarApplicationMenuButtonControlDrawParams; var R: TRect);
const
  StateMap: array [Boolean] of Integer = (DXBAR_NORMAL, DXBAR_HOT);
var
  AImageBounds: TRect;
begin
  DrawBackground(ADrawParams.BarItemControl, ADrawParams.Canvas.Handle, R, 0, False);
  Skin.DrawBackground(ADrawParams.Canvas.Handle, R, DXBAR_APPLICATIONMENUBUTTON, StateMap[ADrawParams.DrawSelected]);
  Inc(R.Left, Max((cxRectWidth(R) - ADrawParams.ContentWidth) div 2, 0));

  DrawGlyph(ADrawParams.BarItemControl, ADrawParams.Canvas.Handle, R, R, AImageBounds,
    ADrawParams.PaintType, ADrawParams.ViewStructure, ADrawParams.ViewSize, not (cpIcon in ADrawParams.ViewStructure),
    ADrawParams.DrawSelected, False, False, False, False, False, False, False);
  DrawButtonLikeControlCaption(ADrawParams, R, AImageBounds);
end;

procedure TdxBarSkinnedPainter.ApplicationMenuDrawBackground(
  ABarSubMenuControl: TdxBarSubMenuControl; ACanvas: TcxCanvas; const R, AItemsArea: TRect);
begin
  ACanvas.SaveClipRegion;
  try
    ACanvas.ExcludeClipRect(AItemsArea);
    Skin.DrawBackgroundEx(ACanvas.Handle, R, AItemsArea, DXBAR_APPLICATIONMENU);
  finally
    ACanvas.RestoreClipRegion;
  end;
end;

function TdxBarSkinnedPainter.ApplicationMenuButtonTextColor(AEnabled, ASelected: Boolean): TColor;
begin
  Result := Skin.GetPartColor(DXBAR_APPLICATIONMENUBUTTON, GetMenuButtonState(AEnabled, ASelected));
end;

function TdxBarSkinnedPainter.ApplicationMenuContentButtonOffsets: TRect;
begin
  Result := Skin.GetContentOffsets(DXBAR_APPLICATIONMENUBUTTON);
end;

function TdxBarSkinnedPainter.ApplicationMenuGetFrameSizes: TRect;
begin
  Result := Skin.GetContentOffsets(DXBAR_APPLICATIONMENUCONTENT);
end;

function TdxBarSkinnedPainter.ExtraMenuButtonTextColor(AEnabled, ASelected: Boolean): TColor;
begin
  Result := Skin.GetPartColor(DXBAR_MENUEXTRAPANE_BUTTON_TEXTCOLOR, GetMenuButtonState(AEnabled, ASelected));
end;

procedure TdxBarSkinnedPainter.ExtraMenuControlDrawBackground(AExtraMenuControl: TCustomdxBarControl;
  ACanvas: TcxCanvas; ARect: TRect; ABrush: HBRUSH; AColor: TColor);
begin
  ExtraMenuControlDrawItemBackground(AExtraMenuControl, ACanvas, ARect);
end;

procedure TdxBarSkinnedPainter.ExtraMenuControlDrawBeginGroup(AExtraMenuControl: TCustomdxBarControl;
  ACanvas: TcxCanvas; ABeginGroupRect: TRect; AToolbarBrush: HBRUSH; AHorz: Boolean);
const
  PartMap: array[Boolean] of Integer =
    (DXBAR_MENUEXTRAPANE_SEPARATOR_VERT, DXBAR_MENUEXTRAPANE_SEPARATOR);
begin
  Skin.DrawBackground(ACanvas.Handle, ABeginGroupRect, PartMap[AHorz]);
end;

procedure TdxBarSkinnedPainter.ExtraMenuControlDrawItemBackground(
  AExtraMenuControl: TCustomdxBarControl; ACanvas: TcxCanvas; AItemRect: TRect);
var
  AExtraPaneRect, AContentRect, ASeparatorRect: TRect;
begin
  ACanvas.SaveClipRegion;
  try
    ACanvas.SetClipRegion(TcxRegion.Create(AItemRect), roIntersect);

    AExtraPaneRect := AExtraMenuControl.ClientRect;
    ASeparatorRect := Rect(AExtraPaneRect.Left, AExtraPaneRect.Top,
      AExtraPaneRect.Left + MenuSeparatorSize, AExtraPaneRect.Bottom);
    AContentRect := Rect(ASeparatorRect.Right, AExtraPaneRect.Top, AExtraPaneRect.Right, AExtraPaneRect.Bottom);
    if AExtraMenuControl.UseRightToLeftAlignment then
    begin
      ASeparatorRect := TdxRightToLeftLayoutConverter.ConvertRect(ASeparatorRect, AExtraPaneRect);
      AContentRect := TdxRightToLeftLayoutConverter.ConvertRect(AContentRect, AExtraPaneRect);
    end;
    Skin.DrawBackground(ACanvas.Handle, ASeparatorRect, DXBAR_MENUSEPARATORVERT);
    FillRectByColor(ACanvas.Handle, AContentRect, Skin.GetPartColor(DXBAR_MENUEXTRAPANE));
  finally
    ACanvas.RestoreClipRegion;
  end;
end;

procedure TdxBarSkinnedPainter.ExtraMenuDrawButton(ADrawParams: TdxBarExtraMenuButtonControlDrawParams; const ARect: TRect);
const
  ButtonStateMap: array[Boolean] of Integer = (DXBAR_NORMAL, DXBAR_HOT);
var
  AImageBounds: TRect;
begin
  Skin.DrawBackground(ADrawParams.Canvas.Handle, ARect, DXBAR_MENUEXTRAPANE_BUTTON,
    ButtonStateMap[ADrawParams.DrawSelected and (ADrawParams.HotPartIndex <> epbcpPinButton)]);

  DrawGlyph(ADrawParams.BarItemControl, ADrawParams.Canvas.Handle, ARect, ARect, AImageBounds,
    ADrawParams.PaintType, ADrawParams.ViewStructure, ADrawParams.ViewSize, not (cpIcon in ADrawParams.ViewStructure),
    ADrawParams.DrawSelected, False, False, False, False, False, False, False);
  DrawButtonLikeControlCaption(ADrawParams, ADrawParams.BarItemControl.FParts[epbcpButton], AImageBounds);
  ExtraMenuDrawPinButton(ADrawParams, ADrawParams.BarItemControl.FParts[epbcpPinButton]);
end;

procedure TdxBarSkinnedPainter.ExtraMenuDrawPinButton(
  ADrawParams: TdxBarExtraMenuButtonControlDrawParams; const ARect: TRect);
const
  PinStateMap: array[Boolean, Boolean] of Integer =
    ((DXBAR_NORMAL, DXBAR_CHECKED), (DXBAR_HOT, DXBAR_HOTCHECK));
begin
  Skin.DrawBackground(ADrawParams.Canvas.Handle, ARect, DXBAR_MENUEXTRAPANE_PINBUTTON,
    PinStateMap[ADrawParams.DrawSelected and (ADrawParams.HotPartIndex = epbcpPinButton), ADrawParams.Pin]);
end;

function TdxBarSkinnedPainter.ExtraMenuHeaderTextColor: TColor;
begin
  Result := Skin.GetPartColor(DXBAR_MENUEXTRAPANE_HEADER_TEXTCOLOR);
end;

function TdxBarSkinnedPainter.ExtraMenuPinButtonSize: Integer;
begin
  Result := Skin.GetPartSize(DXBAR_MENUEXTRAPANE_PINBUTTON);
end;

function TdxBarSkinnedPainter.EditButtonAllowOffsetContent: Boolean;
begin
  Result := False;
end;

function TdxBarSkinnedPainter.EditButtonAllowCompositeFrame: Boolean;
begin
  Result := Skin.GetName = '';
end;

class function TdxBarSkinnedPainter.EditButtonAllowHotTrack(const ADrawParams: TdxBarItemControlDrawParams): Boolean;
begin
  Result := True;
end;

function TdxBarSkinnedPainter.EditButtonIsCustomBorder: Boolean;
begin
  Result := Skin.GetName = '';
end;

function TdxBarSkinnedPainter.EditButtonIsCustomBackground(AState: Integer): Boolean;
begin
  Result := True;
end;

procedure TdxBarSkinnedPainter.EditButtonCorrectDefaultWidth(var ADefaultWidth: Integer);
begin
  Dec(ADefaultWidth);
end;

procedure TdxBarSkinnedPainter.EditButtonDrawBackground(
  const ADrawParams: TdxBarEditLikeControlDrawParams; AState: Integer; ARect: TRect; ABrush: HBrush);
begin
  FillRectByColor(ADrawParams.Canvas.Handle, ARect, EditGetBkColor(ADrawParams));
  Skin.DrawBackground(ADrawParams.Canvas.Handle, ARect, DXBAR_EDIT_BUTTON, AState);
end;

procedure TdxBarSkinnedPainter.EditButtonDrawBorder(
  const ADrawParams: TdxBarItemControlDrawParams; AState: Integer; var ADrawRect: TRect; out AContentRect: TRect);
begin
  AContentRect := EditControlGetContentRect(ADrawParams.PaintType, ADrawRect);
  if (Skin.GetName = '') and (AState in [DXBAR_HOT..DXBAR_HOTCHECK]) then
  begin
    with ADrawParams do
    begin
      Canvas.SaveClipRegion;
      Canvas.SetClipRegion(TcxRegion.Create(BarItemControl.ViewInfo.Bounds), roSet);
      Canvas.SetClipRegion(TcxRegion.Create(ADrawRect), roIntersect);
      FrameRectByColor(Canvas.Handle, ADrawRect,
        Skin.GetPartColor(DXBAR_EDIT_BUTTON_BORDER, AState));
      Canvas.RestoreClipRegion;
      ADrawRect := AContentRect;
    end;
  end;
end;

class function TdxBarSkinnedPainter.EditControlCaptionBackgroundIsOpaque(
  const ADrawParams: TdxBarEditLikeControlDrawParams): Boolean;
begin
  Result := False;
end;

class function TdxBarSkinnedPainter.EditControlCaptionRightIndentIsOpaque(
  const ADrawParams: TdxBarEditLikeControlDrawParams): Boolean;
begin
  Result := EditControlCaptionBackgroundIsOpaque(ADrawParams);
end;

procedure TdxBarSkinnedPainter.EditControlDrawBorder(
  const ADrawParams: TdxBarEditLikeControlDrawParams; var ARect: TRect);
begin
  if not ADrawParams.IsTransparent then
    FrameRectByColor(ADrawParams.Canvas.Handle, ARect, Skin.GetPartColor(DXBAR_EDIT_BORDER, GetEditPartState(ADrawParams, ecpEdit)));
  InflateRect(ARect, -1, -1);
end;

procedure TdxBarSkinnedPainter.EditControlDrawCaption(const ADrawParams: TdxBarEditLikeControlDrawParams);
begin
  if ADrawParams.ViewSize = cvsLarge then
    DrawMultilineCaption(ADrawParams, ADrawParams.BarEditControl.FParts[ecpText])
  else
    inherited;
end;

procedure TdxBarSkinnedPainter.EditControlDrawSelectionFrame(
  const ADrawParams: TdxBarEditLikeControlDrawParams; const ARect: TRect);

  procedure DrawSelection(AState: Integer);
  var
    AColor : TColor;
  begin
    with ADrawParams do
    begin
      Skin.DrawBackground(Canvas.Handle, ARect, DXBAR_SMALLBUTTON, AState);

      AColor := Skin.GetPartColor(DXBAR_MENUEDITSEPARATOR, AState);
      if ADrawParams.ViewLayout = ivlGlyphCaptionControl then
        Canvas.DrawComplexFrame(cxRectInflate(BarEditControl.GetEditRect, 0, -1),
          AColor, clNone, [bLeft])
      else
        Canvas.DrawComplexFrame(cxRectInflate(BarEditControl.GetEditRect, 0, -1),
          AColor, AColor, [bLeft, bRight]);
    end;
  end;

var
  AState: Integer;
begin
  with ADrawParams do
  begin
    Canvas.SaveClipRegion;
    Canvas.SetClipRegion(TcxRegion.Create(EditControlGetContentRect(PaintType, BarEditControl.GetEditRect)), roSubtract);
    try
      if Enabled then
        AState := DXBAR_ACTIVE
      else
        AState := DXBAR_ACTIVEDISABLED;
      DrawSelection(AState);
    finally
      Canvas.RestoreClipRegion;
    end;
  end;
end;

procedure TdxBarSkinnedPainter.EditControlDrawBackground(const ADrawParams: TdxBarEditLikeControlDrawParams);
begin
  with ADrawParams do
  begin
    Canvas.SaveClipRegion;
    Canvas.ExcludeClipRect(EditControlGetContentRect(PaintType, BarEditControl.GetEditRect));
    DrawBackground(BarEditControl, Canvas.Handle, BarEditControl.ItemBounds, 0, False);
    Canvas.RestoreClipRegion;
  end;
end;

procedure TdxBarSkinnedPainter.EditGetRealLookAndFeel(ABarManager: TdxBarManager; ALookAndFeel: TcxLookAndFeel);
begin
  ALookAndFeel.NativeStyle := False;
  ALookAndFeel.SkinName := Skin.GetName;
  if Skin.GetName = '' then
    if ABarManager.FThemeAvailable then
      ALookAndFeel.SetStyle(lfsNative)
    else
      inherited EditGetRealLookAndFeel(ABarManager, ALookAndFeel);
end;

function TdxBarSkinnedPainter.EditGetEnabledTextColor: Cardinal;
begin
  Result := Skin.GetPartColor(DXBAR_EDIT_TEXTCOLOR, DXBAR_NORMAL);
end;

function TdxBarSkinnedPainter.EditGetDisabledTextColor: Cardinal;
begin
  Result := Skin.GetPartColor(DXBAR_EDIT_TEXTCOLOR, DXBAR_DISABLED);
end;

function TdxBarSkinnedPainter.EditGetBkColor(
  const ADrawParams: TdxBarEditLikeControlDrawParams): COLORREF;
begin
  Result := Skin.GetPartColor(DXBAR_EDIT_BACKGROUND, GetEditPartState(ADrawParams, ecpEdit));
end;

class function TdxBarSkinnedPainter.EditControlShowIconDefault(
  const ADrawParams: TdxBarEditLikeControlDrawParams): Boolean;
begin
  Result := True;
end;

class function TdxBarSkinnedPainter.ComboControlArrowOffset: Integer;
begin
  Result := 0;
end;

class function TdxBarSkinnedPainter.ComboControlButtonOffsets(APaintType: TdxBarPaintType): TRect;
begin
  Result := cxEmptyRect;
end;

procedure TdxBarSkinnedPainter.ComboControlDrawArrowButton(
  const ADrawParams: TdxBarEditLikeControlDrawParams; ARect: TRect;
  AInClientArea: Boolean);
begin
  InternalDrawEditButton(ADrawParams, ccpDropButton, ARect);
end;

function TdxBarSkinnedPainter.ColorComboHasCompleteFrame: Boolean;
begin
  Result := True;
end;

function TdxBarSkinnedPainter.GetCustomColorButtonWidth(APaintType: TdxBarPaintType; const ARect: TRect): Integer;
begin
  if Skin.GetName <> '' then
    Result := 19
  else
    Result := inherited GetCustomColorButtonWidth(APaintType, ARect);
end;

function TdxBarSkinnedPainter.GetCustomColorButtonIndents(APaintType: TdxBarPaintType): TRect;
begin
  Result := cxEmptyRect;
end;

procedure TdxBarSkinnedPainter.ColorComboDrawCustomButton(
  const ADrawParams: TdxBarColorComboControlDrawParams; ARect: TRect);
begin
  InternalDrawEditButton(ADrawParams, clcpCustomColorButton, ARect);
end;

procedure TdxBarSkinnedPainter.ColorComboDrawCustomButtonAdjacentZone(
  const ADrawParams: TdxBarColorComboControlDrawParams; ARect: TRect);
begin
// do nothing
end;

function TdxBarSkinnedPainter.DateNavigatorHeaderColor: TColor;
begin
  Result := Skin.GetPartColor(DXBAR_DATENAVIGATOR_HEADER);
end;

class function TdxBarSkinnedPainter.InPlaceSubItemGetArrowWidth(const ADrawParams: TdxBarInPlaceSubItemControlDrawParams): Integer;
begin
  Result := ADrawParams.ArrowSize.cx;
end;

procedure TdxBarSkinnedPainter.InPlaceSubItemControlDrawArrow(const ADrawParams: TdxBarInPlaceSubItemControlDrawParams;
  ADirection: TcxArrowDirection; ARect: TRect);
begin
  ButtonLikeControlDrawMenuArrow(ADrawParams, ADirection, ARect);
end;

procedure TdxBarSkinnedPainter.InPlaceSubItemControlDrawBackground(const ADrawParams: TdxBarInPlaceSubItemControlDrawParams; ARect: TRect);
begin
  if ADrawParams.DrawSelected then
    DrawItemBackgroundInSubMenu(ADrawParams, ARect)
  else
    Skin.DrawBackground(ADrawParams.Canvas.Handle, ARect, DXBAR_MENUGLYPH);
end;

function TdxBarSkinnedPainter.CanUpdateBarPartly: Boolean;
begin
  Result := False;
end;

procedure TdxBarSkinnedPainter.ProgressControlDrawBackground(
  const ADrawParams: TdxBarItemControlDrawParams; var R: TRect);
begin
  inherited;
  Skin.DrawBackground(ADrawParams.Canvas.Handle, R, DXBAR_PROGRESSSUBSTRATE, DXBAR_NORMAL);
  InflateRect(R, -2, -2);
end;

procedure TdxBarSkinnedPainter.ProgressControlFillContent(
  const ADrawParams: TdxBarItemControlDrawParams; const R: TRect; ABarBrush: HBRUSH);
begin
  Skin.DrawBackground(ADrawParams.Canvas.Handle, R, DXBAR_PROGRESSSOLIDBAND, DXBAR_NORMAL);
end;

procedure TdxBarSkinnedPainter.ProgressControlFillDiscreteContent(
  const ADrawParams: TdxBarItemControlDrawParams; const R: TRect; ABarBrush: HBRUSH);
begin
  Skin.DrawBackground(ADrawParams.Canvas.Handle, R, DXBAR_PROGRESSDISCRETEBAND, DXBAR_NORMAL);
end;

function TdxBarSkinnedPainter.GetSpinEditArrowPos(
  const ADrawParams: TdxBarSpinEditDrawParams; ARect: TRect; AButtonIndex: Integer): TPoint;
var
  AYArrowOffset: Integer;
begin
  with ADrawParams do
  begin
    Result.X := ARect.Left + (cxRectWidth(ARect) div 2) - (ArrowSize.cx div 2);
    AYArrowOffset := (cxRectHeight(ARect) div 2) - (ArrowSize.cy div 2);
    if AButtonIndex = secButtonUp then
      Result.Y := ARect.Bottom - AYArrowOffset
    else
      Result.Y := ARect.Top + AYArrowOffset - 1;
  end;
end;

procedure TdxBarSkinnedPainter.SpinEditCorrectFrameRect(
  const ADrawParams: TdxBarItemControlDrawParams; var ARect: TRect);
begin
// do nothing;
end;

function TdxBarSkinnedPainter.GetSpinEditArrowSize(AHeight: Integer): TSize;
begin
  Result := Size(5, 3);
end;

function TdxBarSkinnedPainter.GetSpinEditButtonBounds(const ADrawParams: TdxBarSpinEditDrawParams; const ARect: TRect; AButton: TdxBarSpinEditButton): TRect;
begin
  Result := inherited GetSpinEditButtonBounds(ADrawParams, cxRectInflate(ARect, -1, -1), AButton);
end;

procedure TdxBarSkinnedPainter.SpinEditControlDrawButton(
  const ADrawParams: TdxBarSpinEditDrawParams; ARect: TRect; AButtonIndex: Integer);

  procedure DrawButtonFrame(AState: Integer; var ARect: TRect; out AContentRect: TRect);
  begin
    AContentRect := cxRectInflate(ARect, -1, -1);
    if AState in [DXBAR_NORMAL, DXBAR_DISABLED, DXBAR_ACTIVE, DXBAR_ACTIVEDISABLED] then
    begin
      if AButtonIndex = secButtonUp then
        Inc(ARect.Bottom)
      else
        Dec(ARect.Top);
    end
    else
      FrameRectByColor(ADrawParams.Canvas.Handle, ARect, Skin.GetPartColor(DXBAR_EDIT_BUTTON_BORDER, AState));
    InflateRect(ARect, -1, -1);
  end;

var
  AEditButtonState: Integer;
  AArrowPos: TPoint;
  AContentRect: TRect;
  APart: Integer;
begin
  with ADrawParams do
  begin
    AEditButtonState := GetSpinEditPartState(TdxBarSpinEditDrawParams(BarEditControl.DrawParams), AButtonIndex);
    if Skin.GetName = '' then
      DrawButtonFrame(AEditButtonState, ARect, AContentRect);
    EditButtonDrawBackground(ADrawParams, AEditButtonState, ARect, 0);
    if Skin.GetName <> '' then
    begin
      if AButtonIndex = secButtonUp then
        APart := DXBAR_SPINEDIT_UPBUTTON
      else
        APart := DXBAR_SPINEDIT_DOWNBUTTON;
      Skin.DrawBackground(ADrawParams.Canvas.Handle, ARect, APart, AEditButtonState);
    end
    else
    begin
      AArrowPos := GetSpinEditArrowPos(ADrawParams, AContentRect, AButtonIndex);
      DrawSpinEditArrow(ADrawParams, AArrowPos, AButtonIndex);
    end;
  end;
end;

procedure TdxBarSkinnedPainter.SpinEditControlDrawButtonsAdjacentZone(const ADrawParams: TdxBarSpinEditDrawParams; const ARect: TRect);
begin
  if Skin.GetName = '' then
    SpinEditControlDrawButtonsExternalFrame(ADrawParams, ARect);
end;

procedure TdxBarSkinnedPainter.SpinEditControlDrawButtonsExternalFrame(const ADrawParams: TdxBarSpinEditDrawParams; ARect: TRect);
var
  AEditState: Integer;
  AColor: TColor;
begin
  with ADrawParams do
  begin
    AEditState := GetEditPartState(ADrawParams, ecpEdit);

    if not (HotPartIndex in ecpHeaderParts) and (HotPartIndex <> icpNone) then
      AColor := Skin.GetPartColor(DXBAR_EDIT_BUTTON_BORDER, DXBAR_ACTIVE)
    else
      if AEditState = DXBAR_DISABLED then
        AColor := Skin.GetPartColor(DXBAR_EDIT_BACKGROUND, DXBAR_DISABLED)
      else
        AColor := Skin.GetPartColor(DXBAR_EDIT_BACKGROUND, DXBAR_NORMAL);
    FrameRectByColor(Canvas.Handle, ARect, AColor);
  end;
end;

function TdxBarSkinnedPainter.GetSpinEditButtonIndents(APaintType: TdxBarPaintType): TRect;
begin
  Result := cxEmptyRect;
end;

function TdxBarSkinnedPainter.GetSpinEditButtonWidth(APaintType: TdxBarPaintType; const ARect: TRect): Integer;
begin
  if Skin.GetName <> '' then
    Result := 17
  else
  begin
    Result := cxRectHeight(ARect) div 2 * 8 div 5 + 1;
    Result := Result - GetSpinEditButtonIndents(APaintType).Left -
      GetSpinEditButtonIndents(APaintType).Right;
  end;
end;

procedure TdxBarSkinnedPainter.DrawStaticBorder(const ADrawParams: TdxBarStaticLikeControlDrawParams; var ARect: TRect);
begin
  with ADrawParams do
  begin
    if BorderStyle = sbsNone then Exit;
    Canvas.FrameRect(ARect, Skin.GetPartColor(DXBAR_EDIT_BORDER));
    InflateRect(ARect, -1, -1);
  end;
end;

class function TdxBarSkinnedPainter.StaticBackgroundIsOpaque(const ADrawParams: TdxBarItemControlDrawParams): Boolean;
begin
  Result := False;
end;

procedure TdxBarSkinnedPainter.SeparatorControlGetTextColors(
  ABarItemControl: TdxBarItemControl; AEnabled, ASelected, AFlat: Boolean;
  var AColor1, AColor2: TColor);
const
  StateMap: array [Boolean] of Integer = (DXBAR_DISABLED, DXBAR_NORMAL);
begin
  AColor1 := Skin.GetPartColor(DXBAR_SEPARATOR_TEXTCOLOR, StateMap[AEnabled]);
  AColor2 := AColor1;
end;

function TdxBarSkinnedPainter.SeparatorControlSeparatorSize: Integer;
begin
  Result := Skin.GetPartSize(DXBAR_SEPARATOR_LINE);
end;

procedure TdxBarSkinnedPainter.DrawSeparatorControlLine(ACanvas: TcxCanvas; const R: TRect);
begin
  Skin.DrawBackground(ACanvas.Handle, R, DXBAR_SEPARATOR_LINE);
end;

procedure TdxBarSkinnedPainter.DrawSeparatorGlyphAndCaption(
  const ADrawParams: TdxBarSeparatorControlDrawParams; const ARect: TRect);
var
  ACaptionRect: TRect;
begin
  with ADrawParams do
  begin
    Skin.DrawBackground(Canvas.Handle, ARect, DXBAR_SEPARATOR_BACKGROUND);
    ACaptionRect := ARect;
    ACaptionRect.Left := ACaptionRect.Left +
      SeparatorControlGetIndents(ADrawParams, cpText).Left;
    if Canvas.UseRightToLeftAlignment then
      ACaptionRect := TdxRightToLeftLayoutConverter.ConvertRect(ACaptionRect, ARect);
    DrawItemText(BarItemControl, Canvas.Handle, Caption, ACaptionRect,
      SystemAlignmentsHorz[Alignment], Enabled, False, PaintType = ptVert, True,
      False);
  end;
end;

function TdxBarSkinnedPainter.ScreenTipGetDescriptionTextColor: TColor;
begin
  Result := Skin.GetPartColor(DXBAR_SCREENTIP_DESCRIPTION);
end;

function TdxBarSkinnedPainter.ScreenTipGetTitleTextColor: TColor;
begin
  Result := Skin.GetPartColor(DXBAR_SCREENTIP_TITLE);
end;

procedure TdxBarSkinnedPainter.ScreenTipDrawBackground(ACanvas: TcxCanvas; ARect: TRect);
begin
  Skin.DrawBackground(ACanvas.Handle, ARect, DXBAR_SCREENTIP);
end;

procedure TdxBarSkinnedPainter.ScreenTipDrawFooterLine(ACanvas: TcxCanvas; const ARect: TRect);
var
  R: TRect;
begin
  R := cxRectSetHeight(ARect, 1);
  FillRectByColor(ACanvas.Handle, R, Skin.GetPartColor(DXBAR_SCREENTIP_FOOTERLINE));
  OffsetRect(R, 0, 1);
  FillRectByColor(ACanvas.Handle, R, clWhite);
end;

procedure TdxBarSkinnedPainter.DrawToolbarContentPart(
  ABarControl: TdxBarControl; ACanvas: TcxCanvas);
var
  APrevWindowOrg: TPoint;
  DC: HDC;
  R: TRect;
begin
  DC := ACanvas.Handle;
  with ABarControl.NCOffset do
    OffsetWindowOrgEx(DC, X, Y, APrevWindowOrg);
  R := ABarControl.NCRect;
  try
    Skin.DrawBackground(DC, R,
      GetToolbarSkinPart(ABarControl), GetBarControlState(ABarControl));
  finally
    SetWindowOrgEx(DC, APrevWindowOrg.X, APrevWindowOrg.Y, nil);
  end;
end;

procedure TdxBarSkinnedPainter.DrawToolbarNonContentPart(
  ABarControl: TdxBarControl; DC: HDC);
begin
  with ABarControl.ClientBounds do
    ExcludeClipRect(DC, Left, Top, Right, Bottom);
  Skin.DrawBackground(DC, ABarControl.NCRect, GetToolbarSkinPart(ABarControl),
    GetBarControlState(ABarControl));
  DrawToolbarNonContentPartCaption(ABarControl, DC);
end;

procedure TdxBarSkinnedPainter.DrawToolbarNonContentPartCaption(ABarControl: TdxBarControl; DC: HDC);
var
  ACaptionRect, R: TRect;
  ASkinPart: Integer;
begin
  ASkinPart := GetToolbarSkinPart(ABarControl);
  ACaptionRect := Skin.GetCaptionRect(ABarControl.NCRect, ASkinPart);
  R := ACaptionRect;
  if ABarControl.HasCaptionButtons then
  begin
    R.Right := R.Right - cxRectWidth(ABarControl.CaptionButtons.Rect) - Skin.GetContentOffsets(ASkinPart).Right;
    if ABarControl.UseRightToLeftAlignment then
      R := TdxRightToLeftLayoutConverter.ConvertRect(R, ACaptionRect)
  end;
  Skin.DrawCaption(DC, ABarControl.GetCaption, R, ASkinPart, GetBarControlState(ABarControl));
end;

class function TdxBarSkinnedPainter.GetDefaultArrowSignSize(AScaleFactor: TdxScaleFactor): TSize;
begin
  Result := AScaleFactor.Apply(cxSize(5, 4));
end;

class function TdxBarSkinnedPainter.GetControlTextIndents: TRect;
begin
  Result := Rect(3, 0, 2, 0);
end;

class function TdxBarSkinnedPainter.GetControlCaptionRectCore(const ADrawParams: TdxBarItemControlDrawParams): TRect;
begin
  if (ADrawParams.ViewSize = cvsLarge) and (ADrawParams.PaintType <> ptMenu) then
    Result := cxGetTextRect(ADrawParams.Canvas.Handle, ADrawParams.Caption + GetTextInsteadArrow(ADrawParams), GetMaxLineCount, True)
  else
    Result := inherited GetControlCaptionRectCore(ADrawParams);
end;

function TdxBarSkinnedPainter.GetLargeImageBounds(AItemControl: TdxBarItemControl; const AImageSize: TSize;
  const ADrawRect: TRect; APaintType: TdxBarPaintType; AViewStructure: TdxBarItemControlViewStructure): TRect;

  function GetImageOffset(const AImageSize: TSize): TPoint;
  var
    ACaptionRect: TRect;
  begin
    ACaptionRect := GetControlCaptionRect(AItemControl.DrawParams);
    Result.x := (ADrawRect.Left + ADrawRect.Right - AImageSize.cx) div 2;
    Result.y := (ADrawRect.Top + ADrawRect.Bottom - cxRectHeight(ACaptionRect) - AImageSize.cy) div 2;
  end;

begin
  Result := cxRectBounds(GetImageOffset(AImageSize), AImageSize.cx, AImageSize.cy);
end;

function TdxBarSkinnedPainter.GetDefaultEnabledTextColor(
  ABarItemControl: TdxBarItemControl; ASelected, AFlat: Boolean): TColor;
const
  ButtonItemTextPartMap: array [TdxBarPaintType] of Integer =
    (DXBAR_BUTTONITEMTEXT, DXBAR_MENUBUTTONITEMTEXT, DXBAR_BUTTONITEMTEXT);
  ItemTextPartMap: array [TdxBarPaintType] of Integer =
    (DXBAR_ITEMTEXT, DXBAR_MENUITEMTEXT, DXBAR_ITEMTEXT);
var
  APart: Integer;
begin
  if ABarItemControl is TdxBarButtonLikeControl then
    APart := ButtonItemTextPartMap[ABarItemControl.GetPaintType]
  else
    APart := ItemTextPartMap[ABarItemControl.GetPaintType];

  Result := Skin.GetPartColor(APart, GetTextPartState(ABarItemControl.FDrawParams));
end;

procedure TdxBarSkinnedPainter.GetDisabledTextColors(
  ABarItemControl: TdxBarItemControl; ASelected, AFlat: Boolean; var AColor1, AColor2: TColor);
begin
  AColor1 := GetDefaultEnabledTextColor(ABarItemControl, ASelected, AFlat);
  AColor2 := AColor1;
end;

function TdxBarSkinnedPainter.GetToolbarCaptionRect(ABarControl: TdxBarControl; const ARect: TRect): TRect;
begin
  Result := Skin.GetCaptionRect(ARect, GetToolbarSkinPart(ABarControl));
end;

function TdxBarSkinnedPainter.GetToolbarSkinPart(ABarControl: TdxBarControl): Integer;
begin
  if (ABarControl <> nil) and ABarControl.IsPopup then
    Result := DXBAR_TOOLBARINPOPUP
  else
    Result := DXBAR_TOOLBAR;
end;

procedure TdxBarSkinnedPainter.InflateSizeForArrow(
  const ADrawParams: TdxBarButtonLikeControlDrawParams; var ASize: Integer);
begin
  if (ADrawParams.PaintType <> ptMenu) and (ADrawParams.ViewSize = cvsSmall) and ADrawParams.IsDropDown then
    if ADrawParams.SplitDropDown then
      Inc(ASize, GetControlTextIndents.Right + ADrawParams.ArrowSize.cx)
    else
      Inc(ASize, ADrawParams.ArrowSize.cx);
end;

class function TdxBarSkinnedPainter.IsCompoundPainting: Boolean;
begin
  Result := True;
end;

function TdxBarSkinnedPainter.GetButtonPartState(
  const ADrawParams: TdxBarButtonLikeControlDrawParams; AControlPart: Integer): Integer;

  function GetCustomizingButtonPartState: Integer;
  begin
    if ADrawParams.Downed then
      Result := DXBAR_CHECKED
    else
      if ADrawParams.DroppedDown then
        Result := DXBAR_DROPPEDDOWN
      else
        Result := DXBAR_NORMAL;
  end;

  function GetCustomButtonPartState: Integer;
  begin
    if ADrawParams.IsPressed then
      Result := DXBAR_PRESSED
    else
      if ADrawParams.Downed then
      begin
        if ADrawParams.DroppedDown then
          Result := DXBAR_ACTIVE
        else
          if (ADrawParams.HotPartIndex = AControlPart) or
            ADrawParams.SelectedByKey and not ADrawParams.IsDropDown
          then
            Result := DXBAR_HOTCHECK
          else
            Result := DXBAR_CHECKED
      end
      else
        if not ADrawParams.DroppedDown then
          Result := GetPartState(ADrawParams, AControlPart)
        else
          if ADrawParams.IsDropDown and ADrawParams.SplitDropDown then
            Result := DXBAR_ACTIVE
          else
            Result := DXBAR_DROPPEDDOWN;
  end;

  function GetDropButtonPartState: Integer;
  begin
    if ADrawParams.DroppedDown then
      Result := DXBAR_DROPPEDDOWN
    else
      if ADrawParams.Downed and (ADrawParams.HotPartIndex = icpNone) and not ADrawParams.SelectedByKey then
        Result := DXBAR_CHECKED
      else
        Result := GetPartState(ADrawParams, AControlPart);
  end;

begin
  if ADrawParams.IsCustomizing then
    Result := GetCustomizingButtonPartState
  else
    case AControlPart of
      bcpButton:
        Result := GetCustomButtonPartState;
      bcpDropButton:
        Result := GetDropButtonPartState
      else
        Result := DXBAR_NORMAL;
    end;
end;

function TdxBarSkinnedPainter.GetGlyphState(ABarItemControl: TdxBarItemControl;
  ASelected, ADowned, ADrawDowned, ADroppedDown: Boolean): Integer;
begin
  if not ABarItemControl.Enabled then
    Result := DXBAR_DISABLED
  else
    if ADowned or ADrawDowned or ADroppedDown then
      Result := DXBAR_PRESSED
    else
      if ASelected then
        Result := DXBAR_HOT
      else
        Result := DXBAR_NORMAL;
end;

function TdxBarSkinnedPainter.GetGlyphColorPalette(ABarItemControl: TdxBarItemControl;
  APaintType: TdxBarPaintType; ASelected, ADowned, ADrawDowned, ADroppedDown, AIsSplit: Boolean): IdxColorPalette;
begin
  Result := GetGlyphColorPalette(ABarItemControl, APaintType,
    GetGlyphState(ABarItemControl, ASelected, ADowned, ADrawDowned, ADroppedDown));
end;

function TdxBarSkinnedPainter.GetGlyphColorPalette(
  ABarItemControl: TdxBarItemControl; APaintType: TdxBarPaintType; AState: Integer): IdxColorPalette;
begin
  Result := nil;
end;

class function TdxBarSkinnedPainter.GetEditPartState(const ADrawParams: TdxBarEditLikeControlDrawParams; AControlPart: Integer): Integer;
begin
  Result := DXBAR_NORMAL;
  if not ADrawParams.IsCustomizing then
    case AControlPart of
      ecpEdit:
        if ADrawParams.DroppedDown then
          Result := DXBAR_DROPPEDDOWN
        else
          if ADrawParams.Focused then
            Result := DXBAR_FOCUSED
          else
            Result := GetPartState(ADrawParams, AControlPart);

      ccpDropButton:
        if ADrawParams.DroppedDown then
          Result := DXBAR_DROPPEDDOWN
        else
          if ADrawParams.IsPressed and (ADrawParams.HotPartIndex = AControlPart) or ADrawParams.Focused then
            Result := DXBAR_HOT
          else
            Result := GetPartState(ADrawParams, AControlPart);

      clcpCustomColorButton:
        if ADrawParams.IsPressed then
          Result := DXBAR_PRESSED
        else
          if ADrawParams.DroppedDown or ADrawParams.Focused then
            Result := DXBAR_HOT
          else
            Result := GetPartState(ADrawParams, AControlPart);
    end;
end;

class function TdxBarSkinnedPainter.GetSpinEditPartState(const ADrawParams: TdxBarSpinEditDrawParams; AControlPart: Integer): Integer;
begin
  if ADrawParams.IsCustomizing then
    Result := DXBAR_NORMAL
  else
    if (AControlPart = ADrawParams.ActiveButtonIndex) and (AControlPart = ADrawParams.HotPartIndex) then
      Result := DXBAR_DROPPEDDOWN
    else
    begin
      Result := GetPartState(ADrawParams, AControlPart);
      if (Result = DXBAR_ACTIVE) and ((ADrawParams.HotPartIndex = icpNone) or (ADrawParams.HotPartIndex in ecpHeaderParts)) then
        Result := DXBAR_NORMAL;
    end;
end;

class function TdxBarSkinnedPainter.GetPartState(const ADrawParams: TdxBarItemControlDrawParams; AControlPart: Integer): Integer;
const
  ActiveStateMap: array[Boolean] of Integer = (DXBAR_ACTIVEDISABLED, DXBAR_ACTIVE);
  NormalStateMap: array[Boolean] of Integer = (DXBAR_DISABLED, DXBAR_NORMAL);
begin
  if (ADrawParams.HotPartIndex = AControlPart) and ADrawParams.CanSelect then
    Result := DXBAR_HOT
  else
    if ADrawParams.CanSelect and ADrawParams.DrawSelected or (ADrawParams.HotPartIndex <> icpNone) then
      Result := ActiveStateMap[ADrawParams.Enabled]
    else
      if (ADrawParams is TdxBarButtonLikeControlDrawParams) and TdxBarButtonLikeControlDrawParams(ADrawParams).Downed then
        Result := DXBAR_CHECKED
      else
        Result := NormalStateMap[ADrawParams.Enabled];
end;

class function TdxBarSkinnedPainter.GetTextPartState(const ADrawParams: TdxBarItemControlDrawParams): Integer;
begin
  if ADrawParams.Enabled then
    Result := GetPartState(ADrawParams, icpControl)
  else
    Result := DXBAR_DISABLED;
end;

function TdxBarSkinnedPainter.GetBarControlState(ABarControl: TdxBarControl): Integer;
const
  BarControlStates: array [TdxBarViewState] of Integer = (DXBAR_NORMAL, DXBAR_HOT);
begin
  Result := BarControlStates[ABarControl.ViewState];
end;

function TdxBarSkinnedPainter.GetBarItemControlFadingOptions: TdxFadingOptions;
begin
  Result := Skin.GetBarItemControlFadingOptions;
end;

function TdxBarSkinnedPainter.CreateHintViewInfo(ABarManager: TdxBarManager;
  AHintText: string; const AShortCut: string; AScreenTip: TdxScreenTip): TdxBarCustomHintViewInfo;
begin
  Result := dxBarCreateScreenTipViewInfo(ABarManager, AHintText, AShortCut, AScreenTip, Self);
end;

function TdxBarSkinnedPainter.IsCustomHintSupported: Boolean;
begin
  Result := False;
end;

procedure TdxBarSkinnedPainter.DrawMultilineCaption(const ADrawParams: TdxBarItemControlDrawParams; const ATextRect: TRect);
begin
  with ADrawParams do
    cxDrawMultilineText(Canvas, Caption, ATextRect, DT_CENTER,
      Skin.GetPartColor(DXBAR_ITEMTEXT, GetTextPartState(ADrawParams)));
end;

procedure TdxBarSkinnedPainter.ButtonLikeControlDrawCaption(
  const ADrawParams: TdxBarButtonLikeControlDrawParams;
  const ATextBounds: TRect; ATextAlignment, AFormat: DWORD);

  procedure DrawArrowInEnd(ALastLine: string; var ARectOut: TRect);
  var
    ATextRect, AArrowRect, ATextArrowRect: TRect;
  begin
    if ALastLine <> '' then
    begin
      ATextRect := cxGetTextRect(ADrawParams.Canvas.Handle, ALastLine, 1);

      ALastLine := ALastLine + GetTextInsteadArrow(ADrawParams);
      ATextArrowRect := cxGetTextRect(ADrawParams.Canvas.Handle, ALastLine, 1);

      ARectOut := cxRectOffset(ATextArrowRect,
        ARectOut.Left + (cxRectWidth(ARectOut) - cxRectWidth(ATextArrowRect)) div 2,
        ARectOut.Top);

      AArrowRect := ARectOut;
      AArrowRect.Left := AArrowRect.Right - GetDefaultArrowSignSize(ADrawParams.ScaleFactor).cx;
      ARectOut.Right := ARectOut.Left + cxRectWidth(ATextRect);
      if ADrawParams.UseRightToLeftAlignment then
      begin
        AArrowRect := TdxRightToLeftLayoutConverter.ConvertRect(AArrowRect, ATextBounds);
        ARectOut := TdxRightToLeftLayoutConverter.ConvertRect(ARectOut, ATextBounds);
      end;
    end
    else
      AArrowRect := ARectOut;

    DrawArrow(ADrawParams.Canvas.Handle, AArrowRect, GetButtonPartState(ADrawParams, bcpDropButton), ADrawParams.ScaleFactor);
  end;

var
  ALines: TStrings;
  I, ATextHeight: Integer;
  ARectOut: TRect;
  AColor1, AColor2: TColor;
begin
  with ADrawParams do
  begin
    SetBkMode(Canvas.Handle, TRANSPARENT);
    if BarItemControl <> nil then
      BarItemControl.GetTextColors(Enabled, DrawSelected, IsFlatText, AColor1, AColor2)
    else
      AColor1 := Skin.GetPartColor(DXBAR_BUTTONITEMTEXT, GetTextPartState(ADrawParams));

    SetTextColor(Canvas.Handle, ColorToRGB(AColor1));

    if ADrawParams.UseRightToLeftAlignment then
      case ATextAlignment of
        DT_LEFT:
          ATextAlignment := DT_RIGHT;
        DT_RIGHT:
          ATextAlignment := DT_LEFT;
      end;

    if ADrawParams.Canvas.TextFlags and ETO_RTLREADING <> 0 then
      AFormat := AFormat or DT_RTLREADING;

    ARectOut := ATextBounds;
    if ViewSize = cvsLarge then
    begin
      ALines := TStringList.Create;
      try
        cxGetTextLines(Caption, Canvas, ATextBounds, ALines);
        for I := ALines.Count + 1 to GetMaxLineCount do
          ALines.Add('');

        ATextHeight := cxTextHeight(Canvas.Handle);
        ARectOut.Bottom := ARectOut.Top + ATextHeight;

        for I := 0 to ALines.Count - 1 do
        begin
          if (I = ALines.Count - 1) and IsDropDown then
            DrawArrowInEnd(ALines[I], ARectOut);
          DoDrawText(Canvas.Handle, ALines[I], ARectOut, ATextAlignment or AFormat);
          OffsetRect(ARectOut, 0, ATextHeight);
        end;
      finally
        ALines.Free;
      end;
    end
    else
      DoDrawText(Canvas.Handle, Caption, ARectOut, ATextAlignment or AFormat);

    SetBkMode(Canvas.Handle, OPAQUE);
  end;
end;

procedure TdxBarSkinnedPainter.ButtonLikeControlDrawMenuArrow(
  const ADrawParams: TdxBarButtonLikeControlDrawParams; ADirection: TcxArrowDirection; ARect: TRect);
var
  AArrowSize: TSize;
  APart: Integer;
begin
  if ADrawParams.UseRightToLeftAlignment then
    case ADirection of
      adLeft:
        ADirection := adRight;
      adRight:
        ADirection := adLeft;
    end;
  case ADirection of
    adRight:
      APart := DXBAR_MENUARROWRIGHT;
    adLeft:
      APart := DXBAR_MENUBACKBUTTON;
  else
    APart := DXBAR_MENUARROWDOWN;
  end;

  AArrowSize.cx := LoWord(Skin.GetPartSize(APart));
  AArrowSize.cy := HiWord(Skin.GetPartSize(APart));
  Skin.DrawBackground(ADrawParams.Canvas.Handle, cxRectCenter(GetArrowRect(ADrawParams, ARect), AArrowSize), APart, DXBAR_NORMAL);
end;

class function TdxBarSkinnedPainter.GetGlyphLayout(const ADrawParams: TdxBarButtonLikeControlDrawParams): TdxBarGlyphLayout;
begin
  if ADrawParams.ViewSize = cvsLarge then
    Result := glTop
  else
    Result := glLeft;
end;

procedure TdxBarSkinnedPainter.DrawSpinEditArrow(const ADrawParams: TdxBarSpinEditDrawParams; AArrowPos: TPoint; AButtonIndex: Integer);
var
  P: TcxArrowPoints;
  AArrowDirection: TcxArrowDirection;
  AEditButtonState: Integer;
begin
  case AButtonIndex of
    secButtonUp: AArrowDirection := adUp;
  else {secButtonDown}
    AArrowDirection := adDown;
  end;
  AEditButtonState := GetSpinEditPartState(TdxBarSpinEditDrawParams(ADrawParams.BarEditControl.DrawParams), AButtonIndex);

  CalculateArrowPoints(ADrawParams.BarEditControl.FParts[AButtonIndex], ADrawParams.ArrowSize.cy, AArrowDirection, P);
  ADrawParams.Canvas.SaveClipRegion;
  try
    SetArrowRegion(ADrawParams.Canvas, AArrowDirection, P, roSet);
    Skin.DrawBackground(ADrawParams.Canvas.Handle, GetArrowRectByPoints(P, AArrowDirection), DXBAR_SCROLLARROW, AEditButtonState);
  finally
    ADrawParams.Canvas.RestoreClipRegion;
  end;
  SetArrowRegion(ADrawParams.Canvas, AArrowDirection, P, roSubtract);
end;

procedure TdxBarSkinnedPainter.SubMenuControlDrawMarkContent(ABarSubMenuControl: TdxBarSubMenuControl;
  DC: HDC; R: TRect; ASelected: Boolean);
begin
  Skin.DrawBackground(DC, SubMenuControlMarkContentRect(R), DXBAR_MENUMARK);
end;

procedure TdxBarSkinnedPainter.SubMenuControlDrawMarkSelection(
  ABarSubMenuControl: TdxBarSubMenuControl; ADC: HDC; const AMarkRect: TRect);
begin
  Skin.DrawBackground(ADC, AMarkRect, DXBAR_SMALLBUTTON, DXBAR_HOT);
end;

procedure TdxBarSkinnedPainter.SubMenuControlFillScrollArrow(ACanvas: TcxCanvas; ARect: TRect; AColor: TColor);
begin
  Skin.DrawBackground(ACanvas.Handle, ARect, DXBAR_SCROLLARROW);
end;

function TdxBarSkinnedPainter.SubMenuControlGetScrollBandSize(ABarSubMenuControl: TdxBarSubMenuControl): Integer;
begin
  Result := inherited SubMenuControlGetScrollBandSize(ABarSubMenuControl);
  Result := (Result - 6) * 3 div 4;
end;

class function TdxBarSkinnedPainter.SubMenuControlGetScrollArrowSize(ATextSize: Integer): Integer;
begin
  Result := ATextSize div 7;
end;

function TdxBarSkinnedPainter.GetSkin: IdxSkin;
begin
  Supports(FSkinnedObject, IdxSkin, Result);
end;

function TdxBarSkinnedPainter.BarMarkIsOpaque: Boolean;
begin
  Result := False;
end;

procedure TdxBarSkinnedPainter.DrawBarMarkState(ABarControl: TdxBarControl; DC: HDC; const R: TRect; AState: TdxBarMarkState);
const
  StatesMap: array[TdxBarMarkState] of Integer = (DXBAR_NORMAL, DXBAR_ACTIVE, DXBAR_PRESSED);
begin
  if AState <> msNone then
    Skin.DrawBackground(DC, R, DXBAR_SMALLBUTTON, StatesMap[AState]);
end;

procedure TdxBarSkinnedPainter.DrawButtonBackground(const ADrawParams: TdxBarButtonLikeControlDrawParams);

  procedure InternalDrawBackground(AControlPart, ASkinPart: Integer);

    function GetButtonGroupPosition: TdxBarButtonGroupRealPosition;
    begin
      Result := ADrawParams.ButtonGroup;
      if ADrawParams.SplitDropDown and ADrawParams.IsDropDown then
        case AControlPart of
          bcpButton:
            case Result of
              bgrpFinish:
                Result := bgrpMember;
              bgrpSingle:
                Result := bgrpStart;
            end;

          bcpDropButton:
            case Result of
              bgrpStart:
                Result := bgrpMember;
              bgrpSingle:
                Result := bgrpFinish;
            end;
        end
    end;

    procedure CalculateRects(var APartRect: TRect; out ALeftBorderRect, ARightBorderRect, AMiddleButtonRect, ASplitRect: TRect);
    var
      AButtonGroupRealPosition: TdxBarButtonGroupRealPosition;
    begin
      ALeftBorderRect := APartRect;
      ALeftBorderRect.Right := ALeftBorderRect.Left + Skin.GetPartSize(DXBAR_BUTTONGROUPBORDERLEFT);

      ASplitRect := cxRectSetWidth(APartRect, 0);
      ASplitRect := cxRectCenterHorizontally(ASplitRect, Skin.GetPartSize(DXBAR_BUTTONGROUPSPLITBUTTONSEPARATOR));

      ARightBorderRect := APartRect;
      ARightBorderRect.Left := ARightBorderRect.Right - Skin.GetPartSize(DXBAR_BUTTONGROUPBORDERRIGHT);

      AMiddleButtonRect := APartRect;
      AMiddleButtonRect.Left := AMiddleButtonRect.Right - 1;

      AButtonGroupRealPosition := GetButtonGroupPosition;

      if ADrawParams.UseRightToLeftAlignment then
        case AButtonGroupRealPosition of
          bgrpStart:
            AButtonGroupRealPosition := bgrpFinish;
          bgrpFinish:
            AButtonGroupRealPosition := bgrpStart;
        end;

      case AButtonGroupRealPosition of
        bgrpNone:
          begin
            ALeftBorderRect := cxEmptyRect;
            ARightBorderRect := cxEmptyRect;
            ASplitRect := cxEmptyRect;
            AMiddleButtonRect := cxEmptyRect;
          end;
        bgrpStart:
          begin
            ARightBorderRect := cxEmptyRect;
            APartRect.Left := APartRect.Left + 1;
          end;
        bgrpMember:
          begin
            ALeftBorderRect := cxEmptyRect;
            ARightBorderRect := cxEmptyRect;
          end;
        bgrpFinish:
          begin
            ALeftBorderRect := cxEmptyRect;
            AMiddleButtonRect := cxEmptyRect;

            APartRect.Right := APartRect.Right - 1;
          end;
        bgrpSingle:
          begin
            AMiddleButtonRect := cxEmptyRect;

            APartRect.Left := APartRect.Left + 1;
            APartRect.Right := APartRect.Right - 1;
         end;
      end;
    end;

    procedure DoDraw(ABounds: TRect; AControlPart: Integer);
    var
      APartState: Integer;
      ALeftBorderRect, ARightBorderRect, AMiddleButtonRect, ASplitRect: TRect;
    begin
      with ADrawParams do
      begin
        APartState := GetButtonPartState(ADrawParams, AControlPart);
        CalculateRects(ABounds, ALeftBorderRect, ARightBorderRect, AMiddleButtonRect, ASplitRect);
        Skin.DrawBackground(Canvas.Handle, ABounds, ASkinPart, APartState);
        Skin.DrawBackground(Canvas.Handle, ALeftBorderRect, DXBAR_BUTTONGROUPBORDERLEFT);
        Skin.DrawBackground(Canvas.Handle, ARightBorderRect, DXBAR_BUTTONGROUPBORDERRIGHT);
        if SplitDropDown and IsDropDown then
        begin
          if AControlPart = bcpDropButton then
          begin
            Skin.DrawBackground(Canvas.Handle, ASplitRect, DXBAR_BUTTONGROUPSPLITBUTTONSEPARATOR, APartState);
            Skin.DrawBackground(Canvas.Handle, AMiddleButtonRect, DXBAR_BUTTONGROUPBORDERMIDDLE, APartState);
          end;
        end
        else
          Skin.DrawBackground(Canvas.Handle, AMiddleButtonRect, DXBAR_BUTTONGROUPBORDERMIDDLE, APartState);
      end;
    end;

  begin
    if AControlPart < 0 then
      DoDraw(ADrawParams.BarItemControl.ItemBounds, bcpButton)
    else
      DoDraw(ADrawParams.BarItemControl.FParts[AControlPart], AControlPart);
  end;

var
  AButtonPart, AGlyphPart, ADropButtonPart: Integer;
begin
  with ADrawParams do
  begin
    if ViewSize <> cvsSmall then
    begin
      AButtonPart := DXBAR_LARGEBUTTON;
      AGlyphPart := DXBAR_LARGEBUTTON_GLYPH;
      ADropButtonPart := DXBAR_LARGEBUTTON_DROPBUTTON;
    end
    else
      if ButtonGroup = bgrpNone then
      begin
        AButtonPart := DXBAR_SMALLBUTTON;
        AGlyphPart := DXBAR_SMALLBUTTON_GLYPH;
        ADropButtonPart := DXBAR_SMALLBUTTON_DROPBUTTON;
      end
      else
      begin
        AButtonPart := DXBAR_BUTTONGROUP;
        AGlyphPart := DXBAR_BUTTONGROUP_GLYPH;
        ADropButtonPart := DXBAR_BUTTONGROUP_DROPBUTTON;
      end;

    if SplitDropDown and IsDropDown then
    begin
      InternalDrawBackground(bcpButton, AGlyphPart);
      InternalDrawBackground(bcpDropButton, ADropButtonPart);
    end
    else
      InternalDrawBackground(-1, AButtonPart);
  end;
end;

function TdxBarSkinnedPainter.GetArrowRect(const ADrawParams: TdxBarButtonLikeControlDrawParams; const ARect: TRect): TRect;
begin
  if ADrawParams.UseRightToLeftAlignment then
    Result := cxRectSetLeft(ARect, ARect.Left, ADrawParams.ArrowSize.cx)
  else
    Result := cxRectSetRight(ARect, ARect.Right, ADrawParams.ArrowSize.cx);
end;

function TdxBarSkinnedPainter.GetMenuButtonState(AEnabled, ASelected: Boolean): Integer;
begin
  if not AEnabled then
    Result := DXBAR_DISABLED
  else
    if ASelected then
      Result := DXBAR_HOT
    else
      Result := DXBAR_NORMAL;
end;

class function TdxBarSkinnedPainter.GetTextInsteadArrow(const ADrawParams: TdxBarItemControlDrawParams): string;
var
  AScaleFactor: TdxScaleFactor;
begin
  Result := '';
  if ADrawParams.IsDropDown then
  begin
    AScaleFactor := dxGetScaleFactor(ADrawParams.BarItemControl);
    while GetDefaultArrowSignSize(AScaleFactor).cx > cxTextSize(ADrawParams.Canvas.Handle, Result).cx do
      Result := Result + '.';
    Result := ' ' + Result;
  end;
end;

class function TdxBarSkinnedPainter.GetMaxLineCount: Integer;
begin
  Result := 2;
end;

procedure TdxBarSkinnedPainter.InternalDrawEditButton(
  const ADrawParams: TdxBarEditLikeControlDrawParams; APartIndex: Integer; ARect: TRect);
var
  AContentRect: TRect;
  AState: Integer;
begin
  AState := GetEditPartState(ADrawParams, APartIndex);
  EditButtonDrawBorder(ADrawParams, AState, ARect, AContentRect);
  if Skin.GetName <> '' then
  begin
    FillRectByColor(ADrawParams.Canvas.Handle, ARect, EditGetBkColor(ADrawParams));
    EditButtonDrawBackground(ADrawParams, AState, AContentRect, 0);
    case APartIndex of
      ccpDropButton:
        Skin.DrawBackground(ADrawParams.Canvas.Handle, AContentRect, DXBAR_EDIT_ARROWBUTTON, AState);
      clcpCustomColorButton:
        Skin.DrawBackground(ADrawParams.Canvas.Handle, AContentRect, DXBAR_EDIT_ELLIPSISBUTTON, AState);
    end;
  end
  else
  begin
    EditButtonDrawBackground(ADrawParams, AState, ARect, 0);
    case APartIndex of
      ccpDropButton:
        DrawArrow(ADrawParams.Canvas.Handle, AContentRect, AState, ADrawParams.ScaleFactor);
      clcpCustomColorButton:
        DrawDots(ADrawParams, AContentRect);
    end;
  end;
end;

{ TRegItemRecord }

constructor TRegItemRecord.Create(AItemClass: TdxBarItemClass;
  AItemControlClass: TdxBarItemControlClass; AVisible: Boolean);
begin
  FItemClass := AItemClass;
  FItemControlClass := AItemControlClass;
  FVisible := AVisible;
end;

{ TdxBarItemList }

destructor TdxBarItemList.Destroy;
var
  I: Integer;
begin
  for I := Count - 1 downto 0 do
    Unregister(I);
  inherited Destroy;
end;

procedure TdxBarItemList.Register(AItemClass: TdxBarItemClass;
  AItemControlClass: TdxBarItemControlClass; AVisible: Boolean);
var
  ARecord: TRegItemRecord;
begin
  ARecord := TRegItemRecord.Create(AItemClass, AItemControlClass, AVisible);
  Add(ARecord);
  RegisterClass(ARecord.FItemClass);
end;

procedure TdxBarItemList.Unregister(AItemClass: TdxBarItemClass);
var
  I: Integer;
begin
  for I := 0 to Count - 1 do
    if ItemClass[I] = AItemClass then
    begin
      Unregister(I);
      Break;
    end;
end;

procedure TdxBarItemList.Unregister(Index: Integer);
var
  ARecord: TRegItemRecord;
begin
  ARecord := Items[Index];
  UnregisterClass(ARecord.FItemClass);
  Delete(Index);
  ARecord.Free;
end;

function TdxBarItemList.GetItem(Index: Integer): TRegItemRecord;
begin
  Result := TRegItemRecord(inherited Items[Index]);
end;

function TdxBarItemList.GetItemClass(Index: Integer): TdxBarItemClass;
begin
  Result := Items[Index].FItemClass;
end;

function TdxBarItemList.GetVisibleItemCount: Integer;
var
  I: Integer;
begin
  Result := 0;
  for I := 0 to Count - 1 do
    if Items[I].FVisible then
      Inc(Result);
end;

function TdxBarItemList.GetVisibleItemClass(Index: Integer): TdxBarItemClass;
var
  AVisibleIndex, I: Integer;
begin
  Result := nil;
  AVisibleIndex := -1;
  for I := 0 to Count - 1 do
    begin
      if Items[I].FVisible then
        Inc(AVisibleIndex);
      if AVisibleIndex = Index then
      begin
        Result := ItemClass[I];
        Exit;
      end;
    end;
end;

{ TdxBarNavigationController }

destructor TdxBarNavigationController.Destroy;
begin
  FreeAndNil(FKeyTipsShowingState.KeyTipsData);
  EndKeyTipsWaiting(False);
  inherited Destroy;
end;

procedure TdxBarNavigationController.BeginKeyTipsWaiting(ARootObject: IdxBarAccessibilityHelper);
begin
  if (ARootObject = nil) or IsKeyTipsWaiting and
    (ARootObject.GetHelper <> FKeyTipsWaitingRootObject.GetHelper) then
      raise EdxException.Create('TdxBarNavigationController.BeginKeyTipsWaiting fails');
  if KeyTipsHandlingMode then
    Exit;
  if not IsKeyTipsWaiting then
  begin
    FKeyTipsWaitingRootObject := ARootObject;
    FKeyTipsWaitingTimer := cxCreateTimer(KeyTipsWaitingTimerHandler, dxBarWaitForKeyTipsTime);
  end;
end;

procedure TdxBarNavigationController.ChangeSelectedObject(ASetFocus: Boolean;
  ANewSelectedObject: IdxBarAccessibilityHelper; APrevSelectedObject: IdxBarAccessibilityHelper = nil);
var
  ALockedBarManager: TdxBarManager;
begin
  if ANewSelectedObject = nil then
    Exit;
  if APrevSelectedObject = nil then
    APrevSelectedObject := SelectedObject;
  if ANewSelectedObject <> APrevSelectedObject then
  begin
    if (ANewSelectedObject <> nil) and (APrevSelectedObject <> nil) and
      (ANewSelectedObject.GetBarManager = APrevSelectedObject.GetBarManager) then
      ALockedBarManager := ANewSelectedObject.GetBarManager
    else
      ALockedBarManager := nil;

    if ALockedBarManager <> nil then
      Inc(ALockedBarManager.FChangingFocusedItemControlLockCount);
    try
      if APrevSelectedObject <> nil then
        APrevSelectedObject.Unselect(ANewSelectedObject);
      ANewSelectedObject.Select(ASetFocus);
    finally
      if ALockedBarManager <> nil then
        Dec(ALockedBarManager.FChangingFocusedItemControlLockCount);
    end;
  end;
end;

procedure TdxBarNavigationController.EndKeyTipsWaiting(AShowKeyTipWindows: Boolean);
var
  ANewActiveKeyTipContainer: IdxBarAccessibilityHelper;
begin
  WaitForMenu := False;
  if IsKeyTipsWaiting then
  begin
    DestroyKeyTipsWaitingTimer;
    ANewActiveKeyTipContainer := FKeyTipsWaitingRootObject;
    FKeyTipsWaitingRootObject := nil;
    if AShowKeyTipWindows then
      SetKeyTipsShowingState(ANewActiveKeyTipContainer, '');
  end;
end;

procedure TdxBarNavigationController.HandleKey(AKey: Word; AShift: TShiftState;
  ASelectedObjectParent: IdxBarAccessibilityHelper = nil; ASelectedObject: IdxBarAccessibilityHelper = nil);

  function GetNavigationDirection: TcxAccessibilityNavigationDirection;
  begin
    case AKey of
      VK_LEFT:
        Result := andLeft;
      VK_RIGHT:
        Result := andRight;
      VK_UP:
        Result := andUp;
      VK_DOWN:
        Result := andDown;
      else
        if ssShift in AShift then
          Result := andLeft
        else
          Result := andRight;
    end;
  end;

var
  AKeyTipsWereVisible: Boolean;
  AIsKeyAcceptable: Boolean;
  AKeyTargetObject: IdxBarAccessibilityHelper;
  ANextSelectedObject: IdxBarAccessibilityHelper;
begin
  FHandleKey := True;
  try
    if IsKeyTipsWaiting then
    begin
      WaitForMenu := False;
      if IsKeyTipsKey(AKey, AShift, AIsKeyAcceptable) then
      begin
        if not AIsKeyAcceptable then
          Exit;
        HandleKeyTipKey(AKey, AShift);
        EndKeyTipsWaiting(False);
        Exit;
      end;
    end;

    AKeyTipsWereVisible := KeyTipsHandlingMode;
    if KeyTipsHandlingMode and (AKey <> VK_ESCAPE) then
      if IsKeyTipsKey(AKey, AShift, AIsKeyAcceptable) then
      begin
        if AIsKeyAcceptable then
          HandleKeyTipKey(AKey, AShift);
        Exit;
      end
      else
        StopKeyTipsHandlingMode;

    if (AKey = VK_ESCAPE) and KeyTipsHandlingMode then
      KeyTipsEscapeHandler
    else
    begin
      if ASelectedObjectParent = nil then
        ASelectedObjectParent := SelectedObjectParent;
      if ASelectedObject = nil then
        ASelectedObject := SelectedObject;
      AKeyTargetObject := ASelectedObject;
      if AKeyTargetObject = nil then
        AKeyTargetObject := ASelectedObjectParent;
      if AKeyTargetObject = nil then
        Exit;
      if AKey in [VK_MENU, VK_F10, VK_ESCAPE] then
      begin
        if not ((AKey = VK_ESCAPE) and AKeyTargetObject.HandleNavigationKey(AKey)) then
        begin
          if AKeyTargetObject.CanUnselectOnKeyDown(AKey, AKeyTipsWereVisible and not KeyTipsHandlingMode) then
            AKeyTargetObject.Unselect(nil);
        end;
      end
      else
        if not AKeyTargetObject.HandleNavigationKey(AKey) then
        begin
          if ASelectedObject = nil then
            ANextSelectedObject := ASelectedObjectParent.GetBarHelper.GetDefaultSelectableObject(GetNavigationDirection)
          else
          begin
            if AKey = VK_TAB then
              ANextSelectedObject := ASelectedObject.LogicalNavigationGetNextAccessibleObject(AShift)
            else
              ANextSelectedObject := ASelectedObject.GetNextAccessibleObject(GetNavigationDirection);
          end;
          ChangeSelectedObject(AKey = VK_TAB, ANextSelectedObject, ASelectedObject);
        end;
    end;
  finally
    FHandleKey := False;
  end;
end;

function TdxBarNavigationController.IsKeyTipsKey(AKey: Word; AShift: TShiftState): Boolean;
var
  AIsKeyAcceptable: Boolean;
begin
  Result := IsKeyTipsKey(AKey, AShift, AIsKeyAcceptable);
end;

function TdxBarNavigationController.IsKeyTipsWaiting: Boolean;
begin
  Result := FKeyTipsWaitingRootObject <> nil;
end;

function TdxBarNavigationController.IsNavigationBarControl(
  ABarControl: TCustomdxBarControl): Boolean;
begin
  Result := NavigationMode and (ABarControl = GetActiveBarControl);
end;

function TdxBarNavigationController.IsNavigationKey(AKey: Word): Boolean;
begin
  Result := (AKey in [VK_LEFT, VK_RIGHT, VK_UP, VK_DOWN]) or
    (AKey = VK_TAB) and (GetKeyState(VK_CONTROL) >= 0);
end;

function TdxBarNavigationController.NeedsKey(AKey: Word; AShift: TShiftState): Boolean;
begin
  Result := IsNavigationControllerKey(AKey) and
    (SelectedObjectParent <> nil) and SelectedObjectParent.CanNavigateToChildren(AKey) or
    (IsKeyTipsWaiting or KeyTipsHandlingMode) and IsKeyTipsKey(AKey, AShift);
end;

procedure TdxBarNavigationController.PrepareNewSingleMenuLevel(AItemLinks: TdxBarItemLinks;
  const AParentKind: TdxBarKind);
begin
  if FSingleMenuBackButton = nil then
    FSingleMenuBackButton := AItemLinks.BarManager.AddItem(TdxBarSubMenuBackButton);
  if FSingleMenuCaption = nil then
    FSingleMenuCaption := AItemLinks.BarManager.AddItem(TdxBarSeparator);

  if (AItemLinks.FindByItem(FSingleMenuBackButton) = nil) and
    ((AParentKind = bkSubMenu) or (AItemLinks.FindByItem(FSingleMenuCaption) = nil)) then
  begin
    if AParentKind = bkSubMenu then
      AItemLinks.Insert(0).Item := FSingleMenuBackButton
    else
      AItemLinks.Insert(0).Item := FSingleMenuCaption;
    AItemLinks[0].UserCaption := TCustomdxBarSubItem(AItemLinks.Owner).Caption;
  end;
end;

procedure TdxBarNavigationController.RestorePreviousSingleMenuLevel(AParentItemControl: TdxBarItemControl;
  const AParentKind: TdxBarKind);
begin
  case AParentKind of
    bkSubMenu:
      TdxBarSubItemControl(AParentItemControl).SubMenuParent.RestoreSize;
    bkBarControl:
      begin
        FreeAndNil(FSingleMenuBackButton);
        FreeAndNil(FSingleMenuCaption);
      end;
  end;
end;

procedure TdxBarNavigationController.SelectDefaultObject(
  ARootObject: IdxBarAccessibilityHelper);
var
  ADefaultObject: IdxBarAccessibilityHelper;
begin
  ADefaultObject := ARootObject.GetDefaultAccessibleObject;
  if ADefaultObject <> nil then
  begin
    FNavigationMode := True;
    ADefaultObject.Select(False);
  end;
end;

procedure TdxBarNavigationController.SetKeyTipsShowingState(
  AActiveKeyTipContainer: IdxBarAccessibilityHelper; const AKeyTipsTypingString: string);

  function GetKeyTipWindowsManager(AHelper: IdxBarAccessibilityHelper): IdxBarKeyTipWindowsManager;
  begin
    if not AHelper.AreKeyTipsSupported(Result) then
      Result := nil;
  end;

  function GetHelperInstance(AHelper: IdxBarAccessibilityHelper): TObject;
  begin
    if AHelper <> nil then
      Result := AHelper.GetBarHelper
    else
      Result := nil;
  end;

  procedure SynchronizeKeyTipWindows;
  var
    AKeyTipData: TdxBarKeyTipData;
    AKeyTipWindowsManager: IdxBarKeyTipWindowsManager;
    I: Integer;
  begin
    if FKeyTipsShowingState.ActiveContainer.AreKeyTipsSupported(AKeyTipWindowsManager) then
    begin
      for I := 0 to FKeyTipsShowingState.KeyTipsData.Count - 1 do
      begin
        AKeyTipData := TdxBarKeyTipData(FKeyTipsShowingState.KeyTipsData[I]);
        if not AKeyTipData.Visible then
          Continue;
        if (FKeyTipsShowingState.TypingString = '') or
          (Pos(FKeyTipsShowingState.TypingString, AKeyTipData.NormalizedKeyTip) = 1)
        then
          AKeyTipData.ShowKeyTipWindow(AKeyTipWindowsManager)
        else
          AKeyTipData.HideKeyTipWindow(AKeyTipWindowsManager);
      end;
      AKeyTipWindowsManager.Show;
    end;
  end;

var
  AKeyTipWindowsManager: IdxBarKeyTipWindowsManager;
  ANewContainer, APrevContainer: TObject;
  I: Integer;
begin
  APrevContainer := GetHelperInstance(FKeyTipsShowingState.ActiveContainer);
  ANewContainer := GetHelperInstance(AActiveKeyTipContainer);
  if ANewContainer <> APrevContainer then
  begin
    if FKeyTipsShowingState.ActiveContainer <> nil then
    begin
      AKeyTipWindowsManager := GetKeyTipWindowsManager(FKeyTipsShowingState.ActiveContainer);
      for I := 0 to FKeyTipsShowingState.KeyTipsData.Count - 1 do
        TdxBarKeyTipData(FKeyTipsShowingState.KeyTipsData[I]).HideKeyTipWindow(AKeyTipWindowsManager);
      FreeAndNil(FKeyTipsShowingState.KeyTipsData);
    end;
    FKeyTipsShowingState.ActiveContainer := AActiveKeyTipContainer;
    FKeyTipsShowingState.TypingString := '';
    if FKeyTipsShowingState.ActiveContainer <> nil then
    begin
      AKeyTipWindowsManager := GetKeyTipWindowsManager(FKeyTipsShowingState.ActiveContainer);
      if AKeyTipWindowsManager <> nil then
        AKeyTipWindowsManager.Initialize;
      FKeyTipsShowingState.TypingString := AnsiUpperCase(AKeyTipsTypingString);
      FKeyTipsShowingState.KeyTipsData := TdxObjectList.Create(True);
      FKeyTipsShowingState.ActiveContainer.GetBarHelper.GetKeyTipsData(FKeyTipsShowingState.KeyTipsData);
      SynchronizeKeyTipWindows;
    end;
  end
  else
    if not AnsiSameText(FKeyTipsShowingState.TypingString, AKeyTipsTypingString) then
    begin
      FKeyTipsShowingState.TypingString := AnsiUpperCase(AKeyTipsTypingString);
      SynchronizeKeyTipWindows;
    end;
end;

procedure TdxBarNavigationController.StopKeyboardHandling;
begin
  WaitForMenu := False;
  if SelectedObject <> nil then
    SelectedObject.GetBarManager.HideHint;
  UnselectAssignedSelectedObject;
  if SelectedObject <> nil then
    SelectedObject.Unselect(nil);
  StopKeyTipsHandlingMode;
end;

procedure TdxBarNavigationController.UnassignObject(
  AObject: IdxBarAccessibilityHelper);
begin
  if (FSelectedObject <> nil) and (AObject.GetHelper = FSelectedObject.GetHelper) then
    FSelectedObject := nil;
  if (FSelectedObjectParent <> nil) and (AObject.GetHelper = FSelectedObjectParent.GetHelper) then
  begin
    FSelectedObject := nil;
    FSelectedObjectParent := nil;
  end;
  if (FKeyTipsShowingState.ActiveContainer <> nil) and
    (FKeyTipsShowingState.ActiveContainer.GetHelper = AObject.GetHelper) then
      SetKeyTipsShowingState(nil, '');
end;

procedure TdxBarNavigationController.UnselectAssignedSelectedObject;
begin
  if BarNavigationController.AssignedSelectedObject <> nil then
    BarNavigationController.AssignedSelectedObject.Unselect(nil);
end;

function TdxBarNavigationController.UseSingleMenuWindowMode(AItemControl: TdxBarItemControl): Boolean;
begin
  Result := (AItemControl is TdxBarSubItemControl) and AItemControl.Painter.SubMenuControlUseSingleMenuWindowMode and
    not AItemControl.BarManager.Designing and (AItemControl.Parent <> nil) and
    (AItemControl.Parent.Kind in [bkSubMenu, bkBarControl]);
end;

procedure TdxBarNavigationController.ResetNavigationMode;
begin
  FNavigationMode := False;
end;

procedure TdxBarNavigationController.DestroyKeyTipsWaitingTimer;
begin
  FreeAndNil(FKeyTipsWaitingTimer);
end;

function TdxBarNavigationController.GetActiveBarControl: TCustomdxBarControl;
begin
  if ActiveBarControl = nil then
    Result := BarDesignController.QuickControl
  else
    if IsActiveBarControlAccessible and not ActiveBarControl.IsCustomizing then
      Result := ActiveBarControl
    else
      Result := nil;
end;

function TdxBarNavigationController.GetKeyFromKeyCode(AKey: Word): string;
var
  AKeyChar: Char;
begin
  AKeyChar := GetCharFromKeyCode(AKey);
  if AKeyChar <> #0 then
    Result := AKeyChar
  else
    Result := '';
end;

function TdxBarNavigationController.GetKeyTipsHandlingMode: Boolean;
begin
  Result := FKeyTipsShowingState.ActiveContainer <> nil;
end;

function TdxBarNavigationController.GetSelectedObject: IdxBarAccessibilityHelper;
var
  AActiveBarControl: TCustomdxBarControl;
begin
  AActiveBarControl := GetActiveBarControl;
  if AActiveBarControl <> nil then
  begin
    if AActiveBarControl.SelectedControl <> nil then
      Result := AActiveBarControl.SelectedControl.IAccessibilityHelper
    else
      Result := FSelectedObject;
  end
  else
    Result := FSelectedObject;
end;

function TdxBarNavigationController.GetSelectedObjectParent: IdxBarAccessibilityHelper;
begin
  if GetActiveBarControl <> nil then
    Result := GetActiveBarControl.IAccessibilityHelper
  else
    Result := FSelectedObjectParent;
end;

procedure TdxBarNavigationController.HandleKeyTipKey(AKey: Word; AShift: TShiftState);
var
  AIsKeyAcceptable: Boolean;
  AOnExecute: TNotifyEvent;
  AKeyTipContainer: IdxBarAccessibilityHelper;
begin
  IsKeyTipsKey(AKey, AShift, AIsKeyAcceptable, AOnExecute);
  if Assigned(AOnExecute) then
  begin
    FKeyTipsWaitingRootObject := nil;
    DestroyKeyTipsWaitingTimer;
    AOnExecute(nil);
  end
  else
  begin
    AKeyTipContainer := FKeyTipsShowingState.ActiveContainer;
    if AKeyTipContainer = nil then
    begin
      AKeyTipContainer := FKeyTipsWaitingRootObject;
      FKeyTipsWaitingRootObject := nil;
      DestroyKeyTipsWaitingTimer;
    end;
    SetKeyTipsShowingState(AKeyTipContainer, FKeyTipsShowingState.TypingString + GetKeyFromKeyCode(AKey));
  end;
end;

function TdxBarNavigationController.IsKeyTipsKey(AKey: Word; AShift: TShiftState;
  out AIsKeyAcceptable: Boolean; out AOnExecute: TNotifyEvent): Boolean;
var
  AKeyTipData: TdxBarKeyTipData;
  AKeyTipsData: TdxObjectList;
  AKeyTipsTypingString: string;
  I: Integer;
begin
  Result := KeyTipsHandlingMode and (AKey = VK_ESCAPE);
  if Result then
    Exit;

  Result := IsTextCharForKeyTip(AKey);
  if not Result then
    Exit;

  if ssAlt in AShift then
    Result := False;

  AIsKeyAcceptable := False;
  AOnExecute := nil;
  AKeyTipsData := nil;
  try
    if FKeyTipsShowingState.ActiveContainer = nil then
    begin
      AKeyTipsData := TdxObjectList.Create(True);
      FKeyTipsWaitingRootObject.GetBarHelper.GetKeyTipsData(AKeyTipsData);
      AKeyTipsTypingString := '';
    end
    else
    begin
      AKeyTipsData := FKeyTipsShowingState.KeyTipsData;
      AKeyTipsTypingString := FKeyTipsShowingState.TypingString;
    end;
    AKeyTipsTypingString := AKeyTipsTypingString + AnsiUpperCase(GetKeyFromKeyCode(AKey));
    for I := 0 to AKeyTipsData.Count - 1 do
    begin
      AKeyTipData := TdxBarKeyTipData(AKeyTipsData[I]);
      if (AnsiPos(AKeyTipsTypingString, AKeyTipData.NormalizedKeyTip) = 1) and AKeyTipData.Enabled then
      begin
        AIsKeyAcceptable := True;
        if AnsiSameStr(AKeyTipsTypingString, AKeyTipData.NormalizedKeyTip)  then
          AOnExecute := AKeyTipData.OnExecute;
        Result := True;
        Break;
      end;
    end;
    if FHandleKey and not AIsKeyAcceptable then
      SysUtils.Beep;
  finally
    if FKeyTipsShowingState.ActiveContainer = nil then
      FreeAndNil(AKeyTipsData);
  end;
end;

function TdxBarNavigationController.IsKeyTipsKey(AKey: Word; AShift: TShiftState;
  out AIsKeyAcceptable: Boolean): Boolean;
var
  AOnExecute: TNotifyEvent;
begin
  Result := IsKeyTipsKey(AKey, AShift, AIsKeyAcceptable, AOnExecute);
end;

function TdxBarNavigationController.IsNavigationControllerKey(AKey: Word): Boolean;
begin
  Result := IsNavigationKey(AKey) or
    (ActiveBarControl = nil) and (BarDesignController.QuickControl = nil) and
    ((AKey = VK_MENU) or (AKey = VK_F10) and (SelectedObjectParent <> nil) and SelectedObjectParent.GetBarManager.UseF10ForMenu);
  Result := Result or
    (SelectedObject <> nil) and SelectedObject.IsNavigationKey(AKey) or
    (SelectedObjectParent <> nil) and SelectedObjectParent.IsNavigationKey(AKey);
end;

procedure TdxBarNavigationController.KeyTipsEscapeHandler;
begin
  HandleKeyTipsEscape(FKeyTipsShowingState.ActiveContainer);
end;

procedure TdxBarNavigationController.KeyTipsWaitingTimerHandler(Sender: TObject);
begin
  if WaitForMenu then
    EndKeyTipsWaiting(True)
  else
    DestroyKeyTipsWaitingTimer;
end;

procedure TdxBarNavigationController.StopKeyTipsHandlingMode;
begin
  EndKeyTipsWaiting(False);
  SetKeyTipsShowingState(nil, '');
end;


initialization
  FUnitIsFinalized := False; // D10 bug
  RegisterClasses([TdxBar, TdxBarGroup, TdxBarScreenTip]);

  FUser32DLL := GetModuleHandle(user32);
  if FUser32DLL > 32 then
    @SetLayeredWindowAttributes := GetProcAddress(FUser32DLL, 'SetLayeredWindowAttributes');
  dxBarManagerList := TdxBarManagerList.Create;
  RefreshDeviceConsts;
  CreatePatternBrush;

  FBarControls := TList.Create;
  FBarNavigationController := TdxBarNavigationController.Create;

  dxBarRegisterItem(TdxBarButton, TdxBarButtonControl, True);
  dxBarRegisterItem(TdxBarSubMenuBackButton, TdxBarSubMenuBackButtonControl, False);
  dxBarRegisterItem(TdxBarLargeButton, TdxBarLargeButtonControl, True);
  dxBarRegisterItem(TdxBarEdit, TdxBarEditControl, True);
  dxBarRegisterItem(TCustomdxBarCombo, TCustomdxBarComboControl, True);
  dxBarRegisterItem(TdxBarCombo, TdxBarComboControl, True);
  dxBarRegisterItem(TdxBarSubItem, TdxBarSubItemControl, True);
  dxBarRegisterItem(TdxBarListItem, TdxBarContainerItemControl, True);
  dxBarRegisterItem(TdxBarContainerItem, TdxBarContainerItemControl, True);
  dxBarRegisterItem(TdxBarLabel, TdxBarCustomStaticControl, False);
  dxBarRegisterItem(TdxBarSeparator, TdxBarSeparatorControl, True);

  dxBarRegisterItem(TdxBarQuickCustExtButton, TdxBarQuickCustExtButtonControl, False);
  dxBarRegisterItem(TdxBarQuickCustItem, TdxBarQuickCustItemControl, False);
  dxBarRegisterItem(TdxBarQuickAccessItem, TdxBarSubItemControl, False);

  dxBarRegisterItem(TSystemMenuSubItem, TSystemMenuSubItemControl, False);

  BarDesignController.RegisterBarControlEditor(TdxAddSubItemEditor);
  BarDesignController.RegisterBarControlEditor(TdxAddButtonEditor);
  BarDesignController.RegisterBarControlEditor(TdxAddLargeButtonEditor);
  BarDesignController.RegisterBarControlEditor(TdxItemsEditorEx);

  BarDesignController.RegisterBarControlDesignHelper(TdxBarControl, TdxBarControlDesignHelper);
  BarDesignController.RegisterBarControlDesignHelper(TdxBarSubMenuControl, TdxBarSubMenuControlDesignHelper);

  Screen.Cursors[crdxBarDrag] := LoadCursor(HInstance, 'DXBARDRAGCURSOR');
  Screen.Cursors[crdxBarDragCopy] := LoadCursor(HInstance, 'DXBARDRAGCOPYCURSOR');
  Screen.Cursors[crdxBarDragNoDrop] := LoadCursor(HInstance, 'DXBARDRAGNODROPCURSOR');
  Screen.Cursors[crdxBarEditSizing] := LoadCursor(HInstance, 'DXBAREDITSIZINGCURSOR');

  GroupDescendentsWith(TdxBarComponent, TControl);

  if not IsLibrary then
  begin
    FPrevInitProc := InitProc;
    InitProc := @dxBarInitProc;
  end;

finalization
  FUnitIsFinalized := True;
  FreeAndNil(FBarNavigationController);
  FreeAndNil(FBarControls);

  FreeAndNil(FRegdxItemList);
  FreeAndNil(FBarDesignController);
  FreeAndNil(FBarFlatPainter);

  DeleteObject(PatternBrush);
  dxFreeAndNil(dxBarManagerList);

end.
